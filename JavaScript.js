function hide_game() { var doc = document.getElementById("game_base"); if (doc != undefined) doc.style.visibility = "hidden" }; function checkLoading() { if (!sjs.spritesLoaded()) { setTimeout(function () { checkLoading() }, 500); return } loaded_game.DelayedInit(gameUI); if (!sjs.isPixi) { ticker = new sjs.Ticker(tick_time, mainLoop); ticker.run() } else { director = new Director(frame_rate); director.logicCallback = mainLoop; director.renderCallback = renderLoop; director.start() } checkInit() }; function checkInit() { if (IDSplash.WaitingConfirm || !loaded_game.CanShowWindow() || !iniS.loaderReady) { setTimeout(function () { checkInit() }, 500); return } Context.addSignals(); if (typeof GameStartedCallback === "function") GameStartedCallback(); setTimeout(function () { show_game() }, 1) }; Director = function (frameRate, maxSkip) { this.maxSkip = maxSkip || 5; frameRate = frameRate || 60; this.frameTime = Math.floor(1E3 / frameRate); this.logicCallback = function () { }; this.renderCallback = function () { }; this.running = false; this.nextUpdate = getTimer(); this.stats = new DirectorStats(this); var that = this; this.callback = function () { that.tick() } }; Director.prototype.constructor = Director; Director.autoThrottle = false; Object.defineProperty(Director.prototype, "frameRate", { get: function () { return 1E3 / this.frameTime }, set: function (value) { this.frameTime = 1E3 / value } }); Director.prototype.start = function () { if (this.running) return; this.running = true; this.nextUpdate = getTimer(); this.tick(); if (Director.autoThrottle) this.autoThrottle() }; Director.prototype.autoThrottle = function () { this._timeToSpare = -1; this._throttleInterval = setInterval(Utils.delegate(this, this.__throttleCheck), 1E3) }; Director.prototype.__throttleCheck = function () { if (this.frameTime < this.stats.recommendedFrametime) { this.frameTime = this.stats.recommendedFrametime; this._throttleUpTimestamp = -1 } else if (this.frameTime > this.stats.recommendedFrametime) if (this._throttleUpTimestamp == -1) this._throttleUpTimestamp = getTimer(); else { if (getTimer() - this._throttleUpTimestamp > 1E4) { this.frameTime = this.stats.recommendedFrametime; this._throttleUpTimestamp = -1 } } else this._throttleUpTimestamp = -1 }; Director.prototype.stop = function () { if (!this.running) return; cancelAnimFrame(this.animFrame); this.running = false; if (this._throttleInterval) { clearInterval(this._throttleInterval); this._throttleInterval = undefined } }; Director.prototype.callLogic = function () { var start = getTimer(); this.logicCallback(); return getTimer() - start }; Director.prototype.callRender = function () { var start = getTimer(); this.renderCallback(); return getTimer() - start }; Director.prototype.tick = function () { if (this.running) this.animFrame = requestAnimFrame(this.callback); var frames = 1; var now = getTimer(); if (Math.ceil(now - this.nextUpdate) >= 0) { this.stats.addStats(this.callLogic(), this.callRender()); this.nextUpdate = now + this.frameTime; while (getTimer() - this.nextUpdate >= 0 && frames < this.maxSkip) { this.stats.addStats(this.callLogic()); frames++; this.nextUpdate += this.frameTime } } }; DirectorStats = function (parent, maxStats) { this._stats = []; this._parent = parent; this._maxStats = maxStats; this._skipped = 0; this._meanLogic = 0; this._meanRender = 0; this._tps = Infinity; this._fps = Infinity; this._logicFrames = 0; this._renderFrames = 0; this._lastTPSUpdate = getTimer(); this._lastCalculation = 0; if (this.maxStats > 0) { var that = this; this.intervalID = setInterval(function () { that.cleanUpMemory() }, 1E4) } }; DirectorStats.prototype.constructor = DirectorStats; DirectorStats.maxStats = 0; Object.defineProperty(DirectorStats.prototype, "maxStats", { get: function () { if (this._maxStats !== undefined) return this._maxStats; else return DirectorStats.maxStats }, set: function (value) { this._maxStats = value } }); DirectorStats.prototype.addStats = function (logicDuration, renderDuration) { if (this.maxStats == 0) return; this._logicFrames++; if (renderDuration >= 0) this._renderFrames++; this._stats.push(new DirectorStatsVO(logicDuration, renderDuration)); var time = getTimer(); var timeDelta = time - this._lastTPSUpdate; if (timeDelta > 1E3) { this._tps = Math.floor(this._logicFrames * 1E3 / timeDelta); this._fps = Math.floor(this._renderFrames * 1E3 / timeDelta); this._logicFrames = 0; this._renderFrames = 0; this._lastTPSUpdate = time } }; DirectorStats.prototype.cleanUpMemory = function () { this._stats = this._stats.slice(-this.maxStats) }; DirectorStats.prototype.calculate = function () { this.cleanUpMemory(); this._skipped = 0; this._meanLogic = 0; this._meanRender = 0; var logicAmount = 0; var renderAmount = 0; for (var i = 0, l = this._stats.length; i < l; i++) { if (this._stats[i].renderDuration < 0) this._skipped++; else { this._meanRender += this._stats[i].renderDuration; renderAmount++ } this._meanLogic += this._stats[i].logicDuration; logicAmount++ } this._meanLogic = Math.floor(this._meanLogic / logicAmount * 100) / 100; this._meanRender = Math.floor(this._meanRender / renderAmount * 100) / 100; this._lastCalculation = getTimer() }; Object.defineProperty(DirectorStats.prototype, "skipped", { get: function () { if (getTimer() - this._lastCalculation > 1E3) this.calculate(); return this._skipped } }); Object.defineProperty(DirectorStats.prototype, "meanLogicDuration", { get: function () { if (getTimer() - this._lastCalculation > 1E3) this.calculate(); return this._meanLogic } }); Object.defineProperty(DirectorStats.prototype, "meanRenderDuration", { get: function () { if (getTimer() - this._lastCalculation > 1E3) this.calculate(); return this._meanRender } }); Object.defineProperty(DirectorStats.prototype, "recommendedFrametime", { get: function () { if (getTimer() - this._lastCalculation > 1E3) this.calculate(); return Math.floor((this._meanLogic + 16) / 16) * 16 } }); Object.defineProperty(DirectorStats.prototype, "recommendedFramerate", { get: function () { return 1E3 / this.recommendedFrametime } }); Object.defineProperty(DirectorStats.prototype, "tps", { get: function () { return this._tps } }); Object.defineProperty(DirectorStats.prototype, "fps", { get: function () { return this._fps } }); DirectorStats.prototype.toString = function () { if (getTimer() - this._lastCalculation > 1E3) this.calculate(); var s = '{ "TargetFrameRate": ' + this._parent.frameRate; s += ', "TargetFrameTime": "' + Math.floor(this._parent.frameTime * 100) / 100 + ' ms"'; s += ', "StatFrames": ' + this.maxStats; s += ', "Logic": "' + this._meanLogic + ' ms"'; s += ', "Render": "' + this._meanRender + ' ms"'; s += ', "Skipped": ' + this._skipped; s += ', "TPS": ' + this._tps; s += ', "FPS": ' + this._fps; s += ', "RecommendedFrametime": ' + this.recommendedFrametime; s += ', "RecommendedFramerate": ' + this.recommendedFramerate; s += " }"; return s }; DirectorStats.prototype.destroy = function () { this._parent = undefined; this._stats = undefined; clearInterval(this.intervalID) }; DirectorStatsVO = function (logicDuration, renderDuration) { this.logicDuration = logicDuration; this.renderDuration = renderDuration != undefined ? renderDuration : -1 }; DirectorStatsVO.prototype.constructor = DirectorStatsVO; if (typeof StatsHandler === "undefined") StatsHandler = { HandleEvent: function (action, properties) { }, LoadingStart: function () { }, LoadingComplete: function () { }, ConnectingStart: function () { }, ConnectingComplete: function () { } }; Classify = {}; Classify.currentInstance = undefined; Classify.constr = function (target) { target.prototype.constructor = target; target.ext = Classify.ext; target.override = Classify.override; return target }; Classify.ext = function (target) { var constr = this.prototype.constructor; this.prototype = Object.create(target.prototype); this.prototype.constructor = constr; this.prototype._super = function () { var constr = target.prototype.constructor; return function () { if (this != window) Classify.currentInstance = this; Classify.currentInstance._super = Classify.currentInstance._super._super; return constr.apply(Classify.currentInstance, arguments) } }(); this.prototype._super._super = target.prototype._super; return this }; Classify.override = function (methodName, method) { if (!this.prototype[methodName]) throw Error("Unable to override a method that doesn't exist'"); var actualMethod = this.prototype[methodName]; var __super = function () { if (this != window) Classify.currentInstance = this; return actualMethod.apply(Classify.currentInstance, arguments) }; this.prototype[methodName] = function () { var previous = Classify.currentInstance._super; if (this != window) Classify.currentInstance = this; Classify.currentInstance._super = __super; var r = method.apply(Classify.currentInstance, arguments); Classify.currentInstance._super = previous; return r }; return this }; ServerMessage.ACTION_IGNORE = 0; ServerMessage.ACTION_SHOWMESSAGE = 1; ServerMessage.ACTION_RESERVED = 2; ServerMessage.ACTION_EXIT = 4; ServerMessage.ACTION_REDIRECT = 8; ServerMessage.ACTION_POLL = 16; ServerMessage.ACTION_FINISHROUND = 32; ServerMessage.ACTION_NEWFREEGAME = 64; function ServerMessage(gamebase, title, message, flags, OkNotify, notOnTop) { HostInterface.processMessageEvent({ type: HostInterface.CALL_HANDLE_GAME_ERROR, data: { title: title, message: message, flags: (flags & 4) > 0 } }); title = Utils.getString(title); message = Utils.getString(message); SoundPlayer.Pause(); if (typeof ModalWin != "undefined" && !Utils.OldGame()) { var messageData = []; messageData.title = title; messageData.message = message; ServerMessage.CurrentMessage = message; messageData.pos = modalwin_pos; if ((flags & 4) > 0) { InvalidatePage.CurrentMessage = message; InvalidatePage.GameBasePointer = gamebase; messageData.callback = Utils.delegate(this, CloseGame) } var messageWin = new MessageModalWin(messageData); if (!nx && !notOnTop) messageWin.ShowOnTop(); messageWin.Show() } else { message = Str.ReplaceBR(message); alert(message); if ((flags & 4) > 0) { InvalidatePage(message); if (gamebase.cL == "" || gamebase.cL == undefined) history.back(); else location.href = unescape(gamebase.cL) } } }; function CloseGame() { InvalidatePage(InvalidatePage.CurrentMessage); if (InvalidatePage.GameBasePointer.cL == "" || InvalidatePage.GameBasePointer.cL == undefined) history.back(); else location.href = unescape(InvalidatePage.GameBasePointer.cL); InvalidatePage.CurrentMessage = " "; InvalidatePage.GameBasePointer = undefined } InvalidatePage.CurrentMessage = " "; InvalidatePage.GameBasePointer = undefined; function InvalidatePage(message, noReloadBtn) { if (!sjs.isPixi) { var nodesLength = 0; if (document.getElementById("game") == null) var sjsl = document.getElementById("sjs"); else var sjsl = document.getElementById("game"); nodesLength = sjsl.childNodes.length; for (var i = nodesLength - 1; i >= 0; i--) if (sjsl.childNodes[i].id != "inv") sjsl.removeChild(sjsl.childNodes[i]) } else { var node = document.getElementsByTagName("body")[0]; while (node.hasChildNodes()) node.removeChild(node.lastChild) } var invalid = sjs.layers["inv"]; if (message) new Textfield(invalid, invalid_text_pos, message, "ffffff", "menu_title", true); invalid.Show(true); sjs.layers["invReloadButtonLayer"].Show(!noReloadBtn) }; InvalidatePage.Create = function () { var invalidLayer = new sjs.Layer("inv"); invalidLayer.Show(false); var solid = new sjs.Solid("#000000", invalidLayer, { x: 0, y: 0, w: 2048, h: 2048 }); var invalReloadButtonLayer = new sjs.Layer("invReloadButtonLayer", undefined, invalidLayer); var rpBtn = new Button(invalReloadButtonLayer, invalid_btn_pos, undefined, image_path_menu + "btn_tablegame.png", Locale.IDS_BTN_RELOAD, "000000", "menu_title"); rpBtn.H.yoffset = invalid_btn_Yoffset; rpBtn.H.setBounds(invalid_btn_sprite_pos); GameBase.CreateButtonReleaseHandler(rpBtn, function () { location.reload(true) }) }; Signal = function () { this.callbacks = [] }; Signal.prototype.constructor = Signal; Signal.prototype.fire = function () { for (var i = 0; i < this.callbacks.length; i++) { var vo = this.callbacks[i]; vo.callback.apply(this, arguments); if (--vo._times === 0) { this.callbacks.splice(i, 1); i-- } } }; Signal.prototype.add = function (callback) { var vo = new SignalVO(callback); this.callbacks.push(vo); return vo }; Signal.prototype.remove = function (callback, times) { for (var i = 0; i < this.callbacks.length; i++) if (this.callbacks[i].callback === callback) if (times === undefined || callback._times === times) { this.callbacks.splice(i, 1); i-- } }; Signal.prototype.clear = function () { this.callbacks.length = 0 }; SignalVO = function (callback) { this.callback = callback; this._times = -1 }; SignalVO.prototype.constructor = SignalVO; SignalVO.prototype.times = function (n) { if (n == 0) throw Error("You cannot set a signal callback to run zero times!"); this._times = n }; SignalVO.prototype.once = function () { this._times = 1 }; function NumberDisplay(layer, spacing, digitLinkageName, digitLibrary, properties) { if (this.constructor !== arguments.callee) return new NumberDisplay(layer, spacing, digitLinkageName, digitLibrary); if (digitLinkageName == undefined) digitLinkageName = "digits"; if (digitLibrary == undefined) digitLibrary = ""; if (spacing == undefined) spacing = 3; this.m_symbols = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "dot", "comma", "Euro", "Pound", "Yen", "Dollar", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]; this.K = layer; this.m_Digits; this.m_DigitLinkageName; this.m_DigitLibrary; this.m_Spacing; this.m_BaseWidth; this.m_Width; this.m_Digits = []; this.m_DigitLinkageName = digitLinkageName; this.m_DigitLibrary = digitLibrary; this.m_Spacing = spacing; this.m_BaseWidth = 0; this.ea = properties; this.T = new PNG.BitmapText(" ", this.ea); if (size); this.K.view.addChild(this.T) } NumberDisplay.prototype.constructor = NumberDisplay; NumberDisplay.prototype.getwidth = function () { return this.m_Width }; NumberDisplay.prototype.addDigit = function () { var newDigit = new sjs.Sprite(image_path_game + "digits.png", this.K, undefined, { w: 32, h: 61 }); var symbols = []; var symbol; for (var i = 0; i < 42; i++) { symbol = newDigit; if (symbol) symbol.Visible(i == 0); symbols.push(symbol) } newDigit.symbols = symbols; newDigit.symbol = 0; this.m_Digits.push(newDigit); this.m_BaseWidth = symbols[0].w }; NumberDisplay.prototype.display = function (value) { if (value < 0) value = 0; var str = CreditFormatter.FormatCoinValue(value); var curcode = ["&#128;", "&#36;", "&pound;", "&#165;"]; var cursign = ["\u20ac", "$", "\u00a3", "\u00a5"]; for (var i = 0; i < 4; i++) if (str.search(curcode[i]) == 0) str = str.replace(curcode[i], cursign[i]); this.T.setText(str.toUpperCase()) }; NumberDisplay.prototype.setPos = function (pos) { this.T.x = pos.x; this.T.y = pos.y }; NumberDisplay.prototype.Show = function (b) { this.T.visible = b }; NumberDisplay.prototype.displayText = function (str, offset) { if (offset == undefined) offset = 0; this.T.setText(str) }; if (!window.Utils) Utils = new Object; if (!window.Locale) Locale = new Object; if (!window.Str) Str = new Object; Utils.ToRad = function (deg) { return deg * (Math.PI / 180) }; Utils.ToDeg = function (rad) { return rad * (180 / Math.PI) }; Utils.getString = function (str) { if (Locale[str]) return Locale[str]; else return str }; Utils.copy = function (object, options) { options = options || {}; options.copyArray = options.copyArray || false; options.copyFunctions = options.copyFunctions || false; options.copyObjects = options.copyObjects || false; var newObject = {}; for (var k in object) switch (typeof object[k]) { case "function": if (options.copyFunctions) newObject[k] = object[k]; break; case "object": if (object[k] instanceof Array) if (options.copyArray) newObject[k] = object[k].concat(); else newObject[k] = object[k]; else if (options.copyObjects) newObject[k] = Utils.copy(object[k], options); else newObject[k] = object[k]; break; default: newObject[k] = object[k]; break } return newObject }; Str.Contains = function (str, cStr) { if (str.indexOf(cStr) != -1) return true; return false }; Str.Replace = function (str, find, replace) { return str.split(find).join(replace) }; Str.MultiToSingleLine = function (str) { str = Str.Replace(str, "<br />", " "); return str }; Str.ReplaceBR = function (str) { return Str.Replace(str, "<br />", "\n") }; Str.CompareNoCase = function (str1, str2) { return str1.toLowerCase() == str2.toLowerCase() }; Str.Escape = function (str) { if (!Str.Contains(str, " ") && !Str.Contains(str, '"')) return str; var str2; str2 = Str.Replace(str, "\\", "\\\\"); str = Str.Replace(str2, '"', '\\"'); return str }; Str.Unescape = function (str) { var str2; str2 = Str.Replace(str, '\\"', '"'); str = Str.Replace(str2, "\\\\", "\\"); return str }; Str.TokenizeEscaped = function (tokens, str) { var length = str.length; for (var i = 0; i < length;) { var c = str.charAt(i); if (c == '"') { var tokenStart = i + 1; for (i = tokenStart; i < length; i++) { c = str.charAt(i); if (c == "\\") i++; else if (c == '"') break } tokens.push(Str.Unescape(str.substring(tokenStart, i))); i += 2 } else { var tokenEnd = str.indexOf(" ", i); if (tokenEnd == -1) tokenEnd = str.length; tokens.push(str.substring(i, tokenEnd)); i = tokenEnd + 1 } } return tokens.length }; globalTimeOffset = 0; blurredTime = 0; function getTimer() { return (new Date).getTime() } if (Date && Date.now) getTimer = Date.now; var pmap = {}; function setUrlVars(p) { var parts = p.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) { pmap[key] = value }) } function getUrlVars() { return pmap } Utils.GetClosestValueIndex = function (v, values) { var curDiff; var minDiff = Math.abs(values[0] - v); var closestIndex = 0; var cnt = values.length; for (var i = 1; i < cnt; i++) { curDiff = Math.abs(values[i] - v); if (curDiff < minDiff) { minDiff = curDiff; closestIndex = i } } return closestIndex }; NO_DECIMALS = 1; OPT_DECIMALS = 2; LARGE_CURRENCY = 4; NO_CURRENCY = 8; CURRENCY_RIGHT = 16; FORCE_CUSTOM_CURRENCY = 32; THOUSAND_SEPARATED = 64; Utils.nc = { EUR: "\u20ac", USD: "$", GBP: "\u00a3", JPY: "\u00a5", SEK: "kr" }; Utils.cW; Utils.ju; Utils.lo = false; Utils.SetCurrencyDefaults = function (currency) { Utils.lo = false; Utils.ju = Utils.nc[currency]; if (currency == "SEK") Utils.lo = true; if (currency != "DEMO" && currency != "") Utils.cW = currency; else Utils.cW = undefined }; Utils.CurrencyString = function (currency) { if (Utils.nc[currency]) return Utils.nc[currency]; return currency }; Utils.DenominationString = function (money, currency, flags) { if (flags == undefined) flags = Utils.OPT_DECIMALS; var currencySymbol = Utils.CurrencyString(currency); if (currency == "SEK") flags |= CURRENCY_RIGHT; if (flags & FORCE_CUSTOM_CURRENCY) currencySymbol = currency; return Utils.MoneyToString(money, flags, currencySymbol) }; Utils.PrintDenomination = function (tf, money, currency, flags) { Utils.AutoScale(tf, Utils.DenominationString(money, currency, flags)) }; Utils.PrintCurrency = function (tf, currency) { Utils.AutoScale(tf, Utils.CurrencyString(currency)) }; Utils.MoneyToString = function (v, flags, currency) { if (flags == undefined) flags = 0; var s = ""; var extra = ""; var v2 = Math.floor(v + 1.0E-6); var whole = Math.floor(v2 / 100); var decimals = Math.floor(v2 - whole * 100); flags |= Utils.GetCurrencyDecimalFlag(currency || this.cW); if ((flags & NO_CURRENCY) == 0) if (currency == undefined && this.ju != undefined && (flags & LARGE_CURRENCY) == 0) if (!this.lo) s += this.ju + " "; else extra = " " + this.ju; else if (currency != undefined) if ((flags & CURRENCY_RIGHT) != 0) if (whole < 10 && decimals == 0 || (flags & OPT_DECIMALS) == 0) extra = " " + currency; else extra = currency; else if (decimals == 0 && whole < 10 || (flags & OPT_DECIMALS) == 0) s += currency + " "; else s += currency; else if (this.cW != undefined) s += this.cW + " "; if (v < 1) { if ((flags & (NO_DECIMALS | OPT_DECIMALS)) != 0) return s + "0" + extra; return s + "0.00" + extra } if ((flags & THOUSAND_SEPARATED) != 0) whole = Utils.MakeThousandSeparated(whole); if ((flags & NO_DECIMALS) != 0) return s + String(whole) + extra; if ((flags & OPT_DECIMALS) != 0 && decimals == 0) return s + String(whole) + extra; if (decimals < 10) return s + whole + ".0" + decimals + extra; return s + whole + "." + decimals + extra }; Utils.__TextDiv = document.createElement("div"); Utils.NormalizeString = function (string) { Utils.__TextDiv.innerHTML = string; return Utils.__TextDiv.innerText || Utils.__TextDiv.textContent }; Utils.MakeThousandSeparated = function (value, separator) { if (separator == undefined) separator = ","; var output = ""; var string_value = value.toString(); var string_pos = string_value.length; while (string_pos > 3) { output = separator + string_value.substr(string_pos - 3, 3) + output; string_pos -= 3 } output = string_value.substr(0, string_pos) + output; return output }; Utils.GetCurrencyDecimalFlag = function (currency) { if (typeof CreditFormatter !== "undefined") return CreditFormatter.DenominationMultiplier >= 100 ? NO_DECIMALS : 0; return 0 }; Utils.AutoScale = function (infoText, str, mode) { if (infoText instanceof Button) infoText.SetText(str); else if (infoText instanceof Textfield) infoText.SetText(str); else infoText.text = str }; Utils.getElementScale = function (elem) { var transform = /matrix\([^\)]+\)/.exec(window.getComputedStyle(elem)["-webkit-transform"]), scale = { "x": 1, "y": 1 }; if (transform) { transform = transform[0].replace("matrix(", "").replace(")", "").split(", "); scale.x = parseFloat(transform[0]); scale.y = parseFloat(transform[3]) } return scale }; Utils.Lerp = function (start, end, Alpha) { var v = (start * (1 - Alpha) + end * Alpha) * 1E3; v = Math.round(v) / 1E3; return v }; Utils.RandRange = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min }; Utils.StringToMoney = function (str) { var firstSpace = str.indexOf(" "); var lastSpace = str.lastIndexOf(" "); if (firstSpace == lastSpace) str = str.substring(++firstSpace); else str = str.substring(++firstSpace, lastSpace); var v = Number(str); return Utils.NumberToMoney(v) }; Utils.StringToMoneyRegexp = function (str) { var v = Number(str.match(/\d+\.?\d*/g)); return Utils.NumberToMoney(v) }; Utils.NumberToMoney = function (m) { return Math.floor(Math.round(m * 1E4) / 100) }; Utils.Clamp = function (value, min, max) { return Math.min(Math.max(value, min), max) }; Utils.Rand = function (max) { return Math.floor(Math.random() * max) }; Utils.delegate = function (obj, func) { if (arguments.length > 2) { var args = Array.prototype.slice.call(arguments, 2); return function () { return func.apply(obj, args.concat(Array.prototype.slice.call(arguments))) } } else return function () { return func.apply(obj, arguments) } }; Utils.RandomSerie = function (max) { var a = []; var b = []; for (var i = 1; i <= max; i++) a.push(i); var total = a.length; for (var i = 0; i < total; i++) b.push(a.splice(Math.floor(Math.random() * a.length), 1)); return b }; Utils.OldGame = function (gameid) { var OldGames = [100001, 100004, 100005, 100031, 100016, 100017, 100018, 100047, 100211, 100056, 100093, 100094, 100099, 100105, 100106, 100107, 100108, 100235]; var l = OldGames.length; for (var i = 0; i < l; i++) if (gameid == OldGames[i]) return true; return false }; Utils.FlipValue = function (value) { if (value > 0) return value * -1; else return Math.abs(value) }; function sortNumber(a, b) { return a - b }; Utils.hasOwnPropertyCaseInsensitive = function (obj, property) { var props = []; for (var i in obj) if (obj.hasOwnProperty(i)) props.push(i); var prop; while (prop = props.pop()) if (prop.toLowerCase() === property.toLowerCase()) return prop; return false }; function ItemShaker() { if (this.constructor !== arguments.callee) return new ItemShaker; this.aH = [] } ItemShaker.prototype.constructor = ItemShaker; ItemShaker.prototype.StopShake = function (item, time) { this.RemoveShake(item, time) }; ItemShaker.prototype.RemoveShake = function (item, time) { if (time === undefined) time = 0; if (time < getTimer()) for (var i = this.aH.length - 1; i >= 0; i--) if (this.aH[i].item === item) { item.offset(this.aH[i].startX, this.aH[i].startY); this.aH.splice(i, 1) } }; ItemShaker.prototype.AddShake = function (itemToShake, startTime, shakeDuration, shakeX, shakeY) { if (itemToShake === undefined) return; this.RemoveShake(itemToShake); this.aH.push({ item: itemToShake, startTime: startTime, duration: shakeDuration, shakeX: shakeX, shakeY: shakeY, startX: itemToShake.xoffset, startY: itemToShake.yoffset }) }; ItemShaker.prototype.Tick = function () { for (var i = this.aH.length - 1; i >= 0; i--) { var obj = this.aH[i]; if (getTimer() >= obj.startTime && getTimer() < obj.startTime + obj.duration) obj.item.offset(obj.startX + Utils.Rand(obj.shakeX) - obj.shakeX * 0.5, obj.startY + Utils.Rand(obj.shakeY) - obj.shakeY * 0.5); else if (getTimer() >= obj.startTime + obj.duration) { obj.item.offset(obj.startX, obj.startY); this.aH.splice(i, 1) } } }; function LayerShaker() { if (this.constructor !== arguments.callee) return new LayerShaker; this.aH = []; this.AddShake = LayerShaker.prototype.AddShake; this.Tick = LayerShaker.prototype.Tick; this.RemoveShake = LayerShaker.prototype.RemoveShake; this.StopShake = LayerShaker.prototype.StopShake } LayerShaker.prototype.constructor = LayerShaker; LayerShaker.prototype.StopShake = function (layer, time) { this.RemoveShake(layer, time) }; LayerShaker.prototype.RemoveShake = function (layer, time) { if (time === undefined) time = 0; if (time < getTimer()) for (var i = this.aH.length - 1; i >= 0; i--) if (this.aH[i].layer === layer) { layer.Move(this.aH[i].startX, this.aH[i].startY); this.aH.splice(i, 1) } }; LayerShaker.prototype.AddShake = function (layerToShake, startTime, shakeDuration, shakeX, shakeY) { if (layerToShake === undefined) return; this.RemoveShake(layerToShake); this.aH.push({ layer: layerToShake, startTime: startTime, duration: shakeDuration, shakeX: shakeX, shakeY: shakeY, startX: layerToShake.x, startY: layerToShake.y }) }; LayerShaker.prototype.Tick = function () { for (var i = this.aH.length - 1; i >= 0; i--) { var obj = this.aH[i]; if (getTimer() >= obj.startTime && getTimer() < obj.startTime + obj.duration) obj.layer.Move(obj.startX + Utils.Rand(obj.shakeX) - obj.shakeX * 0.5, obj.startY + Utils.Rand(obj.shakeY) - obj.shakeY * 0.5); else if (getTimer() >= obj.startTime + obj.duration) { obj.layer.Move(obj.startX, obj.startY); this.aH.splice(i, 1) } } }; function Clock(layer, pos, textObject, updateValueCB) { if (this.constructor !== arguments.callee) return new Clock; this.StartTime = Clock.prototype.StartTime; this.CheckTime = Clock.prototype.CheckTime; this.ResetTimeout = Clock.prototype.ResetTimeout; this.m_Timeout = null; this.jv = textObject || new Textfield(layer, pos, "", false, "clock_text"); this.m_LastServerTime = new Date; this.m_ServerTimeOffsetMS = 0; this.m_updateValueCB = updateValueCB; this.m_useServerTime = false } Clock.prototype.constructor = Clock; Clock.prototype.SetUseServerTime = function (b) { this.m_useServerTime = b; this.ResetTimeout() }; Clock.prototype.SetServerTime = function (serverTime) { var d = new Date; this.m_LastServerTime = new Date(serverTime); this.m_ServerTimeOffsetMS = this.m_LastServerTime.getTime() - Date.now(); this.m_ServerTimeOffsetMS += d.getTimezoneOffset() * 6E4; this.ResetTimeout() }; Clock.prototype.StartTime = function () { var that = this; var currentTime; if (this.m_useServerTime) currentTime = new Date(Date.now() + this.m_ServerTimeOffsetMS); else currentTime = new Date; var h = currentTime.getHours(); var m = currentTime.getMinutes(); h = this.CheckTime(h); m = this.CheckTime(m); this.updateValue(h + ":" + m); this.m_Timeout = setTimeout(function () { that.StartTime() }, (60 - currentTime.getSeconds()) * 1E3) }; Clock.prototype.CheckTime = function (i) { if (i < 10) i = "0" + i; return i }; Clock.prototype.ResetTimeout = function () { clearTimeout(this.m_Timeout); this.StartTime() }; Clock.prototype.updateValue = function (value) { if (this.m_updateValueCB) this.m_updateValueCB(value); else this.jv.SetText(value) }; function findKeyframesRule(rule) { var ss = document.styleSheets; for (var i = 0; i < ss.length; ++i) for (var j = 0; j < ss[i].cssRules.length; ++j) if (ss[i].cssRules[j].type == window.CSSRule.MOZ_KEYFRAMES_RULE && ss[i].cssRules[j].name == rule) return ss[i].cssRules[j]; return null }; function change(anim, sprite, pos) { var keyframes = findKeyframesRule(anim); keyframes.deleteRule("from"); keyframes.deleteRule("to"); keyframes.insertRule(pos.from); keyframes.insertRule(pos.to); sprite.dom.style.MozAnimationName = anim } function startChange(sprite, type, pos) { sprite.dom.style.MozAnimationName = "none"; change(type, sprite, pos) } function randomFromTo(from, to) { return Math.floor(Math.random() * (to - from + 1) + from) }; function CrossFade(layerName, colorString, fadeTime, callback, pos) { if (this.constructor !== arguments.callee) return new CrossFade; this.ao = callback; this.L = pos; if (this.L == undefined) { this.L = { x: 0, y: 0, w: 1260, h: 1180 }; if (game_bgr_pos != undefined) if (game_bgr_pos[DEVICE.orientation] != undefined) this.L = game_bgr_pos[DEVICE.orientation] } this.K = sjs.layers[layerName]; if (this.K == undefined) this.K = new sjs.Layer(layerName, undefined, scale_layer, undefined, this.L); this.pE = new sjs.Solid(colorString, this.K, this.L, undefined); this.K.opacity = 0; this.K.UpdateOpacity(); this.K.Show(false); if (this.K.aR == undefined) this.K.aR = new AnimationHandler(this.K, function () { }, true); this.mQ = { duration: fadeTime, alpha: [[[0, 1], [0, fadeTime * 0.5]]], callback: { alpha: Utils.delegate(this, this.OnFadeIn) } }; this.jK = { duration: fadeTime, alpha: [[[1, 0], [100, fadeTime * 0.5]]], callback: { alpha: Utils.delegate(this, this.OnFadeOut) } }; this.ANIM_INDEX_FADE_IN = 0; this.ANIM_INDEX_FADE_OUT = 1; this.K.aR.AddSequence(this.jK) } CrossFade.prototype.constructor = CrossFade; CrossFade.FADE_IN_DONE = "crossfade_fade_in_done"; CrossFade.FADE_OUT_DONE = "crossfade_fade_out_done"; CrossFade.prototype.SetColor = function (colorString) { this.pE.SetColor(colorString) }; CrossFade.prototype.SetDuration = function (duration) { this.mQ.duration = duration; this.mQ.alpha[0][1][1] = duration * 0.5; this.jK.duration = duration; this.jK.alpha[0][1][1] = duration * 0.5 }; CrossFade.prototype.OnFadeIn = function () { this.ao(CrossFade.FADE_IN_DONE); this.K.aR.StopSequences(); this.K.aR.ClearSequences(); this.K.aR.AddSequence(this.jK); this.K.aR.RunSequence() }; CrossFade.prototype.OnFadeOut = function () { this.ao(CrossFade.FADE_OUT_DONE); this.K.Show(false) }; CrossFade.prototype.DoCrossFade = function () { this.K.Show(true); this.K.aR.StopSequences(); this.K.aR.ClearSequences(); this.K.aR.AddSequence(this.mQ); this.K.aR.RunSequence() }; function Trace() { if (this.constructor !== arguments.callee) return new Trace; this.cD = {}; this.AddChannel("default", "color: #000"); this.AddChannel("red", "color: #f00;"); this.AddChannel("green", "color: #0f0;"); this.AddChannel("blue", "color: #00f;"); this.AddChannel("_red", "background-color: #f00; color: #fff;"); this.AddChannel("_green", "background-color: #0f0; color: #ff;"); this.AddChannel("_blue", "background-color: #00f; color: #fff;") } Trace.prototype.constructor = Trace; Trace.prototype.Log = function (message, channel) { if (!this.cD[channel]) channel = "default"; if (this.cD[channel]) if (this.cD[channel].bEnabled) { var d = new Date; var ms = d.getMilliseconds(); var time_string = (d.getHours() < 10 ? "0" + d.getHours() : d.getHours()) + ":" + (d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes()) + ":" + (d.getSeconds() < 10 ? "0" + d.getSeconds() : d.getSeconds()) + "." + (ms / 100 < 1 ? ms / 10 < 1 ? "00" + ms : "0" + ms : ms); if (message && message.constructor) if (message.constructor === String || message.constructor === Number || message.constructor === Boolean) console.log("%c[" + time_string + "]: " + message, this.cD[channel].Style); else if (message.constructor === Array) { var output = "[" + time_string + "]: Array ["; for (var key in message) output += "\n\t" + key + ": " + message[key]; output += "\n]"; console.log("%c" + output, this.cD[channel].Style) } else { var output = "[" + time_string + "]: Object {"; for (var key in message) output += "\n\t" + key + ": " + message[key]; output += "\n}"; console.log("%c" + output, this.cD[channel].Style) } } }; Trace.prototype.AddChannel = function (name, style) { this.cD[name] = { Style: style, bEnabled: true }; log[name] = Utils.delegate(this, function (message) { log(message, name) }) }; Trace.prototype.EnableChannel = function (name, bEnabled) { if (this.cD[name]) this.cD[name].bEnabled = bEnabled }; Trace.prototype.ClearChannels = function () { for (var key in this.cD) log[key] = undefined; this.cD = [] }; Trace.prototype.EnableAllChannels = function () { for (var key in this.cD) this.cD[key].bEnabled = true }; Trace.prototype.DisableAllChannels = function () { for (var key in this.cD) this.cD[key].bEnabled = false }; function logas(sourceobject, channel) { if (!sourceobject.m_AnimState) log("No m_AnimState in object", channel); else for (var key in sourceobject) if (key.indexOf("ANIMSTATE_") > -1) if (sourceobject[key] == sourceobject.m_AnimState) { log("m_AnimState: " + key, channel); break } }; function xlogenum(value, sourceobject, channel, prefix) { for (var key in sourceobject) if (prefix !== undefined) { if (key.indexOf(prefix) === 0) if (sourceobject[key] == value) { log("Value might be: " + key + " (" + value + ")", channel); break } } else if (key.toUpperCase() === key) if (sourceobject[key] == value) { log("Value might be: " + key + " (" + value + ")", channel); break } }; function log(message, channel) { if (arguments.length > 2) for (var i = 0; i < arguments.length - 2; i++) if (arguments.length - 2 > i) message = Str.Replace(message, "{" + i + "}", arguments[i + 2]); Utils.Trace.Log(message, channel) } function xlog(message, channel) { if (arguments.length > 2) for (var i = 0; i < arguments.length - 2; i++) if (arguments.length - 2 > i) message = Str.Replace(message, "{" + i + "}", arguments[i + 2]); Utils.Trace.Log(message, channel) } Utils.Trace = new Trace; CreditFormatter.CREDITDISPLAY_COINS = 1; CreditFormatter.CREDITDISPLAY_CURRENCY = 2; CreditFormatter.CREDITDISPLAY_FIXED = 4; CreditFormatter.CREDITDISPLAY_FIXED_TO_MAX = 8; CreditFormatter.AsCredit = -1; CreditFormatter.Denomination = 0; CreditFormatter.DenominationMultiplier = 0; function CreditFormatter() { if (this.constructor !== arguments.callee) return new CreditFormatter } CreditFormatter.prototype.constructor = CreditFormatter; CreditFormatter.Setup = function (val) { if (CreditFormatter.AsCredit === -1) { var val = parseInt(val); switch (val) { case 0: CreditFormatter.AsCredit = CreditFormatter.CREDITDISPLAY_COINS; break; case 1: CreditFormatter.AsCredit = CreditFormatter.CREDITDISPLAY_CURRENCY; break; case 2: CreditFormatter.AsCredit = CreditFormatter.CREDITDISPLAY_COINS; CreditFormatter.AsCredit += CreditFormatter.CREDITDISPLAY_FIXED; break; case 3: CreditFormatter.AsCredit = CreditFormatter.CREDITDISPLAY_CURRENCY; CreditFormatter.AsCredit += CreditFormatter.CREDITDISPLAY_FIXED; break } } }; CreditFormatter.GetCreditString = function (str1, str2) { if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) return str1; else return str2 }; CreditFormatter.FormatCoinValue = function (value, flags) { if (flags == undefined) flags = 0; if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) return String(Math.floor(value)); else return String(Utils.MoneyToString(value * CreditFormatter.Denomination, flags)) }; CreditFormatter.Display = function (value) { if (CreditFormatter.AsCredit == -1) return (CreditFormatter.CREDITDISPLAY_COINS & value) === value; return (CreditFormatter.AsCredit & value) === value }; function ForceTouchHandler(callback) { this.m_ForceValue = 0; this.m_ForceTouch = undefined; this.ao = callback; this.jd = false; this.fps = 30; this.now; this.frameTime = Math.floor(1E3 / this.fps); this.prevUpdate = getTimer() } ForceTouchHandler.prototype.constructor = ForceTouchHandler; ForceTouchHandler.prototype.onForceTouchStart = function (e) { this.jd = true; this.tick(e) }; ForceTouchHandler.prototype.onForceMoveTouch = function (e) { this.m_ForceTouch = e.touches[0]; this.m_ForceValue = this.m_ForceTouch.force; this.ao(this.m_ForceValue) }; ForceTouchHandler.prototype.onForceTouchEnd = function (e) { this.m_ForceValue = 0; this.jd = false }; ForceTouchHandler.prototype.tick = function (e) { var that = this; if (this.jd) { requestAnimFrame(function () { that.tick(e) }); this.now = getTimer(); var elapsedTime = this.now - this.prevUpdate; if (elapsedTime > this.frameTime) { this.prevUpdate = this.now - elapsedTime % this.frameTime; this.m_ForceTouch = e.touches[0]; this.m_ForceValue = this.m_ForceTouch.force; this.ao(this.m_ForceValue) } } }; ENDOFCMD = "\r\n"; function Comm(_url, _fallback) { if (this.constructor !== arguments.callee) return new Comm; this.dK = []; this.hK = []; this.cz = []; this.hE = _url; this.mw = _fallback; this.aI; this.pp = 1; this.jG = "0"; this.gx = (new Date).getTime(); this.na = false; this.nL = 2E3; this.gI = 5E3; this.np = false; this.oW = false; this.gV = 0; this.hS = 0; this.jr = false; this.gq = undefined; this.mT = []; this.vh = true; this.kY; this.InitTransport(this.hE, true); this.kj = false; this.kL = false; this.ka = []; this.m_PostponedServerMessage = []; return this } Comm.prototype.constructor = Comm; Comm.prototype.Close = function () { if (this.aI != null) { this.aI.abort(); this.aI = undefined } }; Comm.prototype.InitTransport = function (_url) { this.Close(); this.UnLockSend(); this.hE = _url; var self = this; this.onOutput = function (command) { self.onData(command) }; if (typeof XDomainRequest == "function") this.aI = new XDomainRequest; else this.aI = new XMLHttpRequest }; Comm.prototype.SetPingHandler = function (pingHandler) { this.kY = pingHandler }; Comm.prototype.IsFlushed = function () { return this.gV == 0 }; Comm.prototype.SetMinKeepAliveTime = function (minTime, steady) { if (steady == undefined) steady = true; this.np = steady; this.gI = this.nL = minTime; this.na = true }; Comm.prototype.IsDataAvailable = function () { if (this.cz.length == 0) return false; return true }; Comm.prototype.GetMoneyCommand = function () { if (this.mT.length == 0) return null; return this.mT.shift() }; Comm.prototype.GetPostponedServerMessageCommand = function () { if (this.m_PostponedServerMessage.length == 0) return null; return this.m_PostponedServerMessage.shift() }; Comm.prototype.GetProjectionCommand = function () { if (this.ka.length == 0) return null; return this.ka.shift() }; Comm.prototype.PeekNext = function () { if (this.cz.length == 0) return 0; return this.cz[0].ae }; Comm.prototype.GetNextCmd = function () { if (this.cz.length == 0) return new Command; return this.cz.shift() }; Comm.prototype.GetNextJSON = function () { if (this.cz.length == 0) return new Object; var s = this.cz.shift(); var o = new Object; o.data = gJ.parse(s.data); o.command = s.__command; o.Rand = s.Rand; return o }; Comm.prototype.SendCmd = function (cmd) { if (this.jr) this.hK.push(cmd); else this.dK.push(cmd) }; Comm.prototype.Send = function (cmdType, data1, data2, data3, data4) { var cmd = new Command(cmdType); if (data1 != undefined) cmd.AddData(data1); if (data2 != undefined) { if (data1 == undefined) cmd.AddData(""); cmd.AddData(data2) } if (data3 != undefined) { if (data2 == undefined) cmd.AddData(""); cmd.AddData(data3) } if (data4 != undefined) { if (data3 == undefined) cmd.AddData(""); cmd.AddData(data4) } if (this.jr) this.hK.push(cmd); else this.dK.push(cmd) }; Comm.prototype.GetJSON = function (cmd, obj) { obj.__command = cmd; obj.Rand = Math.random(); if (this.jr) this.hK.push(obj); else this.dK.push(obj) }; Comm.prototype.Ticker = function () { if (this.oW) return false; if (this.hE == undefined) return true; var t = getTimer(); if (this.gV > 0) { if (this.jG == "0" && this.aI != null && this.mw != undefined) { if (t - this.gx > 5E3) { this.hE = this.mw; this.mw = undefined; this.InitTransport(this.hE, false); this.SendPacket(); return true } } else if (this.aI != null && this.rs != null && this.jr) if (t - this.gx > 5E3) { Close(); UnLockSend(); this.gV = 0 } if (t - this.gx > 5E3) this.kj = true; if (t - this.gx > 3E4) { this.gx = t; this.InitTransport(this.hE, false); this.SendPacket(); this.hS++; if (this.hS >= 2) { this.kj = false; this.oW = true } } return true } if (this.hS > 0) { this.hS = 0; if (this.nH != null) this.nH.HideWin(); this.nH = null } if (this.dK.length == 0) { if (t - this.gx < this.gI || !this.na || this.jG == "0" && !this.gJ) return true; if (this.np != true) this.gI += this.gI * 5; if (!this.gJ) this.Send(0); else if (this.kY != undefined) this.kY() } else this.gI = this.nL; if (this.gV++ == 0); this.gq = this.CreatePacket(); this.SendPacket(); return true }; Comm.prototype.onData = function (src) { if (this.gV == 0) return; if (UAGENT_IE || this.aI.readyState == 4 && this.aI.status == 200) if (this.gJ) this.ParsePacket(this.aI.responseText); else this.ParsePacket(this.aI.responseText.slice(2, this.aI.responseText.length)) }; Comm.prototype.CreatePacket = function () { if (this.gJ) return this.dK.shift(); var sendStr = this.pp.toString() + ENDOFCMD + this.jG + ENDOFCMD; for (var i = 0; i < this.dK.length; i++) { var cmdStr = this.dK[i].CmdStringGet(); sendStr += cmdStr + ENDOFCMD } this.dK.length = 0; return sendStr }; Comm.prototype.ParsePacket = function (d) { if (this.gJ) { var o = new Object; o.data = d; o.__command = this.gq.__command; o.Rand = this.gq.Rand; this.cz.push(o) } else { var resCmds = d.split(ENDOFCMD); for (var i = 0; i < resCmds.length; i++) { if (resCmds[i].length == 0) continue; var cmd = new Command; cmd.CmdStringSet(resCmds[i]); if (cmd.ae == 103) this.jG = cmd.GetData(0); this.Recv(cmd) } } this.pp++; if (--this.gV == 0); }; Comm.prototype.Recv = function (cmd) { this.kj = false; if (cmd.ae == Command.SGETMONEYANSWER || cmd.ae == Command.SSPBUYINANSWER || cmd.ae == Command.SSPBUYINSTATUS) this.mT.push(cmd); else if (cmd.ae == Command.SSERVERMESSAGE && cmd.GetInt(3) == ServerMessage.ACTION_NEWFREEGAME) this.m_PostponedServerMessage.push(cmd); else if (this.kL && cmd.ae == Command.SSPJACKPOTPROJECTION) this.ka.push(cmd); else if (cmd.ae == Command.SGENERATEKEY) { this.qa = cmd.GetString(0); if (this.qa.length == 0) { this.cz.push(cmd); this.UnLockSend() } else this.InitTransport(this.rs, true) } else if (cmd.ae == Command.SGETKEY) { if (cmd.GetInt(0) == 0) { this.Close(); this.vg = null } this.UnLockSend() } else this.cz.push(cmd) }; Comm.prototype.UnLockSend = function () { this.jr = false; this.dK = this.dK.concat(this.hK); this.hK.length = 0 }; Comm.prototype.SendPacket = function () { this.aI.open("POST", this.hE, true); if (UAGENT_IE) { this.aI.send("d=" + this.gq + "\r\n"); this.aI.onload = this.onOutput } else { this.aI.setRequestHeader("Content-Type", "text/plain"); this.aI.onreadystatechange = this.onOutput; this.aI.send("d=" + this.gq + "\r\n") } this.gx = getTimer() }; HostInterface = { gameType: undefined, callbacks: [], debug: false, gameReady: false, init: function (gameType) { this.gameType = gameType }, addCallback: function (name, func) { this[name] = func }, processGenericEvent: function (event) { if (typeof event != "object") this.log("WARNING! GENERIC NOT FOUND!", event, "IS", typeof event, "OBJECT EXPECTED!"); this.log("Internal HostInterface: Processing GENERIC event: ", event.type); switch (event.type) { case "gameStarted": this.dispatchEvent({ type: "gameStarted" }); this.dispatchEvent({ type: "gameReady" }); break; case HostInterface.CALL_SYSTEM_LOGOUT: this.dispatchEvent({ type: "logout" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processMessageEvent: function (event) { if (typeof event != "object") this.log("WARNING! MESSAGE NOT FOUND!", event, "IS", typeof event, "OBJECT EXPECTED!"); this.log("Internal HostInterface: Processing MESSAGE event: ", event.type); this.dispatchEvent({ type: "gameError", data: event.data }) }, processGambleEvent: function (event) { if (typeof event != "object") this.log("WARNING! GAMBLEEVENT NOT FOUND!", event, "IS", typeof event, "OBJECT EXPECTED!"); this.log("Internal HostInterface: Processing gamble event: ", event.type); switch (event.type) { case HostInterface.CALL_GAMBLE_STARTED: case HostInterface.CALL_GAMBLE_ENDED: case HostInterface.CALL_GAMBLE_WON: case HostInterface.CALL_GAMBLE_LOST: this.dispatchEvent(event); break } }, processRoundEvent: function (event) { if (typeof event != "object" || event.type === undefined) this.log("WARNING! ROUNDEVENT NOT FOUND!", event, "IS", typeof event, "OBJECT EXPECTED!"); this.log("Internal HostInterface: Processing round event: ", event.type); switch (event.type) { case HostInterface.CALL_ROUND_STARTED: case HostInterface.CALL_ROUND_ENDED: case HostInterface.CALL_ROUND_BALANCE_UPDATE: case HostInterface.CALL_ROUND_ABORTED: case HostInterface.CALL_ROUND_WIN: this.dispatchEvent(event); break; default: this.dispatchEvent({ type: HostInterface.CALL_ROUND_UNKNOWN }); break } }, processVideoslotState: function (state) { this.log("Internal HostInterface: Processing VIDEOSLOT state: ", state.type); switch (state.type) { case VideoSlot.WAITINGSPIN: this.dispatchEvent({ type: "gameIdle" }); break; case VideoSlot.HANDLEWIN: this.dispatchEvent({ type: "handleWin" }); break; case VideoSlot.GAMBLE: this.dispatchEvent({ type: "preGamble" }); break; case VideoSlot.GAMBLEANIM: this.dispatchEvent({ type: "gambleShowing" }); break; case VideoSlot.GAMBLEANIM: this.dispatchEvent({ type: "gambleShowing" }); break; case HostInterface.CALL_SPIN_STARTED: this.dispatchEvent({ type: "spinStarted" }); break; case HostInterface.CALL_SPIN_ENDED: this.dispatchEvent({ type: "spinEnded" }); break; case HostInterface.CALL_FREESPIN_STARTED: this.dispatchEvent({ type: "freespinStarted" }); break; case HostInterface.CALL_FREESPIN_ENDED: this.dispatchEvent({ type: "freespinEnded" }); break; case HostInterface.CALL_BONUS_STARTED: this.dispatchEvent({ type: "bonusGameStarted" }); break; case HostInterface.CALL_BONUS_ENDED: this.dispatchEvent({ type: "bonusGameEnded" }); break; case HostInterface.CALL_PAYLINE_WIN: this.dispatchEvent({ type: "paylineWin", data: state }); break; case HostInterface.CALL_AUTOPLAY_STARTED: this.dispatchEvent({ type: "autoplayStarted", data: state }); break; case HostInterface.CALL_AUTOPLAY_ENDED: this.dispatchEvent({ type: "autoplayEnded" }); break; case HostInterface.CALL_AUTOPLAY_NEXTROUND: this.dispatchEvent({ type: "autoplayNextRound", data: state }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processSlotState: function (state) { this.log("Internal HostInterface: Processing SLOT state: ", state); switch (state) { case WAITINGSPIN: this.dispatchEvent({ type: "gameIdle" }); break; case PLAYWINANIM: this.dispatchEvent({ type: "win" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processTableGameState: function (state) { this.log("Internal HostInterface: Processing TABLEGAME state: ", state); switch (state) { case State.GS_IDLE: case State.GS_ROUNDEND: this.dispatchEvent({ type: "gameIdle" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processVideoPokerState: function (state) { this.log("Internal HostInterface: Processing VIDEOPOKER state: ", state); switch (state) { case States.WAITINGPOKER: this.dispatchEvent({ type: "gameIdle" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processScratchCardState: function (state) { this.log("Internal HostInterface: Processing SCRATCHCARD state: ", state); switch (state) { case State.WAITINGSPIN: this.dispatchEvent({ type: "gameIdle" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processKenoState: function (state) { this.log("Internal HostInterface: Processing KENO state: ", state); switch (state) { case "gameIdle": case "end": this.dispatchEvent({ type: "gameIdle" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processHiloState: function (state) { this.log("Internal HostInterface: Processing HILO state: ", state); switch (state) { case "end": this.dispatchEvent({ type: "gameIdle" }); break; default: this.dispatchEvent({ type: "unknown" }); break } }, processRouletteState: function (state) { this.log("Internal HostInterface: Processing ROULETTE state: ", state); switch (state) { case "gameIdle": case "end": this.dispatchEvent({ type: "gameIdle" }); default: this.dispatchEvent({ type: "unknown" }); break } }, log: function (msg) { if (this.debug) { var s = ""; for (var i = 0; i < arguments.length; i++) s += " " + arguments[i]; console.log(s) } }, listeners: [], addEventListener: function (type, f) { var e = { type: type }; if (!this.listeners[e.type]) this.listeners[e.type] = []; var listeners = this.listeners[e.type]; if (listeners.indexOf(f) === -1) listeners.push(f) }, removeEventListener: function (e, f) { var listeners = this.listeners[e.type]; if (listeners) { var index = listeners.indexOf(f); if (index !== -1) listeners.splice(index, 1) } }, dispatchEvent: function (event) { var listeners = this.listeners[event.type]; if (listeners) for (var i = 0; i < listeners.length; i++) listeners[i](event) } }; HostInterface.CALL_HANDLE_GAME_ERROR = "CALL_HANDLE_GAME_ERROR"; HostInterface.CALL_SESSION_ID = "SESSION_ID"; HostInterface.CALL_GAME_SESSION_ID = "GAME_SESSION_ID"; HostInterface.CALL_SYSTEM_LOGOUT = "SYSTEM_LOGOUT"; HostInterface.CALL_GAME_READY = "GAME_READY"; HostInterface.CALL_GAME_IDLE = "GAME_IDLE"; HostInterface.CALL_WINLINE_WIN = "WINLINE_WIN"; HostInterface.CALL_FREESPIN_STARTED = "FREESPIN_STARTED"; HostInterface.CALL_FREESPIN_ENDED = "FREESPIN_ENDED"; HostInterface.CALL_BONUS_STARTED = "BONUS_STARTED"; HostInterface.CALL_BONUS_ENDED = "BONUS_ENDED"; HostInterface.CALL_AUTOPLAY_STARTED = "AUTOPLAY_STARTED"; HostInterface.CALL_AUTOPLAY_NEXTROUND = "AUTOPLAY_NEXTROUND"; HostInterface.CALL_AUTOPLAY_ENDED = "AUTOPLAY_ENDED"; HostInterface.CALLBACK_DESTROY = "destroy"; HostInterface.CALLBACK_LOGOUT = "logout"; HostInterface.CALLBACK_SET_SOUND = "setSound"; HostInterface.CALLBACK_BALANCE_UPDATE = "refreshBalance"; HostInterface.CALLBACK_STOP_AUTOPLAY = "stopAutoplay"; HostInterface.CALL_ROUND_STARTED = "roundStarted"; HostInterface.CALL_ROUND_ENDED = "roundEnded"; HostInterface.CALL_ROUND_ABORTED = "roundAborted"; HostInterface.CALL_ROUND_BALANCE_UPDATE = "balanceUpdate"; HostInterface.CALL_ROUND_WIN = "roundWin"; HostInterface.CALL_ROUND_UNKNOWN = "unknown"; HostInterface.CALL_GAMBLE_STARTED = "gambleStarted"; HostInterface.CALL_GAMBLE_ENDED = "gambleEnded"; HostInterface.CALL_GAMBLE_WON = "gambleWon"; HostInterface.CALL_GAMBLE_LOST = "gambleLost"; HostInterface.CALLBACK_GET_BALANCE = "GetBalance"; HostInterface.CALLBACK_GET_BET = "GetBet"; HostInterface.CALLBACK_GET_WIN = "GetWin"; HostInterface.CALLBACK_GET_SELECTED_COIN_VALUE = "GetSelectedCoinVaule"; HostInterface.CALLBACK_GET_SELECTED_COIN = "GetSelectedCoin"; HostInterface.CALLBACK_GET_SELECTED_LINES = "GetSelectedLines"; HostInterface.CALLBACK_AVAILABLE_COINS = "GetAvailableCoins"; HostInterface.CALL_PAYLINE_WIN = "PAYLINE_WIN"; HostInterface.CALL_SPIN_STARTED = "SPIN_STARTED"; HostInterface.CALL_SPIN_ENDED = "SPIN_ENDED"; Command.CSPBUYIN = 51; Command.CREQSPBUYINSTATUS = 52; Command.SSPBUYINANSWER = 51; Command.SSPBUYINSTATUS = 52; Command.SSPBETLIMITS = 53; Command.SSPDENOMINATIONS = 54; Command.SSPJACKPOTPROJECTION = 55; Command.SSPINTERROUNDDATA = 56; Command.SSPCUSTOMDATA = 57; Command.SSPROUNDENDBALANCE = 58; Command.SSFREEGAME = 81; Command.SSFREEGAMEEND = 82; Command.SSPFUNDSERROR = 90; Command.SSPGAMESESSIONID = 91; Command.CLOGIN = 101; Command.CLOGOUT = 102; Command.CREQUESTSESSION = 103; Command.CNEWSPGAME = 104; Command.CGETNUMPLAYERSONLINE = 105; Command.CJOINMPGAME = 107; Command.CLEAVEMPGAME = 108; Command.CGENERATEKEY = 115; Command.CGETKEY = 116; Command.CLEAVESPGAME = 117; Command.SGETMONEYANSWER = 100; Command.SLOGINANSWER = 101; Command.SLOGOUTANSWER = 102; Command.SNEWSESSIONID = 103; Command.SNEWSPGAMESTARTED = 104; Command.SNUMPLAYERSONLINE = 105; Command.SSEATINFO = 106; Command.SMPGAMEJOINED = 107; Command.SRECONNECTEND = 109; Command.SCRITICALERROR = 111; Command.SILLEGALSESSIONID = 113; Command.SGENERATEKEY = 115; Command.SGETKEY = 116; Command.SLEAVESPGAME = 117; Command.SSERVERMESSAGE = 125; Command.SSERVERTIME = 127; Command.CTREGISTER = 120; Command.CTUNREGISTER = 121; Command.CTLIST = 122; Command.STREGISTERRESPONSE = 120; Command.STUNREGISTERRESPONSE = 121; Command.STLISTRESPONCE = 122; Command.STSTART = 123; function Command(cmd) { if (this.constructor !== arguments.callee) return new Command(cmd); this.ae = cmd; this.dM = []; return this } Command.prototype.constructor = Command; Command.prototype.AddData = function (d) { this.dM.push(d) }; Command.prototype.GetData = function (index) { return this.dM[index] }; Command.prototype.GetMoney = function (index) { return parseInt(this.dM[index]) }; Command.prototype.GetInt = function (index) { return parseInt(this.dM[index]) }; Command.prototype.GetString = function (index) { return String(this.dM[index]) }; Command.prototype.GetXML = function (index) { if (window.DOMParser) { var parser = new DOMParser; var xmlDoc = parser.parseFromString(this.dM[0], "text/xml") } else { var xmlDoc = new ActiveXObject("Microsoft.XMLDOM"); xmlDoc.async = false; xmlDoc.loadXML(this.dM[0]) } return xmlDoc }; Command.prototype.CmdStringSet = function (value) { this.dM.length = 0; var str = unescape(value); Str.TokenizeEscaped(this.dM, value); this.ae = parseInt(this.dM[0]); this.dM.splice(0, 1) }; Command.prototype.CmdStringGet = function () { var cmdStr = this.ae.toString(); for (var i = 0; i < this.dM.length; i++) { var str = String(this.dM[i]); if (typeof this.dM[i] == "string" && (str.indexOf(" ") || str.indexOf('"'))) cmdStr += ' "' + escape(str) + '"'; else cmdStr += " " + str } return cmdStr }; Command.prototype.GetNiceCmdString = function () { var cmdStr = this.ae.toString(); for (var i = 0; i < this.dM.length; i++) { var str = this.dM[i]; if (typeof this.dM[i] == "string" && (Str.Contains(str, " ") || Str.Contains(str, '"'))) cmdStr += ' "' + str + '"'; else cmdStr += " " + str } return cmdStr }; RealityCheck = function (cb) { if (this.constructor !== arguments.callee) return new RealityCheck; this.pB = cb; this.jF = 0; this.rh = 0; this.lC = false; this.ad = false; this.dh = 0; this.dI = 0; this.cn = false; this.fV }; RealityCheck.prototype.constructor = RealityCheck; RealityCheck.prototype.destroy = function () { }; RealityCheck.prototype.Start = function () { var that = this; this.dh = 0; this.dI = 0; var setTimeoutMilliseconds = this.jF * 60 * 1E3; if (!this.ad) this.ad = true; this.fV = setTimeout(function () { that.onTimer() }, setTimeoutMilliseconds) }; RealityCheck.prototype.Stop = function () { this.ad = false; clearTimeout(this.fV) }; RealityCheck.prototype.setTimeout = function (minutes) { this.jF = minutes; if (this.jF <= 0) this.Stop(); else this.Start() }; RealityCheck.prototype.handleEventRoundStart = function (Bet, InGame) { if (!this.cn) { this.dh += Bet; this.cn = InGame } }; RealityCheck.prototype.handleEventRoundEnd = function (Win, InGame) { this.dI += Win; this.cn = InGame; if (this.lC) { this.lC = false; this.trigEvent() } }; RealityCheck.prototype.handleEventRoundAbort = function (InGame) { this.cn = InGame }; RealityCheck.prototype.onTimer = function () { if (!this.cn) this.trigEvent(); else this.lC = true }; RealityCheck.prototype.trigEvent = function () { this.rh += this.jF; this.pB(this.dI, this.dh, this.jF); this.Start() }; function LimitsBase() { if (this.constructor !== arguments.callee) return new Command(cmd); this.eO = []; return this } LimitsBase.prototype.constructor = LimitsBase; LimitsBase.prototype.ReadLimits = function (cmd) { var tokens = cmd.GetString(0).split(" "); var num = Number(tokens[0]); this.eO = new Array(num); if (tokens.length == 1 && num != 0) for (var i = 1; i <= num; i++) this.eO[i - 1] = cmd.GetMoney(i); else for (var i = 1; i <= num; i++) this.eO[i - 1] = Number(tokens[i]) }; LimitsBase.prototype.GetLimit = function (index) { return this.eO[index] }; LimitsBase.prototype.ValidateSign = function (sign) { for (var i = 0; i < eO.length; i++) sign["limit" + (i + 1)].text = Utils.MoneyToString(eO[i], eO[i] >= 100 ? Utils.NO_DECIMALS : 0) }; if (window.DOMHelper === undefined) DOMHelper = {}; DOMHelper.createDiv = function (id, className) { var div = document.createElement("div"); DOMHelper.setId(div, id); DOMHelper.setStyle(div, className); return div }; DOMHelper.createAndAppendDiv = function (parent, id, className) { var div = document.createElement("div"); DOMHelper.setId(div, id); DOMHelper.setStyle(div, className); DOMHelper.appendChild(parent, div); return div }; DOMHelper.createTextfield = function (parent, id, className, text) { var div = DOMHelper.createAndAppendDiv(parent, id, className); DOMHelper.setText(div, text); return div }; DOMHelper.createImage = function (parent, id, className, imagePath) { var div = DOMHelper.createAndAppendDiv(parent, id, className); DOMHelper.setImage(div, imagePath); return div }; DOMHelper.createImageFromSpriteSheet = function createImageFromSpriteSheet(parent, id, className, imagePath, imageData) { var div = DOMHelper.createImage(parent, id, className, imagePath); DOMHelper.setImageFromSpriteSheet(div, imagePath, imageData); return div }; DOMHelper.setImageFromSpriteSheet = function (div, imagePath, imageData) { this.setImage(div, imagePath); div.style.backgroundPosition = -imageData.x + "px " + -imageData.y + "px"; div.style.width = imageData.w + "px"; div.style.height = imageData.h + "px" }; DOMHelper.createButton = function (parent, className, id) { var button = document.createElement("button"); button.type = "button"; button.id = id; DOMHelper.setStyle(button, className); DOMHelper.appendChild(parent, button); return button }; DOMHelper.setWidth = function (div, width) { div.style.width = width + "px" }; DOMHelper.getWidth = function (div) { var width = div.style.width; if (width.length > 0) width = width.substring(0, width.length - 2); else width = 0; return Number(width) }; DOMHelper.setHeight = function (div, height) { div.style.height = height + "px" }; DOMHelper.getHeight = function (div) { var height = div.style.height; if (height.length > 0) height = height.substring(0, height.length - 2); else height = 0; return Number(height) }; DOMHelper.setWidthAndHeight = function (div, width, height) { DOMHelper.setWidth(div, width); DOMHelper.setHeight(div, height) }; DOMHelper.setX = function (div, x) { div.style.left = x + "px" }; DOMHelper.getX = function (div) { var x = div.style.left; if (x.length > 0) x = x.substring(0, x.length - 2); else x = 0; return Number(x) }; DOMHelper.setY = function (div, y) { div.style.top = y + "px" }; DOMHelper.getY = function (div) { var y = div.style.top; if (y.length > 0) y = y.substring(0, y.length - 2); else y = 0; return Number(y) }; DOMHelper.setXAndY = function (div, x, y) { DOMHelper.setX(div, x); DOMHelper.setY(div, y) }; DOMHelper.setText = function (div, text) { div.innerHTML = text }; DOMHelper.setBackgroundColor = function (div, color) { if (typeof color === "number") { var colorString = color.toString(16); var numPaddingDigits = 6 - colorString.length; for (var i = 0; i < numPaddingDigits; i++) colorString = "0" + colorString; color = "#" + colorString } else if (typeof color === "string") if (color.substr(0, 1) !== "#") color = "#" + color; div.style.backgroundColor = color }; DOMHelper.setImage = function (div, imagePath) { if (imagePath == undefined) div.style.backgroundImage = ""; else div.style.backgroundImage = "url(" + imagePath + ")" }; DOMHelper.setImageOffset = function (div, x, y) { x = x || 0; y = y || 0; div.style.backgroundPosition = -x + "px " + -y + "px" }; DOMHelper.setId = function (div, id) { if (id !== undefined) div.id = id }; DOMHelper.setStyle = function (div, styleClassName) { if (styleClassName === undefined) styleClassName = ""; if (styleClassName.length > 0) div.className = styleClassName }; DOMHelper.appendChild = function (parent, child) { if (parent !== undefined) if (parent.appendChild) parent.appendChild(child) }; DOMHelper.resizeFontToFitDiv = function (parentDiv, maxFontSize) { if (parentDiv !== undefined) { parentDiv.style.fontSize = maxFontSize; while (this.divHasExceededMaxWidth(parentDiv) && parseInt(parentDiv.style.fontSize) > 6) parentDiv.style.fontSize = parseInt(parentDiv.style.fontSize) - 1 + "px" } }; DOMHelper.divHasExceededMaxWidth = function (parentDiv, scaleFactor, useParentNodeWidth, adjFactor) { if (!scaleFactor) scaleFactor = 1; if (!adjFactor) adjFactor = 0; var children = parentDiv.children; var maxWidth = useParentNodeWidth ? parentDiv.parentNode.offsetWidth : parentDiv.offsetWidth; var totalLength = 0; for (i = 0; i < children.length; i++) totalLength += children[i].offsetWidth; return totalLength + adjFactor > maxWidth / scaleFactor }; DOMHelper.reorderChildrenInDiv = function (parentDiv, childOrder) { var tset = parentDiv.children; for (var i = 0; i < childOrder.length; i++) parentDiv.appendChild(document.getElementById(childOrder[i])) }; DOMHelper.touchUpEventInTarget = function (e) { if (e.type == "mouseup" || e.type == "mousemove") { var x = e.pageX - window.pageXOffset; var y = e.pageY - window.pageYOffset; var targetElement = document.elementFromPoint(x, y); return targetElement !== null && e.target.id == targetElement.id } else { var x = e.changedTouches[0].pageX - window.pageXOffset; var y = e.changedTouches[0].pageY - window.pageYOffset; var targetElement = document.elementFromPoint(x, y); return targetElement !== null && e.changedTouches[0].target.id == targetElement.id } }; var uiElements = { autoPlayIcon: { "x": 690, "y": 124, "w": 39, "h": 48 }, backBtn: { "x": 1113, "y": 104, "w": 93, "h": 93 }, closeBtn: { "x": 1011, "y": 206, "w": 36, "h": 36 }, clockIcon: { "w": 22, "h": 22 }, fastPlayIcon: { "x": 696, "y": 174, "w": 26, "h": 43 }, gambleCollectBtn: { "x": 812, "y": 2, "w": 156, "h": 114 }, gambleCollectBtnHi: { "x": 853, "y": 118, "w": 156, "h": 114 }, genericBtnBg: { "x": 408, "y": 174, "w": 174, "h": 54 }, genericBtnCheck: { "x": 696, "y": 219, "w": 26, "h": 26 }, genericBtnX: { "x": 1087, "y": 206, "w": 26, "h": 26 }, lobbyBtn: { "x": 1174, "y": 2, "w": 93, "h": 93 }, plusBtn: { "x": 1049, "y": 206, "w": 36, "h": 36 }, presetBetBtn: { "x": 2, "y": 174, "w": 172, "h": 65 }, settingsAutoPlayBtn: { "x": 690, "y": 2, "w": 120, "h": 120 }, settingsAutoPlayStopBtn: { "x": 731, "y": 124, "w": 120, "h": 120 }, settingsBtn: { "x": 1208, "y": 97, "w": 93, "h": 93 }, settingsIconAutoAdjustBet: { "x": 176, "y": 174, "w": 56, "h": 56 }, settingsIconFastPlay: { "x": 234, "y": 174, "w": 56, "h": 56 }, settingsIconLeftHand: { "x": 292, "y": 174, "w": 56, "h": 56 }, settingsIconSound: { "x": 350, "y": 174, "w": 56, "h": 56 }, sliderThumb: { "x": 584, "y": 174, "w": 54, "h": 54 }, sliderThumbDisabled: { "x": 640, "y": 174, "w": 54, "h": 54 }, soundOffBtn: { "x": 1269, "y": 2, "w": 93, "h": 93 }, soundOnBtn: { "x": 1303, "y": 97, "w": 93, "h": 93 }, spinBtnAuto: { "x": 970, "y": 2, "w": 100, "h": 100 }, spinBtnBase: { "x": 2, "y": 2, "w": 170, "h": 170 }, spinBtnBaseHi: { "x": 174, "y": 2, "w": 170, "h": 170 }, spinBtnFast: { "x": 1011, "y": 104, "w": 100, "h": 100 }, spinBtnSpin: { "x": 1072, "y": 2, "w": 100, "h": 100 }, stopBtn: { "x": 346, "y": 2, "w": 170, "h": 170 }, stopBtnHi: { "x": 518, "y": 2, "w": 170, "h": 170 }, toggleBaseOff: { "x": 1115, "y": 199, "w": 78, "h": 40 }, toggleBaseOn: { "x": 1195, "y": 199, "w": 78, "h": 40 }, toggleThumbOff: { "x": 1275, "y": 192, "w": 50, "h": 50 }, toggleThumbOn: { "x": 1327, "y": 192, "w": 50, "h": 50 } }; slidercontrol = { current_value: { right_mode_bg_offset: -30, left_mode_touch_width: 80, hz_mode_touch_top: -25, vertical_animation_offset: 30, horizontal_animation_offset: -50, arrow_animation_width: 40, arrow_normal_width: 20, vertical_padding_right_calc: 5, vertical_padding_right_normal: 10 }, vertical_touch_point_offset: 0, left_right_value_scale_padding: 0, default_min_width: 48, default_max_width: 150 }; checkboxcontrol = { drag_buffer: 20, root_height: 40 }; gamepanel = { panels: { portrait_panel_wrapper_inset: 40 }, max_font_size: 26 }; autoplaybutton = { top: -88, left: 47, fontsize: 30 }; betview = { betcashcap_border: 1, apslider_top: 10, slider_fontsize: 24, UKSliderWidth: 475 }; gamehistoryview = { detailspath: "/CasinoHistory/Details/" }; htmlui_gamepanel = { ls: { gpheight: 40, bgheight: 40 }, pt: { gpheight: 185, bgheight: 185 } }; htmlui_sidepanelvs = { spinscale: { ls: { gamble_top_adj: -114, spinscale_top_adj: 400, spinscale_left_adj: -600, s1_adj: -40, s1_denominator: 520, s2_denominator: 960 }, pt: { reelheight: 450, left: 640 - 600, gamble_top_adj1: -185, gamble_top_adj2: -150, gamble_base_adj: 30, s_denominator: 640 }, w: 170, h: 170 } }; htmlui_quickmenu = { ls: { lineslider: { x: 40, y: 40, w: "", h: 370 }, coinslider: { x: 160, y: 40, w: "", h: 370 }, denomslider: { x: 280, y: 40, w: "", h: 370 }, betslider: { x: 330, y: 0, w: "", h: 410 } }, pt: { lineslider: { x: 5, y: 40, w: "", h: "" }, coinslider: { x: 5, y: 140, w: "", h: "" }, denomslider: { x: 5, y: 240, w: "", h: "" }, betslider: { x: 0, y: 40, w: "", h: "" } } }; htmlui_gamblebutton = { fontsize: 28 }; SliderControl.EASE_LINEAR = "linear"; SliderControl.EASE_INSINE = "cubic-bezier(0.47, 0, 0.745, 0.715)"; SliderControl.EASE_OUTSINE = "cubic-bezier(0.39, 0.575, 0.565, 1)"; SliderControl.EASE_INOUTSINE = "cubic-bezier(0.445, 0.05, 0.55, 0.95)"; SliderControl.EASE_INQUAD = "cubic-bezier(0.55, 0.085, 0.68, 0.53)"; SliderControl.EASE_OUTQUAD = "cubic-bezier(0.25, 0.46, 0.45, 0.94)"; SliderControl.EASE_INOUTQUAD = "cubic-bezier(0.455, 0.03, 0.515, 0.955)"; SliderControl.EASE_INCUBIC = "cubic-bezier(0.55, 0.055, 0.675, 0.19)"; SliderControl.EASE_OUTCUBIC = "cubic-bezier(0.215, 0.61, 0.355, 1)"; SliderControl.EASE_INOUTCUBIC = "cubic-bezier(0.645, 0.045, 0.355, 1)"; SliderControl.EASE_INQUART = "cubic-bezier(0.895, 0.03, 0.685, 0.22)"; SliderControl.EASE_OUTQUART = "cubic-bezier(0.165, 0.84, 0.44, 1)"; SliderControl.EASE_INOUTQUART = "cubic-bezier(0.77, 0, 0.175, 1)"; SliderControl.EASE_INQUINT = "cubic-bezier(0.755, 0.05, 0.855, 0.06)"; SliderControl.EASE_OUTQUINT = "cubic-bezier(0.23, 1, 0.32, 1)"; SliderControl.EASE_INOUTQUINT = "cubic-bezier(0.86, 0, 0.07, 1)"; SliderControl.EASE_INEXPO = "cubic-bezier(0.95, 0.05, 0.795, 0.035)"; SliderControl.EASE_OUTEXPO = "cubic-bezier(0.19, 1, 0.22, 1)"; SliderControl.EASE_INOUTEXPO = "cubic-bezier(1, 0, 0, 1)"; SliderControl.EASE_INCIRC = "cubic-bezier(0.6, 0.04, 0.98, 0.335)"; SliderControl.EASE_OUTCIRC = "cubic-bezier(0.075, 0.82, 0.165, 1)"; SliderControl.EASE_INOUTCIRC = "cubic-bezier(0.785, 0.135, 0.15, 0.86)"; SliderControl.EASE_INBACK = "cubic-bezier(0.6, -0.28, 0.735, 0.045)"; SliderControl.EASE_OUTBACK = "cubic-bezier(0.175, 0.885, 0.32, 1.275)"; SliderControl.EASE_INOUTBACK = "cubic-bezier(0.68, -0.55, 0.265, 1.55)"; function SliderControl(callback, valueArray, displayMinValue) { this.m_ValueArray = valueArray; this.ao = callback; this.displayMinValue = typeof displayMinValue !== "undefined" ? displayMinValue : true; this.m_Root; this.m_LeftValue; this.m_Slider; this.m_Background; this.m_BackgroundFill; this.m_Handle; this.aa; this.m_CurrentValueBase; this.m_CurrentValueText; this.m_CurrentValueArrow; this.m_RightValue; this.m_Row1; this.m_Row2; this.m_Row3; this.m_CurrentValueMinWidth = slidercontrol.default_min_width; this.m_CurrentValueMaxWidth = slidercontrol.default_max_width; this.m_CurrentValueCurrentWidth = this.m_CurrentValueMinWidth; this.m_VerticalModeAnimationOffset = 0; this.setupDivs(); this.m_InputDownEvent; this.m_InputMoveEvent; this.m_InputUpEvent; this.m_InputDownDelegate = Utils.delegate(this, this.onInputDown); this.m_InputMoveDelegate = Utils.delegate(this, this.onInputMove); this.m_InputUpDelegate = Utils.delegate(this, this.onInputUp); this.setupEventHandlers(); this.m_ImageData = {}; this.setupImages(); this.updateLeftAndRightValue(); this.m_bLockedMode = false; this.m_bVerticalMode = false; this.m_bRightMode = false; this.m_bSmoothSnaps = false; this.m_currentAlpha = 0.5; this.m_currentValueEase = "linear"; this.setVerticalMode(false); this.updateSlider(0.5); this.setValid(true); if (this.getNumValues() === 1) this.setLockedMode(true) } SliderControl.prototype.constructor = SliderControl; SliderControl.prototype.setValueArray = function (newValueArray) { this.m_ValueArray = newValueArray; this.updateSlider(this.getCurrentAlpha(), true); this.setVerticalMode(this.m_bVerticalMode); if (this.getNumValues() === 1) this.setLockedMode(true) }; SliderControl.prototype.setCallback = function (newCallback) { this.ao = newCallback }; SliderControl.prototype.removeEventHandlers = function () { this.m_Handle.removeEventListener(this.m_InputDownEvent, this.m_InputDownDelegate, false); this.m_Root.removeEventListener(this.m_InputDownEvent, this.m_InputDownDelegate, false); this.m_Root.removeEventListener(this.m_InputMoveEvent, this.m_InputMoveDelegate, false); window.removeEventListener(this.m_InputUpEvent, this.m_InputUpDelegate, false) }; SliderControl.prototype.setupEventHandlers = function () { if ("ontouchstart" in window) { this.m_InputDownEvent = "touchstart"; this.m_InputMoveEvent = "touchmove"; this.m_InputUpEvent = "touchend" } else { this.m_InputDownEvent = "mousedown"; this.m_InputMoveEvent = "mousemove"; this.m_InputUpEvent = "mouseup" } this.m_Handle.addEventListener(this.m_InputDownEvent, this.m_InputDownDelegate, false); this.m_Root.addEventListener(this.m_InputDownEvent, this.m_InputDownDelegate, false) }; SliderControl.prototype.setupImages = function () { var copyObject = function (obj) { var newObj = {}; for (prop in obj) newObj[prop] = obj[prop]; return newObj }; this.m_ImageData.handle = copyObject(uiElements.sliderThumb); this.m_ImageData.handleDisabled = copyObject(uiElements.sliderThumbDisabled); this.m_ImageData.currentValueHorizontal = copyObject(uiElements.ptSliderValueBg); this.m_ImageData.currentValueVertical = copyObject(uiElements.lsSliderValueBg); this.m_ImageData.currentValueHorizontalDisabled = copyObject(uiElements.ptSliderValueBgDisabled); this.m_ImageData.currentValueVerticalDisabled = copyObject(uiElements.lsSliderValueBgDisabled); this.m_Handle.style.backgroundImage = "url('" + image_path_htmlui + "uiElements.png" + "')"; this.m_Handle.style.backgroundPositionX = -this.m_ImageData.handle.x + "px"; this.m_Handle.style.backgroundPositionY = -this.m_ImageData.handle.y + "px"; this.m_Handle.style.width = this.m_ImageData.handle.w + "px"; this.m_Handle.style.height = this.m_ImageData.handle.h + "px" }; SliderControl.prototype.setupDivs = function () { this.m_Root = document.createElement("div"); this.jE = document.createElement("div"); this.jE.innerHTML = "Caption"; this.m_Root.appendChild(this.jE); this.m_LeftValue = document.createElement("div"); this.m_Root.appendChild(this.m_LeftValue); this.m_Slider = document.createElement("div"); this.m_Root.appendChild(this.m_Slider); this.m_Background = document.createElement("div"); this.m_Slider.appendChild(this.m_Background); this.m_BackgroundFill = document.createElement("div"); this.m_Background.appendChild(this.m_BackgroundFill); this.m_Handle = document.createElement("div"); this.m_Slider.appendChild(this.m_Handle); this.m_CurrentValueBase = document.createElement("div"); this.m_CurrentValueBase.id = "currentvalue_base"; this.m_Slider.appendChild(this.m_CurrentValueBase); this.m_CurrentValueText = document.createElement("div"); this.m_CurrentValueText.id = "currentvalue_text"; this.m_CurrentValueBase.appendChild(this.m_CurrentValueText); this.m_CurrentValueArrow = document.createElement("div"); this.m_CurrentValueArrow.id = "currentvalue_arrow"; this.m_CurrentValueBase.appendChild(this.m_CurrentValueArrow); this.m_RightValue = document.createElement("div"); this.m_Root.appendChild(this.m_RightValue); this.m_Row1 = document.createElement("div"); this.m_Row1.style.display = "table-row"; this.m_Row2 = document.createElement("div"); this.m_Row2.style.display = "table-row"; this.m_Row3 = document.createElement("div"); this.m_Row3.style.display = "table-row"; this.jE.style.pointerEvents = "none"; this.m_LeftValue.style.pointerEvents = "none"; this.m_Background.style.pointerEvents = "none"; this.m_BackgroundFill.style.pointerEvents = "none"; this.m_Slider.style.pointerEvents = "none"; this.m_CurrentValueBase.style.pointerEvents = "none"; this.m_CurrentValueText.style.pointerEvents = "none"; this.m_CurrentValueArrow.style.pointerEvents = "none"; this.m_RightValue.style.pointerEvents = "none"; this.m_Row1.style.pointerEvents = "none"; this.m_Row2.style.pointerEvents = "none"; this.m_Row3.style.pointerEvents = "none" }; SliderControl.prototype.setCaption = function (newCaption) { this.jE.innerHTML = newCaption }; SliderControl.prototype.setEaseType = function (easeString) { this.m_Handle.style.transitionTimingFunction = easeString; this.m_CurrentValueBase.style.transitionTimingFunction = easeString; this.m_BackgroundFill.style.transitionTimingFunction = easeString; this.m_currentValueEase = easeString }; SliderControl.prototype.setSmoothSnaps = function (bSetSmoothSnaps) { if (bSetSmoothSnaps) { this.m_Handle.style.transitionProperty = "margin"; this.m_Handle.style.transitionDuration = "0.15s"; this.m_CurrentValueBase.style.transition = "width 0.25s, top 0.25s, margin 0.15s"; this.m_BackgroundFill.style.transitionProperty = "height, width"; this.m_BackgroundFill.style.transitionDuration = "0.15s" } else { this.m_Handle.style.transitionProperty = ""; this.m_Handle.style.transitionDuration = ""; this.m_CurrentValueBase.style.transitionProperty = ""; this.m_CurrentValueBase.style.transitionDuration = ""; this.m_BackgroundFill.style.transitionProperty = ""; this.m_BackgroundFill.style.transitionDuration = "" } this.m_bSmoothSnaps = bSetSmoothSnaps }; SliderControl.prototype.setRightMode = function (bSetRightMode) { this.m_bRightMode = bSetRightMode; this.setVerticalMode(this.m_bVerticalMode) }; SliderControl.prototype.setValueIndex = function (index) { var alpha = index / (this.getNumValues() - 1); alpha = Math.min(Math.max(alpha, 0), 1); this.updateSlider(alpha) }; SliderControl.prototype.setValue = function (value) { var index = this.m_ValueArray.indexOf(value); if (index > -1) this.setValueIndex(index) }; SliderControl.prototype.getMinValue = function () { return this.getValue(0) }; SliderControl.prototype.getMaxValue = function () { return this.getValue(this.getNumValues() - 1) }; SliderControl.prototype.getCurrentValueIndex = function () { return this.getValueIndex(this.getCurrentAlpha()) }; SliderControl.prototype.getCurrentValue = function () { return this.getValue(this.getCurrentValueIndex()) }; SliderControl.prototype.getCurrentAlpha = function () { if (this.m_bVerticalMode) return this.m_currentAlpha; else return this.m_currentAlpha }; SliderControl.prototype.setCurrentAlpha = function (newAlpha) { if (this.m_bVerticalMode) this.m_currentAlpha = 1 - newAlpha; else this.m_currentAlpha = newAlpha; this.m_currentAlpha = newAlpha }; SliderControl.prototype.getValueIndex = function (alpha) { var maxStep = this.getNumValues() - 1; if (maxStep !== 0) { var step_size = 1 / (this.getNumValues() - 1); var step_index = Math.floor((alpha + step_size * 0.5) / step_size) } else step_index = 0; return step_index }; SliderControl.prototype.getValue = function (index) { if (index < this.getNumValues() && index >= 0) return this.m_ValueArray[index]; return undefined }; SliderControl.prototype.getValueByAlpha = function (alpha) { return this.getValue(this.getValueIndex(alpha)) }; SliderControl.prototype.getNumValues = function () { return this.m_ValueArray.length }; SliderControl.prototype.setVerticalMode = function (bSetAsVerticalMode) { var orientation = bSetAsVerticalMode ? "vertical" : "horizontal"; this.m_Root.className = orientation + " slider_root"; this.m_LeftValue.className = orientation + " slider_left_value"; this.m_Slider.className = orientation + " slider"; this.m_Background.className = orientation + " slider_background"; this.m_BackgroundFill.className = orientation + " slider_fill"; this.m_Handle.className = orientation + " slider_handle"; this.m_RightValue.className = orientation + " slider_right_value"; this.jE.className = orientation + " slider_caption"; this.m_CurrentValueBase.className = orientation + (this.m_bRightMode ? " right" : ""); if (bSetAsVerticalMode) { this.m_Root.appendChild(this.m_Row2); this.m_Row2.appendChild(this.m_Slider); var backgroundOffset = 0; if (this.m_bVerticalMode && this.m_bRightMode) { backgroundOffset = slidercontrol.current_value.right_mode_bg_offset; this.m_LeftValue.className += " right_mode"; this.m_RightValue.className += " right_mode" } } else { this.m_Root.appendChild(this.m_LeftValue); this.m_Root.appendChild(this.m_Slider); this.m_Root.appendChild(this.m_RightValue); if (this.m_Root.contains(this.m_Row1)) this.m_Root.removeChild(this.m_Row1); if (this.m_Root.contains(this.m_Row2)) this.m_Root.removeChild(this.m_Row2); if (this.m_Root.contains(this.m_Row3)) this.m_Root.removeChild(this.m_Row3) } this.m_Handle.style.marginTop = ""; this.m_CurrentValueBase.style.marginTop = ""; this.m_BackgroundFill.style.height = ""; this.m_Handle.style.marginLeft = ""; this.m_CurrentValueBase.style.marginLeft = ""; this.m_BackgroundFill.style.width = ""; var bShouldInvertAlpha = this.m_bVerticalMode !== bSetAsVerticalMode; this.m_bVerticalMode = bSetAsVerticalMode; this.updateVisuals(); this.updateLeftAndRightValue(); this.updateSlider(this.getCurrentAlpha()) }; SliderControl.prototype.onInputDown = function (e) { if (this.m_bVerticalMode) if (this.m_bRightMode) this.m_VerticalModeAnimationOffset = slidercontrol.current_value.vertical_animation_offset; else this.m_VerticalModeAnimationOffset = slidercontrol.current_value.vertical_animation_offset; else; if (e.target !== this.m_Handle) { var alpha = this.calculateSliderPosition(e); this.updateSlider(alpha) } this.m_Root.addEventListener(this.m_InputMoveEvent, this.m_InputMoveDelegate, false); window.addEventListener(this.m_InputUpEvent, this.m_InputUpDelegate, false) }; SliderControl.prototype.onInputMove = function (e) { e.preventDefault(); e.stopPropagation(); var alpha = this.calculateSliderPosition(e); this.updateSlider(alpha) }; SliderControl.prototype.onInputUp = function (e) { this.m_CurrentValueBase.style.marginTop = ""; this.m_CurrentValueArrow.style.borderTopWidth = ""; this.m_CurrentValueArrow.style.borderLeftWidth = ""; this.m_CurrentValueArrow.style.borderRightWidth = ""; this.m_VerticalModeAnimationOffset = 0; this.m_Root.removeEventListener(this.m_InputMoveEvent, this.m_InputMoveDelegate, false); window.removeEventListener(this.m_InputUpEvent, this.m_InputUpDelegate, false) }; SliderControl.prototype.setLockedMode = function (bLockSlider) { bLockSlider = bLockSlider || this.getNumValues() === 1; if (this.m_bLockedMode != bLockSlider) if (bLockSlider) this.removeEventHandlers(); else { this.setupEventHandlers(); this.setVerticalMode(this.m_bVerticalMode) } this.m_bLockedMode = bLockSlider; this.updateVisuals(); this.updateSlider(this.getCurrentAlpha()) }; SliderControl.prototype.updateVisuals = function () { if (this.m_bLockedMode) { this.m_Handle.style.backgroundPositionX = -this.m_ImageData.handleDisabled.x + "px"; this.m_Handle.style.backgroundPositionY = -this.m_ImageData.handleDisabled.y + "px"; this.setStyleDisabled(); this.m_CurrentValueArrow.style.borderTopStyle = "solid"; this.m_CurrentValueArrow.style.borderTopWidth = slidercontrol.current_value.arrow_normal_width + "px"; if (this.m_bVerticalMode) { this.m_Background.style.background = "#ccc"; this.m_BackgroundFill.style.background = "#fff" } else { this.m_Background.style.background = "#fff"; this.m_BackgroundFill.style.background = "#ccc" } } else { this.m_Handle.style.backgroundPositionX = -this.m_ImageData.handle.x + "px"; this.m_Handle.style.backgroundPositionY = -this.m_ImageData.handle.y + "px"; this.m_BackgroundFill.style.background = ""; this.m_Background.style.background = ""; this.setStyleActive(); this.m_CurrentValueArrow.style.borderTopStyle = "solid"; this.m_CurrentValueArrow.style.borderTopWidth = slidercontrol.current_value.arrow_normal_width + "px" } }; SliderControl.prototype.hideMinMaxValues = function (alpha) { var stepIndex = this.getValueIndex(alpha); if (this.m_bLockedMode || this.getNumValues() === 1) { this.m_RightValue.style.opacity = "0"; this.m_LeftValue.style.opacity = "0" } else if (stepIndex === 0) if (this.m_bVerticalMode) { this.m_RightValue.style.opacity = "0"; this.m_LeftValue.style.opacity = "" } else { this.m_LeftValue.style.opacity = ""; this.m_RightValue.style.opacity = "" } else if (stepIndex === this.getNumValues() - 1) if (this.m_bVerticalMode) { this.m_LeftValue.style.opacity = "0"; this.m_RightValue.style.opacity = "" } else { this.m_RightValue.style.opacity = ""; this.m_LeftValue.style.opacity = "" } else { this.m_LeftValue.style.opacity = ""; this.m_RightValue.style.opacity = "" } }; SliderControl.prototype.updateSlider = function (alpha, bForceCallback) { var stepIndex = this.getValueIndex(alpha); var maxStep = this.getNumValues() - 1; var stepAlpha = 1; if (maxStep !== 0) stepAlpha = stepIndex / (this.getNumValues() - 1); this.hideMinMaxValues(alpha); if (this.m_bVerticalMode) this.updateSliderVertical(stepAlpha, stepIndex); else this.updateSliderHorizontal(stepAlpha, stepIndex); var bSendCallback = this.getCurrentAlpha() !== stepAlpha || bForceCallback; var oldAlpha = this.getCurrentAlpha(); this.setCurrentAlpha(stepAlpha); if (bSendCallback && this.ao !== undefined) this.ao({ alpha: stepAlpha, oldAlpha: oldAlpha, index: this.getValueIndex(stepAlpha), oldIndex: this.getValueIndex(oldAlpha), value: this.getValueByAlpha(stepAlpha), oldValue: this.getValueByAlpha(oldAlpha) }) }; SliderControl.prototype.calculateSliderPosition = function (e) { if (this.m_bVerticalMode) return this.calculateSliderPositionVertical(e); else return this.calculateSliderPositionHorizontal(e) }; SliderControl.prototype.calculateSliderPositionVertical = function (e) { if (e.type === "touchstart" || e.type === "touchmove") { if (e.touches && e.touches.length > 0) { var touch = e.touches[0]; var trackRect = this.m_Background.getBoundingClientRect(); var trackStart = trackRect.top; var trackLength = trackRect.height; var touchPoint = touch.clientY + slidercontrol.vertical_touch_point_offset; var normalizedTouchPoint = (touchPoint - trackStart) / trackLength; var clamped = Math.min(Math.max(normalizedTouchPoint, 0), 1); clamped = 1 - clamped; return clamped } } else if (e.type === "mousedown" || e.type === "mousemove") { var trackRect = this.m_Background.getBoundingClientRect(); var trackStart = trackRect.top; var trackLength = trackRect.height; var normalizedTouchPoint = (e.clientY - trackStart) / trackLength; var clamped = Math.min(Math.max(normalizedTouchPoint, 0), 1); clamped = 1 - clamped; return clamped } return 0 }; SliderControl.prototype.calculateSliderPositionHorizontal = function (e) { if (e.type === "touchstart" || e.type === "touchmove") { if (e.touches && e.touches.length > 0) { var touch = e.touches[0]; var trackRect = this.m_Background.getBoundingClientRect(); var trackStart = trackRect.left; var trackLength = trackRect.width; var touchPoint = touch.clientX; var normalizedTouchPoint = (touchPoint - trackStart) / trackLength; var clamped = Math.min(Math.max(normalizedTouchPoint, 0), 1); return clamped } } else if (e.type === "mousedown" || e.type === "mousemove") { var trackRect = this.m_Background.getBoundingClientRect(); var trackStart = trackRect.left; var trackLength = trackRect.width; var normalizedTouchPoint = (e.clientX - trackStart) / trackLength; var clamped = Math.min(Math.max(normalizedTouchPoint, 0), 1); return clamped } return 0 }; SliderControl.prototype.updateSliderTopValue = function () { var topValue = Math.floor(this.m_Root.clientHeight / 2); if (topValue > 0) { this.m_Handle.style.top = topValue + "px"; this.m_CurrentValueBase.style.top = topValue + "px" } }; SliderControl.prototype.updateSliderHorizontal = function (alpha, index) { this.m_Handle.style.marginLeft = Math.floor(alpha * 100) + "%"; this.m_CurrentValueBase.style.marginLeft = Math.floor(alpha * 100) + "%"; this.m_BackgroundFill.style.width = Math.floor(alpha * 100) + "%"; this.updateSliderTopValue(); this.setCurrentValueText(this.getValue(index)) }; SliderControl.prototype.updateSliderVertical = function (alpha, index) { var track_height = this.getSliderSize(); this.m_Handle.style.marginTop = Math.floor((1 - alpha) * track_height) + "px"; this.m_CurrentValueBase.style.marginTop = Math.floor((1 - alpha) * track_height) + "px"; this.m_BackgroundFill.style.height = Math.floor((1 - alpha) * 100) + "%"; this.setCurrentValueText(this.getValue(index)) }; SliderControl.prototype.getSliderSize = function () { var rect = this.m_Background.getClientRects()[0]; var size = 0; if (rect) if (this.m_bVerticalMode) { size = rect.height; size = this.m_Background.clientHeight } else { size = rect.width; size = this.m_Background.clientWidth } return size }; SliderControl.prototype.setXAndY = function (x, y) { if (x !== undefined) this.m_Root.style.left = x + "px"; if (y !== undefined) this.m_Root.style.top = y + "px" }; SliderControl.prototype.setWidthAndHeight = function (width, height) { if (width === "") this.m_Root.style.width = ""; else if (width !== undefined) this.m_Root.style.width = width + "px"; if (height === "") this.m_Root.style.height = ""; else if (height !== undefined) { console.log("HEIGHT"); console.log(height); this.m_Root.style.height = height + "px" } this.updateSlider(this.getCurrentAlpha()) }; SliderControl.prototype.getDOMNode = function () { return this.m_Root }; SliderControl.prototype.setCurrentValueText = function (text) { if (this.m_bVerticalMode) if ((text === "0" || text === "0.00") && !this.displayMinValue) this.setCurrentTextVertical("-"); else this.setCurrentTextVertical(text); else if ((text === "0" || text === "0.00") && !this.displayMinValue) this.setCurrentTextHorizontal("-"); else this.setCurrentTextHorizontal(text) }; SliderControl.prototype.setCurrentTextVertical = function (text) { this.m_CurrentValueText.innerText = text; this.m_CurrentValueText.style.display = "inline-block"; this.m_CurrentValueText.style.width = "auto"; this.m_CurrentValueText.style.left = "auto"; if (this.m_bRightMode) { this.m_CurrentValueText.style.paddingLeft = slidercontrol.current_value.vertical_padding_right_calc + "px"; var width = this.m_CurrentValueText.scrollWidth; this.m_CurrentValueText.style.paddingLeft = "0px"; this.m_CurrentValueText.style.left = "0"; if (width <= this.m_CurrentValueMaxWidth) { width = Math.max(width, this.m_CurrentValueMinWidth); this.m_CurrentValueCurrentWidth = width; this.m_CurrentValueBase.style.width = "100%"; this.m_CurrentValueText.style.transform = ""; this.m_CurrentValueText.style.webkitTransform = ""; this.m_CurrentValueText.style.display = "block"; this.m_CurrentValueText.style.width = ""; console.log(this.m_CurrentValueBase.width) } else { this.m_CurrentValueCurrentWidth = this.m_CurrentValueMaxWidth; var scale = this.m_CurrentValueCurrentWidth / width; this.m_CurrentValueBase.style.width = "100%"; this.m_CurrentValueText.style.webkitTransform = "scale(" + scale + ", " + scale + ")"; this.m_CurrentValueText.style.transform = "scale(" + scale + ", " + scale + ")"; this.m_CurrentValueText.style.webkitTransformOrigin = "0% 50%"; this.m_CurrentValueText.style.transformOrigin = "0% 50%"; this.m_CurrentValueText.style.width = Math.floor(1 / scale * 100) + "%" } } else { this.m_CurrentValueText.style.paddingRight = slidercontrol.current_value.vertical_padding_right_calc + "px"; var width = this.m_CurrentValueText.offsetWidth; this.m_CurrentValueText.style.paddingRight = slidercontrol.current_value.vertical_padding_right_normal + "px"; if (width <= this.m_CurrentValueMaxWidth) { width = Math.max(width, this.m_CurrentValueMinWidth); this.m_CurrentValueCurrentWidth = width; this.m_CurrentValueText.style.transform = ""; this.m_CurrentValueText.style.webkitTransform = ""; this.m_CurrentValueText.style.display = "block"; this.m_CurrentValueText.style.width = "" } else { this.m_CurrentValueCurrentWidth = this.m_CurrentValueMaxWidth; var scale = this.m_CurrentValueCurrentWidth / width; this.m_CurrentValueText.style.transform = "scale(" + scale + ", " + scale + ")"; this.m_CurrentValueText.style.webkitTransform = "scale(" + scale + ", " + scale + ")"; this.m_CurrentValueText.style.width = Math.floor(1 / scale * 100) + "%" } } }; SliderControl.prototype.setCurrentTextHorizontal = function (text) { this.m_CurrentValueText.innerText = text; this.m_CurrentValueText.style.display = "inline-block"; this.m_CurrentValueText.style.transitionDuration = "0"; this.m_CurrentValueText.style.transform = ""; this.m_CurrentValueText.style.webkitTransform = ""; var width = this.m_CurrentValueText.scrollWidth; if (width <= this.m_CurrentValueMaxWidth) { width = Math.max(width, this.m_CurrentValueMinWidth); this.m_CurrentValueCurrentWidth = width; this.m_CurrentValueText.style.transform = ""; this.m_CurrentValueText.style.webkitTransform = ""; this.m_CurrentValueText.style.display = "block"; this.m_CurrentValueText.style.width = "" } else { this.m_CurrentValueCurrentWidth = this.m_CurrentValueMaxWidth; var scale = this.m_CurrentValueCurrentWidth / width; this.m_CurrentValueText.style.transform = "scale(" + scale + ", " + scale + ")"; this.m_CurrentValueText.style.webkitTransform = "scale(" + scale + ", " + scale + ")"; this.m_CurrentValueText.style.width = "" } this.m_CurrentValueText.style.transitionDuration = "" }; SliderControl.prototype.updateLeftAndRightValue = function () { var minValue = this.getMinValue(); if (!this.displayMinValue) minValue = "-"; this.m_LeftValue.innerText = this.m_bVerticalMode ? this.getMaxValue() : minValue; this.m_RightValue.innerText = !this.m_bVerticalMode ? this.getMaxValue() : minValue; if (this.m_bVerticalMode) { var leftWidth = this.m_LeftValue.clientWidth; var leftScrollWidth = this.m_LeftValue.scrollWidth + slidercontrol.left_right_value_scale_padding; var leftScale = leftWidth / leftScrollWidth; leftScale = Math.min(leftScale, 1); this.m_LeftValue.style.transform = "scale(" + leftScale + ", " + leftScale + ")"; this.m_LeftValue.style.webkitTransform = "scale(" + leftScale + ", " + leftScale + ")"; var rightWidth = this.m_RightValue.clientWidth; var rightScrollWidth = this.m_RightValue.scrollWidth + slidercontrol.left_right_value_scale_padding; var rightScale = rightWidth / rightScrollWidth; rightScale = Math.min(rightScale, 1); this.m_RightValue.style.transform = "scale(" + rightScale + ", " + rightScale + ")"; this.m_RightValue.style.webkitTransform = "scale(" + rightScale + ", " + rightScale + ")" } else { this.m_LeftValue.style.transform = ""; this.m_RightValue.style.transform = "" } }; SliderControl.prototype.setValid = function (b) { this.m_isValid = b; if (b) this.setStyleActive(); else this.setStyleInvalid() }; SliderControl.prototype.isValid = function () { return this.m_isValid }; SliderControl.prototype.setStyleActive = function () { if (!this.m_isValid) { this.setStyleInvalid(); return } this.m_CurrentValueArrow.classList.remove("currentValue_Arrow_Invalid"); this.m_CurrentValueText.classList.remove("currentValue_Text_Invalid"); this.m_CurrentValueArrow.classList.remove("currentValue_Arrow_Disabled"); this.m_CurrentValueText.classList.remove("currentValue_Text_Disabled"); this.m_CurrentValueArrow.classList.add("currentValue_Arrow"); this.m_CurrentValueText.classList.add("currentValue_Text"); this.updateSliderTopValue() }; SliderControl.prototype.setStyleDisabled = function () { this.m_CurrentValueArrow.classList.remove("currentValue_Arrow_Invalid"); this.m_CurrentValueText.classList.remove("currentValue_Text_Invalid"); this.m_CurrentValueArrow.classList.add("currentValue_Arrow_Disabled"); this.m_CurrentValueText.classList.add("currentValue_Text_Disabled"); this.m_CurrentValueArrow.classList.remove("currentValue_Arrow"); this.m_CurrentValueText.classList.remove("currentValue_Text"); this.updateSliderTopValue() }; SliderControl.prototype.setStyleInvalid = function () { this.m_CurrentValueArrow.classList.add("currentValue_Arrow_Invalid"); this.m_CurrentValueText.classList.add("currentValue_Text_Invalid"); this.m_CurrentValueArrow.classList.remove("currentValue_Arrow_Disabled"); this.m_CurrentValueText.classList.remove("currentValue_Text_Disabled"); this.m_CurrentValueArrow.classList.remove("currentValue_Arrow"); this.m_CurrentValueText.classList.remove("currentValue_Text"); this.updateSliderTopValue() }; function CheckboxControl(callback, textString, iconName) { this.ao = callback; this.m_bEnabled = false; this.m_Root = document.createElement("div"); this.m_Background = document.createElement("div"); this.m_Thumb = document.createElement("div"); this.m_Root.className = "checkbox_root"; this.m_TouchInside = false; if (iconName !== undefined) { this.bO = document.createElement("div"); this.bO.className = "checkbox_icon"; this.bO.style.backgroundImage = "url('" + image_path_htmlui + "uiElements.png" + "')"; var icon = uiElements[iconName]; this.bO.style.width = icon.w + "px"; this.bO.style.height = icon.h + "px"; this.bO.style.backgroundPositionX = -icon.x + "px"; this.bO.style.backgroundPositionY = -icon.y + "px"; this.m_Root.appendChild(this.bO) } if (textString !== undefined) { this.T = document.createElement("div"); this.T.className = "checkbox_text"; this.m_Root.appendChild(this.T); this.T.innerHTML = textString } this.m_Root.appendChild(this.m_Background); this.m_Background.appendChild(this.m_Thumb); this.m_Root.style.position = "absolute"; this.m_ImageData = {}; this.setupImages(); this.m_InputDownEvent; this.m_InputMoveEvent; this.m_InputUpEvent; this.m_InputMoveDelegate = Utils.delegate(this, this.onInputMove); this.m_InputUpDelegate = Utils.delegate(this, this.onInputUp); this.m_InputTarget; this.setupEventHandlers(); this.m_bWantToToggle = false; this.m_StartDragPoint = { x: 0, y: 0 }; this.m_LastDragPoint = { x: 0, y: 0 }; this.setEnabled(false); this.setXAndY(0, 0) } CheckboxControl.prototype.constructor = CheckboxControl; CheckboxControl.prototype.setCallback = function (newCallback) { this.ao = newCallback }; CheckboxControl.prototype.setupImages = function () { var copyObject = function (obj) { var newObj = {}; for (prop in obj) newObj[prop] = obj[prop]; return newObj }; this.m_ImageData.thumbOn = copyObject(uiElements.toggleThumbOn); this.m_ImageData.thumbOff = copyObject(uiElements.toggleThumbOff); this.m_ImageData.backgroundOn = copyObject(uiElements.toggleBaseOn); this.m_ImageData.backgroundOff = copyObject(uiElements.toggleBaseOff); this.m_Background.style.backgroundImage = "url(" + image_path_htmlui + "uiElements.png)"; this.m_Thumb.style.backgroundImage = "url(" + image_path_htmlui + "uiElements.png)"; this.m_Background.style.width = this.m_ImageData.backgroundOff.w + "px"; this.m_Background.style.height = this.m_ImageData.backgroundOff.h + "px"; this.m_Thumb.style.width = this.m_ImageData.thumbOff.w + "px"; this.m_Thumb.style.height = this.m_ImageData.thumbOff.h + "px"; this.setEnabled(this.m_bEnabled) }; CheckboxControl.prototype.setupEventHandlers = function () { if ("ontouchstart" in window) { this.m_InputDownEvent = "touchstart"; this.m_InputUpEvent = "touchend"; this.m_InputMoveEvent = "touchmove"; this.m_InputTarget = this.m_Background } else { this.m_InputDownEvent = "mousedown"; this.m_InputUpEvent = "mouseup"; this.m_InputMoveEvent = "mousemove"; this.m_InputTarget = window } this.m_Background.addEventListener(this.m_InputDownEvent, Utils.delegate(this, this.onInputDown)) }; CheckboxControl.prototype.onInputMove = function (e) { var input = e; var x, y; if (e.type == "mouseup" || e.type == "mousemove") { x = e.pageX; y = e.pageY } else { x = e.changedTouches[0].pageX; y = e.changedTouches[0].pageY } if (e.touches && e.touches.length > 0) input = e.touches[0]; this.m_LastDragPoint.x = x; this.m_LastDragPoint.y = y; if (x > this.m_StartDragPoint.x + checkboxcontrol.drag_buffer) { this.setEnabled(true); this.m_bWantToToggle = false } else if (x < this.m_StartDragPoint.x - checkboxcontrol.drag_buffer) { this.setEnabled(false); this.m_bWantToToggle = false } if (!DOMHelper.touchUpEventInTarget(e)) this.m_TouchInside = false; e.preventDefault(); e.stopPropagation() }; CheckboxControl.prototype.onInputDown = function (e) { var input = e; if (e.touches && e.touches.length > 0) input = e.touches[0]; this.m_bWantToToggle = true; this.m_LastDragPoint.x = this.m_StartDragPoint.x = input.pageX; this.m_LastDragPoint.y = this.m_StartDragPoint.y = input.pageY; this.m_InputTarget.addEventListener(this.m_InputMoveEvent, this.m_InputMoveDelegate); this.m_InputTarget.addEventListener(this.m_InputUpEvent, this.m_InputUpDelegate); this.m_TouchInside = true }; CheckboxControl.prototype.onInputUp = function (e) { var rects = this.m_Background.getClientRects(); var rect = undefined; if (rects.length > 0) rect = rects[0]; if (this.m_TouchInside && this.m_bWantToToggle) { this.toggle(); this.m_InputTarget.removeEventListener(this.m_InputMoveEvent, this.m_InputMoveDelegate); this.m_InputTarget.removeEventListener(this.m_InputUpEvent, this.m_InputUpDelegate); return } if (this.m_bWantToToggle) if (rect !== undefined) { var bIsWithinX = this.m_LastDragPoint.x >= rect.left && this.m_LastDragPoint.x <= rect.right; var bIsWithinY = this.m_LastDragPoint.y >= rect.top && this.m_LastDragPoint.y <= rect.bottom; if (bIsWithinX && bIsWithinY) this.toggle() } else this.toggle(); this.m_bWantToToggle = false; this.m_InputTarget.removeEventListener(this.m_InputMoveEvent, this.m_InputMoveDelegate); this.m_InputTarget.removeEventListener(this.m_InputUpEvent, this.m_InputUpDelegate) }; CheckboxControl.prototype.setX = function (x) { this.setXAndY(x, undefined) }; CheckboxControl.prototype.setY = function (y) { this.setXAndY(undefined, y) }; CheckboxControl.prototype.setXAndY = function (x, y) { if (x !== undefined) this.m_Root.style.left = x + "px"; if (y !== undefined) this.m_Root.style.top = y + "px" }; CheckboxControl.prototype.setEnabled = function (bSetEnabled, ignoreCallback) { var bSendCallback = this.m_bEnabled !== bSetEnabled && !ignoreCallback; this.m_bEnabled = bSetEnabled; if (bSetEnabled) { this.m_Background.className = "checkbox_background_on"; this.m_Thumb.className = "checkbox_thumb_on"; this.m_Background.style.backgroundPositionX = -this.m_ImageData.backgroundOn.x + "px"; this.m_Background.style.backgroundPositionY = -this.m_ImageData.backgroundOn.y + "px"; this.m_Thumb.style.backgroundPosition = -this.m_ImageData.thumbOn.x + "px " + -this.m_ImageData.thumbOn.y + "px" } else { this.m_Background.className = "checkbox_background_off"; this.m_Thumb.className = "checkbox_thumb_off"; this.m_Background.style.backgroundPosition = -this.m_ImageData.backgroundOff.x + "px " + -this.m_ImageData.backgroundOff.y + "px"; this.m_Thumb.style.backgroundPosition = -this.m_ImageData.thumbOff.x + "px " + -this.m_ImageData.thumbOff.y + "px" } if (this.ao !== undefined && bSendCallback) this.ao({ value: this.m_bEnabled }) }; CheckboxControl.prototype.toggle = function () { this.setEnabled(!this.m_bEnabled) }; CheckboxControl.prototype.getEnabled = function () { return this.m_bEnabled }; CheckboxControl.prototype.getDOMNode = function () { return this.m_Root }; CheckboxControl.prototype.setWidth = function (width) { if (width !== undefined) { this.m_Root.style.width = width + "px"; if (this.T) this.T.style.fontSize = ""; if (this.getContentWidth() > width) this.fitText(width) } }; CheckboxControl.prototype.fitText = function (width) { if (this.T) { var availableWidth = this.T.clientWidth - (this.getContentWidth() - width); var fontSize = Number(window.getComputedStyle(this.T).fontSize.replace("px", "")); while (this.T.clientWidth > availableWidth && fontSize > 5) { fontSize--; this.T.style.fontSize = fontSize + "px" } } }; CheckboxControl.prototype.getContentWidth = function () { var width = this.m_Background.clientWidth; if (this.bO) width += this.bO.clientWidth; if (this.T) width += this.T.clientWidth; return width }; function ModalWin(data, parent) { if (this.constructor !== arguments.callee) return new ModalWin; this.m_ModalWinContainer = document.getElementById("modalwin_container") || DOMHelper.createAndAppendDiv(document.body, "modalwin_container", "modalwinContainer"); this.m_ModalWinContainer.style.display = "none"; this.m_ModalWinContainer.className = "modalwinContainer"; var title = data.title; var message = data.message; var confirmationModalWin = data.confirm; var flipConfirm = data.flipConfirm; var cancelCaption = data.cancelCaption; var confirmCaption = data.confirmCaption; var cancelIconPos; if (confirmationModalWin) cancelIconPos = data.cancelIconPos == null ? data.pos.buttons.cancel_button.icon : data.cancelIconPos; var cancelIconImgPath; if (data.cancelIconImgPath != null) cancelIconImgPath = data.cancelIconImgPath; else cancelIconImgPath = image_path_popup + "modalwin.png"; if (data.cancelCaption == null) cancelCaption = Locale.IDS_BTN_NO; if (data.confirmCaption == null) confirmCaption = Locale.IDS_BTN_YES; if (confirmationModalWin == undefined || !confirmationModalWin) confirmCaption = Locale.IDS_BTN_OK; this.kz = 0; this.L = data.pos; this.fp = false; this.oA = false; this.ct = data.callback; this.mp = true; if (data.autohideOnCb != undefined) this.mp = data.autohideOnCb; this.pS = data.smalltext != undefined ? data.smalltext : false; this.jH; this.hL; this.sq = true; this.m_modalWinStyle = DEVICE.orientation == "pt" ? "modalwinPt" : "modalwinLs"; this.cE = DOMHelper.createAndAppendDiv(this.m_ModalWinContainer, undefined, this.m_modalWinStyle); this.cE.style.position = "absolute"; this.cE.style.display = "none"; this.ResetZIndex(); this.jH = DOMHelper.createAndAppendDiv(this.cE, undefined, "modalwin_title_newui"); DOMHelper.setText(this.jH, title); var style = this.pS ? "modalwin_message_small" : "modalwin_message_newui"; this.hL = DOMHelper.createAndAppendDiv(this.cE, undefined, style); DOMHelper.setText(this.hL, message); this.m_ButtonContainer = DOMHelper.createAndAppendDiv(this.cE, undefined, "modalwin_btn_container"); if (confirmationModalWin) { this.fX = DOMHelper.createImageFromSpriteSheet(this.m_ButtonContainer, "", "modalwin_cancel_btn", image_path_htmlui + "uiElements.png", uiElements.genericBtnBg); this.m_CancelIcon = DOMHelper.createImageFromSpriteSheet(this.fX, "", "modalwin_btn_icon", image_path_htmlui + "uiElements.png", uiElements.genericBtnX); this.m_CancelButtonText = DOMHelper.createAndAppendDiv(this.fX, undefined, "modalwin_btn_text"); DOMHelper.setText(this.m_CancelButtonText, cancelCaption) } this.ly = DOMHelper.createImageFromSpriteSheet(this.m_ButtonContainer, "", "modalwin_confirm_btn", image_path_htmlui + "uiElements.png", uiElements.genericBtnBg); this.m_ConfirmIcon = DOMHelper.createImageFromSpriteSheet(this.ly, "", "modalwin_btn_icon", image_path_htmlui + "uiElements.png", uiElements.genericBtnCheck); this.m_ConfirmIconText = DOMHelper.createAndAppendDiv(this.ly, undefined, "modalwin_btn_text"); DOMHelper.setText(this.m_ConfirmIconText, confirmCaption); var that = this; if (flipConfirm) { this.ly.addEventListener("click", Utils.delegate(this, this.OnCancel)); this.fX.addEventListener("click", Utils.delegate(this, this.OnOk)) } else { this.ly.addEventListener("click", Utils.delegate(this, this.OnOk)); if (this.fX != undefined) this.fX.addEventListener("click", Utils.delegate(this, this.OnCancel)) } ModalWin.elements.push(this); this.kz = ModalWin.elements.length - 1 } ModalWin.prototype.constructor = ModalWin; ModalWin.elements = []; ModalWin.queue = []; ModalWin.GetVisibleState = function () { for (var i = 0; i < ModalWin.elements.length; i++) if (ModalWin.elements[i].fp) return true; return false }; ModalWin.OnOrientationChange = function (pt) { for (var m = 0; m < ModalWin.elements.length; m++) { ModalWin.elements[m].OnOrientationChange(pt); if (ModalWin.elements[m].fp === false) ModalWin.elements[m].Hide(); else ModalWin.elements[m].Show() } }; ModalWin.Disable = function () { for (var w = 0; w < ModalWin.elements.length; w++) ModalWin.elements[w].Enable(false) }; ModalWin.prototype.ResetZIndex = function () { this.cE.style.zIndex = 1001 }; ModalWin.prototype.ShowOnTop = function () { this.oA = true; this.cE.style.zIndex = 10001 }; ModalWin.prototype.SetMessageData = function (data) { var title = data.title; var message = data.message; this.ct = data.callback; DOMHelper.setText(this.jH, title); DOMHelper.setText(this.hL, message) }; ModalWin.prototype.Enable = function (b) { if (!b && this.fp) ModalWin.queue.push(this); if (b) { this.cE.style.display = ""; this.jH.style.display = ""; this.hL.style.display = "" } else { this.cE.style.display = "none"; this.jH.style.display = "none"; this.hL.style.display = "none" } if (b) this.ly.style.display = ""; else this.ly.style.display = "none"; if (this.fX != undefined) b ? this.fX.style.display = "" : this.fX.style.display = "none"; this.fp = b }; ModalWin.prototype.Show = function () { ModalWin.Disable(); this.Enable(true); this.m_ModalWinContainer.style.display = ""; this.OnOrientationChange(DEVICE.orientation === "pt") }; ModalWin.prototype.Hide = function () { this.m_ModalWinContainer.style.display = "none"; this.fp = false; for (var i = 0; i < ModalWin.queue.length; i++) if (ModalWin.queue[i].kz == this.kz) ModalWin.queue.splice(i); if (ModalWin.queue.length > 0) ModalWin.queue[ModalWin.queue.length - 1].Show(); if (this.oA) this.ResetZIndex() }; ModalWin.prototype.OnOk = function (e) { if (this.ct != undefined) this.ct(true); if (this.mp) this.Hide() }; ModalWin.prototype.OnCancel = function (e) { if (this.ct != undefined) this.ct(false); if (this.mp) this.Hide() }; ModalWin.prototype.OnOrientationChange = function (pt) { if (DEVICE.desktop) this.m_modalWinStyle = "modalwinDesktop"; else this.cE.style = pt ? "modalwinPt" : "modalwinLs"; var screenSize = DEVICE[DEVICE.orientation]; var scale = 1; if (pt) scale = screenSize.w / this.cE.clientWidth * 0.6; else { scale = screenSize.h / this.cE.clientHeight * 0.6; if (this.cE.clientWidth * scale > screenSize.w * 0.9) scale = screenSize.w / this.cE.clientWidth * 0.9 } this.cE.style.msTransform = "scale(" + scale + ", " + scale + ") translateY(-50%)"; this.cE.style.webkitTransform = "scale(" + scale + ", " + scale + ") translateY(-50%)"; this.cE.style.transform = "scale(" + scale + ", " + scale + ") translateY(-50%)" }; function SoundQuestionModalWin(data) { if (this.constructor !== arguments.callee) return new SoundQuestionModalWin; data.callback(false) } SoundQuestionModalWin.prototype.constructor = SoundQuestionModalWin; SoundQuestionModalWin.prototype.Show = function () { }; SoundQuestionModalWin.prototype.ShowOnTop = function () { }; function ExitQuestionModalWin(data) { if (this.constructor !== arguments.callee) return new ExitQuestionModalWin; var tmpModalWinObj = new Object; tmpModalWinObj.title = Locale.IDS_MENU_EXIT; tmpModalWinObj.message = Locale.IDS_LEAVEGAME; tmpModalWinObj.pos = data.pos; tmpModalWinObj.callback = data.callback; tmpModalWinObj.confirm = true; this.bC = new ModalWin(tmpModalWinObj, "game_base") } ExitQuestionModalWin.prototype.constructor = ExitQuestionModalWin; ExitQuestionModalWin.prototype.Show = function () { this.bC.ct(true) }; ExitQuestionModalWin.prototype.ShowOnTop = function () { this.bC.ShowOnTop() }; function MessageModalWin(data) { if (this.constructor !== arguments.callee) return new MessageModalWin; var tmpModalWinObj = new Object; tmpModalWinObj.title = data.title; tmpModalWinObj.message = data.message; tmpModalWinObj.pos = data.pos; tmpModalWinObj.callback = data.callback; tmpModalWinObj.confirm = data.confirm != undefined ? data.confirm : false; tmpModalWinObj.smalltext = data.smalltext; if (MessageModalWin.elements.length > 0) { MessageModalWin.elements[0].SetMessageData(tmpModalWinObj); return MessageModalWin.elements[0] } this.bC = new ModalWin(tmpModalWinObj, "game_base"); MessageModalWin.elements.push(this) } MessageModalWin.prototype.constructor = MessageModalWin; MessageModalWin.elements = []; MessageModalWin.prototype.Show = function () { this.bC.Show() }; MessageModalWin.prototype.ShowOnTop = function () { this.bC.ShowOnTop() }; MessageModalWin.prototype.SetMessageData = function (data) { this.bC.SetMessageData(data) }; function RealityCheckModalWin(data) { if (this.constructor !== arguments.callee) return new RealityCheckModalWin; var tmpModalWinObj = new Object; tmpModalWinObj.title = " "; tmpModalWinObj.message = " "; tmpModalWinObj.pos = data.pos; tmpModalWinObj.callback = data.callback; tmpModalWinObj.confirm = true; tmpModalWinObj.flipConfirm = true; tmpModalWinObj.cancelCaption = Locale.IDS_BTN_EXIT; tmpModalWinObj.confirmCaption = Locale.IDS_BTN_CONTINUE; this.bC = new ModalWin(tmpModalWinObj, "game_base") }; RealityCheckModalWin.prototype.constructor = RealityCheckModalWin; RealityCheckModalWin.prototype.Show = function () { this.bC.Show() }; RealityCheckModalWin.prototype.ShowOnTop = function () { this.bC.ShowOnTop() }; RealityCheckModalWin.prototype.SetMessageData = function (data) { this.bC.SetMessageData(data) }; function InsufficientFundsModalWin(data) { if (this.constructor !== arguments.callee) return new InsufficientFundsModalWin; var tmpModalWinObj = new Object; tmpModalWinObj.title = Locale.IDS_SERVER_INSUFFICIENTFUNDS; tmpModalWinObj.message = Locale.IDS_SERVER_NOMONEYTEXT; tmpModalWinObj.pos = data.pos; tmpModalWinObj.callback = data.callback; tmpModalWinObj.confirm = true; tmpModalWinObj.flipConfirm = true; tmpModalWinObj.cancelCaption = data.cancelCaption; tmpModalWinObj.confirmCaption = Locale.IDS_BTN_BACK; tmpModalWinObj.cancelIconPos = cancel_icon_pos; tmpModalWinObj.cancelIconImgPath = image_path_menu + "menu.png"; this.bC = new ModalWin(tmpModalWinObj, "game_base") } InsufficientFundsModalWin.prototype.constructor = InsufficientFundsModalWin; InsufficientFundsModalWin.prototype.Show = function () { this.bC.Show() }; InsufficientFundsModalWin.prototype.ShowOnTop = function () { this.bC.ShowOnTop() }; InsufficientFundsModalWin.prototype.SetMessageData = function (data) { this.bC.SetMessageData(data) }; function AdditionalFreegamesModalWin(data) { if (this.constructor !== arguments.callee) return new AdditionalFreegamesModalWin(data); var tmpModalWinObj = new Object; tmpModalWinObj.title = Locale.IDS_FREEGAMESTITLE; tmpModalWinObj.message = Locale.IDS_ADDITIONALFREEGAMES; tmpModalWinObj.pos = data.pos; tmpModalWinObj.callback = data.callback; tmpModalWinObj.confirm = true; tmpModalWinObj.autohideOnCb = false; tmpModalWinObj.cancelCaption = Locale.IDS_BTN_NO; tmpModalWinObj.confirmCaption = Locale.IDS_BTN_YES; this.bC = new ModalWin(tmpModalWinObj, "game_base") } AdditionalFreegamesModalWin.prototype.constructor = AdditionalFreegamesModalWin; AdditionalFreegamesModalWin.prototype.Show = function () { this.bC.Show() }; AdditionalFreegamesModalWin.prototype.Hide = function () { this.bC.Hide() }; AdditionalFreegamesModalWin.prototype.ShowOnTop = function () { this.bC.ShowOnTop() }; AdditionalFreegamesModalWin.prototype.SetMessageData = function (data) { this.bC.SetMessageData(data) }; function InSessionFreeGameModalWin(data) { if (this.constructor !== arguments.callee) return new FreeGamesOfferModalWin(data); var tmpModalWinObj = new Object; tmpModalWinObj.title = Locale.IDS_FREEGAMESTITLE; tmpModalWinObj.message = Locale.IDS_HASFREEGAMES; tmpModalWinObj.pos = data.pos; tmpModalWinObj.callback = data.callback; tmpModalWinObj.confirm = true; tmpModalWinObj.autohideOnCb = false; tmpModalWinObj.cancelCaption = Locale.IDS_BTN_NO; tmpModalWinObj.confirmCaption = Locale.IDS_BTN_YES; this.bC = new ModalWin(tmpModalWinObj) }; InSessionFreeGameModalWin.prototype.constructor = InSessionFreeGameModalWin; InSessionFreeGameModalWin.prototype.Show = function () { this.bC.Show() }; InSessionFreeGameModalWin.prototype.Hide = function () { this.bC.Hide() }; InSessionFreeGameModalWin.prototype.ShowOnTop = function () { this.bC.ShowOnTop() }; InSessionFreeGameModalWin.prototype.SetMessageData = function (data) { this.bC.SetMessageData(data) }; IDSplash.WaitingConfirm = true; function IDSplash(ticketId, sessionId) { if (this.constructor !== arguments.callee) return new IDSplash; this.L = idsplashscreen_pos; this.cK = DOMHelper.createAndAppendDiv(document.body, "aams_modalwinContainer", "aams_modalwinContainer"); this.cK.style.zIndex = 9999999999999; this.L.content.bgr_sprite.x = this.L.content.bgr_sprite.xoffset; this.L.content.bgr_sprite.y = this.L.content.bgr_sprite.yoffset; this.m_Background = DOMHelper.createImageFromSpriteSheet(this.cK, "aams_modalwinLs", "", image_path_popup + "modalwin.png", this.L.content.bgr_sprite); this.m_Title = DOMHelper.createTextfield(this.cK, "aams_title", "aams_title", Localizer.getInstance().getString("IDS_SESSIONDETAILS_TITLE")); this.m_Ticket = DOMHelper.createTextfield(this.cK, "aams_ticket", "aams_ticket", Localizer.getInstance().getString("IDS_AAMS_TICKETID") + " " + ticketId); this.m_Session = DOMHelper.createTextfield(this.cK, "aams_session", "aams_session", Localizer.getInstance().getString("IDS_AAMS_SESSIONID") + " " + sessionId); this.L.content.continue_btn.x = this.L.content.continue_btn.xoffset; this.L.content.continue_btn.y = this.L.content.continue_btn.yoffset; this.qw = DOMHelper.createImageFromSpriteSheet(this.cK, "aams_continue", "", image_path_popup + "modalwin.png", this.L.content.continue_btn); this.ButtonCap = DOMHelper.createTextfield(this.qw, "aams_continue_cap", "aams_continue_cap", Localizer.getInstance().getString("IDS_BTN_CONTINUE")); this.qw.addEventListener("click", Utils.delegate(this, this.OnConfirm)); this.Show(false) } IDSplash.prototype.constructor = IDSplash; IDSplash.prototype.Show = function (b) { if (b) this.cK.style.visibility = "visible"; else this.cK.style.visibility = "hidden" }; IDSplash.prototype.OnConfirm = function () { IDSplash.WaitingConfirm = false; document.getElementsByTagName("body")[0].removeChild(document.getElementById("aams_modalwinContainer")) }; IDSplash.OnOrientationChange = function (portrait) { var pos = idsplashscreen_pos; if (sjs.layers["idsplash"]) { sjs.layers["idsplash"].setBounds(pos.layers.containerlayer[portrait ? "pt" : "ls"]); sjs.layers["idsplash"].SetScale(pos.layers.containerlayer[portrait ? "pt" : "ls"].scale) } }; QuickMenuVS.EVENT_AUTOPLAY_ENABLED = "event_autoplay_enabled"; QuickMenuVS.EVENT_AUTOPLAY_DISABLED = "event_autoplay_disabled"; QuickMenuVS.EVENT_FASTPLAY_ENABLED = "event_fastplay_enabled"; QuickMenuVS.EVENT_FASTPLAY_DISABLED = "event_fastplay_disabled"; QuickMenuVS.EVENT_COINS_CHANGED = "event_coins_changed"; QuickMenuVS.EVENT_LINES_CHANGED = "event_lines_changed"; QuickMenuVS.EVENT_DENOM_CHANGED = "event_denom_changed"; QuickMenuVS.EVENT_BET_CHANGED = "event_bet_changed"; QuickMenuVS.PAGE_REGULAR_SLIDERS = "page_line_coin_denom"; QuickMenuVS.PAGE_QUICKBET_BUTTONS = "page_quickbet_buttons"; function QuickMenuVS(callback, parentDiv, quickBetValues) { this.ao = callback; this.m_QuickBetValues = quickBetValues; this.m_PageType = QuickMenuVS.PAGE_REGULAR_SLIDERS; this.m_NumAutoSpins = 0; this.m_QuickBetMoney = []; this.m_StartEvent = "mousedown"; this.m_EndEvent = "mouseup"; this.m_MoveEvent = "mousemove"; if ("ontouchstart" in window) { this.m_StartEvent = "touchstart"; this.m_EndEvent = "touchend"; this.m_MoveEvent = "touchmove" } this.hc = DOMHelper.createAndAppendDiv(parentDiv, "quickmenu_base", "portrait"); this.m_LayoutRegular = DOMHelper.createDiv("quickmenu_layout"); this.m_LayoutQuickBet = DOMHelper.createDiv("quickmenu_layout"); this.m_BetInfoBackground = DOMHelper.createAndAppendDiv(this.m_LayoutRegular, "quickmenu_betinfo_base"); DEBUG.quick = this; this.m_BetInfoLeft = DOMHelper.createAndAppendDiv(this.m_BetInfoBackground, "quickmenu_betinfo_left_subgroup"); this.m_BetInfoRight = DOMHelper.createAndAppendDiv(this.m_BetInfoBackground, "quickmenu_betinfo_right_subgroup"); this.m_BetInfoCoinsCaption = DOMHelper.createTextfield(this.m_BetInfoLeft, "quickmenu_betinfo_left_value", undefined, Localizer.getInstance().getString("IDS_BETINCOINS_CAPTION")); this.m_BetInfoCoinsValue = DOMHelper.createTextfield(this.m_BetInfoLeft, "quickmenu_betinfo_right_value", undefined, "25"); this.m_BetInfoCashCaption = DOMHelper.createTextfield(this.m_BetInfoRight, "quickmenu_betinfo_left_value", undefined, Localizer.getInstance().getString("IDS_BETINCASH_CAPTION")); this.m_BetInfoCashValue = DOMHelper.createTextfield(this.m_BetInfoRight, "quickmenu_betinfo_right_value", undefined, "\u00a35.00"); this.m_DenomSlider = new SliderControl(Utils.delegate(this, this.onDenomSliderEvent), ["0.01", "0.02", "0.05", "0.10", "0.25"]); DOMHelper.appendChild(this.m_LayoutRegular, this.m_DenomSlider.getDOMNode()); this.m_DenomSlider.setVerticalMode(true); this.m_DenomSlider.setWidthAndHeight(undefined, 350); this.m_DenomSlider.setXAndY(280, 50); this.m_CoinSlider = new SliderControl(Utils.delegate(this, this.onCoinSliderEvent), [1, 2]); DOMHelper.appendChild(this.m_LayoutRegular, this.m_CoinSlider.getDOMNode()); this.m_CoinSlider.setVerticalMode(true); this.m_CoinSlider.setWidthAndHeight(undefined, 350); this.m_CoinSlider.setXAndY(160, 50); this.m_CoinSlider.setCaption(Localizer.getInstance().getString("IDS_COINS_CAPTION")); this.m_LineSlider = new SliderControl(Utils.delegate(this, this.onLineSliderEvent), [50]); DOMHelper.appendChild(this.m_LayoutRegular, this.m_LineSlider.getDOMNode()); this.m_LineSlider.setVerticalMode(true); this.m_LineSlider.setWidthAndHeight(undefined, 350); this.m_LineSlider.setXAndY(40, 50); this.m_LineSlider.setCaption(Localizer.getInstance().getString("IDS_LINES_CAPTION")); this.m_BetButtons = DOMHelper.createAndAppendDiv(this.m_LayoutQuickBet, "quickmenu_bet_buttons"); if (this.m_QuickBetValues != undefined) for (var i = 0; i < this.m_QuickBetValues.length; i++) DOMHelper.createButton(this.m_BetButtons, "quickmenu_bet_button", "quickbet_button" + i).addEventListener(this.m_StartEvent, Utils.delegate(this, this.quickBetButtonPressed)); this.m_BetSlider = new SliderControl(Utils.delegate(this, this.onBetSliderEvent), [1, 2, 3, 4, 5, 6]); DOMHelper.appendChild(this.m_LayoutQuickBet, this.m_BetSlider.getDOMNode()); DOMHelper.appendChild(this.hc, this.m_LayoutQuickBet); this.m_ToggleButtonsBase = DOMHelper.createAndAppendDiv(this.hc, "togglebutton_base"); this.m_FastPlayToggleButton = DOMHelper.createAndAppendDiv(this.m_ToggleButtonsBase, "togglebutton_fastplay"); this.m_FastPlayToggleButton.style.display = "none"; this.m_FastPlayToggleButtonIcon = DOMHelper.createImageFromSpriteSheet(this.m_FastPlayToggleButton, "togglebutton_fastplay_icon", "", image_path_htmlui + "uiElements.png", uiElements.fastPlayIcon); this.m_FastPlayToggleButton.addEventListener("touchstart", Utils.delegate(this, this.onClickFastPlay)); this.setCreditDisplayType() } QuickMenuVS.prototype.constructor = QuickMenuVS; QuickMenuVS.prototype.lockSliders = function (bDisable) { this.m_LineSlider.setLockedMode(bDisable); this.m_CoinSlider.setLockedMode(bDisable); this.m_DenomSlider.setLockedMode(bDisable); this.m_BetSlider.setLockedMode(bDisable) }; QuickMenuVS.prototype.setPortraitMode = function (bSetPortraitMode) { }; QuickMenuVS.prototype.setPageType = function (pageType) { this.m_PageType = pageType; switch (pageType) { case QuickMenuVS.PAGE_REGULAR_SLIDERS: if (this.hc.contains(this.m_LayoutQuickBet)) this.hc.removeChild(this.m_LayoutQuickBet); this.hc.appendChild(this.m_LayoutRegular); break; case QuickMenuVS.PAGE_QUICKBET_BUTTONS: if (this.hc.contains(this.m_LayoutRegular)) this.hc.removeChild(this.m_LayoutRegular); this.hc.appendChild(this.m_LayoutQuickBet); break } }; QuickMenuVS.prototype.setFastPlayButtonState = function (bIsEnabled) { this.m_FastPlayOn = bIsEnabled; if (this.m_FastPlayOn) this.m_FastPlayToggleButton.style.background = "#FFDA1C"; else this.m_FastPlayToggleButton.style.background = "" }; QuickMenuVS.prototype.setFastPlayButtonHighlight = function (bIsEnabled) { }; QuickMenuVS.prototype.onClickAutoPlay = function (e) { var eventType = !this.m_AutoPlayOn ? QuickMenuVS.EVENT_AUTOPLAY_ENABLED : QuickMenuVS.EVENT_AUTOPLAY_DISABLED; this.ao({ type: eventType, value: !this.m_AutoPlayOn }) }; QuickMenuVS.prototype.onClickFastPlay = function (e) { var eventType = !this.m_FastPlayOn ? QuickMenuVS.EVENT_FASTPLAY_ENABLED : QuickMenuVS.EVENT_FASTPLAY_DISABLED; this.ao({ type: eventType, value: !this.m_FastPlayOn }) }; QuickMenuVS.prototype.show = function (bShow) { this.hc.style.opacity = bShow ? 1 : 0; this.hc.style.pointerEvents = bShow ? "" : "none" }; QuickMenuVS.prototype.setNumAutoSpins = function (numAutoSpins) { }; QuickMenuVS.prototype.setDenominatonSliderIndex = function (index) { this.m_DenomSlider.setValueIndex(index) }; QuickMenuVS.prototype.setCoinSliderIndex = function (index) { this.m_CoinSlider.setValueIndex(index) }; QuickMenuVS.prototype.setLineSliderIndex = function (index) { this.m_LineSlider.setValueIndex(index) }; QuickMenuVS.prototype.setCoinSliderValues = function (values) { this.m_CoinSlider.setValueArray(values) }; QuickMenuVS.prototype.setLineSliderValues = function (values) { this.m_LineSlider.setValueArray(values) }; QuickMenuVS.prototype.setDenominationSliderValues = function (values, lines, coins) { this.dU = coins; this.eV = lines; this.m_DenomSlider.setValueArray(values); var betSliderValues = []; for (var i = 0; i < values.length; i++) betSliderValues.push(Utils.MoneyToString(values[i] * lines * coins * 100, NO_CURRENCY)); this.m_BetSlider.setValueArray(betSliderValues) }; QuickMenuVS.prototype.onLineSliderEvent = function (e) { this.ao({ type: QuickMenuVS.EVENT_LINES_CHANGED, data: e }) }; QuickMenuVS.prototype.onCoinSliderEvent = function (e) { this.ao({ type: QuickMenuVS.EVENT_COINS_CHANGED, data: e }) }; QuickMenuVS.prototype.onDenomSliderEvent = function (e) { this.ao({ type: QuickMenuVS.EVENT_DENOM_CHANGED, data: e }) }; QuickMenuVS.prototype.onBetSliderEvent = function (e) { this.ao({ type: QuickMenuVS.EVENT_DENOM_CHANGED, data: e }) }; QuickMenuVS.prototype.HandleOrientationChange = function (portrait) { this.m_BetSlider.setVerticalMode(!portrait); if (portrait) if (this.m_PageType === QuickMenuVS.PAGE_QUICKBET_BUTTONS) this.setQuickBetPT(); else { if (this.m_PageType === QuickMenuVS.PAGE_REGULAR_SLIDERS) this.setRegularPT() } else if (this.m_PageType === QuickMenuVS.PAGE_QUICKBET_BUTTONS) this.setQuickBetLS(); else if (this.m_PageType === QuickMenuVS.PAGE_REGULAR_SLIDERS) this.setRegularLS() }; QuickMenuVS.prototype.setRegularLS = function () { DOMHelper.setStyle(this.hc, "landscape"); this.setPageType(QuickMenuVS.PAGE_REGULAR_SLIDERS); this.m_LineSlider.setVerticalMode(true); this.m_LineSlider.setWidthAndHeight("", 370); this.m_LineSlider.setXAndY(40, 40); this.m_CoinSlider.setVerticalMode(true); this.m_CoinSlider.setWidthAndHeight("", 370); this.m_CoinSlider.setXAndY(160, 40); this.m_DenomSlider.setVerticalMode(true); this.m_DenomSlider.setWidthAndHeight("", 370); this.m_DenomSlider.setXAndY(280, 40) }; QuickMenuVS.prototype.setRegularPT = function () { DOMHelper.setStyle(this.hc, "portrait"); this.setPageType(QuickMenuVS.PAGE_REGULAR_SLIDERS); this.m_LineSlider.setVerticalMode(false); this.m_LineSlider.setWidthAndHeight("", ""); this.m_LineSlider.setXAndY(5, 40); this.m_CoinSlider.setVerticalMode(false); this.m_CoinSlider.setWidthAndHeight("", ""); this.m_CoinSlider.setXAndY(5, 140); this.m_DenomSlider.setVerticalMode(false); this.m_DenomSlider.setWidthAndHeight("", ""); this.m_DenomSlider.setXAndY(5, 240) }; QuickMenuVS.prototype.setQuickBetLS = function () { DOMHelper.setStyle(this.hc, "landscape"); this.setPageType(QuickMenuVS.PAGE_QUICKBET_BUTTONS); this.m_BetSlider.setXAndY(330, 0); this.m_BetSlider.setWidthAndHeight("", 410) }; QuickMenuVS.prototype.setQuickBetPT = function () { DOMHelper.setStyle(this.hc, "portrait quick"); this.setPageType(QuickMenuVS.PAGE_QUICKBET_BUTTONS); this.m_BetSlider.setXAndY(0, 40); this.m_BetSlider.setWidthAndHeight("", "") }; QuickMenuVS.prototype.updateBetInfo = function (numLines, numCoins, denom) { this.m_BetInfoCoinsValue.innerHTML = numCoins * numLines; this.m_BetInfoCashValue.innerHTML = Utils.MoneyToString(numCoins * numLines * this.m_DenomSlider.getValue(denom) * 100); this.m_LineSlider.setValue(numLines); this.m_CoinSlider.setValue(numCoins); this.m_DenomSlider.setValueIndex(denom); this.m_BetSlider.setValueIndex(denom) }; QuickMenuVS.prototype.setCreditDisplayType = function () { if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS) || CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_CURRENCY)) if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_FIXED)) if (DEVICE.orientation === "pt") this.setQuickBetPT(); else this.setQuickBetLS(); else if (DEVICE.orientation === "pt") this.setRegularPT(); else this.setRegularLS() }; QuickMenuVS.prototype.setCurrency = function (currency) { this.m_DenomSlider.setCaption(Localizer.getInstance().getString("IDS_COINVALUE_CAPTION") + "(" + currency + ")"); this.m_BetSlider.setCaption(Localizer.getInstance().getString("IDS_BET_CAPTION") + "(" + currency + ")") }; QuickMenuVS.prototype.setQuickBetValues = function (currency, coins, lines, denominationMultiplier) { if (this.m_PageType == QuickMenuVS.PAGE_QUICKBET_BUTTONS) if (this.m_QuickBetValues != undefined) for (var i = 0; i < this.m_QuickBetValues.length; i++) { buttonValue = parseInt(this.m_QuickBetValues[i]) * coins * lines * denominationMultiplier; this.m_QuickBetMoney[i] = Utils.MoneyToString(buttonValue, NO_CURRENCY); var buttonDiv = document.getElementById("quickbet_button" + i); if (this.m_BetSlider.m_ValueArray.indexOf(this.m_QuickBetMoney[i]) >= 0) DOMHelper.setText(buttonDiv, Utils.MoneyToString(buttonValue, OPT_DECIMALS)); else buttonDiv.style.display = "none" } }; QuickMenuVS.prototype.quickBetButtonPressed = function (e) { var betAmount = this.m_QuickBetMoney[parseInt(e.currentTarget.id.match(/\d+$/)[0], 10)]; this.m_BetSlider.setValue(betAmount) }; SpinButton.EVENT_SPIN_CLICK = "event_spin_click"; SpinButton.EVENT_PLUS_CLICK = "event_plus_click"; SpinButton.EVENT_STOP_CLICK = "event_stop_click"; SpinButton.EVENT_START_AUTOPLAY = "event_start_autoplay"; function SpinButton(callback, parentDiv, quickBetValues, autoplaysettings) { this.ao = callback; this.m_AutoplaySettings = autoplaysettings; this.hc = DOMHelper.createAndAppendDiv(parentDiv, undefined, "btn_spin_base"); DOMHelper.setWidthAndHeight(this.hc, uiElements.spinBtnBase.w, uiElements.spinBtnBase.h); this.m_AutoplayForceDlg = new AutoPlayForceDialog(this.hc, this.m_AutoplaySettings); this.m_SpinButtonForceTouch = DOMHelper.createAndAppendDiv(this.hc, "btn_spin_force", "spinbtn_forceTouch"); this.m_TouchInside = false; this.m_Background = DOMHelper.createImageFromSpriteSheet(this.hc, undefined, "btn_spin_background", image_path_htmlui + "uiElements.png", uiElements.spinBtnBase); this.m_SpinIcon = DOMHelper.createImageFromSpriteSheet(this.hc, undefined, "btn_spin_spin", image_path_htmlui + "uiElements.png", uiElements.spinBtnSpin); this.m_SpinIcon.style.pointerEvents = "none"; this.m_SpinIdle = DOMHelper.createImageFromSpriteSheet(this.hc, "btn_spin_idle_animation", "btn_spin_idle", image_path_htmlui + "uiElements.png", uiElements.spinBtnBaseHi); this.m_SpinIdle.style.pointerEvents = "none"; this.m_FastPlayIcon = DOMHelper.createImageFromSpriteSheet(this.hc, undefined, "btn_spin_fast", image_path_htmlui + "uiElements.png", uiElements.spinBtnFast); this.m_FastPlayIcon.style.pointerEvents = "none"; this.m_AutoIcon = DOMHelper.createImageFromSpriteSheet(this.hc, undefined, "btn_spin_auto", image_path_htmlui + "uiElements.png", uiElements.spinBtnAuto); this.m_AutoIcon.style.pointerEvents = "none"; this.m_AutoIcon.style.lineHeight = uiElements.spinBtnAuto.h + "px"; this.m_AutoText = DOMHelper.createAndAppendDiv(this.m_AutoIcon, undefined, "btn_spin_auto_text"); this.m_AutoText.style.pointerEvents = "none"; this.m_StartEvent = "mousedown"; this.m_EndEvent = "mouseup"; this.m_MoveEvent = "mousemove"; if ("ontouchstart" in window) { this.m_StartEvent = "touchstart"; this.m_EndEvent = "touchend"; this.m_MoveEvent = "touchmove" } this.m_HitArea = DOMHelper.createAndAppendDiv(this.hc, "spin_hitarea", "btn_spin_hitarea"); this.m_HitArea.style.pointerEvents = "all"; this.m_SpinButtonDelegate = Utils.delegate(this, this.onClickSpin); this.m_ScaleButtonDelegate = Utils.delegate(this, this.scaleButton); this.m_SpinButtonMoveDelegate = Utils.delegate(this, this.checkSpinHitArea); this.m_ForceChangeDelegate = Utils.delegate(this, this.onForceChange); this.m_bPlusButtonEnabled = false; this.m_NumAutoSpins = 0; this.m_bQuickMenuShowing = false; this.m_bFastPlayEnabled = false; this.m_ForceTouchHandler = new ForceTouchHandler(this.m_ForceChangeDelegate); this.m_ForceTouch = 0; this.setFastPlay(false); this.setAutoPlay(false); this.m_AutoplayForceDlg.hide(); this.show(false); this.enableSpinButton(false); this.m_bQuickMenuShowing = false } SpinButton.prototype.constructor = SpinButton; SpinButton.prototype.onQuickMenuEvent = function (e) { switch (e.type) { case QuickMenuVS.EVENT_AUTOPLAY_ENABLED: case QuickMenuVS.EVENT_AUTOPLAY_DISABLED: break; case QuickMenuVS.EVENT_FASTPLAY_ENABLED: case QuickMenuVS.EVENT_FASTPLAY_DISABLED: this.setFastPlay(e.value); break } this.ao(e) }; SpinButton.prototype.onForceChange = function (forcevalue) { if (this.m_AutoplayForceDlg.m_AutoplayVisible) return; this.m_ForceTouch = forcevalue; var gb = document.getElementById("game_base"); document.getElementById("btn_spin_force").style.transform = "scale(" + (1 + this.m_ForceTouch * 0.5) + ")"; if (this.m_ForceTouch > 0) gb.style.webkitFilter = "blur(" + this.m_ForceTouch * 10 + "px)"; if (this.m_ForceTouch > 0.8) this.showAutoPlayMenu() }; SpinButton.prototype.showAutoPlayMenu = function () { if (!this.m_AutoplayForceDlg.m_bAutoPlayIsRunning) { this.m_AutoplayForceDlg.show(); this.m_ForceTouchHandler.jd = false; this.m_Background.classList.remove("scaleupspin"); this.m_AutoIcon.classList.remove("scaleupspin"); this.m_SpinIdle.classList.remove("scaleupspin"); this.m_SpinIcon.classList.remove("scaleupspin"); document.getElementById("btn_spin_force").style.transform = "scale(1)"; var gb = document.getElementById("game_base"); gb.style.webkitFilter = "blur(10px)"; gb.addEventListener("touchend", function () { this.hideAutoPlayMenu() }.bind(this)) } }; SpinButton.prototype.hideAutoPlayMenu = function () { this.m_AutoplayForceDlg.hide(); this.removeBlur() }; SpinButton.prototype.setLeftHandMode = function (bLeftHandMode) { if (bLeftHandMode) DOMHelper.setStyle(this.hc, "btn_spin_base left"); else DOMHelper.setStyle(this.hc, "btn_spin_base"); this.m_AutoplayForceDlg.setLeftHandMode(bLeftHandMode) }; SpinButton.prototype.onClickSpin = function (e) { e.preventDefault(); this.m_Background.classList.remove("scaleupspin"); this.m_AutoIcon.classList.remove("scaleupspin"); this.m_SpinIcon.classList.remove("scaleupspin"); this.m_SpinIdle.classList.remove("scaleupspin"); this.m_ForceTouchHandler.jd = false; this.m_ForceTouch = 0; if (!this.m_TouchInside) return; if (this.ao) if (!this.m_AutoplayForceDlg.m_bAutoPlayIsRunning) { if (this.m_AutoplayForceDlg.m_bAutoPlayIsStarting) { if (!this.m_AutoplayForceDlg.m_ClickedToOpenAPMenu) { this.hideAutoPlayMenu(); this.ao({ type: SpinButton.EVENT_START_AUTOPLAY }) } } else { this.removeBlur(); this.ao({ type: SpinButton.EVENT_SPIN_CLICK }); StatsHandler.HandleEvent("onroundstart") } this.m_AutoplayForceDlg.m_ClickedToOpenAPMenu = false } else this.ao({ type: SpinButton.EVENT_STOP_CLICK }) }; SpinButton.prototype.checkSpinHitArea = function (e) { if (!this.m_HitArea.m_ButtonPressed) return; if (!DOMHelper.touchUpEventInTarget(e)) { this.m_ForceTouch = 0; this.m_ForceTouchHandler.jd = false; if (!this.m_AutoplayVisible) this.removeBlur(); this.m_TouchInside = false; this.m_Background.classList.remove("scaleupspin"); this.m_AutoIcon.classList.remove("scaleupspin"); this.m_SpinIdle.classList.remove("scaleupspin"); this.m_SpinIcon.classList.remove("scaleupspin") } else { this.m_TouchInside = true; this.m_Background.classList.add("scaleupspin"); this.m_AutoIcon.classList.add("scaleupspin"); this.m_SpinIdle.classList.add("scaleupspin"); this.m_SpinIcon.classList.add("scaleupspin") } }; SpinButton.prototype.show = function (bShow) { if (!bShow) this.hideAutoPlayMenu(); if (this.m_AutoplayForceDlg.m_bAutoPlayIsRunning) bShow = true; this.hc.style.display = bShow ? "" : "none"; this.m_AutoplayForceDlg.m_bVisible = bShow; if (bShow) this.hc.style.pointerEvents = ""; else this.hc.style.pointerEvents = "none" }; SpinButton.prototype.setFastPlay = function (bShowFastPlay) { this.m_FastPlayIcon.style.opacity = bShowFastPlay && !this.m_AutoplayForceDlg.m_bShowAutoPlay ? 1 : 0; this.m_bFastPlayEnabled = bShowFastPlay }; SpinButton.prototype.setNumAutoSpins = function (numAutoSpins) { if (numAutoSpins === 0) this.m_AutoIcon.style.opacity = 0; if (numAutoSpins === undefined) numAutoSpins = this.m_NumAutoSpins; this.m_NumAutoSpins = numAutoSpins; DOMHelper.setText(this.m_AutoText, this.m_NumAutoSpins) }; SpinButton.prototype.setAutoPlay = function (bShowAutoPlay, numAutoSpins) { this.m_AutoplayForceDlg.m_bShowAutoPlay = bShowAutoPlay; this.m_AutoplayForceDlg.m_bAutoPlayIsRunning = bShowAutoPlay; this.m_AutoIcon.style.opacity = bShowAutoPlay ? 1 : 0; this.m_SpinIcon.style.opacity = !bShowAutoPlay ? 1 : 0; this.m_FastPlayIcon.style.opacity = !bShowAutoPlay && this.m_bFastPlayEnabled ? 1 : 0; if (bShowAutoPlay) { this.setNumAutoSpins(numAutoSpins); this.m_Background.style.display = "none"; this.m_SpinIdle.style.display = "none"; DOMHelper.setImageFromSpriteSheet(this.m_AutoIcon, image_path_htmlui + "uiElements.png", uiElements.stopBtn) } else { DOMHelper.setText(this.m_AutoText, ""); this.m_Background.style.display = ""; this.m_SpinIdle.style.display = ""; DOMHelper.setImageFromSpriteSheet(this.m_AutoIcon, image_path_htmlui + "uiElements.png", uiElements.spinBtnAuto) } }; SpinButton.prototype.enableSpinButton = function (bEnable) { if (bEnable || this.m_AutoplayForceDlg.m_bAutoPlayIsRunning) { this.m_HitArea.addEventListener(this.m_StartEvent, this.m_ScaleButtonDelegate, false); this.m_HitArea.addEventListener(this.m_MoveEvent, this.m_SpinButtonMoveDelegate, false); this.m_HitArea.addEventListener(this.m_EndEvent, this.m_SpinButtonDelegate, false); this.m_HitArea.bHasListener = true } else if (this.m_HitArea.bHasListener) { this.m_HitArea.removeEventListener(this.m_StartEvent, this.m_ScaleButtonDelegate, false); this.m_HitArea.removeEventListener(this.m_MoveEvent, this.m_SpinButtonMoveDelegate, false); this.m_HitArea.removeEventListener(this.m_EndEvent, this.m_SpinButtonDelegate, false); this.m_HitArea.bHasListener = false } }; SpinButton.prototype.HandleOrientationChange = function (portrait) { if (gameRes > 320) if (DEVICE.orientation == "ls") this.m_AutoplayForceDlg.m_AutoPlaySlider.setWidthAndHeight(400); else this.m_AutoplayForceDlg.m_AutoPlaySlider.setWidthAndHeight(340) }; SpinButton.prototype.scaleButton = function (e) { this.m_HitArea.m_ButtonPressed = true; this.m_TouchInside = true; this.m_Background.classList.add("scaleupspin"); this.m_AutoIcon.classList.add("scaleupspin"); this.m_SpinIcon.classList.add("scaleupspin"); this.m_SpinIdle.classList.add("scaleupspin") }; SpinButton.prototype.removeBlur = function () { document.getElementById("game_base").style.webkitFilter = ""; document.getElementById("btn_spin_force").style.transform = "scale(0)" }; GambleButton.EVENT_GAMBLE_CLICK = "event_gamble_click"; GambleButton.EVENT_COLLECT_CLICK = "event_collect_click"; function GambleButton(callback, parentDiv) { this.ao = callback; this.m_bVisible = true; this.m_StartEvent = "mousedown"; this.m_EndEvent = "mouseup"; this.m_MoveEvent = "mousemove"; if ("ontouchstart" in window) { this.m_StartEvent = "touchstart"; this.m_EndEvent = "touchend"; this.m_MoveEvent = "touchmove" } this.hc = document.getElementById("gamble_base") || DOMHelper.createAndAppendDiv(parentDiv, "gamble_base", "btn_gamble_collect_base"); this.hc.style.display = ""; DOMHelper.setStyle(this.hc, "btn_gamble_collect_base"); this.m_BtnGambleBase = DOMHelper.createAndAppendDiv(this.hc, "gamble_button", "btn_gamble_base"); DOMHelper.setHeight(this.m_BtnGambleBase, uiElements.gambleCollectBtn.h); this.m_BtnGamble = DOMHelper.createImageFromSpriteSheet(this.m_BtnGambleBase, "", "btn_gamble", image_path_htmlui + "uiElements.png", uiElements.gambleCollectBtn); this.m_BtnGambleText = DOMHelper.createAndAppendDiv(this.m_BtnGamble, undefined, "btn_gamble_text"); DOMHelper.setText(this.m_BtnGambleText, Localizer.getInstance().getString("IDS_BTN_GAMBLE")); DOMHelper.resizeFontToFitDiv(this.m_BtnGamble, htmlui_gamblebutton.fontsize + "px"); this.m_BtnGambleHitArea = DOMHelper.createAndAppendDiv(this.m_BtnGambleBase, undefined, "btn_gamble_hitarea"); this.m_BtnGamble.style.lineHeight = uiElements.gambleCollectBtn.h + "px"; this.m_BtnCollectBase = DOMHelper.createAndAppendDiv(this.hc, "collect_button", "btn_collect_base"); DOMHelper.setHeight(this.m_BtnCollectBase, uiElements.gambleCollectBtn.h); this.m_BtnCollect = DOMHelper.createImageFromSpriteSheet(this.m_BtnCollectBase, "", "btn_collect", image_path_htmlui + "uiElements.png", uiElements.gambleCollectBtn); this.m_BtnCollectText = DOMHelper.createAndAppendDiv(this.m_BtnCollect, undefined, "btn_collect_text"); DOMHelper.setText(this.m_BtnCollectText, Localizer.getInstance().getString("IDS_BTN_COLLECT")); DOMHelper.resizeFontToFitDiv(this.m_BtnCollect, htmlui_gamblebutton.fontsize + "px"); this.m_BtnCollectHitArea = DOMHelper.createAndAppendDiv(this.m_BtnCollectBase, undefined, "btn_collect_hitarea"); this.m_BtnCollect.style.lineHeight = uiElements.gambleCollectBtn.h + "px"; this.m_BtnGambleClickDelegate = Utils.delegate(this, this.onClickGamble); this.m_BtnCollectClickDelegate = Utils.delegate(this, this.onClickCollect); this.enableCollectButton(false); this.enableGambleButton(false) } GambleButton.prototype.constructor = GambleButton; GambleButton.prototype.show = function (bShow) { this.hc.style.opacity = bShow ? 1 : 0; this.m_bVisible = bShow; if (bShow) this.hc.style.pointerEvents = ""; else this.hc.style.pointerEvents = "none" }; GambleButton.prototype.onClickGamble = function (e) { if (!DOMHelper.touchUpEventInTarget(e)) return; if (this.ao) this.ao({ type: GambleButton.EVENT_GAMBLE_CLICK }) }; GambleButton.prototype.onClickCollect = function (e) { if (!DOMHelper.touchUpEventInTarget(e)) return; if (this.ao) this.ao({ type: GambleButton.EVENT_COLLECT_CLICK }) }; GambleButton.prototype.enableGambleButton = function (bEnable) { this.m_bGambleButtonEnabled = bEnable; this.m_BtnGamble.style.opacity = bEnable ? "1" : "0.6"; if (bEnable) { this.m_BtnGambleHitArea.addEventListener(this.m_EndEvent, this.m_BtnGambleClickDelegate, false); this.m_BtnGambleHitArea.bHasListener = true } else if (this.m_BtnGambleHitArea.bHasListener) { this.m_BtnGambleHitArea.removeEventListener(this.m_EndEvent, this.m_BtnGambleClickDelegate, false); this.m_BtnGambleHitArea.bHasListener = false } }; GambleButton.prototype.enableCollectButton = function (bEnable) { this.m_bCollectButtonEnabled = bEnable; if (bEnable) { this.m_BtnCollectHitArea.addEventListener(this.m_EndEvent, this.m_BtnCollectClickDelegate, false); this.m_BtnCollectHitArea.bHasListener = true } else if (this.m_BtnCollectHitArea.bHasListener) { this.m_BtnCollectHitArea.removeEventListener(this.m_EndEvent, this.m_BtnCollectClickDelegate, false); this.m_BtnCollectHitArea.bHasListener = false } }; function SidePanelVS(callback, parentDiv, quickBetValues, autoplaysettings) { this.ao = callback; this.m_SpinScale = document.getElementById("spinbutton_container") || DOMHelper.createAndAppendDiv(document.body, "spinbutton_container"); this.m_SpinScale.style.display = ""; this.m_SpinScale.style.width = htmlui_sidepanelvs.spinscale.w + "px"; this.m_SpinScale.style.height = htmlui_sidepanelvs.spinscale.h + "px"; this.m_SpinScale.style.position = "absolute"; this.m_SpinScale.style.left = "0px"; this.m_SpinScale.style.top = "0px"; this.m_SpinScale.style.pointerEvents = "none"; this.m_LeftHandMode = false; this.eN = new SpinButton(Utils.delegate(this, this.onSpinButtonEvent), this.m_SpinScale, quickBetValues, autoplaysettings); this.dV = new GambleButton(Utils.delegate(this, this.onGambleButtonEvent), parentDiv); this.et = {}; this.et.getShowing = function () { return false } } SidePanelVS.prototype.constructor = SidePanelVS; SidePanelVS.prototype.onSpinButtonEvent = function (e) { switch (e.type) { case SpinButton.EVENT_SPIN_CLICK: this.ao({ type: 0 }); break; case SpinButton.EVENT_PLUS_CLICK: break; case SpinButton.EVENT_STOP_CLICK: this.ao({ type: 1 }); break; default: this.ao(e); break } }; SidePanelVS.prototype.onGambleButtonEvent = function (e) { switch (e.type) { case GambleButton.EVENT_GAMBLE_CLICK: this.ao({ type: 2 }); break; case GambleButton.EVENT_COLLECT_CLICK: this.ao({ type: 3 }); break } }; SidePanelVS.prototype.ReconnectEnd = function () { }; SidePanelVS.prototype.ShowSpinPanel = function (bShowSpinPanel) { if (bShowSpinPanel) { this.eN.enableSpinButton(true); this.eN.setAutoPlay(false); this.eN.show(bShowSpinPanel) } else { this.eN.enableSpinButton(false); this.eN.show(false) } }; SidePanelVS.prototype.ShowAutoPlayPanel = function (bShowAutoPlayPanel) { this.eN.setAutoPlay(bShowAutoPlayPanel) }; SidePanelVS.prototype.ShowGamblePanel = function (bShowGamblePanel) { this.DisableGamble(!bShowGamblePanel); this.DisableCollect(!bShowGamblePanel); this.dV.show(bShowGamblePanel) }; SidePanelVS.prototype.SetBlinkButtons = function (bBlinkButtons) { }; SidePanelVS.prototype.UpdateAutoPlayText = function (numAutoSpins) { this.eN.setNumAutoSpins(numAutoSpins) }; SidePanelVS.prototype.DisableGamble = function (bDisableGamble) { this.dV.enableGambleButton(!bDisableGamble) }; SidePanelVS.prototype.DisableCollect = function (bDisableCollect) { this.dV.enableCollectButton(!bDisableCollect) }; SidePanelVS.prototype.Ticker = function () { }; SidePanelVS.prototype.BlinkSequenceEnd = function () { }; SidePanelVS.prototype.HandleOrientationChange = function (portrait) { var pt = DEVICE.orientation == "pt"; var canvas = document.getElementById("game_base"); var gamePanel = document.getElementById("gamepanel"); var gambleBase = document.getElementById("gamble_base"); var gambleButton = document.getElementById("gamble_button"); var collectButton = document.getElementById("collect_button"); var spinButtonScaleAdj = 0.85; canvas = canvas.children[0]; var canvasWidth = canvas.style.width.slice(0, -2); var canvasHeight = canvas.style.height.slice(0, -2); this.eN.HandleOrientationChange(portrait); var scaleFactor = scale_layer_pos[DEVICE.orientation].scale; if (pt) { var gpheight = htmlui_gamepanel.pt.gpheight * scaleFactor; this.eN.hc.className = "btn_spin_base pt"; var gbTop = DEVICE.pt.h + htmlui_sidepanelvs.spinscale.pt.gamble_top_adj2; gbTop -= gpheight; this.dV.hc.style.left = "0px"; this.dV.hc.style.top = gbTop + "px"; this.dV.m_BtnGambleBase.className = "btn_gamble_base pt"; this.dV.m_BtnCollectBase.className = "btn_collect_base pt"; this.dV.hc.style.width = ""; this.dV.hc.style.transformOrigin = "0% 100%"; var s = DEVICE.pt.w / htmlui_sidepanelvs.spinscale.pt.s_denominator; var buttonPos = sjs.layers.scalelayer.y + (reels_layer_pos.y + reels_layer_pos.h) * scaleFactor; var self = this; if (UAGENT_IOS) { if (UAGENT_IPHONE5 || UAGENT_IOS8 && UAGENT_IPHONE) if (!window.navigator.standalone) buttonPos = buttonPos * 1.03; else buttonPos = buttonPos * 1.05; if (UAGENT_IPAD || UAGENT_IPHONE4) buttonPos = buttonPos * 1.02 } else buttonPos = buttonPos * 1.04; this.m_SpinScale.style.top = buttonPos + "px"; this.dV.hc.style.top = parseInt(this.m_SpinScale.style.top) + htmlui_sidepanelvs.spinscale.pt.gamble_base_adj + "px"; var spinWidth = htmlui_sidepanelvs.spinscale.w; if (UAGENT_IE || UAGENT_ANDROID) spinWidth *= s; this.m_SpinScale.style.left = parseInt(gamePanel.style.width) / 2 - htmlui_sidepanelvs.spinscale.w / 2 + "px"; this.m_SpinScale.style.transform = "scale( " + s * spinButtonScaleAdj + ", " + s * spinButtonScaleAdj + ")"; gambleBase.style.width = "100%"; if (this.m_LeftHandMode) { gambleButton.style.left = -14 * s + "%"; collectButton.style.left = 14 * s + "%"; gambleButton.style.cssFloat = "right"; collectButton.style.cssFloat = "left" } else { gambleButton.style.left = 14 * s + "%"; collectButton.style.left = -14 * s + "%"; gambleButton.style.cssFloat = "left"; collectButton.style.cssFloat = "right" } this.dV.hc.style.transform = ""; gambleButton.style.transform = "scale( " + s + ", " + s + ")"; collectButton.style.transform = "scale( " + s + ", " + s + ")"; if (typeof MysteryJackpotFeature !== "undefined" && MysteryJackpotFeature.Active) { var py = Number(Str.Replace(gamePanel.style.top, "px", "")) - mysteryjackpot.spinbutton.yadj; this.m_SpinScale.style.top = py + "px"; this.dV.hc.style.top = py + mysteryjackpot.gamblebutton.yadj + "px" } } else { this.eN.hc.className = "btn_spin_base"; this.dV.hc.style.top = Math.floor(DEVICE.ls.h * N_HALF) + htmlui_sidepanelvs.spinscale.ls.gamble_top_adj + "px"; this.dV.m_BtnGambleBase.className = "btn_gamble_base"; this.dV.m_BtnCollectBase.className = "btn_collect_base"; this.dV.hc.style.width = uiElements.gambleCollectBtn.w + "px"; this.dV.hc.style.transformOrigin = "0% 100%"; if (this.m_LeftHandMode) { this.m_SpinScale.style.left = 10 * scaleFactor + "px"; gambleBase.style.left = DEVICE.ls.w - gambleBase.clientWidth * scaleFactor + "px" } else { this.m_SpinScale.style.left = DEVICE.ls.w - parseInt(this.m_SpinScale.style.width) + "px"; gambleBase.style.left = 10 * scaleFactor + "px" } var s1 = (DEVICE.ls.h + htmlui_sidepanelvs.spinscale.ls.s1_adj) / htmlui_sidepanelvs.spinscale.ls.s1_denominator; var s2 = DEVICE.ls.w / htmlui_sidepanelvs.spinscale.ls.s2_denominator; var s = s1 < s2 ? s1 : s2; s -= 0.1; this.m_SpinScale.style.top = DEVICE.ls.h - htmlui_sidepanelvs.spinscale.ls.spinscale_top_adj * s + "px"; this.m_SpinScale.style.bottom = ""; this.m_SpinScale.style.transform = "scale( " + s * spinButtonScaleAdj + ", " + s * spinButtonScaleAdj + ")"; gambleButton.style.transform = ""; collectButton.style.transform = ""; gambleButton.style.left = ""; collectButton.style.left = ""; this.dV.hc.style.transform = "scale( " + s + ", " + s + ")" } }; SidePanelVS.prototype.setLeftHandMode = function () { this.m_LeftHandMode = !this.m_LeftHandMode; this.eN.setLeftHandMode(this.m_LeftHandMode); this.HandleOrientationChange() }; function ViewArea(swipeCallback) { this.SCROLL_DIRECTION_NONE = 0; this.SCROLL_DIRECTION_HORIZONTAL = 1; this.SCROLL_DIRECTION_VERTICAL = 2; this.m_Root = DOMHelper.createDiv("menu_view_area"); this.m_Root.addEventListener("touchstart", Utils.delegate(this, this.onTouchStart)); this.m_Root.addEventListener("touchend", Utils.delegate(this, this.onTouchEnd)); this.m_Root.addEventListener("touchmove", Utils.delegate(this, this.onTouchMove)); this.m_Table = DOMHelper.createAndAppendDiv(this.m_Root, "menu_view_area_table"); this.m_ViewSwipeCallback = swipeCallback; this.m_Views = []; this.m_ViewIndex = 0; this.m_ViewWidth = 0; this.m_ViewHeight = 0; this.m_PrevTouchX = 0; this.m_PrevTouchY = 0; this.m_LastTimeStamp = 0; this.m_ScrollX = 0; this.m_ScrollVelocity = 0; this.m_ScrollDirection = this.SCROLL_DIRECTION_NONE }; ViewArea.prototype.addView = function (viewContent) { if (!viewContent) viewContent = DOMHelper.createDiv(); var viewContainer = DOMHelper.createAndAppendDiv(this.m_Table, undefined, "menu_view"); viewContainer.appendChild(viewContent); viewContainer.style.overflowY = "auto"; this.m_Views.push(viewContainer); this.setSize(this.m_ViewWidth, this.m_ViewHeight); return this.m_Views.length - 1 }; ViewArea.prototype.scroll = function (value) { this.setScrollOffset(this.m_ScrollX + value) }; ViewArea.prototype.setScrollOffset = function (value) { var maxScroll = -this.m_ViewWidth * (this.m_Views.length - 1); this.m_ScrollX = Math.max(maxScroll, Math.min(0, value)); this.m_Table.style.marginLeft = this.m_ScrollX + "px" }; ViewArea.prototype.shouldScrollLeft = function (distanceThreshold, velocityThreshold, velocityDistanceThreshold) { var scrollDistance = -this.m_ScrollX - this.m_ViewIndex * this.m_ViewWidth; var distanceIsOverThreshold = scrollDistance < -distanceThreshold; var velocityIsOverThreshold = this.m_ScrollVelocity > velocityThreshold && scrollDistance < -velocityDistanceThreshold; return (distanceIsOverThreshold || velocityIsOverThreshold) && this.m_ViewIndex > 0 }; ViewArea.prototype.shouldScrollRight = function (distanceThreshold, velocityThreshold, velocityDistanceThreshold) { var scrollDistance = -this.m_ScrollX - this.m_ViewIndex * this.m_ViewWidth; var distanceIsOverThreshold = scrollDistance > distanceThreshold; var velocityIsOverThreshold = this.m_ScrollVelocity < -velocityThreshold && scrollDistance > velocityDistanceThreshold; return (distanceIsOverThreshold || velocityIsOverThreshold) && this.m_ViewIndex < this.m_Views.length - 1 }; ViewArea.prototype.onTouchMove = function (event) { var touch = event.changedTouches[0]; var deltaX = touch.pageX - this.m_PrevTouchX; var deltaY = touch.pageY - this.m_PrevTouchY; var deltaTime = (event.timeStamp - this.m_LastTimeStamp) / 1E3; this.m_ScrollVelocity = deltaX / this.m_ViewWidth / deltaTime; if (this.m_ScrollDirection === this.SCROLL_DIRECTION_NONE) Math.abs(deltaX) > Math.abs(deltaY) ? this.m_ScrollDirection = this.SCROLL_DIRECTION_HORIZONTAL : this.m_ScrollDirection = this.SCROLL_DIRECTION_VERTICAL; if (this.m_ScrollDirection === this.SCROLL_DIRECTION_HORIZONTAL) { this.scroll(deltaX); event.preventDefault() } this.m_PrevTouchX = touch.pageX; this.m_PrevTouchY = touch.pageY; this.m_LastTimeStamp = event.timeStamp; event.stopPropagation() }; ViewArea.prototype.onTouchEnd = function (event) { var velocityThreshold = 2; var velocityDistanceThreshold = 0.1 * this.m_ViewWidth; var distanceThreshold = 0.4 * this.m_ViewWidth; var scrollDistance = -this.m_ScrollX - this.m_ViewIndex * this.m_ViewWidth; var newViewIndex = this.m_ViewIndex; if (this.shouldScrollRight(distanceThreshold, velocityThreshold, velocityDistanceThreshold)) { newViewIndex++; this.m_ViewSwipeCallback(this.m_ViewIndex, newViewIndex) } else if (this.shouldScrollLeft(distanceThreshold, velocityThreshold, velocityDistanceThreshold)) { newViewIndex--; this.m_ViewSwipeCallback(this.m_ViewIndex, newViewIndex) } this.m_ScrollVelocity = 0; this.gotoView(newViewIndex, 300) }; ViewArea.prototype.iosReset = function () { for (var i = 0; i < this.m_Views.length; i++) this.m_Views[i].style.webkitOverflowScrolling = "" }; ViewArea.prototype.onTouchStart = function (event) { var touch = event.changedTouches[0]; this.m_PrevTouchX = touch.pageX; this.m_PrevTouchY = touch.pageY; this.m_ScrollDirection = this.SCROLL_DIRECTION_NONE; this.setScrollTransitionDuration(0); this.m_LastTimeStamp = event.timeStamp }; ViewArea.prototype.setScrollTransitionDuration = function (duration) { this.m_Table.style.transitionDuration = duration + "ms"; this.m_Table.style.webkitTransitionDuration = duration + "ms" }; ViewArea.prototype.gotoView = function (index, duration) { if (index >= 0 && index < this.m_Views.length) { if (index !== this.m_ViewIndex) this.m_Views[this.m_ViewIndex].scrollTop = 0; this.m_ViewIndex = index; this.setScrollTransitionDuration(duration); this.setScrollOffset(-this.m_ViewIndex * this.m_ViewWidth); this.m_Views[index].style.webkitOverflowScrolling = "touch" } }; ViewArea.prototype.getScrollView = function (element) { var result; var currentElement = element; while (currentElement) { if (currentElement.className === "menu_view") { result = currentElement; break } currentElement = currentElement.parentElement } return result }; ViewArea.prototype.setSize = function (width, height) { this.m_ViewWidth = width; this.m_ViewHeight = height; this.m_Root.style.width = this.m_ViewWidth + "px"; this.m_Root.style.height = this.m_ViewHeight + "px"; this.m_Table.style.width = this.m_ViewWidth * this.m_Views.length + "px"; this.m_Table.style.height = "100%"; var viewDivs = this.m_Table.getElementsByClassName("menu_view"); for (var i = 0; i < viewDivs.length; i++) { viewDivs[i].style.width = this.m_ViewWidth + "px"; viewDivs[i].style.height = this.m_ViewHeight + "px" } this.gotoView(this.m_ViewIndex, 0) }; ViewArea.prototype.getDOMNode = function () { return this.m_Root }; function NavigationBar(buttonClickCallback, scrollCallback) { this.m_ButtonClickCallback = buttonClickCallback; this.m_ScrollCallback = scrollCallback; this.m_Root = DOMHelper.createDiv("navbar"); this.m_Root.addEventListener("touchstart", Utils.delegate(this, this.onTouchStart)); this.m_Root.addEventListener("touchmove", Utils.delegate(this, this.onTouchMove)); this.m_ButtonContainer = DOMHelper.createAndAppendDiv(this.m_Root, "navbar_table"); this.bB = []; this.m_ButtonIndex = 0; this.m_Width = 0; this.m_PrevTouchX = 0; this.m_ScrollX = 0; this.m_EndEvent = "ontouchstart" in window ? "touchend" : "mouseup" } NavigationBar.prototype.setScrollTransitionDuration = function (duration) { this.m_ButtonContainer.style.transitionDuration = duration + "ms"; this.m_ButtonContainer.style.webkitTransitionDuration = duration + "ms" }; NavigationBar.prototype.scroll = function (value) { this.setScrollOffset(this.m_ScrollX + value) }; NavigationBar.prototype.setScrollOffset = function (value) { var maxScroll = Math.max(0, this.m_ButtonContainer.offsetWidth - this.m_Width); this.m_ScrollX = Math.max(-maxScroll, Math.min(0, value)); this.m_ButtonContainer.style.marginLeft = this.m_ScrollX + "px"; this.m_ScrollCallback(-this.m_ScrollX, maxScroll) }; NavigationBar.prototype.onTouchMove = function (event) { var touch = event.changedTouches[0]; var deltaX = touch.pageX - this.m_PrevTouchX; this.scroll(deltaX); this.m_PrevTouchX = touch.pageX; event.preventDefault() }; NavigationBar.prototype.onTouchStart = function (event) { var touch = event.changedTouches[0]; this.m_PrevTouchX = touch.pageX; this.setScrollTransitionDuration(0) }; NavigationBar.prototype.setWidth = function (width) { this.m_Width = width; DOMHelper.setWidth(this.m_Root, width); this.centerButton(this.m_ButtonIndex, 0) }; NavigationBar.prototype.deselectAll = function () { for (var i = 0; i < this.bB.length; i++) this.bB[i].deselect() }; NavigationBar.prototype.addButton = function (name) { var that = this; var index = this.bB.length; var button = new NavigationBarButton(name); button.getDOMNode().addEventListener(this.m_EndEvent, function (event) { that.m_ButtonClickCallback(index) }, false); this.m_ButtonContainer.appendChild(button.getDOMNode()); return this.bB.push(button) - 1 }; NavigationBar.prototype.selectButton = function (index) { this.deselectAll(); this.m_ButtonIndex = index; this.bB[index].select(); this.centerButton(index, 200) }; NavigationBar.prototype.getButtonX = function (index) { var result = 0; for (var i = 0; i < index; i++) result += this.bB[i].getWidth(); return result }; NavigationBar.prototype.centerButton = function (index, duration) { if (this.bB.length > 0) { var navBarHalfWidth = this.m_Width / 2; var buttonHalfWidth = this.bB[index].getWidth() / 2; var buttonX = this.getButtonX(index); var offset = navBarHalfWidth - buttonHalfWidth - buttonX; this.setScrollTransitionDuration(duration); this.setScrollOffset(offset) } }; NavigationBar.prototype.getDOMNode = function () { return this.m_Root }; function NavigationBarButton(name) { this.m_Root = DOMHelper.createDiv(undefined, "navbar_button"); this.m_Root.innerHTML = name; this.m_SelectedIndicator = DOMHelper.createAndAppendDiv(this.m_Root); this.deselect() } NavigationBarButton.prototype.getWidth = function () { return this.m_Root.offsetWidth }; NavigationBarButton.prototype.select = function () { this.m_Root.className = "navbar_button selected" }; NavigationBarButton.prototype.deselect = function () { this.m_Root.className = "navbar_button" }; NavigationBarButton.prototype.getDOMNode = function () { return this.m_Root }; function MenuItem(title, color) { this.m_Title = title; this.m_View = undefined; if (color) this.test(color, title) } MenuItem.prototype.onFocusIn = function () { }; MenuItem.prototype.onFocusOut = function () { }; MenuItem.prototype.onSwipeIn = function () { }; MenuItem.prototype.onSwipeOut = function () { }; MenuItem.prototype.onClick = function () { }; MenuItem.prototype.handleOrientationChange = function () { }; MenuItem.prototype.getTitle = function () { return this.m_Title }; MenuItem.prototype.getView = function () { return this.m_View }; MenuItem.prototype.test = function (color, text) { this.m_View = DOMHelper.createDiv(); this.m_View.style.backgroundColor = color; this.m_View.style.color = "#000000"; this.m_View.style.width = "100%"; this.m_View.style.height = "100%"; this.m_View.style.textAlign = "center"; var title = DOMHelper.createAndAppendDiv(this.m_View); title.style.fontSize = "50px"; title.style.fontFamily = "oswaldbold"; title.innerHTML = text }; function Menu(gameTitle) { this.m_Root = document.getElementById("menu"); if (this.m_Root == undefined) { this.m_Root = DOMHelper.createDiv("menu"); this.m_Root.style.visibility = "hidden"; document.body.insertBefore(this.m_Root, document.getElementById("gamepanel")) } else this.m_Root.style.visibility = "hidden"; this.m_Root.style.display = ""; this.m_Header = DOMHelper.createAndAppendDiv(this.m_Root, "menu_header"); this.m_GameTitlePortrait = DOMHelper.createAndAppendDiv(this.m_Header, "gametitle_portrait"); this.m_NavigationBar = new NavigationBar(Utils.delegate(this, this.onNavigationBarButtonClick), Utils.delegate(this, this.onNavigationBarScroll)); var navbarRow = DOMHelper.createAndAppendDiv(this.m_Header, "navbar_row"); var navbarRowTable = DOMHelper.createAndAppendDiv(navbarRow, "navbar_row_table"); this.m_NavbarCell = DOMHelper.createAndAppendDiv(navbarRowTable, "navbar_cell"); this.m_NavbarCell.appendChild(this.m_NavigationBar.getDOMNode()); this.m_GameTitleLandscape = DOMHelper.createAndAppendDiv(navbarRowTable, "gametitle_landscape"); this.m_OverflowIndicator = DOMHelper.createAndAppendDiv(navbarRow, "overflow_indicator"); this.m_ViewArea = new ViewArea(Utils.delegate(this, this.onViewSwipe)); this.m_Root.appendChild(this.m_ViewArea.getDOMNode()); this.m_MenuItems = []; this.m_CurrentMenuItem = -1; this.fp = false; this.m_GameTitle = gameTitle; this.m_GameTitleScale = 1; this.setGameTitle(gameTitle); this.Show(false) }; Menu.prototype.reconnectEnd = function () { this.Show(true); this.HandleOrientationChange(); this.Show(false); this.m_Root.style.visibility = "" }; Menu.prototype.onNavigationBarScroll = function (value, maxValue) { if (value === maxValue || DEVICE.orientation === "pt") this.m_OverflowIndicator.style.display = "none"; else this.m_OverflowIndicator.style.display = "block" }; Menu.prototype.Show = function (show) { show ? this.m_Root.style.display = "" : this.m_Root.style.display = "none"; this.fp = show; this.m_ViewArea.iosReset(); if (show) if (this.m_MenuItems[this.m_CurrentMenuItem].m_View.id == "gamehistoryview") this.m_MenuItems[this.m_CurrentMenuItem].onFocusIn() }; Menu.prototype.onViewSwipe = function (oldIndex, newIndex) { this.m_MenuItems[oldIndex].onSwipeOut(); this.m_MenuItems[newIndex].onSwipeIn(); this.setFocus(newIndex, 200) }; Menu.prototype.onNavigationBarButtonClick = function (index) { this.setFocus(index, 200); this.m_MenuItems[index].onClick() }; Menu.prototype.setFocus = function (index, duration) { if (index !== this.m_CurrentMenuItem) { this.m_ViewArea.gotoView(index, duration); this.m_NavigationBar.selectButton(index); if (this.m_CurrentMenuItem >= 0) this.m_MenuItems[this.m_CurrentMenuItem].onFocusOut(); this.m_CurrentMenuItem = index; this.m_MenuItems[this.m_CurrentMenuItem].onFocusIn() } }; Menu.prototype.addMenuItem = function (item) { this.m_NavigationBar.addButton(item.getTitle()); this.m_ViewArea.addView(item.getView()); this.m_MenuItems.push(item); if (this.m_CurrentMenuItem < 0) this.setFocus(this.m_MenuItems.length - 1) }; Menu.prototype.setGameTitle = function (gameTitle) { this.m_GameTitle = gameTitle; this.m_GameTitlePortrait.innerHTML = gameTitle; this.m_GameTitleLandscape.innerHTML = gameTitle; if (this.m_GameTitle.length > 22) this.adjustGameTitleSize() }; Menu.prototype.adjustGameTitleSize = function () { this.m_GameTitleLandscape.innerHTML = this.m_GameTitle.substring(0, 22); var maxWidth = this.m_GameTitleLandscape.offsetWidth; this.m_GameTitleLandscape.innerHTML = this.m_GameTitle; var actualWidth = this.m_GameTitleLandscape.offsetWidth; this.m_GameTitleScale = maxWidth / actualWidth; this.m_GameTitleLandscape.style.msTransform = "scaleX(" + this.m_GameTitleScale + ")"; this.m_GameTitleLandscape.style.webkitTransform = "scaleX(" + this.m_GameTitleScale + ")"; this.m_GameTitleLandscape.style.transform = "scaleX(" + this.m_GameTitleScale + ")" }; Menu.prototype.HandleOrientationChange = function () { var visible = this.fp; if (!visible) this.Show(true); DOMHelper.setWidth(this.m_Root, DEVICE[DEVICE.orientation].w); this.m_GameTitlePortrait.style.height = ""; if (UAGENT_IPHONE) { if (DEVICE.orientation === "ls") this.m_GameTitlePortrait.style.height = "50px"; this.m_GameTitleLandscape.style.display = "none"; this.m_GameTitlePortrait.style.display = "" } else if (DEVICE.orientation === "pt") { this.m_GameTitleLandscape.style.display = "none"; this.m_GameTitlePortrait.style.display = "" } else { this.m_GameTitleLandscape.style.display = ""; this.m_GameTitlePortrait.style.display = "none" } this.m_NavigationBar.setWidth(DEVICE[DEVICE.orientation].w - this.m_GameTitleLandscape.offsetWidth * this.m_GameTitleScale); var gamePanel = document.getElementById("gamepanel"); if (gamePanel) this.m_ViewArea.setSize(DEVICE[DEVICE.orientation].w, DEVICE[DEVICE.orientation].h - this.m_Header.offsetHeight - gamePanel.offsetHeight); else this.m_ViewArea.setSize(DEVICE[DEVICE.orientation].w, DEVICE[DEVICE.orientation].h - this.m_Header.offsetHeight); for (var i = 0; i < this.m_MenuItems.length; i++) this.m_MenuItems[i].handleOrientationChange(); this.m_OverflowIndicator.style.left = this.m_NavbarCell.clientWidth - this.m_OverflowIndicator.clientWidth + "px"; if (!visible) this.Show(false) }; Menu.prototype.getDOMNode = function () { return this.m_Root }; Menu.prototype.SetDlgObjects = function (contentWindows) { }; Menu.prototype.ShowContent = function (contWindow) { }; Menu.prototype.GetCurrentWindow = function () { return this.m_CurrentMenuItem }; Menu.prototype.SetCurrentWindow = function (windowIndex) { }; Menu.prototype.GetIsShowing = function () { return this.fp }; Menu.prototype.SetIsShowing = function (b) { this.fp = b }; function GameRulesView(url) { this._super(pt_help_btn_cap); this.m_View = DOMHelper.createDiv("gamerulesview"); this.m_Content; this.m_StatsTimeOut } Classify.constr(GameRulesView).ext(MenuItem); GameRulesView.prototype.loadPage = function (url) { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.addEventListener("readystatechange", Utils.delegate(this, this.onReadyStateChange)); xhr.addEventListener("error", Utils.delegate(this, this.onError)); xhr.responseType = "document"; xhr.send() }; GameRulesView.override("onFocusIn", function () { this.m_StatsTimeOut = setTimeout(function () { StatsHandler.HandleEvent("showhelp") }, 3E3) }); GameRulesView.override("onFocusOut", function () { clearTimeout(this.m_StatsTimeOut) }); GameRulesView.prototype.onReadyStateChange = function (event) { var xhr = event.target; if (xhr.readyState === 4 && xhr.status === 200) this.createContentDiv(xhr.response.body) }; GameRulesView.prototype.onError = function (event) { console.log("onError: ", event) }; GameRulesView.prototype.createContentDiv = function (contents) { this.stripElementsByTagName(contents, "script"); this.stripElementsByTagName(contents, "a"); this.m_Content = DOMHelper.createDiv(); this.m_Content.innerHTML = contents.innerHTML; this.m_View.appendChild(this.m_Content) }; GameRulesView.prototype.stripElementsByTagName = function (parent, tag) { var i, elements = []; var nodeList = parent.getElementsByTagName(tag); for (i = 0; i < nodeList.length; i++) elements.push(nodeList[i]); for (i = 0; i < elements.length; i++) elements[i].parentNode.removeChild(elements[i]) }; function AutoPlayButton(callback) { this.m_Root = DOMHelper.createDiv("autoplay_button"); this.m_Root.style.width = uiElements.settingsAutoPlayBtn.w + "px"; this.m_Root.style.height = uiElements.settingsAutoPlayBtn.h + "px"; this.m_callback = callback; this.m_Button = DOMHelper.createImageFromSpriteSheet(this.m_Root, "autoplay_button", undefined, image_path_htmlui + "uiElements.png", uiElements.settingsAutoPlayBtn); this.fw = DOMHelper.createAndAppendDiv(this.m_Button, "autoplay_button_spins"); this.m_StartEvent = "mousedown"; this.m_EndEvent = "mouseup"; this.m_MoveEvent = "mousemove"; if ("ontouchstart" in window) { this.m_StartEvent = "touchstart"; this.m_EndEvent = "touchend"; this.m_MoveEvent = "touchmove" } this.m_Button.addEventListener(this.m_StartEvent, Utils.delegate(this, this.onStart), false); this.m_Button.addEventListener(this.m_EndEvent, Utils.delegate(this, this.onEnd), false); this.m_Button.addEventListener(this.m_MoveEvent, Utils.delegate(this, this.onMove), false) }; AutoPlayButton.prototype.setAutoPlaying = function (value) { if (value) { this.fw.style.color = "white"; DOMHelper.setImageFromSpriteSheet(this.m_Button, image_path_htmlui + "uiElements.png", uiElements.settingsAutoPlayStopBtn) } else { this.fw.style.color = "black"; DOMHelper.setImageFromSpriteSheet(this.m_Button, image_path_htmlui + "uiElements.png", uiElements.settingsAutoPlayBtn) } }; AutoPlayButton.prototype.setSpins = function (spins) { this.fw.innerHTML = spins }; AutoPlayButton.prototype.getDOMNode = function () { return this.m_Root }; AutoPlayButton.prototype.getWidth = function () { return this.m_Button.clientWidth }; AutoPlayButton.prototype.onStart = function (e) { this.m_Button.classList.add("scaleup"); this.m_Button.buttonPressed = true }; AutoPlayButton.prototype.onEnd = function (e) { this.m_Button.classList.remove("scaleup"); if (!DOMHelper.touchUpEventInTarget(e)) return; this.m_Button.buttonPressed = false; this.m_callback(e) }; AutoPlayButton.prototype.onMove = function (e) { if (!this.m_Button.buttonPressed) return; if (!DOMHelper.touchUpEventInTarget(e)) this.m_Button.classList.remove("scaleup"); else this.m_Button.classList.add("scaleup"); e.preventDefault(); e.stopPropagation() }; BetView.TotalLossData = [0, 100, 200, 500, 1E3, 1500, 2E3, 2500, 5E3, 1E4, 15E3, 2E4, 25E3, 5E4, 1E5, 2E5, 5E5, 1E6]; function BetView(betCallback, autoPlayCallback, startAutoPlayCallback, stopAutoPlayCallback, quickBetValues, autoPlaySettings, videoslotsettings, disable) { this._super(this.getString("IDS_MENU_BET_VSLOT")); this.m_BetCallback = betCallback; this.m_AutoPlayCallback = autoPlayCallback; this.m_StartAutoPlayCallback = startAutoPlayCallback; this.m_StopAutoPlayCallback = stopAutoPlayCallback; this.m_QuickBetValues = quickBetValues; this.m_View = DOMHelper.createDiv("betview"); this.m_LinesSlider; this.m_CoinsSlider; this.m_CoinValueSlider; this.m_BetSlider; this.m_AutoPlaySlider; this.m_AutoPlayButton; this.m_BetCoinsValue; this.m_BetCashValue; this.m_StopOnFreespins; this.m_StopOnBonusGame; this.m_StopOnJackpot; this.m_QuickBetButtons = []; this.m_Initialized = false; this.m_StopAutoplayCaption; this.m_AutoPlayEnabled = true; this.m_FirstHalf = DOMHelper.createAndAppendDiv(this.m_View, "betview_firsthalf"); this.m_SecondHalf = DOMHelper.createAndAppendDiv(this.m_View, "betview_secondhalf"); this.m_NormalBet = this.m_FirstHalf.appendChild(this.createNormalBet()); this.m_FixedBet = this.m_FirstHalf.appendChild(this.createFixedBet()); this.bf = this.m_SecondHalf.appendChild(this.createAutoPlay(autoPlaySettings)); this.setCreditDisplayType(); this.cW; this.m_AutoplayReset = false; this.m_AutoplayLimits = false; this.m_WinExceedsLimitSlider; this.m_TotalLossSlider; this.mr; this.m_SpinsDefault; this.hh = 1; this.m_DefaultDenominations = []; this.m_VideoSlotSettings = videoslotsettings; this.m_DisableAutoplay = disable; if (this.m_DisableAutoplay) this.disableAutoplayDlg() }; Classify.constr(BetView).ext(MenuItem); BetView.prototype.createNormalBet = function () { var container = DOMHelper.createDiv("betview_normalbet"); this.m_LinesSlider = this.createSlider(undefined, this.getString("IDS_LINES_CAPTION"), [0, 1]); this.m_LinesSlider.setCallback(Utils.delegate(this, this.onLinesSliderEvent)); this.m_CoinsSlider = this.createSlider(undefined, this.getString("IDS_COINS_CAPTION"), [0, 1]); this.m_CoinsSlider.setCallback(Utils.delegate(this, this.onCoinsSliderEvent)); this.m_CoinValueSlider = this.createSlider(undefined, "", [0, 1]); this.m_CoinValueSlider.setCallback(Utils.delegate(this, this.onCoinValueSliderEvent)); this.m_BetInfo = container.appendChild(this.createBetInfo()); container.appendChild(this.m_LinesSlider.getDOMNode()); container.appendChild(this.m_CoinsSlider.getDOMNode()); container.appendChild(this.m_CoinValueSlider.getDOMNode()); return container }; BetView.prototype.createFixedBet = function () { var container = DOMHelper.createDiv("betview_fixedbet"); for (var i = 0; i < 4; i++) this.m_QuickBetButtons.push(this.createBetButton()); var table = DOMHelper.createDiv("betview_fixedbet_table"); var tr = table.appendChild(document.createElement("tr")); var td = tr.appendChild(document.createElement("td")); td.appendChild(this.m_QuickBetButtons[0]); td = tr.appendChild(document.createElement("td")); td.appendChild(this.m_QuickBetButtons[1]); tr = table.appendChild(document.createElement("tr")); td = tr.appendChild(document.createElement("td")); td.appendChild(this.m_QuickBetButtons[2]); td = tr.appendChild(document.createElement("td")); td.appendChild(this.m_QuickBetButtons[3]); this.m_BetSlider = this.createSlider(undefined, "", [0, 1]); this.m_BetSlider.setCallback(Utils.delegate(this, this.onBetSliderEvent)); container.appendChild(this.m_BetSlider.getDOMNode()); container.appendChild(table); return container }; BetView.prototype.createBetButton = function () { var button = document.createElement("button"); button.className = "betview_button"; button.style.display = "none"; button.addEventListener("click", Utils.delegate(this, this.onBetButtonClick)); return button }; BetView.prototype.createBetInfo = function () { var container = DOMHelper.createDiv("betview_betinfo"); var tableCell = DOMHelper.createAndAppendDiv(container, undefined, "cell"); tableCell.style.textAlign = "left"; var betCoinsCaption = DOMHelper.createAndAppendDiv(tableCell, undefined, "caption"); betCoinsCaption.innerHTML = this.getString("IDS_BETINCOINS_CAPTION"); tableCell = DOMHelper.createAndAppendDiv(container, undefined, "cell"); tableCell.style.textAlign = "right"; this.m_BetCoinsValue = DOMHelper.createAndAppendDiv(tableCell, undefined, "value"); tableCell = DOMHelper.createAndAppendDiv(container, undefined, "cell"); tableCell.style.textAlign = "left"; var betCashCaption = DOMHelper.createAndAppendDiv(tableCell, undefined, "caption"); betCashCaption.style.borderLeft = betview.betcashcap_border + "px solid #b3b3b3"; betCashCaption.innerHTML = this.getString("IDS_BETINCASH_CAPTION"); tableCell = DOMHelper.createAndAppendDiv(container, undefined, "cell"); tableCell.style.textAlign = "right"; this.m_BetCashValue = DOMHelper.createAndAppendDiv(tableCell, undefined, "value"); return container }; BetView.prototype.createAutoPlay = function (autoPlaySettings) { var container = DOMHelper.createDiv("betview_autoplay"); this.m_AutoPlayCaption = DOMHelper.createAndAppendDiv(container, "betview_autoplay_caption"); this.m_AutoPlayCaption.className = "caption"; this.m_AutoPlayCaption.innerHTML = this.getString("IDS_AP_CAPTION2"); this.m_AutoPlayButton = new AutoPlayButton(Utils.delegate(this, this.onAutoPlayClick)); this.m_AutoPlayButton.getDOMNode().style.cssFloat = "right"; this.m_AutoPlaySlider = this.createSlider(undefined, this.getString("IDS_AP_CAPTION2"), [0, 1]); this.m_AutoPlaySlider.setCallback(Utils.delegate(this, this.onAutoPlaySliderEvent)); this.m_AutoPlaySlider.getDOMNode().style.top = betview.apslider_top + "px"; this.m_AutoPlaySlider.jE.style.display = "none"; container.appendChild(this.m_AutoPlaySlider.getDOMNode()); container.appendChild(this.m_AutoPlayButton.getDOMNode()); this.m_StopAutoplayCaption = DOMHelper.createAndAppendDiv(container); this.m_StopAutoplayCaption.className = "caption"; this.m_StopAutoplayCaption.style.clear = "both"; this.m_StopAutoplayCaption.innerHTML = this.getString("IDS_AP_STOPAUTOPLAY"); var hasAutoplaySettings = autoPlaySettings.GetFreeSpinEnabled() || autoPlaySettings.GetBonusEnabled() || autoPlaySettings.GetJackpotEnabled(); this.m_StopAutoplayCaption.style.display = hasAutoplaySettings ? "" : "none"; this.m_StopOnFreespins = this.createCheckbox(Utils.delegate(this, this.onStopOnFreespins), this.getString("IDS_AP_ONFREESPINS"), container); this.m_StopOnFreespins.getDOMNode().style.display = autoPlaySettings.GetFreeSpinEnabled() ? "" : "none"; this.m_StopOnBonusGame = this.createCheckbox(Utils.delegate(this, this.onStopOnBonusGame), this.getString("IDS_AP_ONBONUS"), container); this.m_StopOnBonusGame.getDOMNode().style.display = autoPlaySettings.GetBonusEnabled() ? "" : "none"; this.m_StopOnJackpot = this.createCheckbox(Utils.delegate(this, this.onStopOnJackpot), this.getString("IDS_AP_ONJACKPOT"), container); this.m_StopOnJackpot.getDOMNode().style.display = autoPlaySettings.GetJackpotEnabled() ? "" : "none"; return container }; BetView.prototype.createCheckbox = function (callback, caption, parent, icon) { var checkbox = new CheckboxControl(callback, caption, icon); checkbox.getDOMNode().classList.add("betview_checkbox"); checkbox.getDOMNode().style.position = ""; parent.appendChild(checkbox.getDOMNode()); return checkbox }; BetView.prototype.createSlider = function (callback, caption, values, left, top, displayMinValue) { var displayMinValue = typeof displayMinValue !== "undefined" ? displayMinValue : true; var slider = new SliderControl(callback, values, displayMinValue); slider.getDOMNode().style.fontSize = betview.slider_fontsize + "px"; slider.getDOMNode().style.position = "relative"; slider.getDOMNode().style.top = typeof top == "undefined" ? "0px" : top; slider.getDOMNode().style.left = typeof left == "undefined" ? "0px" : left; slider.setCaption(caption); return slider }; BetView.prototype.onBetButtonClick = function (event) { var index = this.m_QuickBetButtons.indexOf(event.target); this.m_BetSlider.setValue(this.m_QuickBetButtons[index].innerHTML) }; BetView.prototype.onAutoPlayClick = function (event) { if (this.m_AutoPlayEnabled) { this.m_AutoPlayCallback(-1, this.m_AutoPlaySlider.getCurrentValueIndex() + 1); this.m_StartAutoPlayCallback() } else { this.m_StopAutoPlayCallback(); if (this.m_AutoplayReset) this.resetLimitSettings() } }; BetView.prototype.onBetSliderEvent = function (event) { this.updateCoinValue(event.index + 1); if (this.m_AutoplayLimits) this.enableAutoplayIfOptionsAreValid() }; BetView.prototype.onLinesSliderEvent = function (event) { this.updateLines(event.value); if (this.m_AutoplayLimits) this.enableAutoplayIfOptionsAreValid() }; BetView.prototype.onCoinsSliderEvent = function (event) { this.updateCoins(event.value); if (this.m_AutoplayLimits) this.enableAutoplayIfOptionsAreValid() }; BetView.prototype.onCoinValueSliderEvent = function (event) { this.updateCoinValue(event.index + 1); if (this.m_AutoplayLimits) this.enableAutoplayIfOptionsAreValid() }; BetView.prototype.onAutoPlaySliderEvent = function (event) { this.m_AutoPlayButton.setSpins(event.value); if (this.m_AutoplayReset) { this.m_AutoPlaySlider.setValid(event.value > 0); this.enableAutoplayIfOptionsAreValid() } }; BetView.prototype.onStopOnFreespins = function (value) { this.m_AutoPlayCallback(1) }; BetView.prototype.onStopOnBonusGame = function (value) { this.m_AutoPlayCallback(2) }; BetView.prototype.onStopOnJackpot = function (value) { this.m_AutoPlayCallback(3) }; BetView.prototype.onTotalLossSliderEvent = function (event) { this.m_AutoPlayCallback(7, event.value); if (this.m_AutoplayReset) this.enableAutoplayIfOptionsAreValid() }; BetView.prototype.onWinLimitSliderEvent = function (event) { var value = event.value; this.m_AutoPlayCallback(4, value > 0 ? value : "") }; BetView.prototype.resizeSliderCaption = function (slider, width) { var oldWidth = slider.jE.clientWidth; slider.jE.style.width = width + "px"; var diff = slider.jE.clientWidth - width; var adjustedWidth = width - diff; slider.jE.style.width = adjustedWidth + "px" }; BetView.prototype.handleOrientationChange = function () { var toggleMultiplier = DEVICE.orientation === "ls" ? 0.8 : 0.9; this.m_FirstHalf.className = DEVICE.orientation; this.m_SecondHalf.className = DEVICE.orientation; this.m_LinesSlider.setWidthAndHeight(this.m_NormalBet.offsetWidth); this.m_CoinsSlider.setWidthAndHeight(this.m_NormalBet.offsetWidth); this.m_CoinValueSlider.setWidthAndHeight(this.m_NormalBet.offsetWidth); this.m_BetSlider.setWidthAndHeight(this.m_FixedBet.offsetWidth * 0.98); this.m_StopOnFreespins.setWidth(this.bf.clientWidth * toggleMultiplier); this.m_StopOnBonusGame.setWidth(this.bf.clientWidth * toggleMultiplier); this.m_StopOnJackpot.setWidth(this.bf.clientWidth * toggleMultiplier); if (DEVICE.orientation === "ls") { this.m_AutoPlayCaption.style.display = ""; this.m_AutoPlaySlider.setWidthAndHeight(this.bf.clientWidth - this.m_AutoPlayButton.getWidth() - 2); this.m_AutoPlaySlider.jE.style.display = "none"; this.m_AutoPlaySlider.getDOMNode().style.cssFloat = "left"; this.m_AutoPlayButton.getDOMNode().style.display = ""; this.m_AutoPlayButton.getDOMNode().style.marginRight = ""; if (this.m_TotalLossSlider) this.m_TotalLossSlider.setWidthAndHeight(this.bf.clientWidth); if (this.m_WinExceedsLimitSlider) this.m_WinExceedsLimitSlider.setWidthAndHeight(this.bf.clientWidth) } else { this.m_AutoPlayCaption.style.display = "none"; this.m_AutoPlaySlider.setWidthAndHeight(this.bf.clientWidth); this.m_AutoPlaySlider.jE.style.display = ""; this.m_AutoPlaySlider.getDOMNode().style.cssFloat = ""; this.m_AutoPlayButton.getDOMNode().style.display = "block"; this.m_AutoPlayButton.getDOMNode().style.marginRight = "5%"; if (this.m_TotalLossSlider) this.m_TotalLossSlider.setWidthAndHeight(this.bf.clientWidth); if (this.m_WinExceedsLimitSlider) this.m_WinExceedsLimitSlider.setWidthAndHeight(this.bf.clientWidth) } var maxSliderCaptionWidth = Math.max(this.m_LinesSlider.jE.clientWidth, this.m_CoinsSlider.jE.clientWidth); maxSliderCaptionWidth = Math.max(maxSliderCaptionWidth, this.m_CoinValueSlider.jE.clientWidth); if (maxSliderCaptionWidth > 0) { this.resizeSliderCaption(this.m_LinesSlider, maxSliderCaptionWidth); this.resizeSliderCaption(this.m_CoinsSlider, maxSliderCaptionWidth); this.resizeSliderCaption(this.m_CoinValueSlider, maxSliderCaptionWidth) } this.adjustBetInfo() }; BetView.prototype.getString = function (name) { return !Locale[name] ? "undefined" : Localizer.getInstance().getString(name) }; BetView.prototype.setTotalBet = function (totalBet) { this.m_BetCashValue.innerHTML = totalBet; this.adjustBetInfo() }; BetView.prototype.setTotalCoinBet = function (totalCoinBet) { this.m_BetCoinsValue.innerHTML = totalCoinBet; this.adjustBetInfo() }; BetView.prototype.setStopOnFreespins = function (value) { this.m_StopOnFreespins.setEnabled(value, true) }; BetView.prototype.setStopOnBonusGame = function (value) { this.m_StopOnBonusGame.setEnabled(value, true) }; BetView.prototype.setStopOnJackpot = function (value) { this.m_StopOnJackpot.setEnabled(value, true) }; BetView.prototype.updateBetSliders = function (data) { if (this.m_Initialized) if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_FIXED)) this.m_BetSlider.setValueIndex(data.denominationsIndex - 1); else { this.m_CoinValueSlider.setValueIndex(data.denominationsIndex - 1); this.m_CoinsSlider.setValueIndex(data.coinsIndex - 1); this.m_LinesSlider.setValueIndex(data.linesIndex - 1) } }; BetView.prototype.updateLines = function (value) { this.m_BetCallback(2, value) }; BetView.prototype.updateCoins = function (value) { this.m_BetCallback(1, value) }; BetView.prototype.updateCoinValue = function (value) { this.m_BetCallback(0, value) }; BetView.prototype.setBetData = function (data) { var denomArray = []; var coinsArray = []; var linesArray = []; var i; for (i = 0; i < data.coins; i++) coinsArray.push(i + 1); for (i = 0; i < data.lines; i++) linesArray.push(i + 1); for (i = 0; i < data.denominations.length; i++) denomArray.push((data.denominations[i] / 100).toFixed(2)); var initDenominationIndex = data.denominations.indexOf(data.initDenomination); if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_FIXED)) this.setFixedBetData(data.denominations, coinsArray, linesArray, initDenominationIndex, data.initCoin); else this.setNormalBetData(denomArray, coinsArray, linesArray, initDenominationIndex, data.initCoin, data.initLine); this.m_Initialized = true }; BetView.prototype.setNormalBetData = function (denominations, coins, lines, initDenominationIndex, initCoin, initLine) { var denomArray = []; for (var i = 0; i < denominations.length; i++) { var denom = Utils.NumberToMoney(Number(denominations[i])); denomArray.push(Utils.MoneyToString(denom, NO_CURRENCY)) } this.m_DefaultDenominations = denomArray.slice(); this.m_CoinValueSlider.setValueArray(denomArray); this.m_CoinValueSlider.setValueIndex(initDenominationIndex); this.m_CoinsSlider.setValueArray(coins); this.m_CoinsSlider.setValue(initCoin); this.m_LinesSlider.setValueArray(lines); this.m_LinesSlider.setValue(initLine) }; BetView.prototype.setFixedBetData = function (denominations, coins, lines, initDenominationIndex, initCoin) { var coinsPerLine = initCoin; var numLines = lines[lines.length - 1]; var denomArray = []; for (var i = 0; i < denominations.length; i++) denomArray.push(Utils.MoneyToString(denominations[i] * coinsPerLine * numLines, NO_CURRENCY)); this.m_DefaultDenominations = denomArray.slice(); this.m_BetSlider.setValueArray(denomArray); this.m_BetSlider.setValueIndex(initDenominationIndex); this.updateCoins(coinsPerLine); this.updateLines(lines.length) }; BetView.prototype.setAutoPlayData = function (data) { this.mr = data.spinsArray; this.m_SpinsDefault = data.initSpins - 1; if (this.m_AutoplayReset) { if (this.mr.length > 0 && this.mr[0] != 0) this.mr.unshift(0); this.m_SpinsDefault = 0 } this.m_AutoPlaySlider.setValueArray(this.mr); this.m_AutoPlaySlider.setValueIndex(this.m_SpinsDefault) }; BetView.prototype.setCurrency = function (currency) { this.cW = currency; this.m_CoinValueSlider.setCaption(this.getString("IDS_COINVALUE_CAPTION") + " (" + currency + ")"); this.m_BetSlider.setCaption(this.getString("IDS_BET_CAPTION") + " (" + currency + ")"); if (this.m_AutoplayLimits) { this.m_TotalLossSlider.setCaption(this.getString("IDS_AP_LOSSREACHES") + " (" + this.cW + ")"); this.m_WinExceedsLimitSlider.setCaption(this.getString("IDS_AP_WINEXCEEDS") + " (" + this.cW + ")") } this.setQuickBetValues(this.m_QuickBetValues) }; BetView.prototype.setCreditDisplayType = function () { if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_FIXED)) { this.m_NormalBet.style.display = "none"; this.m_FixedBet.style.display = "block" } else { this.m_NormalBet.style.display = "block"; this.m_FixedBet.style.display = "none" } }; BetView.prototype.disableAutoplayDlg = function () { this.m_AutoPlayButton.m_Root.classList.add("disabled"); this.m_StopAutoplayCaption.style.display = "none"; this.m_StopOnFreespins.getDOMNode().style.display = "none"; this.m_StopOnBonusGame.getDOMNode().style.display = "none"; this.m_StopOnJackpot.getDOMNode().style.display = "none"; this.m_AutoPlaySlider.setLockedMode(true); console.log(this.m_AutoPlayLimits); console.log(this.m_TotalLossSlider); console.log(this.m_WinExceedsLimitSlider); if (this.m_AutoplayLimits) { if (this.m_TotalLossSlider) this.m_TotalLossSlider.setLockedMode(true); if (this.m_WinExceedsLimitSlider) this.m_WinExceedsLimitSlider.setLockedMode(true) } this.m_AutoPlayEnabled = false }; BetView.prototype.enableAutoPlay = function (value, gambleMode) { if (this.m_DisableAutoplay) return; if (this.m_AutoplayReset) this.enableAutoplayIfOptionsAreValid(); else this.m_AutoPlayButton.m_Root.classList.remove("disabled"); if (value) { this.m_AutoPlaySlider.setLockedMode(false); if (this.m_AutoplayLimits) { if (this.m_TotalLossSlider) this.m_TotalLossSlider.setLockedMode(false); if (this.m_WinExceedsLimitSlider) this.m_WinExceedsLimitSlider.setLockedMode(false) } this.m_AutoPlayButton.setSpins(this.m_AutoPlaySlider.getCurrentValue()); this.m_AutoPlayButton.setAutoPlaying(false); if (!this.m_AutoPlayEnabled && this.m_AutoplayReset) this.resetLimitSettings() } else { this.m_AutoPlaySlider.setLockedMode(true); if (this.m_AutoplayLimits) { if (this.m_TotalLossSlider) this.m_TotalLossSlider.setLockedMode(true); if (this.m_WinExceedsLimitSlider) this.m_WinExceedsLimitSlider.setLockedMode(true) } if (!gambleMode) this.m_AutoPlayButton.setAutoPlaying(true); else this.m_AutoPlayButton.m_Root.classList.add("disabled") } this.m_AutoPlayEnabled = value }; BetView.prototype.setQuickBetValues = function (values) { for (var i = 0; i < this.m_QuickBetButtons.length; i++) if (values && i < values.length) { this.m_QuickBetButtons[i].style.display = "block"; this.m_QuickBetButtons[i].innerHTML = Utils.MoneyToString(values[i]) } else this.m_QuickBetButtons[i].style.display = "none" }; BetView.prototype.disableBets = function (disable) { for (var i = 0; i < this.m_QuickBetButtons.length; i++) this.m_QuickBetButtons[i].disabled = disable; this.m_BetSlider.setLockedMode(disable); this.m_CoinsSlider.setLockedMode(disable); this.m_CoinValueSlider.setLockedMode(disable); this.m_LinesSlider.setLockedMode(disable) }; BetView.prototype.setAutoPlaySpins = function (spins) { if (!this.m_AutoPlayEnabled) this.m_AutoPlayButton.setSpins(spins) }; BetView.prototype.adjustBetInfo = function () { var width = this.m_BetInfo.clientWidth; this.m_BetInfo.style.msTransform = ""; this.m_BetInfo.style.webkitTransform = ""; this.m_BetInfo.style.transform = ""; if (width > this.m_FirstHalf.clientWidth) { var scale = this.m_FirstHalf.clientWidth / width; this.m_BetInfo.style.msTransform = "scale(" + scale + ", " + scale + ")"; this.m_BetInfo.style.webkitTransform = "scale(" + scale + ", " + scale + ")"; this.m_BetInfo.style.transform = "scale(" + scale + ", " + scale + ")" } }; BetView.prototype.showJackpot = function () { if (!this.m_DisableAutoplay) this.m_StopOnJackpot.getDOMNode().style.display = ""; if (this.m_AutoplayLimits) this.showLimits() }; BetView.prototype.showLimits = function () { var dataArray = BetView.TotalLossData; var formattedDataArray = []; for (var i = 0; i < dataArray.length; i++) formattedDataArray.push(Utils.MoneyToString(dataArray[i])); if (this.m_WinExceedsLimitSlider === undefined) { this.m_WinExceedsLimitSlider = this.createSlider(undefined, this.getString("IDS_AP_WINEXCEEDS"), formattedDataArray, "0px", "10px", false); this.m_WinExceedsLimitSlider.setCallback(Utils.delegate(this, this.onWinLimitSliderEvent)); this.m_WinExceedsLimitSlider.setValue(Utils.MoneyToString(0, NO_CURRENCY)) } if (this.m_TotalLossSlider === undefined) { this.m_TotalLossSlider = this.createSlider(undefined, this.getString("IDS_AP_LOSSREACHES"), formattedDataArray, "0px", "10px"); this.m_TotalLossSlider.setCallback(Utils.delegate(this, this.onTotalLossSliderEvent)); this.m_TotalLossSlider.setValue(Utils.MoneyToString(0, NO_CURRENCY)) } this.m_TotalLossSlider.setCaption(this.getString("IDS_AP_LOSSREACHES") + " (" + this.cW + ")"); this.m_WinExceedsLimitSlider.setCaption(this.getString("IDS_AP_WINEXCEEDS") + " (" + this.cW + ")"); this.bf.appendChild(this.m_WinExceedsLimitSlider.getDOMNode()); this.bf.appendChild(this.m_TotalLossSlider.getDOMNode()); this.bf.appendChild(this.m_StopOnFreespins.getDOMNode()); this.bf.appendChild(this.m_StopOnBonusGame.getDOMNode()); this.bf.appendChild(this.m_StopOnJackpot.getDOMNode()); if (this.m_AutoplayReset) this.resetLimitSettings(); if (this.m_DisableAutoplay) this.disableAutoplayDlg() }; BetView.prototype.enableAutoplayIfOptionsAreValid = function () { if (this.m_DisableAutoplay) return; if (this.m_AutoplayLimits) { var valid = this.m_VideoSlotSettings.GetBetAmountRaw() <= BetView.TotalLossData[this.m_TotalLossSlider.getCurrentValueIndex()] * this.hh; this.m_TotalLossSlider.setValid(valid) } var enabled = this.m_AutoplayReset; if (this.m_AutoplayLimits) enabled = enabled && this.m_TotalLossSlider.isValid(); enabled = enabled && this.m_AutoPlaySlider.getCurrentValue() > 0; if (enabled) this.m_AutoPlayButton.m_Root.classList.remove("disabled"); else this.m_AutoPlayButton.m_Root.classList.add("disabled") }; BetView.prototype.resetLimitSettings = function () { if (this.m_AutoplayLimits) { this.m_TotalLossSlider.setValue(Utils.MoneyToString(0, NO_CURRENCY)); this.m_TotalLossSlider.setValid(false) } this.m_AutoPlaySlider.setValue(0); this.m_AutoPlaySlider.setValid(false); this.enableAutoplayIfOptionsAreValid() }; BetView.prototype.setAutoPlayLimitSettings = function (settings) { for (var k in settings) switch (k) { case "autoplayreset": this.m_AutoplayReset = settings[k]; break; case "autoplaylimits": this.m_AutoplayLimits = settings[k]; break } if (this.m_AutoplayLimits) this.showLimits(); if (this.m_AutoplayReset) this.resetLimitSettings() }; BetView.prototype.setDenominationMultiplier = function (denominationMultiplier) { this.hh = denominationMultiplier; if (this.m_AutoplayLimits) { this.m_TotalLossSlider.setCaption(this.getString("IDS_AP_LOSSREACHES") + " (" + this.cW + ")"); this.m_WinExceedsLimitSlider.setCaption(this.getString("IDS_AP_WINEXCEEDS") + " (" + this.cW + ")"); var formattedDataArray = []; for (var i = 0; i < BetView.TotalLossData.length; i++) formattedDataArray.push(Utils.MoneyToString(BetView.TotalLossData[i] * this.hh, NO_CURRENCY)); this.m_TotalLossSlider.setValueArray(formattedDataArray); this.m_WinExceedsLimitSlider.setValueArray(formattedDataArray) } }; BetView.prototype.AddTemporaryDenomination = function (denom, bet, lines) { var slider; var value; if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_FIXED)) { slider = this.m_BetSlider; value = Utils.MoneyToString(denom * bet * lines, NO_CURRENCY) } else { slider = this.m_CoinValueSlider; value = Utils.MoneyToString(denom, NO_CURRENCY) } var arr = slider.m_ValueArray; arr.push(value); arr.sort(function (a, b) { return Utils.StringToMoneyRegexp(a) - Utils.StringToMoneyRegexp(b) }); slider.setValueArray(arr) }; BetView.prototype.RemoveTemporaryDenominations = function () { var slider; if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_FIXED)) slider = this.m_BetSlider; else slider = this.m_CoinValueSlider; var arr = slider.m_ValueArray; for (var i = 0; i < arr.length; i++) { var value = arr[i]; var index = this.m_DefaultDenominations.indexOf(value); if (index == -1) arr.splice(i, 1) } slider.setValueArray(arr) }; SettingsView.SOUND = 0; SettingsView.AUTO_ADJUST = 1; SettingsView.LEFT_HAND_MODE = 2; SettingsView.FAST_PLAY = 3; function SettingsView(callback, fastPlayEnabled) { this._super(Locale.IDS_BTN_SETTINGS); this.ao = callback; this.m_View = DOMHelper.createDiv("settingsview"); this.m_Checkboxes = []; this.m_Checkboxes[SettingsView.SOUND] = this.createCheckbox(Utils.delegate(this, this.onSound), Localizer.getInstance().getString("IDS_M_SETTINGS_L1"), this.m_View, "settingsIconSound"); this.m_Checkboxes[SettingsView.AUTO_ADJUST] = this.createCheckbox(Utils.delegate(this, this.onAutoAdjustBet), Localizer.getInstance().getString("IDS_M_SETTINGS_L9"), this.m_View, "settingsIconAutoAdjustBet"); this.m_Checkboxes[SettingsView.LEFT_HAND_MODE] = this.createCheckbox(Utils.delegate(this, this.onLeftHandMode), Localizer.getInstance().getString("IDS_M_SETTINGS_L14"), this.m_View, "settingsIconLeftHand"); if (fastPlayEnabled) this.m_Checkboxes[SettingsView.FAST_PLAY] = this.createCheckbox(Utils.delegate(this, this.onFastPlay), Localizer.getInstance().getString("IDS_M_SETTINGS_L12"), this.m_View, "settingsIconFastPlay"); this.m_SkipCallback = [false, false, false, false] } Classify.constr(SettingsView).ext(MenuItem); SettingsView.prototype.createCheckbox = function (callback, caption, parent, icon) { var checkbox = new CheckboxControl(callback, caption, icon); checkbox.getDOMNode().classList.add("settingsview_checkbox"); checkbox.getDOMNode().style.position = ""; parent.appendChild(checkbox.getDOMNode()); return checkbox }; SettingsView.prototype.onSound = function (event) { if (!this.m_SkipCallback[SettingsView.SOUND]) this.ao(SettingsView.SOUND); this.m_SkipCallback[SettingsView.SOUND] = false }; SettingsView.prototype.onAutoAdjustBet = function (event) { if (!this.m_SkipCallback[SettingsView.AUTO_ADJUST]) this.ao(SettingsView.AUTO_ADJUST); this.m_SkipCallback[SettingsView.AUTO_ADJUST] = false }; SettingsView.prototype.onLeftHandMode = function (event) { if (!this.m_SkipCallback[SettingsView.LEFT_HAND_MODE]) this.ao(SettingsView.LEFT_HAND_MODE); this.m_SkipCallback[SettingsView.LEFT_HAND_MODE] = false }; SettingsView.prototype.onFastPlay = function (event) { if (!this.m_SkipCallback[SettingsView.FAST_PLAY]) this.ao(SettingsView.FAST_PLAY); this.m_SkipCallback[SettingsView.FAST_PLAY] = false }; SettingsView.prototype.CheckSettings = function (id, state) { if (state == "disabled") this.m_Checkboxes[id].setEnabled(state); else { if (this.m_Checkboxes[id].getEnabled() !== state) this.m_SkipCallback[id] = true; this.m_Checkboxes[id].setEnabled(state) } }; SettingsView.prototype.handleOrientationChange = function (event) { var i; var checkBoxWidth = this.m_View.clientWidth; for (i = 0; i < this.m_Checkboxes.length; i++) this.m_Checkboxes[i].setWidth(checkBoxWidth * 0.9) }; SettingsView.prototype.showSetting = function (id, b) { if (b) this.m_Checkboxes[id].getDOMNode().style.display = ""; else this.m_Checkboxes[id].getDOMNode().style.display = "none" }; function CashierView(callback) { this._super(pt_cashier_btn_cap); this.ao = callback; this.m_View = DOMHelper.createDiv("cashierview"); this.m_View.appendChild(this.createButton()) } Classify.constr(CashierView).ext(MenuItem); CashierView.prototype.createButton = function () { var button = DOMHelper.createDiv("cashier_button", "cashierview_button"); button.innerHTML = pt_cashier_btn_cap; button.onclick = this.ao; return button }; function GameHistoryView() { this.m_StartEvent = "mousedown"; this.m_EndEvent = "mouseup"; this.m_MoveEvent = "mousemove"; this.m_IsTouchDevice = "ontouchstart" in window; if (this.m_IsTouchDevice) { this.m_StartEvent = "touchstart"; this.m_EndEvent = "touchend"; this.m_MoveEvent = "touchmove" } this._super(Localizer.getInstance().getString("IDS_BTN_GAMEHISTORY")); this.m_View = DOMHelper.createDiv("gamehistoryview"); this.gameHistoryOverlay = DOMHelper.createAndAppendDiv(this.m_View, "gamehistoryoverlay"); this.m_DetailsView = DOMHelper.createAndAppendDiv(this.m_View, "detailsview"); this.m_DetailsView.style.display = "none"; this.m_CloseDetailsViewButton = DOMHelper.createImageFromSpriteSheet(undefined, "closedetails", undefined, image_path_htmlui + "uiElements.png", uiElements.closeBtn); this.m_CloseDetailsViewButton.addEventListener(this.m_EndEvent, Utils.delegate(this, this.closeDetailsView), false); this.m_Content; this.m_CloseDetailsViewDelegate = Utils.delegate(this, this.closeDetailsView) } Classify.constr(GameHistoryView).ext(MenuItem); GameHistoryView.override("onFocusIn", function () { this.m_StatsTimeOut = setTimeout(function () { StatsHandler.HandleEvent("showhistory") }, 3E3) }); GameHistoryView.override("onFocusOut", function () { clearTimeout(this.m_StatsTimeOut) }); GameHistoryView.prototype.loadPage = function (url) { url += "&nocache=" + (new Date).getTime(); var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.setRequestHeader("Expires", "0"); xhr.addEventListener("readystatechange", Utils.delegate(this, this.onReadyStateChange)); xhr.addEventListener("error", Utils.delegate(this, this.onError)); xhr.responseType = "document"; xhr.send() }; GameHistoryView.prototype.onReadyStateChange = function (event) { var xhr = event.target; if (xhr.readyState === 4 && xhr.status === 200 && !this.m_Content) this.createContentDiv(xhr.response.body) }; GameHistoryView.prototype.onError = function (event) { console.log("onError: ", event) }; GameHistoryView.prototype.createContentDiv = function (contents) { this.addDetailsButton(contents); this.m_Content = DOMHelper.createDiv(); this.m_Content.innerHTML = contents.innerHTML; this.m_View.appendChild(this.m_Content); this.m_RoundHistoryElement = this.m_Content.getElementsByClassName("roundhistory")[0]; this.m_RoundHistoryElement.style.width = document.getElementById("gamehistoryview").clientWidth * 0.95 + "px"; var headerWrapper = this.m_RoundHistoryElement.getElementsByClassName("header")[0]; var headerList = headerWrapper.getElementsByTagName("th"); headerList[headerList.length - 1].innerHTML = Localizer.getInstance().getString("IDS_DETAILS_CAPTION"); var trList = this.m_RoundHistoryElement.getElementsByTagName("tr"); for (var i = 1; i < trList.length; i++) { trList[i].addEventListener(this.m_StartEvent, Utils.delegate(this, this.checkElementClickedOnTouchStart)); trList[i].addEventListener(this.m_EndEvent, Utils.delegate(this, this.checkElementClickedOnTouchEnd)) } }; GameHistoryView.prototype.checkElementClickedOnTouchStart = function (e) { this.clickedElement = this.m_IsTouchDevice ? e.touches[0].pageY : e.y }; GameHistoryView.prototype.checkElementClickedOnTouchEnd = function (e) { this.clickedElementEnd = this.m_IsTouchDevice ? e.changedTouches[0].pageY : e.y; if (this.clickedElement + 20 < this.clickedElementEnd && !(this.clickedElement - 20 < this.clickedElementEnd) || !(this.clickedElement + 20 < this.clickedElementEnd) && this.clickedElement - 20 < this.clickedElementEnd) { var regExp = /\(([^)]+)\)/; var hrefString = e.target.parentElement.lastElementChild.children[0].href; var matches = regExp.exec(hrefString); this.opendetails(matches[1]) } this.clickedElement = "" }; GameHistoryView.prototype.addDetailsButton = function (contents) { var i, elements = []; var nodeList = contents.getElementsByTagName("a"); for (i = 0; i < nodeList.length; i++) { nodeList[i].innerHTML = ""; nodeList[i].style.pointerEvents = "none"; var detailsImage = DOMHelper.createImageFromSpriteSheet(undefined, "detailsButton", undefined, image_path_htmlui + "uiElements.png", uiElements.plusBtn); nodeList[i].appendChild(detailsImage) } }; GameHistoryView.prototype.stripElementsByTagName = function (parent, tag) { var i, elements = []; var nodeList = parent.getElementsByTagName(tag); for (i = 0; i < nodeList.length; i++) elements.push(nodeList[i]); for (i = 0; i < elements.length; i++) elements[i].parentNode.removeChild(elements[i]) }; GameHistoryView.prototype.opendetails = function (rid) { var url = gamehistoryview.detailspath + rid + "?lang=" + G.R.O.aB.language; this.loadDetails(decodeURIComponent(url)) }; GameHistoryView.prototype.loadDetails = function (url) { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.addEventListener("readystatechange", Utils.delegate(this, this.onReadyStateChangeDetails)); xhr.addEventListener("error", Utils.delegate(this, this.onError)); xhr.responseType = "document"; xhr.send() }; GameHistoryView.prototype.onReadyStateChangeDetails = function (event) { var xhr = event.target; if (xhr.readyState === 4 && xhr.status === 200) this.createDetailsWindow(xhr.response.body) }; GameHistoryView.prototype.createDetailsWindow = function (response) { this.stripElementsByTagName(response, "a"); this.m_DetailsView.innerHTML = response.innerHTML; this.m_DetailsView.appendChild(this.m_CloseDetailsViewButton); this.rearrangeTableElements(); this.m_DetailsView.style.display = "inline-block"; this.m_DetailsView.style.left = this.m_View.clientWidth / 2 - this.m_DetailsView.clientWidth / 2 + "px"; this.roundHistoryDiv = document.getElementsByClassName("roundhistory")[0]; this.m_View.style.height = this.roundHistoryDiv.clientHeight * 1.1 + "px"; this.gameHistoryOverlay.classList.add("dimmed"); this.m_View.classList.add("dimmed"); this.gameHistoryOverlay.addEventListener(this.m_StartEvent, this.m_CloseDetailsViewDelegate) }; GameHistoryView.prototype.closeDetailsView = function () { this.m_DetailsView.style.display = "none"; this.gameHistoryOverlay.classList.remove("dimmed"); if (this.roundhistoryDiv) this.m_View.style.height = this.roundHistoryDiv.clientHeight * 1.1 + "px"; this.m_View.classList.remove("dimmed"); this.gameHistoryOverlay.removeEventListener(this.m_StartEvent, this.m_CloseDetailsViewDelegate) }; GameHistoryView.prototype.rearrangeTableElements = function () { var roundDetailsTableParent = this.m_DetailsView.getElementsByTagName("tbody")[0]; var roundDetailsTableElements = roundDetailsTableParent.getElementsByTagName("tr"); var loopLength = roundDetailsTableElements.length; if (DEVICE.orientation == "ls") roundDetailsTableElements[0].style.width = document.body.clientWidth * 0.367 + "px"; else roundDetailsTableElements[0].style.width = document.body.clientWidth * 0.613 + "px"; for (i = 0; i < loopLength; i++) { var trElement = document.createElement("tr"); trElement.insertBefore(roundDetailsTableElements[i].lastChild, trElement.childNodes[0]); trElement.insertBefore(roundDetailsTableElements[i].lastChild, trElement.childNodes[0]); roundDetailsTableParent.appendChild(trElement) } }; GameHistoryView.prototype.handleOrientationChange = function (event) { this.gameHistoryOverlay.style.height = document.getElementById("menu_view_area").style.height; if (this.m_RoundHistoryElement) this.m_RoundHistoryElement.style.width = document.getElementById("gamehistoryview").clientWidth * 0.95 + "px"; DOMHelper.setStyle(this.m_View, DEVICE.orientation); this.m_DetailsView.style.top = document.getElementById("menu_header").clientHeight * 1.1 + "px"; this.m_DetailsView.style.left = this.m_View.clientWidth / 2 - this.m_DetailsView.clientWidth / 2 + "px" }; GameHistoryView.prototype.onFocusOut = function () { this.closeDetailsView(); if (this.m_Content) { this.m_View.removeChild(this.m_Content); this.m_Content = "" } }; GameHistoryView.prototype.onFocusIn = function () { if (this.m_Content) { this.m_View.removeChild(this.m_Content); this.m_Content = "" } this.loadPage(decodeURIComponent(G.R.O.en) + "&method=open") }; function VideoSlotMenu(gameName, gbpointer, cwbcb, cwscb, cwapcb, cwapcbstart, cwapcbstop, cwptgrcb, ghcb, cashcb, autoplaysettings, videoslotsettings) { this.ns = gbpointer; this.aq = new Menu(gameName); var disable = false; if (this.ns.aB.disableautoplay && this.ns.aB.disableautoplay == 1) disable = true; this.m_BetView = new BetView(cwbcb, cwapcb, cwapcbstart, cwapcbstop, gbpointer.m_QuickBetValues, autoplaysettings, videoslotsettings, disable); this.m_SettingsView = new SettingsView(cwscb); this.qu = new Paytable; this.m_GameHistoryView = new GameHistoryView(ghcb); this.m_CashierView = new CashierView(cashcb); this.aq.addMenuItem(this.m_BetView); this.aq.addMenuItem(this.m_SettingsView); this.aq.addMenuItem(this.qu); if (this.ns.ha !== "") { this.m_GameRulesView = new GameRulesView(this.ns.ha); this.aq.addMenuItem(this.m_GameRulesView) } if (this.ns.en !== "") this.aq.addMenuItem(this.m_GameHistoryView); if (this.ns.eg !== "") if (this.ns.m_PracticeMode) this.aq.addMenuItem(new MenuItem(Localizer.getInstance().getString("IDS_PLAYFORREAL"), "#00ff00")); else this.aq.addMenuItem(this.m_CashierView); this.dQ; this.pZ = cwbcb; this.fv; this.qe = cwscb; this.pW = cwapcb; this.pG = cwapcbstart; this.pN = cwapcbstop; this.mI = cwptgrcb; this.qk = ghcb; this.ou = cashcb; this.Show(false); this.dB = false; this.cN = { ik: { Enable2: function () { } } } } VideoSlotMenu.prototype.constructor = VideoSlotMenu; VideoSlotMenu.prototype.setCurrency = function (currency) { this.m_BetView.setCurrency(currency) }; VideoSlotMenu.prototype.Ticker = function (time) { }; VideoSlotMenu.prototype.SetBetDlgSpinnerData = function (data) { this.m_BetView.setBetData(data) }; VideoSlotMenu.prototype.SetBetDlgBetData = function (data, spinner) { this.m_BetView.setTotalBet(data.totBet); this.m_BetView.setTotalCoinBet(data.totCoinBet); if (spinner) this.m_BetView.updateBetSliders(data) }; VideoSlotMenu.prototype.SetSettingsStates = function (id, state) { this.m_SettingsView.CheckSettings(id, state) }; VideoSlotMenu.prototype.SetAutoPlayStates = function (autoplayState) { this.m_BetView.setStopOnFreespins(autoplayState.freeSpinWin); this.m_BetView.setStopOnBonusGame(autoplayState.bonusGameWin); this.m_BetView.setStopOnJackpot(autoplayState.jackpotWin) }; VideoSlotMenu.prototype.SetAutoPlayDlgSpinnerData = function (data) { this.m_BetView.setAutoPlayData(data) }; VideoSlotMenu.prototype.SetAutoPlayLimitSettings = function (settings) { this.m_BetView.setAutoPlayLimitSettings(settings) }; VideoSlotMenu.prototype.Show = function (b) { this.aq.Show(b); this.SetIsShowing(b) }; VideoSlotMenu.prototype.LockBetSpinners = function (b) { this.dB = b }; VideoSlotMenu.prototype.DisableAllBetSpinners = function (b, noAPUpdate) { if (this.dB && b) return; this.m_BetView.disableBets(b) }; VideoSlotMenu.prototype.EnableAutoPlayDlg = function (b, gamblemode) { this.m_BetView.enableAutoPlay(b, gamblemode) }; VideoSlotMenu.prototype.GetIsShowing = function () { return this.aq.GetIsShowing() }; VideoSlotMenu.prototype.SetIsShowing = function (value) { return this.aq.SetIsShowing(value) }; VideoSlotMenu.prototype.HandleOrientationChange = function (portrait) { this.aq.HandleOrientationChange(portrait) }; VideoSlotMenu.prototype.ReconnectEnd = function () { this.aq && this.aq.reconnectEnd && this.aq.reconnectEnd() }; VideoSlotMenu.prototype.getPaytable = function () { return this.qu }; VideoSlotMenu.prototype.setAutoPlaySpins = function (spins) { this.m_BetView.setAutoPlaySpins(spins) }; VideoSlotMenu.prototype.showSetting = function (id, show) { this.m_SettingsView.showSetting(id, show) }; VideoSlotMenu.prototype.SetDenominationMultiplier = function (denominationMultiplier) { this.m_BetView.setDenominationMultiplier(denominationMultiplier) }; VideoSlotMenu.prototype.AddTemporaryDenomination = function (denom, bet, lines) { this.m_BetView.AddTemporaryDenomination(denom, bet, lines) }; VideoSlotMenu.prototype.RemoveTemporaryDenominations = function () { this.m_BetView.RemoveTemporaryDenominations() }; function AutoPlayForceDialog(parentDiv, autoplaysettings) { this.dw = autoplaysettings; if (gameRes > 320) { this.m_AutoplayBase = DOMHelper.createAndAppendDiv(parentDiv, undefined, "spinbtn_autoplaymenu_base"); this.m_AutoPlaySlider = this.createSlider(Utils.delegate(this, this.onAutoPlaySliderEvent), Locale.IDS_AP_CAPTION2, [0, 1]); this.m_AutoPlaySlider.getDOMNode().style.top = betview.apslider_top + "px"; this.m_AutoPlaySlider.jE.style.display = "none"; this.m_AutoPlaySlider.setWidthAndHeight(400); this.m_AutoplaySliderCaption = DOMHelper.createAndAppendDiv(this.m_AutoplayBase, undefined, "spinbtn_autoplaymenu_caption"); DOMHelper.setText(this.m_AutoplaySliderCaption, Locale.IDS_AP_CAPTION2); this.m_AutoSliderContainer = DOMHelper.createAndAppendDiv(this.m_AutoplayBase, undefined, "spinbtn_autoplaymenu_container"); this.m_AutoSliderContainer.appendChild(this.m_AutoPlaySlider.getDOMNode()) } this.m_AutoPlayVisible = false; this.m_bAutoPlayIsStarting = false; this.m_bAutoPlayIsRunning = false; this.m_ClickedToOpenAPMenu = false; this.m_LastAutoplayIndex = 2 } AutoPlayForceDialog.prototype.constructor = AutoPlayForceDialog; AutoPlayForceDialog.prototype.createSlider = function (callback, caption, values) { var slider = new SliderControl(callback, values); slider.getDOMNode().style.fontSize = betview.slider_fontsize + "px"; slider.getDOMNode().style.position = "relative"; slider.getDOMNode().style.top = "0px"; slider.getDOMNode().style.left = "0px"; slider.setCaption(caption); return slider }; AutoPlayForceDialog.prototype.onAutoPlaySliderEvent = function (e) { if (this.m_AutoplayVisible) { this.dw.SetSpins(e.value); this.m_LastAutoplayIndex = e.index } }; AutoPlayForceDialog.prototype.hide = function () { if (gameRes > 320) { this.m_AutoplayBase.classList.remove("fadeInSpinAutoplay"); this.m_AutoplayBase.classList.add("fadeOutSpinAutoplay"); this.m_AutoplayBase.style.visibility = "hidden"; this.m_AutoplayVisible = false; this.m_bAutoPlayIsStarting = false } }; AutoPlayForceDialog.prototype.show = function () { if (gameRes > 320) { if (this.m_AutoplayVisible) return; document.getElementById("spinbutton_container").classList.remove("zoomSpinButtonDown"); document.getElementById("spinbutton_container").classList.add("zoomSpinButtonUp"); this.m_AutoplayVisible = true; this.m_bAutoPlayIsStarting = true; this.m_ClickedToOpenAPMenu = true; this.m_AutoPlaySlider.setValueArray(this.dw.GetSpinsArray()); this.m_AutoPlaySlider.setValueIndex(this.m_LastAutoplayIndex); this.m_AutoplayBase.classList.remove("fadeOutSpinAutoplay"); this.m_AutoplayBase.classList.add("fadeInSpinAutoplay") } }; AutoPlayForceDialog.prototype.setLeftHandMode = function (bLeftHandMode) { if (gameRes > 320) if (bLeftHandMode) { DOMHelper.setStyle(this.m_AutoplayBase, "spinbtn_autoplaymenu_base_lefthandmode"); DOMHelper.setStyle(this.m_AutoSliderContainer, "spinbtn_autoplaymenu_container_lefthandmode"); DOMHelper.setStyle(this.m_AutoplaySliderCaption, "spinbtn_autoplaymenu_caption_lefthandmode"); if (this.m_AutoplayVisible == false) { this.m_AutoplayBase.classList.remove("fadeInSpinAutoplay"); this.m_AutoplayBase.classList.add("fadeOutSpinAutoplay") } } else { DOMHelper.setStyle(this.m_AutoplayBase, "spinbtn_autoplaymenu_base"); DOMHelper.setStyle(this.m_AutoSliderContainer, "spinbtn_autoplaymenu_container"); DOMHelper.setStyle(this.m_AutoplaySliderCaption, "spinbtn_autoplaymenu_caption"); if (this.m_AutoplayVisible == false) { this.m_AutoplayBase.classList.remove("fadeInSpinAutoplay"); this.m_AutoplayBase.classList.add("fadeOutSpinAutoplay") } } }; Context = { blur: new Signal, focus: new Signal, addSignals: function () { var IsWebView = function () { var standalone = window.navigator.standalone, userAgent = window.navigator.userAgent.toLowerCase(), safari = /safari/.test(userAgent), ios = /iphone|ipod|ipad/.test(userAgent); return ios && !standalone && !safari }; if (!IsWebView()) (function () { var hidden = "hidden"; if (hidden in document) document.addEventListener("visibilitychange", onchange); else if ((hidden = "mozHidden") in document) document.addEventListener("mozvisibilitychange", onchange); else if ((hidden = "webkitHidden") in document) document.addEventListener("webkitvisibilitychange", onchange); else if ((hidden = "msHidden") in document) document.addEventListener("msvisibilitychange", onchange); else if ("onfocusin" in document) document.onfocusin = document.onfocusout = onchange; else window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange; var v = "visible"; var h = "hidden"; var evtMap = { focus: v, focusin: v, pageshow: v, blur: h, focusout: h, pagehide: h }; function onchange(evt) { var type = "unknown"; evt = evt || window.event; if (evt.type in evtMap) type = evtMap[evt.type]; else type = this[hidden] ? h : v; if (type === h) Context.blur.fire(); else Context.focus.fire() } })() } }; function SplashScreenHandler(gameId, continuecb) { if (this.constructor !== arguments.callee) return new SplashScreenHandler(gameId); this.sl = gameId; this.hn = false; this.ql = continuecb } SplashScreenHandler.prototype.constructor = SplashScreenHandler; SplashScreenHandler.ReadCookie = function (gameid) { var idString = "splashcheckboxcookie_" + gameid; var cookieValue = null; var getcookie = document.cookie.match("(^|;) ?" + idString + "=([^;]*)(;|$)"); if (getcookie) cookieValue = Str.Unescape(getcookie[2]); var cookieValid = getcookie && cookieValue == "1"; return cookieValid }; SplashScreenHandler.prototype.SaveCookie = function () { var amountOfDays = 1E3; var date = new Date; date.setTime(date.getTime() + amountOfDays * 24 * 60 * 60 * 1E3); var expires = "; expires=" + date.toGMTString(); var idString = "splashcheckboxcookie_" + this.sl; document.cookie = idString + "=1" + expires + "; path=/" }; SplashScreenHandler.prototype.Show = function (b) { }; SplashScreenHandler.prototype.ToggleSaveCookie = function () { this.hn = !this.hn }; SplashScreenHandler.prototype.OnContinue = function () { if (this.hn) this.SaveCookie(); this.Show(false); this.RemoveSplashFromDOM() }; SplashScreenHandler.prototype.RemoveSplashFromDOM = function () { if (sjs.isPixi) { var layers = [sjs.layers["splashscreen"], sjs.layers["gpcoveri"], sjs.layers["gpcoverb"]]; layers[0].view.parent.removeChild(layers[0].view); layers[1].view.parent.removeChild(layers[1].view); layers[2].view.parent.removeChild(layers[2].view) } else { var layers = [document.getElementById("splashscreen"), document.getElementById("gpcoveri"), document.getElementById("gpcoverb")]; layers[0].parentElement.removeChild(layers[0]); layers[1].parentElement.removeChild(layers[1]); layers[2].parentElement.removeChild(layers[2]) } this.ql() }; function SplashScreen(gameId, removecb) { if (this.constructor !== arguments.callee) return new SplashScreen(gameId, removecb); var handler = new SplashScreenHandler(gameId, removecb); handler.K = sjs.layers["splashscreen"]; handler.dX = sjs.layers["splashscreencontainer"]; handler.L = splashscreen_pos; this.pD = new sjs.Layer("gpcoveri", undefined, sjs.layers["gamepanellayer"], undefined, handler.L.content.gpicover); this.nM = new sjs.Solid("#000000", this.pD, handler.L.content.gpicover); this.nM.opacity = 0.5; this.nM.update(); this.rd = new sjs.Layer("gpcoverb", undefined, sjs.layers["gpbuttons"], undefined, handler.L.content.gpbcover); this.pa = new sjs.Solid("#000000", this.rd, handler.L.content.gpbcover); this.pa.opacity = 0.7; this.pa.update(); new Button(handler.K, handler.L.content.background, function () { }); handler.HandleOrientationChange = SplashScreen.prototype.HandleOrientationChange; handler.Show = SplashScreen.prototype.Show; handler.ToggleSaveCookie = SplashScreen.prototype.ToggleSaveCookie; handler.StartAnimations = SplashScreen.prototype.StartAnimations; this.CreateContent(handler); this.CreateButtons(handler); return handler } SplashScreen.prototype.constructor = SplashScreen; SplashScreen.prototype.ToggleSaveCookie = function () { this.hn = !this.hn; this.oj.Checked(this.hn) }; SplashScreen.prototype.CreateButtons = function (handler) { handler.qw = new Button(handler.dX, handler.L.content.continue_btn, Utils.delegate(handler, handler.OnContinue), image_path_game + "splashscreen.png", Locale.IDS_BTN_CONTINUE, undefined, "splash_continue_btn_cap"); handler.qw.H.setBounds(handler.L.content.continue_btn.sprite); handler.oj = new Button(handler.dX, handler.L.content.checkbox.btn, Utils.delegate(handler, handler.ToggleSaveCookie), image_path_game + "splashscreen.png", undefined, ""); handler.oj.H.setBounds(handler.L.content.checkbox.btn); handler.m_checkboxCaption = new Button(handler.dX, handler.L.content.checkbox.textfield, Utils.delegate(handler, handler.ToggleSaveCookie), undefined, Locale.IDS_DONTSHOWAGAIN, undefined, "splash_checkbox_cap", true) }; SplashScreen.prototype.CreateContent = function (handler) { new sjs.Solid("#333333", handler.dX, handler.L.content.template_solid) }; SplashScreen.prototype.StartAnimations = function (handler) { }; SplashScreen.prototype.Show = function (b) { this.K.Show(b); this.dX.Show(b) }; SplashScreen.prototype.HandleOrientationChange = function () { sjs.layers["splashscreen"].Scale(scale_layer_pos[DEVICE.orientation].scale, scale_layer_pos[DEVICE.orientation].scale); sjs.layers["splashscreen"].setBounds(scale_layer_pos[DEVICE.orientation]); if (DEVICE.orientation == "ls") sjs.layers["splashscreen"].Origin("center", "78.813559322033898305084745762712%"); else sjs.layers["splashscreen"].Origin("center", "bottom") }; function GambleCard(pos, layer, initData) { this.m_CompleteCallback; this.K = layer; this.L = pos; this.m_CardBack; this.m_CardFace; this.m_FrameCount = 0; this.m_RunAnim = false; this.m_Animating; this.m_CardIndex; this.aP; this.C; this.C = true; this.m_CardIndex = 0; this.aP = false; this.Init(initData) }; GambleCard.prototype.Init = function (initData) { this.m_CardBack = new sjs.Sprite(image_path_game + "gamble.png", this.K, undefined, this.L.pos); this.m_CardBack.yoffset = this.L.offset.yoffset; this.m_CardCycle = new sjs.Cycle(this.L.card_anim_cycle.card_anim_cycle); this.m_CardCycle.sprites = [this.m_CardBack]; this.m_CardCycle.repeat = false; var cardImage = "vp_cards.png"; if (gamble.gamble_card.gambleCardImage) cardImage = gamble.gamble_card.gambleCardImage; this.m_CardFace = new sjs.Sprite(image_path_cards + cardImage, this.K, undefined, this.L.pos); this.m_CardFace.xscale = 0 }; GambleCard.prototype.setCallback = function (func) { this.m_CompleteCallback = func }; GambleCard.prototype.getCardIndex = function () { return this.m_CardIndex }; GambleCard.prototype.getVisible = function () { return this.aP }; GambleCard.prototype.ReconnectEnd = function () { this.C = false }; GambleCard.prototype.onComplete = function (e) { this.m_CompleteCallback() }; GambleCard.prototype.Ticker = function () { if (this.m_Animating == 1 && this.m_RunAnim) { if (this.m_FrameCount < 3) { this.m_CardCycle.next(); this.m_CardCycle.sprites[0].update() } else if (this.m_FrameCount > 2 && this.m_FrameCount < 6) { if (this.m_FrameCount == 3) { this.m_CardCycle.sprites[0].Visible(false); this.m_CardCycle.sprites[0].update(); this.m_CardFace.Visible(true) } this.m_CardFace.xscale = this.L.face_scale_cycle[this.m_FrameCount - 3]; this.m_CardFace.update() } if (this.m_FrameCount > 4) { this.m_FrameCount = 0; this.m_Animating = 0; this.m_RunAnim = false; this.onComplete() } else this.m_FrameCount++ } }; GambleCard.prototype.Show = function (cardIndex) { this.aP = true; this.m_CardIndex = cardIndex; var n = cardIndex; if (n < 13) { this.m_CardFace.yoffset = 0; this.m_CardFace.xoffset = this.L.size.w * n } else if (n > 12 && n < 26) { this.m_CardFace.yoffset = this.L.size.h; this.m_CardFace.xoffset = this.L.size.w * (n - 13) } else if (n > 25 && n < 39) { this.m_CardFace.yoffset = this.L.size.h * 2; this.m_CardFace.xoffset = this.L.size.w * (n - 26) } else if (n > 38 && n < 52) { this.m_CardFace.yoffset = this.L.size.h * 3; this.m_CardFace.xoffset = this.L.size.w * (n - 39) } this.m_CardFace.update(); if (!this.C) { this.m_CardFace.xscale = 0; this.m_CardFace.update(); this.m_Animating = 1; this.m_RunAnim = true } else this.onComplete() }; GambleCard.prototype.Hide = function () { if (!this.getVisible()) return; this.aP = false; this.m_Animating = 2; this.m_RunAnim = true; this.m_FrameCount = 0; this.m_CardCycle.reset() }; GambleCard.prototype.FastHide = function () { this.m_CardFace.Visible(false); this.m_CardCycle.sprites[0].xoffset = this.L.card_anim_cycle.card_anim_cycle[0][0]; this.m_CardCycle.sprites[0].update(); this.m_CardCycle.sprites[0].Visible(true); this.m_FrameCount = 0; this.m_CardCycle.reset() }; GambleCard.prototype.HandleOrientationChange = function (portrait) { }; gamble: gamble = { sound_lose: sound_lose = 10, sound_win: sound_win = 9, gamble_layer: gamble_layer = { pt: pt = { x: 287, y: 490, w: 698, h: 430, scale: 1.2 }, ls: ls = { x: 287, y: 490, w: 698, h: 430, scale: 1.075 } }, gamble_window: gamble_window = { size: size = { w: 698, h: 430 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h } }, buttons: buttons = { red: red = { size: size = { w: 120, h: 74 }, offset: offset = { xoff: 720, yoff: 0, xon: 720, yon: 74, xenabled: 720, yenabled: 0, xdisabled: 720, ydisabled: 148 }, pos: pos = { xoffset_on: 720, yoffset_on: 74, x: gamble_window.pos.x + 72, y: gamble_window.pos.y + 162, w: size.w, h: size.h, offsets: offset, caption_offset: caption_offset = { x: 0, y: 0 } }, textpos: textpos = { x: pos.x + 20, w: size.w - 40 } }, black: black = { size: size = { w: 120, h: 74 }, offset: offset = { xoff: 720, yoff: 0, xon: 720, yon: 74, xenabled: 720, yenabled: 0, xdisabled: 720, ydisabled: 148 }, pos: pos = { xoffset_on: 720, yoffset_on: 74, x: gamble_window.pos.x + 72, y: gamble_window.pos.y + 244, w: size.w, h: size.h, offsets: offset, caption_offset: caption_offset = { x: 0, y: 0 } }, textpos: textpos = { x: pos.x + 20, w: size.w - 40 } }, heart: heart = { size: size = { w: 70, h: 70 }, offset: offset = { xoff: 0, yoff: 430, xon: 70, yon: 430, xenabled: 0, yenabled: 430, xdisabled: 140, ydisabled: 430 }, pos: pos = { xoffset_on: 70, yoffset_on: 430, x: gamble_window.pos.x + 470, y: gamble_window.pos.y + 166, w: size.w, h: size.h, offsets: offset } }, diamond: diamond = { size: size = { w: 70, h: 70 }, offset: offset = { xoff: 210, yoff: 430, xon: 280, yon: 430, xenabled: 210, yenabled: 430, xdisabled: 350, ydisabled: 430 }, pos: pos = { xoffset_on: 280, yoffset_on: 430, x: gamble_window.pos.x + 564, y: gamble_window.pos.y + 166, w: size.w, h: size.h, offsets: offset } }, club: club = { size: size = { w: 70, h: 70 }, offset: offset = { xoff: 420, yoff: 430, xon: 490, yon: 430, xenabled: 420, yenabled: 430, xdisabled: 560, ydisabled: 430 }, pos: pos = { xoffset_on: 490, yoffset_on: 430, x: gamble_window.pos.x + 470, y: gamble_window.pos.y + 248, w: size.w, h: size.h, offsets: offset } }, spade: spade = { size: size = { w: 70, h: 70 }, offset: offset = { xoff: 630, yoff: 430, xon: 700, yon: 430, xenabled: 630, yenabled: 430, xdisabled: 770, ydisabled: 430 }, pos: pos = { xoffset_on: 700, yoffset_on: 430, x: gamble_window.pos.x + 564, y: gamble_window.pos.y + 248, w: size.w, h: size.h, offsets: offset } } }, text: text = { info_val: info_val = { pos: pos = { x: gamble_window.pos.x + 84, y: gamble_window.pos.y + 56, w: 514, h: 28 } }, color_cap: color_cap = { pos: pos = { x: gamble_window.pos.x + 60, y: gamble_window.pos.y + 106, w: 144, h: 20 } }, suit_cap: suit_cap = { pos: pos = { x: gamble_window.pos.x + 480, y: gamble_window.pos.y + 106, w: 144, h: 20 } }, color_val: color_val = { pos: pos = { x: gamble_window.pos.x + 60, y: gamble_window.pos.y + 130, w: 144, h: 28 } }, suit_val: suit_val = { pos: pos = { x: gamble_window.pos.x + 480, y: gamble_window.pos.y + 130, w: 144, h: 28 } }, prev_cards_cap: prev_cards_cap = { pos: pos = { x: gamble_window.pos.x + 68, y: gamble_window.pos.y + 327, w: 216, h: 34 } } }, history_suit: history_suit = { xadj: xadj = 40, pos: pos = { x: gamble_window.pos.x + 300, y: gamble_window.pos.y + 329, w: 32, h: 32 }, offset: offset = { x: 808, yempty: 270, yheart: 302, ydiamond: 334, yclub: 366, yspade: 398 } }, gamble_card: gamble_card = { size: size = { w: 120, h: 170 }, pos: pos = { x: gamble_window.pos.x + 274, y: gamble_window.pos.y + 144, w: size.w, h: size.h }, offset: offset = { yoffset: 500 }, card_anim_cycle: card_anim_cycle = { card_anim_cycle: [[size.w * 0, offset.yoffset, 1], [size.w * 1, offset.yoffset, 1], [size.w * 2, offset.yoffset, 1], [size.w * 3, offset.yoffset, 1]] }, face_scale_cycle: face_scale_cycle = [0.25, 0.7, 1], face_scale_cycle_back: face_scale_cycle_back = [0.7, 0.25, 0] } }; RedOrBlack.WINAMOUNTCHANGED = 0; RedOrBlack.INIT = 1; RedOrBlack.WINAMOUNTCHANGED = 2; RedOrBlack.COMPLETE = 3; RedOrBlack.PICK = 4; RedOrBlack.DISABLECOLLECT = 5; RedOrBlack.RUNNING = 6; RedOrBlack.GAMBLEPICK_RED = 1; RedOrBlack.GAMBLEPICK_BLACK = 3; RedOrBlack.GAMBLEPICK_CLUB = 4; RedOrBlack.GAMBLEPICK_DIAMOND = 5; RedOrBlack.GAMBLEPICK_SPADE = 6; RedOrBlack.GAMBLEPICK_HEART = 7; RedOrBlack.STATE_SELECT = 0; RedOrBlack.STATE_WAITOUTCOME = 1; RedOrBlack.STATE_ANIMATECARD = 2; RedOrBlack.STATE_DISPLAYOUTCOME = 3; RedOrBlack.STATE_END = 4; function RedOrBlack(settings, pos, gamblecallback) { var that = this; this.ff = gamblecallback; var pos = pos; this.L = pos; this.iE; this.cF; this.mO; this.iS; this.kF = false; this.jN = true; this.C; this.fM; this.bQ; this.fQ; this.iE = false; this.cF = false; this.fM = true; this.iS = false; this.mO = false; this.C = true; this.fV; this.ob = 1E3; this.iR; this.bG; this.bG = settings; this.setEnableGambleFeature(true); this.m_UI = new RedOrBlackUI(pos, Utils.delegate(this, this.OnGamble)); this.m_Card = this.m_UI.getCard(); this.m_Card.setCallback(Utils.delegate(this, this.onGambleCardComplete)); this.qO } RedOrBlack.prototype.constructor = RedOrBlack; RedOrBlack.prototype.setConfirmCollect = function (b) { this.kF = b }; RedOrBlack.prototype.getConfirmCollect = function () { return this.kF }; RedOrBlack.prototype.Ticker = function () { this.m_Card.Ticker(); if (this.m_UI.BlinkButtons) this.m_UI.BlinkButtons() }; RedOrBlack.prototype.setDisplayOutcomeDelay = function (val) { this.ob = val }; RedOrBlack.prototype.OnChangeState = function (s) { switch (s) { case RedOrBlack.STATE_WAITOUTCOME: this.m_UI.SetSelection(this.getPicked()); this.Enable(false); break; case RedOrBlack.STATE_ANIMATECARD: this.setAcceptInput(false); this.ff({ n: RedOrBlack.DISABLECOLLECT, b: true }); break; case RedOrBlack.STATE_DISPLAYOUTCOME: setTimeout(Utils.delegate(this, this.OnGameEvent), this.C ? 1 : this.ob); break; case RedOrBlack.STATE_SELECT: this.setAcceptInput(true); this.Enable(true); this.ff({ n: RedOrBlack.DISABLECOLLECT, b: false }); break; case RedOrBlack.STATE_END: this.setAcceptInput(true); break } }; RedOrBlack.prototype.ReconnectEnd = function () { this.C = false; this.m_Card.ReconnectEnd(); this.m_UI.ReconnectEnd() }; RedOrBlack.prototype.OnIncomingPacket = function (cmd) { switch (cmd.ae) { case CmdType.GAMBLECMD: var type = CmdType.GAMBLECMD; var selection = cmd.GetInt(0); var winCode = cmd.GetInt(1); var winAmount = cmd.GetInt(2); var cardIndex = cmd.GetInt(3); var canContinueGamble = cmd.GetInt(4) == 0; this.iR = winCode; this.setWonCoins(winAmount); if (this.C) { this.OnChangeState(RedOrBlack.STATE_WAITOUTCOME); this.setPicked(selection); this.m_UI.SetSelection(selection); this.m_UI.CardSelected(); this.ff({ n: RedOrBlack.RUNNING }) } this.OnChangeState(RedOrBlack.STATE_ANIMATECARD); this.m_Card.Show(Math.floor(cardIndex / 13) * 13); this.cF = canContinueGamble; if (winCode == 0) this.cF = false; break; case CmdType.NOGAMBLECMD: break } }; RedOrBlack.prototype.onGambleCardComplete = function (e) { this.m_UI.End(this.m_Card.getCardIndex(), this.iR, this.cF); if (this.iR == 0) SoundPlayer.Play(this.L.sound_lose); else SoundPlayer.Play(this.L.sound_win); this.ff({ n: RedOrBlack.WINAMOUNTCHANGED }); this.OnChangeState(RedOrBlack.STATE_DISPLAYOUTCOME) }; RedOrBlack.prototype.OnGameEvent = function (e) { if (this.iR == 0) this.EndGamble(); else if (this.cF) this.InitGamble(); else { this.cF = true; this.EndGamble() } }; RedOrBlack.prototype.Start = function () { this.bQ = true; this.Show(true); this.InitGamble() }; RedOrBlack.prototype.Show = function (b) { this.m_UI.Show(b) }; RedOrBlack.prototype.Enable = function (b) { this.m_UI.Enable(b) }; RedOrBlack.prototype.EndGamble = function () { this.OnChangeState(RedOrBlack.STATE_END); this.ff({ n: RedOrBlack.COMPLETE }) }; RedOrBlack.prototype.InitGamble = function () { this.m_UI.Start(this.getWonCoins()); this.Enable(true); this.m_Card.FastHide(); this.OnChangeState(RedOrBlack.STATE_SELECT); this.ff({ n: RedOrBlack.INIT }) }; RedOrBlack.prototype.OnGamble = function (caller) { var pick = 0; switch (caller) { case "gambleRed": pick = RedOrBlack.GAMBLEPICK_RED; break; case "gambleBlack": pick = RedOrBlack.GAMBLEPICK_BLACK; break; case "gambleDiamond": pick = RedOrBlack.GAMBLEPICK_DIAMOND; break; case "gambleClub": pick = RedOrBlack.GAMBLEPICK_CLUB; break; case "gambleHeart": pick = RedOrBlack.GAMBLEPICK_HEART; break; case "gambleSpade": pick = RedOrBlack.GAMBLEPICK_SPADE; break } this.setPicked(pick); this.OnChangeState(RedOrBlack.STATE_WAITOUTCOME); this.m_UI.CardSelected(); this.ff({ n: RedOrBlack.PICK, rb_choice: pick }) }; RedOrBlack.prototype.End = function () { this.m_UI.EnableButtons(false); this.bQ = false; this.Show(false); if (this.CanGamble() || this.cF && this.mO && !this.iS || !this.jN) { this.iS = true; this.jN = true; this.ff({ n: RedOrBlack.PICK, rb_choice: 0 }); this.SetGambleFinished(true) } }; RedOrBlack.prototype.SetGambleFinished = function (b) { this.cF = !b }; RedOrBlack.prototype.CanGamble = function () { return this.iE && this.cF }; RedOrBlack.prototype.setEnableGambleFeature = function (b) { this.iE = b }; RedOrBlack.prototype.getStarted = function () { return this.bQ }; RedOrBlack.prototype.setAutoCollect = function (value) { this.mO = value; this.iS = false }; RedOrBlack.prototype.setWonCoins = function (value) { this.fQ = value; this.iS = false; if (value > 0 && this.kF) this.jN = false; else this.jN = true }; RedOrBlack.prototype.getWonCoins = function () { return this.fQ }; RedOrBlack.prototype.getAcceptInput = function () { return this.fM }; RedOrBlack.prototype.setAcceptInput = function (b) { this.fM = b }; RedOrBlack.prototype.getMaxGambles = function () { return 5 }; RedOrBlack.prototype.getGambleLimit = function () { return 2500 }; RedOrBlack.prototype.getPicked = function () { return this.qO }; RedOrBlack.prototype.setPicked = function (picked) { this.qO = picked }; RedOrBlack.prototype.HandleOrientationChange = function (portrait) { this.m_UI.HandleOrientationChange(portrait) }; function RedOrBlackUI(pos, callback) { var that = this; this.C = true; this.L = pos; this.ct = callback; this.m_GambleLayer; this.m_Background; this.m_InfoBar; this.m_ColorPaysCap; this.m_SuitPaysCap; this.m_ColorPaysVal; this.m_SuitPaysVal; this.m_PreviousCardsCap; this.m_RedButton; this.m_BlackButton; this.m_ClubButton; this.m_DiamondButton; this.m_SpadeButton; this.m_HeartButton; this.m_HistoryClips; this.m_PreviousCards; this.HISTORY_LENGTH = 8; this.m_Card; this.m_SelectedBtn; this.fn; this.fZ = 300; this.gC = false; this.di; var heart = this.L.history_suit.offset.yheart; var diamond = this.L.history_suit.offset.ydiamond; var spade = this.L.history_suit.offset.yspade; var club = this.L.history_suit.offset.yclub; var empty = this.L.history_suit.offset.yempty; this.m_Suits = [club, diamond, spade, heart, empty]; this.m_PreviousCards = []; this.m_SuitsHistory = []; this.UpdateHistory(); this.m_GambleLayer = sjs.layers["gamblelayer"] ? sjs.layers["gamblelayer"] : new sjs.Layer("gamblelayer", undefined, undefined); this.m_Background = new sjs.Sprite(image_path_game + "gamble.png", this.m_GambleLayer, undefined, this.L.gamble_window.pos); this.m_InfoBar = new Textfield(this.m_GambleLayer, this.L.text.info_val.pos, Locale.IDS_VP_BONUS2, false, "gamble_info_val", false); this.m_ColorPaysCap = new Textfield(this.m_GambleLayer, this.L.text.color_cap.pos, Locale.IDS_COLORPAYS, false, "gamble_color_cap", undefined, undefined, true); this.m_SuitPaysCap = new Textfield(this.m_GambleLayer, this.L.text.suit_cap.pos, Locale.IDS_SUITPAYS, false, "gamble_suit_cap", undefined, undefined, true); this.m_ColorPaysVal = new Textfield(this.m_GambleLayer, this.L.text.color_val.pos, "70", false, "gamble_color_val"); this.m_SuitPaysVal = new Textfield(this.m_GambleLayer, this.L.text.suit_val.pos, "140", false, "gamble_suit_val"); this.m_PreviousCardsCap = new Textfield(this.m_GambleLayer, this.L.text.prev_cards_cap.pos, Locale.IDS_PREVIOUSCARDS, false, "gamble_prev_cards_cap"); this.m_RedButton = new Button(this.m_GambleLayer, this.L.buttons.red.pos, function () { that.ButtonCallback("gambleRed") }, image_path_game + "gamble.png", Locale.IDS_VP_RED, "", "gamble_btn gamble_btn_red", undefined, undefined, undefined, undefined); this.m_RedButton.T.setBounds(this.L.buttons.red.textpos); this.m_BlackButton = new Button(this.m_GambleLayer, this.L.buttons.black.pos, function () { that.ButtonCallback("gambleBlack") }, image_path_game + "gamble.png", Locale.IDS_VP_BLACK, "", "gamble_btn", undefined, undefined, undefined, undefined); this.m_BlackButton.T.setBounds(this.L.buttons.black.textpos); this.m_ClubButton = new Button(this.m_GambleLayer, this.L.buttons.club.pos, function () { that.ButtonCallback("gambleClub") }, image_path_game + "gamble.png", " ", "", "control", undefined, undefined, undefined, undefined); this.m_DiamondButton = new Button(this.m_GambleLayer, this.L.buttons.diamond.pos, function () { that.ButtonCallback("gambleDiamond") }, image_path_game + "gamble.png", " ", "", "control", undefined, undefined, undefined, undefined); this.m_SpadeButton = new Button(this.m_GambleLayer, this.L.buttons.spade.pos, function () { that.ButtonCallback("gambleSpade") }, image_path_game + "gamble.png", " ", "", "control", undefined, undefined, undefined, undefined); this.m_HeartButton = new Button(this.m_GambleLayer, this.L.buttons.heart.pos, function () { that.ButtonCallback("gambleHeart") }, image_path_game + "gamble.png", " ", "", "control", undefined, undefined, undefined, undefined); this.bB; this.bB = [this.m_RedButton, this.m_BlackButton, this.m_ClubButton, this.m_DiamondButton, this.m_SpadeButton, this.m_HeartButton]; var xadj = { x: this.L.history_suit.pos.x }; for (var i = 0; i < this.HISTORY_LENGTH; i++) { this.m_SuitsHistory.push(new sjs.Sprite(image_path_game + "gamble.png", this.m_GambleLayer, undefined, this.L.history_suit.pos)); this.m_SuitsHistory[i].x = xadj.x; xadj.x += this.L.history_suit.xadj; this.m_SuitsHistory[i].yoffset = this.L.history_suit.offset.yempty; this.m_SuitsHistory[i].xoffset = this.L.history_suit.offset.x } this.m_Card = new GambleCard(this.L.gamble_card, this.m_GambleLayer) } RedOrBlackUI.prototype.constructor = RedOrBlackUI; RedOrBlackUI.prototype.EnableButtons = function (b) { var l = this.bB.length; for (var i = 0; i < l; i++) this.bB[i].Enable2(b) }; RedOrBlackUI.prototype.getCard = function () { return this.m_Card }; RedOrBlackUI.prototype.ButtonCallback = function (caller) { this.ct(caller) }; RedOrBlackUI.prototype.Show = function (b) { this.m_GambleLayer.Show(b) }; RedOrBlackUI.prototype.SetInfoText = function (identifier) { this.m_InfoBar.SetText(identifier) }; RedOrBlackUI.prototype.CardSelected = function () { this.SetInfoText(" ") }; RedOrBlackUI.prototype.Start = function (coins) { this.SetInfoText(Str.MultiToSingleLine(Locale.IDS_VP_BONUS2)); this.m_ColorPaysVal.SetText(CreditFormatter.FormatCoinValue(coins * 2)); this.m_SuitPaysVal.SetText(CreditFormatter.FormatCoinValue(coins * 4)); this.m_GambleLayer.Show(true); this.fn = getTimer() + this.fZ; this.gC = true; this.di = false }; RedOrBlackUI.prototype.End = function (cardIndex, winCode, canContinue) { if (winCode == 0) this.SetInfoText(Locale.IDS_VP_GAMEOVER); else this.SetInfoText(winCode == 1 ? Locale.IDS_VP_TIE : canContinue ? Locale.IDS_VP_WIN : Str.MultiToSingleLine(Locale.IDS_VP_BONUS2)); this.AddCardToHistory(cardIndex) }; RedOrBlackUI.prototype.BlinkButtons = function () { if (this.gC) if (this.fn < getTimer()) { if (this.di) { this.m_RedButton.Offset(this.L.buttons.red.offset.xdisabled, this.L.buttons.red.offset.ydisabled); this.m_BlackButton.Offset(this.L.buttons.black.offset.xdisabled, this.L.buttons.black.offset.ydisabled); this.m_ClubButton.Offset(this.L.buttons.club.offset.xenabled, this.L.buttons.club.offset.yenabled); this.m_DiamondButton.Offset(this.L.buttons.diamond.offset.xenabled, this.L.buttons.diamond.offset.yenabled); this.m_SpadeButton.Offset(this.L.buttons.spade.offset.xenabled, this.L.buttons.spade.offset.yenabled); this.m_HeartButton.Offset(this.L.buttons.heart.offset.xenabled, this.L.buttons.heart.offset.yenabled) } else { this.m_RedButton.Offset(this.L.buttons.red.offset.xenabled, this.L.buttons.red.offset.yenabled); this.m_BlackButton.Offset(this.L.buttons.black.offset.xenabled, this.L.buttons.black.offset.yenabled); this.m_ClubButton.Offset(this.L.buttons.club.offset.xdisabled, this.L.buttons.club.offset.ydisabled); this.m_DiamondButton.Offset(this.L.buttons.diamond.offset.xdisabled, this.L.buttons.diamond.offset.ydisabled); this.m_SpadeButton.Offset(this.L.buttons.spade.offset.xdisabled, this.L.buttons.spade.offset.ydisabled); this.m_HeartButton.Offset(this.L.buttons.heart.offset.xdisabled, this.L.buttons.heart.offset.ydisabled) } this.fn = getTimer() + this.fZ; this.di = !this.di } }; RedOrBlackUI.prototype.AddCardToHistory = function (card) { this.m_PreviousCards.unshift(card); if (this.m_PreviousCards.length > this.HISTORY_LENGTH) this.m_PreviousCards.length = 8; this.UpdateHistory() }; RedOrBlackUI.prototype.UpdateHistory = function () { for (var i = 0; i < this.m_PreviousCards.length; i++) { var suit = Math.floor(this.m_PreviousCards[i] / 13) + 1; this.m_SuitsHistory[i].yoffset = this.m_Suits[suit - 1]; this.m_SuitsHistory[i].update() } }; RedOrBlackUI.prototype.ButtonsIdToIndex = function (id) { var tmpArray = [RedOrBlack.GAMBLEPICK_RED, RedOrBlack.GAMBLEPICK_BLACK, RedOrBlack.GAMBLEPICK_CLUB, RedOrBlack.GAMBLEPICK_DIAMOND, RedOrBlack.GAMBLEPICK_SPADE, RedOrBlack.GAMBLEPICK_HEART]; for (var i = 0; i < tmpArray.length; i++) if (id == tmpArray[i]) return i }; RedOrBlackUI.prototype.ButtonsIdToString = function (id) { var tmpArray = [RedOrBlack.GAMBLEPICK_RED, RedOrBlack.GAMBLEPICK_BLACK, RedOrBlack.GAMBLEPICK_CLUB, RedOrBlack.GAMBLEPICK_DIAMOND, RedOrBlack.GAMBLEPICK_SPADE, RedOrBlack.GAMBLEPICK_HEART]; var v_strings = ["red", "black", "club", "diamond", "spade", "heart"]; for (var i = 0; i < tmpArray.length; i++) if (id == tmpArray[i]) return v_strings[i] }; RedOrBlackUI.prototype.Enable = function (b) { if (!b) this.gC = false; for (var i = 0; i < this.bB.length; i++) this.bB[i].Enable2(b); if (this.C) return; var tmpStringId = this.ButtonsIdToString(this.m_SelectedBtn); if (!b) { this.bB[this.ButtonsIdToIndex(this.m_SelectedBtn)].H.xoffset = this.L.buttons[tmpStringId].pos.xoffset_on; this.bB[this.ButtonsIdToIndex(this.m_SelectedBtn)].H.yoffset = this.L.buttons[tmpStringId].pos.yoffset_on; this.bB[this.ButtonsIdToIndex(this.m_SelectedBtn)].H.update() } }; RedOrBlackUI.prototype.SetSelection = function (selection) { this.m_SelectedBtn = selection }; RedOrBlackUI.prototype.HandleOrientationChange = function (portrait) { this.m_GambleLayer.setBounds(this.L.gamble_layer[DEVICE.orientation]); this.m_GambleLayer.SetScale(this.L.gamble_layer[DEVICE.orientation].scale) }; RedOrBlackUI.prototype.ReconnectEnd = function () { this.C = false }; function SoundManager() { SoundManager.instance = this; this.fallback = false; this.context = undefined; this.buffers = {}; this.masterGainNode = undefined; this.mp3offset = 0; this._soundDefinitions = {}; this._soundDefinitionsCount = 0; this._soundInstances = []; this._soundInstancesCount = 0; this._soundsLookUp = []; this._supportedFileType; this._enabled = true; this._reconnecting = true; this._masterVolume = 1; this._mute = false; this._deviceBlurred = false; this._playedSources = 0; SoundManager._Init(); if (typeof Context !== "undefined") { Context.blur.add(Utils.delegate(SoundManager, SoundManager.onBlur)); Context.focus.add(Utils.delegate(SoundManager, SoundManager.onFocus)) } } SoundManager.TagOperator = { AND: 0, OR: 1 }; SoundManager.FileType = { OGG: 0, MP3: 1, M4A: 2, MP3FB: 3 }; SoundManager.WebAudioSupport = function () { if (typeof AudioContext == "function" || typeof AudioContext === "object" || typeof webkitAudioContext === "function" || typeof webkitAudioContext === "object") return true; else { SoundManager.instance.fallback = true; SoundManager.instance._supportedFileType = SoundManager.FileType.MP3FB; if (SoundManager.SetupSoundPlayerFallback !== undefined) SoundManager.SetupSoundPlayerFallback(); return false } }; SoundManager.GetSupportedFiletype = function () { if (SoundManager.instance._supportedFileType !== undefined && SoundManager.instance._supportedFileType !== SoundManager.FileType.OGG) return SoundManager.instance._supportedFileType; var a = document.createElement("audio"); var oggSupport = ! !(a.canPlayType && a.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, "")); var mp3Support = ! !(a.canPlayType && a.canPlayType("audio/mpeg;").replace(/no/, "")); if (oggSupport && !SoundManager.instance.fallback) SoundManager.instance._supportedFileType = SoundManager.FileType.OGG; else if (mp3Support && !SoundManager.instance.fallback) SoundManager.instance._supportedFileType = SoundManager.FileType.MP3; else if (mp3Support && !SoundManager.instance.fallback) SoundManager.instance._supportedFileType = SoundManager.FileType.MP3FB; return SoundManager.instance._supportedFileType }; SoundManager._FormatUrl = function (url, fileType) { fileType = fileType === undefined ? SoundManager.GetSupportedFiletype() : fileType; url = url.substr(0, url.length - 4); switch (fileType) { case SoundManager.FileType.OGG: url += ".ogg"; break; case SoundManager.FileType.MP3: url += ".mp3"; break; case SoundManager.FileType.M4A: url += ".m4a"; break; case SoundManager.FileType.MP3FB: url += "_fb.mp3"; break } return url }; SoundManager.CheckSoundSupport = function () { return SoundManager.WebAudioSupport() }; SoundManager.GetTime = function () { return SoundManager.instance.context.currentTime }; SoundManager._Init = function () { if (SoundManager.WebAudioSupport()) try { window.AudioContext = window.AudioContext || window.webkitAudioContext; SoundManager.instance.context = SoundManager.createAudioContext(); SoundManager.instance.context.createGain = SoundManager.instance.context.createGain || SoundManager.instance.context.createGainNode; if (typeof SoundManager.instance.context.currentTime === "undefined") { SoundManager.instance._initiatedTime = new Date; SoundManager.GetTime = function () { return (new Date - SoundManager.instance._initiatedTime) * 0.001 } } SoundManager.instance.masterGainNode = SoundManager.instance.context.createGain(); SoundManager.instance.masterGainNode.connect(SoundManager.instance.context.destination) } catch (e) { SoundManager.instance.fallback = true; SoundManager.SetupSoundPlayerFallback() } else SoundManager.instance.fallback = true }; SoundManager.createAudioContext = function (desiredSampleRate) { desiredSampleRate = typeof desiredSampleRate === "number" ? desiredSampleRate : 44100; var context = new AudioContext; if (/(iPhone|iPad)/i.test(navigator.userAgent) && context.sampleRate !== desiredSampleRate) { var buffer = context.createBuffer(1, 1, desiredSampleRate); var dummy = context.createBufferSource(); dummy.buffer = buffer; dummy.connect(context.destination); dummy.start(0); dummy.disconnect(); context.close(); context = new AudioContext } return context }; SoundManager.LoadBuffer = function (url, bufferId, bufferLoadedCallback) { if (typeof bufferId !== "string" || bufferId.substr(0, 4) != "buf_") bufferId = "buf_" + bufferId; if (SoundManager.instance.fallback) { if (SoundPlayerFallback.me === undefined) { url = SoundManager._FormatUrl(url); SPC(url, SoundManager.instance._soundsLookUp); SoundManager.SetupSoundPlayerFallback() } return } if (bufferId in SoundManager.instance.buffers) throw 'Buffer with ID "' + bufferId + '" is already defined!'; var that = SoundManager.instance; var req = new XMLHttpRequest; url = SoundManager._FormatUrl(url); req.open("GET", url, true); req.responseType = "arraybuffer"; req.onerror = function () { if (SoundManager.instance._supportedFileType > 0) { SoundManager.Enable(false); return } SoundManager.instance._supportedFileType = FileType.MP3; SoundManager.LoadBuffer(url, bufferId, bufferLoadedCallback); return }; req.onload = function () { if (typeof that.context.decodeAudioData === "function") { var callback = function (buffer) { that.buffers[bufferId] = buffer; SoundManager._LoadBufferComplete(bufferId, bufferLoadedCallback) }; var error = function (error) { SoundManager.instance._supportedFileType = FileType.MP3; SoundManager.LoadBuffer(url, bufferId, bufferLoadedCallback); return }; that.context.decodeAudioData(req.response, callback, error) } else if (typeof that.context.createBuffer === "function") { that.buffers[bufferId] = this.context.createBuffer(req.response, false); SoundManager._LoadBufferComplete(bufferId, bufferLoadedCallback) } }; req.send() }; SoundManager._LoadBufferComplete = function (bufferId, bufferLoadedCallback) { for (var i = 0; i < SoundManager.instance._soundInstancesCount; i++) if (SoundManager.instance._soundInstances[i].definition.bufferId == bufferId) { if (SoundManager.instance._supportedFileType == SoundManager.FileType.MP3) SoundManager.instance._soundInstances[i].definition.encoderOffset = SoundManager.instance.mp3offset; SoundManager.instance._soundInstances[i].isLoaded = true; if (SoundManager.instance._soundInstances[i].onLoaded !== undefined) SoundManager.instance._soundInstances[i].onLoaded.fire() } if (bufferLoadedCallback != undefined) bufferLoadedCallback(bufferId) }; SoundManager.ParseObject = function (object) { var bufferId = "buf_" + object.soundBufferId; if (object.mp3offset !== undefined) SoundManager.instance.mp3offset = object.mp3offset; for (k in object.sounds) { name = k.toString(); var hasLoop = object.sounds[k].loopStart && object.sounds[k].loopEnd; SoundManager.DefineSound(name, bufferId, object.sounds[k].start / 44100, object.sounds[k].end / 44100, object.sounds[k].unique, object.sounds[k].priority, hasLoop ? object.sounds[k].loopStart / 44100 : undefined, hasLoop ? object.sounds[k].loopEnd / 44100 : undefined) } if (object.url != undefined) SoundManager.LoadBuffer(object.url, bufferId) }; SoundManager.DefineSound = function (name, bufferId, startTime, endTime, unique, priority, loopStart, loopEnd) { if ("snd_" + name in SoundManager.instance._soundDefinitions) return; var snd = new SndDefinition(SoundManager.instance._soundDefinitionsCount, name, bufferId, startTime, endTime, unique, priority, loopStart, loopEnd); SoundManager.instance._soundDefinitions["snd_" + name] = snd; SoundManager.instance._soundsLookUp.push(name); SoundManager.instance._soundDefinitionsCount++ }; SoundManager.GetSoundDefinition = function (name) { if ("snd_" + name in SoundManager.instance._soundDefinitions) return SoundManager.instance._soundDefinitions["snd_" + name]; else console.error(name + " is not a valid SndDefinition") }; SoundManager.CreateBufferSource = function () { var source = SoundManager.instance.context.createBufferSource(); if (typeof source.stop === "undefined") source.stop = source.noteOff; if (typeof source.start === "undefined") source.start = source.noteGrainOn; source["id"] = "src_" + SoundManager.instance._playedSources++; return source }; SoundManager.MergeBuffers = function (targetId, sourceId) { setTimeout(function () { var target = SoundManager.instance.buffers[targetId]; var source = SoundManager.instance.buffers[sourceId]; numChannels = target.numberOfChannels; var newBuffer = SoundManager.instance.context.createBuffer(target.numberOfChannels, source.length + target.length, target.sampleRate); for (var i = 0; i < numChannels; i++) { newBuffer.getChannelData(i).set(new Float32Array(target.getChannelData(i))); newBuffer.getChannelData(i).set(new Float32Array(source.getChannelData(i)), target.length) } delete SoundManager.instance.buffers[sourceId]; SoundManager.instance.buffers[targetId] = newBuffer }, 0) }; SoundManager.MainLoop = function () { for (var i = 0; i < SoundManager.instance._soundInstancesCount; i++) if (SoundManager.instance._soundInstances[i].ReadyToBeDestroyed()) SoundManager.instance._soundInstances[i].Destroy() }; SoundManager.SetMute = function (mute) { SoundManager.instance._mute = mute; if (SoundManager.instance._deviceBlurred) return; var gain = mute ? 0 : SoundManager.instance._masterVolume; var now = SoundManager.GetTime(); SoundManager.instance.masterGainNode.gain.cancelScheduledValues(0); SoundManager.instance.masterGainNode.gain.linearRampToValueAtTime(SoundManager.instance.masterGainNode.gain.value, now); SoundManager.instance.masterGainNode.gain.linearRampToValueAtTime(gain, now + (mute ? 0.01 : 0.75)) }; SoundManager.SetMasterVolume = function (gain) { SoundManager.instance._masterVolume = gain; SoundManager.instance.masterGainNode.gain.value = SoundManager.instance.masterGainNode.gain.value === 0 ? 0 : gain }; SoundManager.Enable = function (enabled) { if (enabled && !SoundManager.IsReconnecting()) SoundManager.SetMute(false); else SoundManager.SetMute(true); SoundManager.instance._enabled = enabled }; SoundManager.IsEnabled = function () { return SoundManager.instance._enabled }; SoundManager.ReconnectStart = function () { SoundManager.instance._reconnecting = true; SoundManager.SetMute(true) }; SoundManager.ReconnectEnd = function () { SoundManager.instance._reconnecting = false; SoundManager.SetMute(!SoundManager.IsEnabled()) }; SoundManager.IsReconnecting = function () { return SoundManager.instance._reconnecting }; SoundManager.GetSoundDefinitionById = function (id) { if (id in SoundManager.instance._soundsLookUp) return SoundManager.instance._soundDefinitions["snd_" + SoundManager.instance._soundsLookUp[id]]; return undefined }; SoundManager.AddSoundInstance = function (snd) { SoundManager.instance._soundInstances.push(snd); SoundManager.instance._soundInstancesCount++ }; SoundManager.StopTags = function (tags, operator) { var tagsCount = tags.length; for (var i = 0; i < SoundManager.instance._soundInstancesCount; i++) if (SoundManager._checkFilter(SoundManager.instance._soundInstances[i].definition, tags, tagsCount, operator)) snd.Stop() }; SoundManager._checkTags = function (definition, tags, tagsCount, operator) { var definitionTagsCount = definition.tags.length; var matches = 0; for (var i = 0; i < definitionTagsCount; i++) for (var j = 0; j < tagsCount; j++) if (definition.tags[i] === tags[j]) if (operator === SoundManager.TagOperator.AND) matches++; else if (operator === SoundManager.TagOperator.OR) return true; return matches === tagsCount }; SoundManager.onBlur = function () { var muted = SoundManager.instance._mute; SoundManager.SetMute(true); SoundManager.instance._mute = muted; SoundManager.instance._deviceBlurred = true }; SoundManager.onFocus = function () { SoundManager.instance._deviceBlurred = false; SoundManager.SetMute(SoundManager.instance._mute) }; new SoundManager; function Snd(name) { this.definition = SoundManager.GetSoundDefinition(name); this.name = name; this._sources = {}; this._state = Snd.State.STOPPED; this._playedAt; this._pausedAt; this._looping = false; this._modules = {}; this._numModules = 0; this._lastModule = undefined; if (!SoundManager.instance.fallback) { this.volume = SoundManager.instance.context.createGain(); this.volume.connect(SoundManager.instance.masterGainNode) } SoundManager.AddSoundInstance(this); this.onLoaded = new Signal; this.isLoaded = this.definition.bufferId in SoundManager.instance.buffers }; Snd.State = { STOPPED: 0, PLAYING: 1, PAUSED: 2 }; Snd.prototype.StopAll = function (delay) { this.Destroy(delay) }; Snd.prototype.Play = function (gain, offset, forceOnReconnect, loop, delay) { forceOnReconnect = forceOnReconnect === undefined ? false : forceOnReconnect; this._looping = loop === undefined ? false : loop; delay = delay === undefined ? 0 : delay; if (SoundManager.IsReconnecting() && !forceOnReconnect) return; if (!this.isLoaded) { if (forceOnReconnect) { var playDelegate = Utils.delegate(this, this.Play, gain, offset, forceOnReconnect, loop, delay); this.onLoaded.add(playDelegate) } return } if (SoundManager.instance.buffers[this.definition.bufferId].length < this.definition.GetStart()) return; if (offset === undefined) offset = 0; else this._state = Snd.State.STOPPED; var src = SoundManager.CreateBufferSource(); src.buffer = SoundManager.instance.buffers[this.definition.bufferId]; if (this.definition.unique && this._state == Snd.State.PLAYING) return; src.connect(this.volume); this._sources[src.id] = src; if (gain !== undefined) this.SetVolume(gain, true); var that = this; src.onended = function () { that.state = Snd.State.STOPPED; delete that._sources[src.id] }; if (this._state === Snd.State.PAUSED) offset = (this._pausedAt - this._playedAt) % this.GetDuration(); src.start(delay + SoundManager.GetTime(), this.definition.GetStart() + offset, this.GetDuration(this._looping) - offset); this._state = Snd.State.PLAYING; this._playedAt = SoundManager.GetTime() - offset + delay; if (this._looping) { src.loop = true; src.loopStart = this.definition.GetLoopStart(); src.loopEnd = this.definition.GetLoopEnd() } }; Snd.prototype.PlayForever = function (gain, offset, forceOnReconnect, delay) { this.Play(gain, offset, forceOnReconnect, true, delay) }; Snd.prototype.PlayFadeIn = function (gain, time, offset, forceOnReconnect, loop, delay) { if (!this.isLoaded) { if (forceOnReconnect) { var delegate = Utils.delegate(this, this.PlayFadeIn, gain, time, offset, forceOnReconnect, loop, delay); this.onLoaded.add(delegate) } return } this.Play(0, offset, forceOnReconnect, loop, delay); this.FadeTo(gain, time) }; Snd.prototype.Stop = function (delay) { if (SoundManager.IsReconnecting()) this.StopAll(0); delay = delay === undefined ? 0 : delay; this.StopAll(delay); this._state = Snd.State.STOPPED; this._looping = false }; Snd.prototype.StopLoop = function () { if (this.isPlaying()) { for (var k in this._sources) this._sources[k].loop = false; var offset = (SoundManager.GetTime() - this._playedAt) % this.GetLoopDuration(); var timeToEnd = this.GetDuration() - offset; this.Stop(timeToEnd) } }; Snd.prototype.Pause = function (delay) { delay = delay === undefined ? 0 : delay; if (this._state !== Snd.State.PLAYING) return; this.StopAll(delay); this._state = Snd.State.PAUSED; this._pausedAt = SoundManager.GetTime() + delay }; Snd.prototype.FadeTo = function (gain, time) { time = time === undefined ? 1 : time; if (SoundManager.IsReconnecting()) time = 0; var now = SoundManager.GetTime(); this.StopFade(); this.volume.gain.linearRampToValueAtTime(this.volume.gain.value, now); this.volume.gain.linearRampToValueAtTime(gain, now + time) }; Snd.prototype.FadeChain = function (chain) { if (SoundManager.IsReconnecting()) time = 0; var now = SoundManager.GetTime(); this.StopFade(); this.volume.gain.linearRampToValueAtTime(this.volume.gain.value, now); for (var i = 0; i < chain.length; i++) this.volume.gain.linearRampToValueAtTime(chain[i].gain, now + chain[i].time) }; Snd.prototype.StopFade = function () { this.volume.gain.cancelScheduledValues(0) }; Snd.prototype.SetVolume = function (gain, stopFade) { gain = gain === undefined ? 1 : gain; if (stopFade !== undefined || stopFade) this.StopFade(); this.volume.gain.value = gain }; Snd.prototype.FadeOut = function (time, pause) { time = time === undefined ? false : time; pause = pause === undefined ? false : pause; this.FadeTo(0, time); if (pause) this.Pause(time); else this.Stop(time) }; Snd.prototype.GetDuration = function () { return this.definition.duration }; Snd.prototype.GetLoopDuration = function () { return this.definition.loopDuration }; Snd.prototype.GetCurrentTime = function () { if (this.isPlaying()) return (SoundManager.GetTime() - this._playedAt) % this.GetDuration(); else if (this._state === Snd.State.PAUSED) return (this._pausedAt - this._playedAt) % this.GetDuration(); return 0 }; Snd.prototype.Destroy = function (delay) { this.onLoaded.clear(); for (var key in this._sources) { this._sources[key].onended = undefined; try { this._sources[key].stop(SoundManager.GetTime() + delay) } catch (e) { } } this._sources = {}; this._state = Snd.State.STOPPED }; Snd.prototype.isPlaying = function () { var playingFlag = this._state == Snd.State.PLAYING; var time = !this._looping && SoundManager.GetTime() < this._playedAt + this.GetDuration(); return playingFlag && (time || this._looping); return this._state == Snd.State.PLAYING && !this._looping && SoundManager.GetTime() < this._playedAt + this.GetDuration() }; Snd.prototype.AddModule = function (module) { if (this._lastModule !== undefined) { module.numberOfInputs = this._lastModule.numberOfOutputs; this._lastModule.GetOutput().disconnect(0); this._lastModule.GetOutput().connect(module.GetInput()) } module.Connected(); this._lastModule = module; if (this._numModules == 0) { this.volume.disconnect(0); this.volume.connect(module.GetInput()) } this._lastModule.GetOutput().connect(SoundManager.instance.masterGainNode); this._modules[module.id] = module; this._numModules++ }; Snd.prototype.GetModule = function (id) { if (id in this._modules) return this._modules[id]; return undefined }; Snd.prototype.ReadyToBeDestroyed = function () { return !this.isPlaying && this._state !== Snd.State.PAUSED }; function SndDefinition(id, name, bufferId, startTime, endTime, unique, priority, loopStart, loopEnd) { this.id = id; this.name = name; this.bufferId = bufferId; this.unique = unique; this._startTime = startTime; this._endTime = endTime; this.duration = endTime - startTime; this._loopStart = loopStart || startTime; this._loopEnd = loopEnd || endTime; this.loopDuration = this._loopEnd - this._loopStart; this.priority = priority } SndDefinition.prototype.GetStart = function () { return this._startTime }; SndDefinition.prototype.GetEnd = function () { return this._endTime }; SndDefinition.prototype.GetLoopStart = function () { return this._loopStart }; SndDefinition.prototype.GetLoopEnd = function () { return this._loopEnd }; SoundManager.SetupSoundPlayerFallback = function () { Snd.prototype.Play = function (gain, offset, forceOnReconnect, loop, delay) { if (SoundPlayerFallback.me.myobj.readyState === 0) return; if (this.definition.priority > -1 && this.definition.priority >= SoundManager.instance._playingPriority) { SoundPlayerFallback.Pause(); SoundManager.instance._playingPriority = this.definition.priority; SoundManager.instance._playingSoundEnd = SoundManager.GetTime() + this.GetDuration(); if (offset === undefined) offset = 0; else this._state = Snd.State.STOPPED; forceOnReconnect = forceOnReconnect === undefined ? false : forceOnReconnect; if (SoundManager.IsReconnecting() && !forceOnReconnect) return; SoundPlayerFallback.me._playingLoop = loop === undefined ? false : loop; if (this._state == Snd.State.PAUSED) offset = (this._pausedAt - this._playedAt) % this.GetDuration(); if (offset != 0) { SoundPlayerFallback.me.myobj.currentTime = this.definition.GetStart() + offset; SoundPlayerFallback.PlayTime(this.definition.id - 1, this.definition.GetStart() + offset, loop) } else { SoundPlayerFallback.me.myobj.currentTime = this.definition.GetStart(); SoundPlayerFallback.Play(this.definition.id - 1, loop) } this._state = Snd.State.PLAYING; this._playedAt = SoundManager.GetTime() - offset; SoundPlayerFallback.me._playingSnd = this } }; Snd.prototype.Stop = function () { if (SoundPlayerFallback.me._playingSnd !== this) return; SoundPlayerFallback.Pause(this.definition.id - 1); this._state = Snd.State.STOPPED; SoundPlayerFallback.me._playingLoop = false; SoundPlayerFallback.me._playingSnd = undefined }; Snd.prototype.Pause = function () { if (SoundPlayerFallback.me._playingSnd !== this) return; this._pausedAt = SoundManager.GetTime(); this._state = Snd.State.PAUSED; SoundPlayerFallback.Pause(this.definition.id - 1); SoundPlayerFallback.me._playingLoop = false; SoundPlayerFallback.me._playingSnd = undefined }; Snd.prototype.PlayFadeIn = function (gain, time, offset, forceOnReconnect, loop, delay) { this.Play(gain, offset, forceOnReconnect, loop, delay) }; Snd.prototype.FadeChain = function () { }; Snd.prototype.FadeTo = function () { }; Snd.prototype.StopFade = function () { }; Snd.prototype.SetPan = function () { }; Snd.prototype.SetVolume = function () { }; Snd.prototype.AddModule = function () { }; Snd.prototype.FadeOut = function (time, pause) { if (pause) this.Pause(); else this.Stop() }; Snd.prototype.PlayFadeIn = function () { this.Play() }; SoundManager.MainLoop = function () { var time = SoundManager.GetTime(); if (SoundManager.instance._playingPriority > -1 && time > SoundManager.instance._playingSoundEnd) { SoundPlayerFallback.Pause(); SoundManager.instance._playingPriority = -1; if (SoundPlayerFallback.me._playingSnd && SoundPlayerFallback.me._playingLoop === true) SoundPlayerFallback.me._playingSnd.Play(undefined, undefined, undefined, true) } }; SoundManager.ReconnectEnd = SoundPlayerFallback.ReconnectEnd; SoundManager.ReconnectStart = function () { SoundPlayerFallback.getObject().C = true }; SoundManager.IsReconnecting = function () { return SoundPlayerFallback.getObject().C }; SoundManager.IsEnabled = SoundPlayerFallback.GetEnabled; SoundManager.Enable = SoundPlayerFallback.ToggleOnOff; SoundManager.instance.initiatedTime = new Date; SoundManager.CheckSoundSupport = SoundPlayerFallback.CheckSoundSupport; SoundManager.instance._initiatedTime = new Date; SoundManager.GetTime = function () { return (new Date - SoundManager.instance._initiatedTime) * 0.001 }; SoundManager.SetMasterVolume = function (gain) { SoundManager.instance._masterVolume = gain; SoundPlayerFallback.getObject().myobj.volume = SoundPlayerFallback.getObject().myobj.volume == 0 ? 0 : gain }; SoundManager.SetMute = function (mute) { SoundPlayerFallback.getObject().myobj.volume = mute ? 0 : SoundManager.instance._masterVolume }; SoundManager.instance._playingPriority = -1; SoundManager.instance._playingSoundEnd = 0; if (typeof Gain !== "undefined") for (var k in Gain.prototype) Gain.prototype[k] = function () { } }; function SPC(filename, samples) { new SoundPlayerFallback(filename, samples) }; function SoundPlayerFallback(filename_, samples_) { this.samples = []; for (var i = 0; i < samples_.length; i++) this.samples.push(SoundManager.GetSoundDefinitionById(i)); SoundPlayerFallback.me = this; this.bEnabled = false; this.current_sample = -1; this.aJn = ""; this.myobj = document.createElement("audio"); this.myobj.style.position = "relative"; this.myobj.style.bottom = 0; this.myobj.src = filename_; this.myobj.type = "audio/mpeg"; this.myobj.id = "sound"; this.bLoaded = false; document.body.insertBefore(this.myobj, document.body.lastChild); if (!UAGENT_IE || UAGENT_IE_10 || UAGENT_IE_11) { this.myobj.addEventListener("timeupdate", this, false); this.myobj.addEventListener("loadeddata", this, false); window.addEventListener("DOMContentLoaded", this, false) } this.bFirstSound = true; this.hl = []; this.jg = []; this.C = true; this._playingLoop = false; this._playingSnd = undefined } SoundPlayerFallback.prototype.bEnabled = false; SoundPlayerFallback.Pause = function () { SoundPlayerFallback.getObject().myobj.pause() }; SoundPlayerFallback.getCurrentTime = function () { return SoundPlayerFallback.getObject().myobj.currentTime }; SoundPlayerFallback.getObject = function () { return SoundPlayerFallback.me }; SoundPlayerFallback.ReconnectEnd = function () { SoundPlayerFallback.me.C = false; SoundManager.SetMute(false) }; SoundPlayerFallback.QueueSound = function (sndIndex, delay) { if (SoundPlayerFallback.me.C) return; if (delay == undefined) delay = 1; for (var i = 0; i < SoundPlayerFallback.me.hl.length; i++) if (getTimer() + delay < SoundPlayerFallback.me.jg[i]) { SoundPlayerFallback.me.hl = []; SoundPlayerFallback.me.jg = []; break } SoundPlayerFallback.me.hl.push(sndIndex); SoundPlayerFallback.me.jg.push(getTimer() + delay) }; SoundPlayerFallback.MainLoop = function () { if (SoundPlayerFallback.me.C || SoundPlayerFallback.me.hl.length == 0) return }; SoundPlayerFallback.CheckSoundSupport = function () { var support = false; if (UAGENT_IPHONE || UAGENT_IPAD) support = true; if (UAGENT_ANDROID) { if (/Android[\/\s](\d+\.\d+)/.test(navigator.userAgent)) { var version = new Number(RegExp.$1); if (version >= 2.3) support = true; else support = false } else support = true; SoundPlayerFallback.getObject().bFirstSound = false } if (UAGENT_IE || UAGENT_IE_10 || UAGENT_IE_11) { support = true; SoundPlayerFallback.getObject().bFirstSound = true } return support }; SoundPlayerFallback.ToggleOnOff = function (b) { if (!SoundPlayerFallback.CheckSoundSupport()) { SoundPlayerFallback.getObject().bEnabled = false; return } SoundPlayerFallback.getObject().bEnabled = b; SoundManager.SetMute(!b) }; SoundPlayerFallback.GetEnabled = function () { return SoundPlayerFallback.getObject().bEnabled }; SoundPlayerFallback.Play = function (index, bLoop) { if (typeof SoundPlayerFallback.getObject() == "undefined" || SoundPlayerFallback.me.C) return; var indexToUse = SoundPlayerFallback.me.mL == null ? index : SoundPlayerFallback.me.mL; if (this.getObject().bFirstSound) SoundPlayerFallback.internal_play(indexToUse, bLoop); else setTimeout("SoundPlayerFallback.internal_play(" + indexToUse + "," + bLoop + ")", 1) }; SoundPlayerFallback.PlayTime = function (index, time, bLoop) { if (typeof SoundPlayerFallback.getObject() == "undefined" || SoundPlayerFallback.me.C) return; if (bLoop == undefined) bLoop = false; var indexToUse = SoundPlayerFallback.me.mL == null ? index : SoundPlayerFallback.me.mL; if (this.getObject().bFirstSound) SoundPlayerFallback.internal_play_time(indexToUse, bLoop, time); else setTimeout("SoundPlayerFallback.internal_play_time(" + indexToUse + "," + bLoop + "," + time + ")", 1) }; SoundPlayerFallback.internal_play = function (index, aHl) { if (typeof index == "string") return; if (this.bLoaded == false) return; if (typeof this.me == "undefined") { this.me = {}; this.me.bEnabled = true } if (this.me.bEnabled == true) if (SoundPlayerFallback.getObject().myobj) SoundPlayerFallback.getObject().play(index + 1, aHl) }; SoundPlayerFallback.internal_play_time = function (index, aHl, time) { if (typeof index == "string") return; if (this.bLoaded == false) return; if (typeof this.me == "undefined") { this.me = {}; this.me.bEnabled = true } if (this.me.bEnabled == true) if (SoundPlayerFallback.getObject().myobj) SoundPlayerFallback.getObject().play_time(index + 1, aHl, time) }; SoundPlayerFallback.prototype = { handleEvent: function (e) { switch (e.type) { case "DOMContentLoaded": this.myobj.load(); this.play(0); break; case "loadeddata": this.bLoaded = true; break; case "timeupdate": this.check_stop(); break; default: alert(e.type); break } }, play: function (index, aHl) { if (!this.samples[index]) return; this.current_sample = index; this.aHl = aHl; this.myobj.play(); if (!this.bLoaded || this.bFirstSound) { setTimeout(function () { SoundPlayerFallback.getObject().myobj.pause() }, 5); this.bFirstSound = false } }, play_time: function (index, aHl, time) { if (!this.samples[index]) return; this.current_sample = index; if (index > 0 && !this.bFirstSound) { try { this.myobj.currentTime = time } catch (e) { } if (this.myobj.currentTime == 0) { this.myobj.load(); return } } this.aHl = aHl; this.myobj.currentTime = time; this.myobj.play(); if (!this.bLoaded || this.bFirstSound) { setTimeout(function () { SoundPlayerFallback.getObject().myobj.pause() }, 5); this.bFirstSound = false } }, check_stop: function () { if (this.current_sample < 0) return; if (this.myobj.currentTime >= this.samples[this.current_sample].endTime) if (this.aHl) this.myobj.currentTime = this.samples[this.current_sample].startTime; else { this.current_sample = -1; this.myobj.pause() } } }; function SoundPlayer() { } function SoundPlayer2() { } SoundPlayer.SoundInstances = {}; SoundPlayer2.SECONDARY = 1; SoundPlayer.getCurrentTime = function () { SoundManager.GetTime() }; SoundPlayer.getObject = function () { }; SoundPlayer.ReconnectEnd = function () { SoundManager.ReconnectEnd() }; SoundPlayer.MainLoop = function () { SoundManager.MainLoop() }; SoundPlayer.CheckSoundSupport = function () { return true }; SoundPlayer.ToggleOnOff = function (b) { SoundManager.Enable(b) }; SoundPlayer.GetEnabled = function () { return SoundManager.IsEnabled() }; SoundPlayer.Pause = function (index) { if (index === undefined) for (var key in SoundPlayer.SoundInstances) SoundPlayer.SoundInstances[key].Stop(); else { var instance = SoundPlayer.GetSoundInstance(index); if (instance !== undefined) instance.Stop() } }; SoundPlayer.Play = function (index, delay, loop, flags) { var instance = SoundPlayer.GetSoundInstance(index); if (instance !== undefined) instance.Play(undefined, undefined, undefined, loop, delay) }; SoundPlayer.PlayTime = function (index, time, loop, flags) { SoundPlayer.GetSoundInstance(index).Play(undefined, time, undefined, true, undefined) }; SoundPlayer.CreateBufferSource = function () { }; SoundPlayer.QueueSound = function (sndIndex, delay) { }; SoundPlayer.GetSoundInstance = function (id) { id += 1; if (!(id in SoundPlayer.SoundInstances)) { var definition = SoundManager.GetSoundDefinitionById(id); if (definition === undefined) return undefined; SoundPlayer.SoundInstances[id] = new Snd(definition.name) } return SoundPlayer.SoundInstances[id] }; function RoundEvent() { } RoundEvent.BET = "bet"; RoundEvent.WIN = "win"; RoundEvent.BALANCE = "balance"; RoundEvent.ROUNDSTART = "roundstart"; RoundEvent.ROUNDEND = "roundend"; RoundEvent.ROUNDABORT = "roundabort"; RoundEvent.CURRENCY = "currency"; GameBase.TIMESYNC_OFF = 0; GameBase.TIMESYNC_LOCAL = 1; GameBase.TIMESYNC_SERVER = 2; GameBase.MSG_GENERIC = 0; GameBase.MSG_BET = 1; GameBase.MSG_WIN = 2; GameBase.MSG_BALANCE = 3; GameBase.MSG_INFORMATION = 4; if (typeof JackpotHandler == "undefined") JackpotHandler = undefined; function GameBase(gameName, gameVersion, parent) { var that = this; this.V; this.aZ; this.bz; this.C = true; this.iK = 0; this.bd; this.aB; this.m_ReloadGame = false; this.cG = false; this.rM; this.rq = gameName + " 1.9.9b"; this.uy; this.cp = 100095; this.bn = parent; this.gU = 2; this.im = 1; this.qd; this.sc = ""; this.nr = false; this.pP = 0; this.rw = false; this.kP = 0; this.eo = 0; this.lg = GameBase.TIMESYNC_OFF; this.pr = 1E4; this.fW = 1E3; this.lF = 0; this.nS = 0; this.gK = 0; this.gr = 0; this.mF = 0; this.lastTimeSync = 0; this.kA = false; this.jz = false; this.hT; this.qJ; this.ml; this.gd; this.ir; this.pw; this.ny = false; this.kI = 0; this.pq = 0; this.gQ = new Array; this.po = false; this.eU = false; this.aM = true; this.ai; this.m_NeedsRoundEndBalance = true; this.cL = ""; this.eg = ""; this.ha = ""; this.en = ""; this.tK = false; this.dI = 0; this.oq = false; this.kG = false; this.qo = false; if (UAGENT_CMOBILE) { this.SetScrollToggleSetting(true); this.qo = true } this.XORkey = "jdkl39fjfMFJofksS8"; this.fi = false; this.m_PracticeMode = false; this.sh; this.ew = undefined; this.gs = 0; this.kD; this.lH; this.lb; this.fh; this.iM; this.m_AutoplayLimits = false; this.m_AutoplayReset = false; this.jQ = undefined; this.lj; this.ix; this.gG = 0; if (UAGENT_IE10 || UAGENT_IE11) this.gG = 1; this.mv; this.lJ; this.mo; this.rU = undefined; this.oz = 0; this.hQ = new RealityCheck(Utils.delegate(this, this.ShowRealityCheck)); this.ll = false; this.om; this.qI = false; this.rk; this.qh = true; this.lk = false; this.m_ExternalRedirect; Context.blur.add(function () { SoundPlayer.Pause(); PAUSE = true; blurredTime = (new Date).getTime() }); Context.focus.add(function () { PAUSE = false; globalTimeOffset += (new Date).getTime() - blurredTime; blurredTime = (new Date).getTime() }); var OnTouchMoveEvt = function (e, toggleScrollSetting, allowScrolling) { if (toggleScrollSetting) { if (!allowScrolling) if (UAGENT_IE) window.scrollTo(0, 0); else e.preventDefault ? e.preventDefault() : e.returnValue = false } else { if (UAGENT_IE) window.scrollTo(0, 0); else e.preventDefault ? e.preventDefault() : e.returnValue = false; if (UAGENT_IE && window.attachEvent != undefined) window.attachEvent("touchend", SetCorrextScrollPos, false); else window.addEventListener("touchend", SetCorrextScrollPos, false) } }; var SetCorrextScrollPos = function () { window.scrollTo(0, 1); if (window.detachEvent != undefined) window.detachEvent("touchend", SetCorrextScrollPos, false); else window.removeEventListener("touchend", SetCorrextScrollPos, false) }; if (UAGENT_IE) window.addEventListener("scroll", function (event) { OnTouchMoveEvt(event, that.kG, that.qo) }, false); else if (UAGENT_IOS7 && UAGENT_IPHONE); else window.addEventListener("touchmove", function (event) { OnTouchMoveEvt(event, that.kG, that.qo) }, false); var orientationHasBeenSet = false; var gH; if (window.innerWidth >= 960) gH = true; else gH = false; var onResize = function (event) { if (that.ai == undefined) return; if (window.innerWidth >= 960 && !gH || window.innerWidth >= 960 && !orientationHasBeenSet) { gH = true; callInitOrientationCheck(true); orientationHasBeenSet = true } else if (window.innerWidth < 960 && gH || window.innerWidth < 960 && !orientationHasBeenSet) { gH = false; callInitOrientationCheck(false); orientationHasBeenSet = true } }; if (UAGENT_FIREFOX || UAGENT_IE) window.addEventListener("resize", onResize, false); var callInitOrientationCheck = function (b) { that.ai.initOrientationCheck(true, b) }; HostInterface.addCallback(HostInterface.CALLBACK_BALANCE_UPDATE, this.OnBalanceRefresh.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_LOGOUT, this.OnLogout.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_SET_SOUND, this.OnSetSound); HostInterface.addCallback(HostInterface.CALLBACK_GET_BALANCE, this.GetBalance.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_GET_BET, this.GetBet.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_GET_WIN, this.GetWin.bind(this)); return this } GameBase.prototype.constructor = GameBase; GameBase.prototype.OnSetSound = function (b) { }; GameBase.prototype.SetScrollToggleSetting = function (b) { this.kG = b }; GameBase.prototype.IsReconnecting = function () { return this.C }; GameBase.prototype.CanShowWindow = function () { if (this.kP > 0) this.kP--; return !this.C && this.kP == 0 || this.cG }; GameBase.prototype.GetProductId = function () { return gU }; GameBase.prototype.GetProductGroup = function () { return im }; GameBase.prototype.UseExternalInterface = function () { return true }; GameBase.prototype.Connect = function (server, fallback, offline) { if (offline) this.aZ = new Offline(server, fallback); else this.aZ = new Comm(server, fallback) }; GameBase.prototype.CheckValidURL = function (url) { url = decodeURIComponent(url); for (var i = 0; i < url.length; i++) if (url.charAt(i) == "?") return true; return false }; GameBase.prototype.LoadConfigURL = function (vars) { this.aB = getUrlVars(); lang = this.aB.language; if (this.aB.limits != undefined) this.pw = this.aB.limits.split(","); this.bd = this.aB; if (this.bd.ticket == "") this.kA = false; else { this.kA = true; this.bd.ticket = decodeURIComponent(this.bd.ticket) } if (this.aB.lobby != "" && this.aB.lobby != undefined) this.cL = this.aB.lobby; if (this.aB.gameid != undefined && this.aB.gameid != "") this.cp = this.aB.gameid; if (this.aB.pid != undefined) this.im = this.aB.pid; if (this.aB.cashier != "" && this.aB.cashier != undefined) this.eg = this.aB.cashier; if (this.aB.help != "" && this.aB.help != undefined && this.CheckValidURL(this.aB.help)) this.ha = this.aB.help; if (this.aB.reloadgame != "" && this.aB.reloadgame != undefined) this.oi = this.aB.reloadgame; if (this.aB.practice != "" && this.aB.practice === "1") this.m_PracticeMode = true; if (this.aB.gamehistory != "" && this.aB.gamehistory != undefined) this.en = this.aB.gamehistory; if (this.aB.realitycheck != "" && this.aB.realitycheck != undefined) this.oz = Number(this.aB.realitycheck); if (this.aB.displayclock != undefined && this.aB.displayclock != "") this.eU = this.aB.displayclock == "true"; if (this.aB.minspinningtime != undefined) { this.fW = Number(this.aB.minspinningtime); if (this.fW < 1E3) this.fW = 1E3; else if (this.fW > 3E3) this.fW = 3E3 } if (this.aB.autospins != undefined) { this.iM = []; this.iM = this.aB.autospins.split(","); this.fh = 1 } if (this.aB.defaultautospins != undefined) { var defaultautospins = this.aB.defaultautospins; for (var i = 0; i < this.iM.length; i++) if (this.iM[i] == defaultautospins) this.fh = i + 1 } if (this.aB.autoplaylimits != undefined) this.m_AutoplayLimits = this.aB.autoplaylimits == true; if (this.aB.autoplayreset != undefined) this.m_AutoplayReset = this.aB.autoplayreset == true; if (typeof CreditFormatter != "undefined") CreditFormatter.Setup(this.aB.creditdisplay); if (this.aB.brand != undefined) this.lj = this.aB.brand; if (this.aB.topmenu != undefined) if (this.aB.topmenu == "true") this.ix = true; if (this.aB.iflink != undefined && this.aB.iflink != "0" && this.aB.iflink != "") this.ll = true; if (this.aB.canvas != "") if (this.aB.canvas == "1") { this.hw = true; CANVAS_SCRATCH_SUPPORT = this.hw; sjs.useCanvas = this.hw } else if (this.aB.canvas == "0") { this.hw = false; CANVAS_SCRATCH_SUPPORT = this.hw; sjs.useCanvas = this.hw } if (this.aB.cashierurlmode != undefined) this.gG = Number(this.aB.cashierurlmode); this.mv = Number(this.aB.defaultLimit || 0); this.lJ = Number(this.aB.denom || 1); this.mo = Number(this.aB.lines || 0); if (this.aB.settings != undefined && this.aB.settings != "") this.rU = decodeURIComponent(this.aB.settings); if (this.aB.showsplash != undefined) this.qh = this.aB.showsplash === "1"; this.gU = this.im * 10 - 8; setImagePath(this.aB.resourceroot); if (this.aZ == undefined) this.Connect(this.bd.server, this.bd.fallback, this.bd.offline > 0); if (this.aB.quickbetvalues != undefined) this.m_QuickBetValues = this.aB.quickbetvalues.split(","); var propName = Utils.hasOwnPropertyCaseInsensitive(this.aB, "autoadjustbet"); if (propName && this.bn.bG) { var propValue = this.aB[propName].toString().toLowerCase(); this.bn.bG.m_AutoAdjustBet = !JSON.parse(propValue) } propName = Utils.hasOwnPropertyCaseInsensitive(this.aB, "autohold"); if (propName && this.bn.bG) { var propValue = this.aB[propName].toString().toLowerCase(); this.bn.bG.m_AutoHold = !JSON.parse(propValue) } propName = Utils.hasOwnPropertyCaseInsensitive(this.aB, "nevergamble"); if (propName && this.bn.bG) { var propValue = this.aB[propName].toString().toLowerCase(); this.bn.bG.m_NeverGamble = !JSON.parse(propValue) } propName = Utils.hasOwnPropertyCaseInsensitive(this.aB, "quickstop"); if (propName) this.m_QuickStopEnabled = Boolean(Number(this.aB[propName])); return true }; GameBase.prototype.getAutoSpins = function () { return this.iM }; GameBase.prototype.getDefaultAutoSpins = function () { return this.fh }; GameBase.prototype.Fps = function () { var tick = false; var time = getTimer(); var diff = time - this.pq; this.gQ.push(diff); this.pq = time; if (this.gQ.length > 2) this.gQ.shift(); diff = 0; for (var i = 0; i < this.gQ.length; i++) diff += this.gQ[i]; diff /= this.gQ.length; if (this.kI == 0) { this.nP.T.text = "FPS: " + Math.round(1E3 * (1 / diff)); this.nP.T.update() } this.kI++; if (this.kI == 4) this.kI = 0 }; GameBase.prototype.DelayedInit = function () { InvalidatePage.Create(); OnLogout = LoginSubmitPointer.OnLogout; if (this.jQ != undefined) this.jQ.OverrideMenuCallbacks(this); if (this.po) { this.fps_layer = new sjs.Layer("fps"); this.nP = new Textfield(this.fps_layer, { x: 0, y: 0, w: 80, h: 20 }, undefined, "ffffff", "normal") } if (this.aM) { this.ai = new Orientation(this.bn); Orientation.ORIENTATIONOBJECT = this.ai } if (UAGENT_IE) if (window.innerHeight < window.innerWidth) this.ew = false; else this.ew = true; this.bz = new MiniLoader; var exitModalWinObj = new Object; exitModalWinObj.pos = modalwin_pos; exitModalWinObj.callback = Utils.delegate(this, this.GoToLobby); this.kD = new ExitQuestionModalWin(exitModalWinObj); var realityCheckModalWinObj = new Object; realityCheckModalWinObj.pos = modalwin_pos; this.lb = new RealityCheckModalWin(realityCheckModalWinObj); this.hG = new Object; this.hG.pos = modalwin_pos; this.sn = new MessageModalWin(this.hG); this.hQ.setTimeout(this.oz); this.dG = new Object; this.dG.title = " "; this.dG.message = " "; this.dG.pos = modalwin_pos; this.jm = new MessageModalWin(this.dG); if (SoundPlayer.CheckSoundSupport()) { var soundModalWinObj = new Object; soundModalWinObj.pos = modalwin_pos; soundModalWinObj.callback = Utils.delegate(this, this.SetInitialSound); this.lH = new SoundQuestionModalWin(soundModalWinObj) } if (this.ll) { var insFundsModalWinObj = new Object; insFundsModalWinObj.pos = modalwin_pos; insFundsModalWinObj.cancelCaption = pt_cashier_btn_cap; insFundsModalWinObj.callback = Utils.delegate(this, this.IfModalWinCb); this.om = new InsufficientFundsModalWin(insFundsModalWinObj) } var afgModalWinObj = new Object; afgModalWinObj.pos = modalwin_pos; afgModalWinObj.callback = Utils.delegate(this, this.AdditionalFgCallback); this.qF = new AdditionalFreegamesModalWin(afgModalWinObj); var inSessionFreeGameModalWinObj = new Object; inSessionFreeGameModalWinObj.pos = modalwin_pos; inSessionFreeGameModalWinObj.callback = Utils.delegate(this, this.InSessionFreeGameCallback); this.m_InSessionFreegamesModalWin = new InSessionFreeGameModalWin(inSessionFreeGameModalWinObj); this.gd = document.getElementById("username"); this.ir = document.getElementById("passw"); this.ml = document.getElementById("loaderContainer"); this.qJ = document.getElementById("loaderContainer").style.height; this.hT = document.getElementById("loginContainer"); this.pk = document.getElementById("login"); if (this.bd.login != "") if (this.kA == true || this.aB.practice == "1") { this.Login(this.bd.ticket, this.bd.login, this.bd.secure, this.bd.contextId); this.hT.style.display = "none"; this.bd.login = ""; this.bd.pwd = "" } else this.ShowLoginUI(); var useServerTime = Boolean(Number(this.aB.useservertime)); this.bn.m_GamePanelHandler.SetUseServerTime(useServerTime); HostInterface.gameReady = true }; GameBase.prototype.TryLogin = function (b) { if (b) { this.jz = false; this.hT.style.display = "none"; this.pk.style.display = "none"; this.hT.style.display = "none"; this.ml.style.display = "table"; days = 7; pwvalue = this.ir.value; this.Login(this.gd.value, this.ir.value, this.bd.secure, this.bd.contextId) } else { days = -1; pwvalue = "" } var date = new Date; date.setTime(date.getTime() + days * 24 * 60 * 60 * 1E3); var expires = "; expires=" + date.toGMTString(); document.cookie = "usrcookie=" + this.encrypt(this.gd.value, this.XORkey) + expires + "; path=/" }; GameBase.prototype.ShowLoginUI = function () { this.jz = true; var getcookie = document.cookie.match("(^|;) ?" + "usrcookie" + "=([^;]*)(;|$)"); if (this.bd.login != undefined) this.gd.value = this.bd.login; else if (document.cookie && getcookie) this.gd.value = this.decrypt(Str.Unescape(getcookie[2]), this.XORkey); else this.gd.value = ""; this.hT.style.display = "table"; this.pk.style.display = "table"; this.ml.style.display = "none"; this.ir.value = ""; if (this.bd.login != undefined && this.bd.pwd != undefined) { this.ir.value = this.bd.pwd; this.TryLogin(true) } }; GameBase.prototype.CalcProductGroup = function () { this.im = Math.floor((this.gU - 1) / 10) + 1 }; GameBase.CreateButtonReleaseHandler = function (b, f) { b.SetClickListener(f); b.SetClickListener(f, true) }; GameBase.prototype.Login = function (login, pwd, secureURL, contextId) { StatsHandler.ConnectingStart(); this.aZ.Send(Command.CREQUESTSESSION, this.gU, this.aB.language, this.cp, navigator.userAgent); this.aZ.Send(Command.CLOGIN, login, pwd, contextId); this.qd = login }; GameBase.prototype.SetTimeSyncState = function (state, delay) { this.lg = state; if (delay != undefined) this.pr = delay }; GameBase.prototype.BaseTicker = function () { SoundPlayer.MainLoop(); if (this.ew != undefined) if (UAGENT_IE) if (window.innerHeight < window.innerWidth) if (this.ew) { this.ew = false; this.ai.IEorientationChange(90) } else { this.ew = true; this.ai.IEorientationChange(90) } else if (window.innerHeight > window.innerWidth) if (!this.ew) { this.ew = true; this.ai.IEorientationChange(180) } else { this.ew = false; this.ai.IEorientationChange(180) } if (this.po) this.Fps(); if (this.V != undefined) if (this.V.GetEnabled()) this.V.Ticker(); if (!this.nr) if (this.CanShowWindow()) { this.nr = true; HostInterface.processGenericEvent({ type: "gameStarted" }) } if (this.CanShowWindow()) if (!this.oq && this.aM) { this.oq = true; if (window.innerWidth >= 960 && window.orientation == undefined && UAGENT_FIREFOX) this.ai.initOrientationCheck(true, true); else { this.ai.addOrientationListener(); this.ai.initOrientationCheck() } } if (this.bz != undefined) if (this.aZ.kj) { if (!this.bz.nZ) this.bz.Show(true); this.bz.bz.angle += 0.31; this.bz.bz.update() } else if (this.bz.nZ) this.bz.Show(false); if (this.cG) return false; if (this.lg > 0) { var time = this.eo = (new Date).getTime(); if (time - this.lastTimeSync > this.pr && TimeSync() && this.lg == GameBase.TIMESYNC_SERVER) TimeSyncStart() } if (this.aZ != undefined && !this.aZ.Ticker()) { this.cG = true; ServerMessage(this, Locale.IDS_SERVER_NOCONNECTION, Locale.IDS_SERVER_NOCONNECTIONTEXT, 4); this.KillLoader() } return true }; GameBase.prototype.KillLoader = function () { if (sjs.isPixi) if (!png_preloader.destroyed) show_game() }; GameBase.prototype.Ticker = function () { if (!this.BaseTicker()) { if (this.gs > 0 && this.cG) { this.gs = 0; this.cG = true; if (typeof ExitGame !== "undefined") ExitGame(); else if ((this.cL == "" || this.cL == undefined) && !this.m_ExternalRedirect) history.back(); else if (this.m_ExternalRedirect) HostInterface.processGenericEvent({ type: HostInterface.CALL_SYSTEM_LOGOUT }); else location.href = decodeURIComponent(this.cL) } return false } var cmd = this.aZ.GetMoneyCommand(); if (cmd != null) if (!this.qI) this.ProcessCommand(cmd); else this.rk = cmd; if (this.aZ.kL) { cmd = this.aZ.GetProjectionCommand(); if (cmd != null) this.ProcessCommand(cmd) } var time = (new Date).getTime(); if (JackpotHandler) JackpotHandler.tick(time); if (this.gs > 0) { if (this.gs - time < 0 || this.aZ.IsFlushed()) { this.gs = 0; this.cG = true; if (typeof ExitGame !== "undefined") ExitGame(); else if (this.cL == "" && !this.m_ReloadGame && !this.m_ExternalRedirect) history.back(); else if (this.m_ExternalRedirect) HostInterface.processGenericEvent({ type: HostInterface.CALL_SYSTEM_LOGOUT }); else if (this.m_ReloadGame) window.location.href = decodeURIComponent(this.oi); else location.href = decodeURIComponent(this.cL) } return false } return true }; GameBase.prototype.OnLogout = function (skipSetTimer, externalRedirect) { var that = LoginSubmitPointer; this.m_ExternalRedirect = externalRedirect; that.aZ.Send(Command.CLOGOUT); if (!skipSetTimer) that.gs = getTimer() + 2E3 }; GameBase.prototype.TimeSync = function () { return this.gr == 3 }; GameBase.prototype.GetServerTime = function () { return this.eo + this.lF }; GameBase.prototype.TimeSyncStart = function () { this.eo = (new Date).getTime(); this.aZ.Send(126, this.eo / 10, 0, 0, 0); this.gr = 1; this.mF = 0; this.gK = -1; this.lastTimeSync = (new Date).getTime() }; GameBase.prototype.TimeSyncTick = function (s) { switch (this.gr) { case 1: var time1 = s.GetInt(1); var s_time1 = s.GetInt(2); this.eo = (new Date).getTime(); var time2 = eo / 10; this.aZ.Send(126, time1, s_time1, time2, 0); this.gr++; break; case 2: var time1 = s.GetInt(1); var s_time1 = s.GetInt(2); var time2 = s.GetInt(3); var s_time2 = s.GetInt(4); var c_diff = time2 - time1; var s_diff = s_time2 - s_time1; var symDiff = Math.abs(c_diff - s_diff); if (symDiff < this.gK || this.gK < 0) { var tmp = s_time1 - time2 + (c_diff + s_diff) / 4; this.gK = symDiff; this.nS = tmp * 10 } if (this.gK > 50 && this.mF < 3) { this.mF++; this.eo = (new Date).getTime(); this.aZ.Send(126, this.eo / 10, 0, 0, 0); this.gr = 1; break } else { this.lF = this.nS; this.gr++ } break } }; GameBase.prototype.BaseProcessCommand = function (cmd) { switch (cmd.ae) { case 126: TimeSyncTick(cmd); break; case Command.SLOGINANSWER: this.iK = cmd.GetInt(0); if (this.aB.gamehistory != "" && this.aB.gamehistory != undefined) this.en = decodeURIComponent(this.aB.gamehistory) + "?pid=" + this.gU + "&custid=" + this.iK + "&lang=" + this.aB.language + "&gameid=" + this.cp; if (this.iK == 0) if (this.kA) { this.cG = true; var errorMsg = cmd.GetString(1); if (errorMsg != "" && errorMsg != "undefined") ServerMessage(this, Locale.IDS_SERVER_NOLOGIN, errorMsg, 4); else ServerMessage(this, Locale.IDS_SERVER_NOLOGIN, Locale.IDS_SERVER_NOLOGINTEXT, 4); this.KillLoader() } else { var errorMsg = cmd.GetString(1); if (errorMsg != "" && errorMsg != "undefined") ServerMessage(this, Locale.IDS_SERVER_NOLOGIN, errorMsg, 1); else ServerMessage(this, Locale.IDS_SERVER_NOLOGIN, Locale.IDS_SERVER_NOLOGINTEXT, 1); if (document.cookie) this.TryLogin(false); document.getElementById("loginlabel").textContent = "Wrong username or password"; this.ShowLoginUI(); this.KillLoader() } break; case Command.SSPGAMESESSIONID: if (this.rw) this.pP = cmd.GetInt(0); HostInterface.processGenericEvent({ type: HostInterface.CALL_GAME_SESSION_ID, data: cmd.GetInt(0) }); break; case Command.SNEWSESSIONID: HostInterface.processGenericEvent({ type: HostInterface.CALL_SESSION_ID, data: cmd.GetString(0) }); StatsHandler.ConnectingComplete(); break; case Command.SNEWSPGAMESTARTED: if (cmd.GetInt(0) != 1) { this.cG = true; ServerMessage(this, Locale.IDS_SERVER_NOGAME, Locale.IDS_SERVER_NOGAMETEXT, 4); this.KillLoader() } break; case Command.SMPGAMEJOINED: if (cmd.GetInt(0) != 1) { this.cG = true; ServerMessage(this, Locale.IDS_SERVER_NOGAME, Locale.IDS_SERVER_NOGAMETEXT, 4); this.KillLoader() } break; case Command.SSERVERMESSAGE: ServerMessage(this, cmd.GetString(1), cmd.GetString(2), cmd.GetInt(3)); break; case Command.SSEATINFO: if (this.iK == cmd.GetInt(1)) this.uK = cmd.GetInt(0); OnSeatInfo(cmd.GetInt(0), cmd.GetString(2)); break; case Command.SRECONNECTEND: this.C = false; this.kP = 2; SoundPlayer.ReconnectEnd(); if (SoundPlayer.CheckSoundSupport()) this.lH.Show(true); break; case Command.SCRITICALERROR: this.cG = true; ServerMessage(this, Locale.IDS_SERVER_ERROR, Locale.IDS_SERVER_ERRORTEXT, 4); this.KillLoader(); break; case Command.SILLEGALSESSIONID: this.cG = true; ServerMessage(this, Locale.IDS_SERVER_NOSESSION, Locale.IDS_SERVER_NOSESSIONTEXT, 4); this.KillLoader(); break; case Command.SLOGOUTANSWER: break; default: break } }; GameBase.prototype.OnFundsError = function (reason) { if (this.bn.OnFundsError) this.bn.OnFundsError(reason) }; GameBase.prototype.ProcessCommand = function (cmd) { this.BaseProcessCommand(cmd); switch (cmd.ae) { case Command.SSPFUNDSERROR: var ROUND_BET_LIMIT_EXCEEDED = 3; if (cmd.GetInt(1) !== ROUND_BET_LIMIT_EXCEEDED) { var errorMsg = cmd.GetString(3); var eFlag = errorMsg != "" && errorMsg != undefined && errorMsg != "undefined"; var title = Locale.IDS_SERVER_NOMONEY; if (cmd.GetInt(0) > 0) title = Locale.IDS_SERVICEMSG_TITLE; if (this.ll && !this.fi && cmd.GetInt(0) < 0) this.om.Show(true); else ServerMessage(this, title, eFlag ? errorMsg : Locale.IDS_SERVER_NOMONEYTEXT, 1) } this.OnFundsError(cmd.GetInt(1)); break; case Command.SLOGINANSWER: if (this.iK > 0) { if (this.cW == undefined) { this.cW = cmd.GetData(1); if (this.cW == "DEMO") { this.fi = true; this.cW = "" } if (JackpotHandler) JackpotHandler.SetCurrency(this.cW); Utils.SetCurrencyDefaults(this.cW); this.OnCurrency(); this.SetBalanceText(); if (JackpotHandler && JackpotHandler.setForFun) JackpotHandler.setForFun(this.fi); if (JackpotHandler && JackpotHandler.setDemoMode) JackpotHandler.setDemoMode(this.fi); if (this.bn.SetCurrency) this.bn.SetCurrency(this.cW); var rawIDString = cmd.GetString(2); if (rawIDString != "undefined") { var tmpArray = rawIDString.split("#"); var ticketId = tmpArray[1]; var sessionId = tmpArray[0]; this.oD = new IDSplash(ticketId, sessionId); IDSplash.OnOrientationChange(Orientation.ORIENTATIONOBJECT.bF) } } this.aZ.Send(Command.CNEWSPGAME, this.cp, 0, this.rU) } break; case Command.SRECONNECTEND: if (JackpotHandler) JackpotHandler.ReconnectEnd(); if (this.bn.bX && !this.lk) this.bn.bX.Show(true); else if (this.bn.bX && this.lk) { this.bn.bX.RemoveSplashFromDOM(); this.bn.bX = null } if (this.oD && !this.fc) this.oD.Show(true); else IDSplash.WaitingConfirm = false; break; case Command.SSPBUYINSTATUS: var newBalance = cmd.GetMoney(0); var serverInGame = cmd.GetInt(1); if (!serverInGame && this.cn) { if (this.m_NeedsRoundEndBalance) this.gj = newBalance } else { this.co = newBalance; if (this.fc) this.es = this.co - this.dh; else this.es = this.co; this.SetBalanceText() } this.m_NeedsRoundEndBalance = true; if (!this.cn) this.ShowNewGame(); break; case Command.SSPBETLIMITS: if (this.oC != undefined) this.oC.ReadLimits(cmd); break; case Command.SSPJACKPOTPROJECTION: JackpotHandler.ReadJackpot(cmd); break; case Command.SSPINTERROUNDDATA: this.bn.OnInterRoundData(cmd); break; case Command.SSERVERTIME: if (this.eU) this.bn.m_GamePanelHandler.SetServerTime(cmd.GetString(0)); break } }; GameBase.prototype.RoundStart = function (inGame) { this.lk = true; var updateBalance = true; if (this.bn.bb) updateBalance = !this.bn.bb.Active(); if (inGame == undefined) inGame = true; this.cn = inGame; if (this.cn && !this.fc) HostInterface.processRoundEvent({ type: HostInterface.CALL_ROUND_STARTED }); else if (!this.cn) HostInterface.processRoundEvent({ type: HostInterface.CALL_ROUND_ENDED }); if (this.cn && updateBalance) this.es = this.co - this.dh; if (!this.fc) { this.fc = true; this.SetBalanceText() } if (inGame && !this.mu) { this.mu = true; if (!this.C) this.SetTickerText(Locale.IDS_MSG_GOODLUCK, GameBase.MSG_INFORMATION) } this.hQ.handleEventRoundStart(this.dh, this.cn) }; GameBase.prototype.AbortRound = function () { this.fc = false; this.cn = false; if (this.gj >= 0) { this.co = this.gj; this.gj = -1 } this.es = this.co; this.SetBalanceText(); this.hQ.handleEventRoundAbort(this.cn); HostInterface.processRoundEvent({ type: HostInterface.CALL_ROUND_ABORTED }) }; GameBase.prototype.RoundEnd = function (win, stayInGame) { if (this.fc) { this.fc = false; if (stayInGame == undefined || stayInGame == false) this.cn = false; this.m_NeedsRoundEndBalance = true; this.bS = (new Date).getTime(); if (win > 0) if (!this.ny || win > this.dh) { if (this.ny) this.kR = Locale.IDS_MSG_YOUWON + Utils.MoneyToString(win - this.dh); else this.kR = Locale.IDS_MSG_YOUWON + Utils.MoneyToString(win); this.kH = GameBase.MSG_WIN; this.tk = false; this.SetTickerText(this.kR, this.kH); HostInterface.processRoundEvent({ type: HostInterface.CALL_ROUND_WIN, data: win }) } if (this.gj >= 0) { this.co = this.gj; this.gj = -1 } else { var updateBalance = true; if (this.bn.bb) updateBalance = !this.bn.bb.Active(); if (updateBalance) this.co -= this.dh; this.co += win; this.m_NeedsRoundEndBalance = false } this.es = this.co; this.SetBalanceText(); if (!this.fi) this.cQ = Utils.MoneyToString(this.co) + " " + this.cW; this.mu = false } if (JackpotHandler && JackpotHandler.RoundEnd) JackpotHandler.RoundEnd(); this.dI = win; this.hQ.handleEventRoundEnd(win, this.cn); HostInterface.processRoundEvent({ type: HostInterface.CALL_ROUND_ENDED }) }; GameBase.prototype.SetBalanceText = function () { var updateBalanceText = true; if (this.bn.bb) updateBalanceText = !this.bn.bb.Active(); if (updateBalanceText) { var balance = 0; if (this.fc) balance = this.es; else balance = this.co; if (isNaN(balance)) this.bn.bu.m_GamePanelHandler.setBalance(" "); else this.bn.UpdateGamePanel(balance); HostInterface.processRoundEvent({ type: HostInterface.CALL_ROUND_BALANCE_UPDATE, balance: balance, balanceString: Utils.MoneyToString(balance), currency: Utils.cW }) } }; GameBase.prototype.ShowNewGame = function () { this.cn = false; this.fc = false }; GameBase.prototype.OnCurrency = function () { }; GameBase.prototype.SetBet = function (bet, keepWin) { this.dh = bet; this.bS = (new Date).getTime(); this.kR = Locale.IDS_MSG_BET + Utils.MoneyToString(bet); this.kH = GameBase.MSG_BET; this.tk = false; var updateBalance = true; if (this.bn.bb) updateBalance = !this.bn.bb.Active(); if (this.fc && updateBalance) { this.es = this.co - this.dh; this.SetBalanceText() } if (!this.cn && this.dh > 0 && !this.C) this.SetTickerText(this.kR, this.kH) }; GameBase.prototype.SetTickerText = function (s, type) { if (this.V != undefined) this.V.ShowMessage({ Message: s, Type: type == GameBase.MSG_BALANCE ? MESSAGE_MESSAGE : MESSAGE_INSTANT }) }; GameBase.prototype.ShowLobbyConfirmation = function () { this.kD.Show() }; GameBase.prototype.ShowRealityCheck = function (eWin, eBet, eMinutes) { var str = ""; var str1 = ""; var minuteString = ""; var str2 = ""; var str3 = ""; var str4 = ""; str1 = Locale.IDS_RC_PLAYTIME; if (eMinutes > 1) minuteString = Locale.IDS_RC_MINUTES; else minuteString = Locale.IDS_RC_MINUTE; str2 = Locale.IDS_RC_WON; str3 = Locale.IDS_RC_LOST; str4 = Locale.IDS_RC_CONTINUE; str1 = str1.replace("%d", eMinutes); str1 = str1.replace("%x", minuteString); str2 = str2.replace("%x", Utils.MoneyToString(eWin)); str3 = str3.replace("%x", Utils.MoneyToString(eBet)); str += str1 + "<br/>" + str2 + "<br/>" + str3 + "<br/>" + str4; this.hG.title = Locale.IDS_RC_HEADING; this.hG.message = str; this.hG.callback = Utils.delegate(this, this.RealityCheckExitCallback); this.lb.SetMessageData(this.hG); this.lb.Show() }; GameBase.prototype.OnReloadGame = function (b) { this.OnLogout(); InvalidatePage(undefined, true); this.m_ReloadGame = true }; GameBase.prototype.AdditionalFgCallback = function (b) { this.qF.Hide(); if (b) this.OnReloadGame(); else this.bn.bb.OnAdditionalFgDeclined() }; GameBase.prototype.InSessionFreeGameCallback = function (b) { if (b) this.OnReloadGame(); else this.m_InSessionFreegamesModalWin.Hide() }; GameBase.prototype.SetInitialSound = function (b) { if (UAGENT_IPAD || UAGENT_IPHONE) SoundPlayer.Play(-1); SoundPlayer.ToggleOnOff(b); if (b) StatsHandler.HandleEvent("initialsoundon"); else StatsHandler.HandleEvent("initialsoundoff"); if (this.bn.SetInitialSound) this.bn.SetInitialSound(b) }; GameBase.prototype.GoToLobby = function (b) { if (!b) { this.kD.Show(); return } this.OnLogout(); InvalidatePage(undefined, true) }; GameBase.prototype.RealityCheckExitCallback = function (b) { if (!b) return; this.OnLogout(); InvalidatePage(undefined, true) }; GameBase.prototype.OpenGameRulesPage = function () { if (this.ha != "") { StatsHandler.HandleEvent("showhelp"); if (this.gG == 1) { this.OnLogout(true); InvalidatePage(undefined, true); window.location.href = decodeURIComponent(this.ha) + "&method=href&currency=" + this.cW } else { var gamerules = window.open(decodeURIComponent(this.ha) + "&method=open&currency=" + this.cW, "_blank"); if (gamerules == undefined) { this.dG.title = Locale.IDS_BTN_GAME_RULES; this.dG.message = Locale.IDS_TURNOFFBLOCKER; this.dG.pos = modalwin_pos; this.jm.SetMessageData(this.dG); this.jm.Show(true) } } } }; GameBase.prototype.OpenGameHistoryPage = function () { if (this.en != "") if (this.gG == 1) { this.OnLogout(true); InvalidatePage(undefined, true); window.location.href = decodeURIComponent(this.en) + "&method=href" } else { var gamehist = window.open(decodeURIComponent(this.en) + "&method=open", "_blank"); if (gamehist == undefined) { this.dG.title = Locale.IDS_BTN_GAMEHISTORY; this.dG.message = Locale.IDS_TURNOFFBLOCKER; this.dG.pos = modalwin_pos; this.jm.SetMessageData(this.dG); this.jm.Show(true) } } }; GameBase.prototype.IfModalWinCb = function (b) { if (b) this.OpenCashierPage() }; GameBase.prototype.OpenCashierPage = function () { if (this.eg != "") if (this.fi) { if (this.gG == 1) { this.OnLogout(true); InvalidatePage(undefined, true) } window.location.href = decodeURIComponent(this.eg) } else if (this.gG == 1) { this.OnLogout(true); InvalidatePage(undefined, true); window.location.href = decodeURIComponent(this.eg) } else window.open(decodeURIComponent(this.eg), "_blank") }; GameBase.prototype.encrypt = function (str, pwd) { if (pwd == null || pwd.length <= 0) return null; var prand = ""; for (var i = 0; i < pwd.length; i++) prand += pwd.charCodeAt(i).toString(); var sPos = Math.floor(prand.length / 5); var mult = parseInt(prand.charAt(sPos) + prand.charAt(sPos * 2) + prand.charAt(sPos * 3) + prand.charAt(sPos * 4) + prand.charAt(sPos * 5)); var incr = Math.ceil(pwd.length / 2); var modu = Math.pow(2, 31) - 1; if (mult < 2) return null; var salt = Math.round(Math.random() * 1E9) % 1E8; prand += salt; while (prand.length > 10) prand = (parseInt(prand.substring(0, 10)) + parseInt(prand.substring(10, prand.length))).toString(); prand = (mult * prand + incr) % modu; var enc_chr = ""; var enc_str = ""; for (var i = 0; i < str.length; i++) { enc_chr = parseInt(str.charCodeAt(i) ^ Math.floor(prand / modu * 255)); if (enc_chr < 16) enc_str += "0" + enc_chr.toString(16); else enc_str += enc_chr.toString(16); prand = (mult * prand + incr) % modu } salt = salt.toString(16); while (salt.length < 8) salt = "0" + salt; enc_str += salt; return enc_str }; GameBase.prototype.decrypt = function (str, pwd) { if (str == null || str.length < 8) return; if (pwd == null || pwd.length <= 0) return; var prand = ""; for (var i = 0; i < pwd.length; i++) prand += pwd.charCodeAt(i).toString(); var sPos = Math.floor(prand.length / 5); var mult = parseInt(prand.charAt(sPos) + prand.charAt(sPos * 2) + prand.charAt(sPos * 3) + prand.charAt(sPos * 4) + prand.charAt(sPos * 5)); var incr = Math.round(pwd.length / 2); var modu = Math.pow(2, 31) - 1; var salt = parseInt(str.substring(str.length - 8, str.length), 16); str = str.substring(0, str.length - 8); prand += salt; while (prand.length > 10) prand = (parseInt(prand.substring(0, 10)) + parseInt(prand.substring(10, prand.length))).toString(); prand = (mult * prand + incr) % modu; var enc_chr = ""; var enc_str = ""; for (var i = 0; i < str.length; i += 2) { enc_chr = parseInt(parseInt(str.substring(i, i + 2), 16) ^ Math.floor(prand / modu * 255)); enc_str += String.fromCharCode(enc_chr); prand = (mult * prand + incr) % modu } return enc_str }; GameBase.prototype.getBalance = function () { return this.co }; GameBase.prototype.GetBalance = function () { var o = {}; o.BalanceInMoney = Utils.MoneyToString(this.getBalance()); o.Currency = Utils.cW; return o }; GameBase.prototype.GetBet = function () { var o = {}; o.BetInMoney = Utils.MoneyToString(this.dh); o.Currency = Utils.cW; return o }; GameBase.prototype.GetWin = function () { var o = {}; o.WinInMoney = Utils.MoneyToString(this.dI); o.Currency = Utils.cW; return o }; GameBase.prototype.getCurrentFunds = function () { return this.es }; GameBase.prototype.SetHandleJPProjectionSeparately = function (b) { this.aZ.kL = b }; GameBase.prototype.ReadSoundCookie = function () { var gameid = this.cp; var idString = "soundenablecookie_" + gameid; var cookieValue = null; var getcookie = document.cookie.match("(^|;) ?" + idString + "=([^;]*)(;|$)"); if (getcookie) cookieValue = Str.Unescape(getcookie[2]); if (getcookie) return cookieValue == "1"; return false }; GameBase.prototype.SaveSoundCookie = function () { var amountOfDays = 1E3; var date = new Date; date.setTime(date.getTime() + amountOfDays * 24 * 60 * 60 * 1E3); var expires = "; expires=" + date.toGMTString(); var idString = "soundenablecookie_" + this.cp; var soundEnable = SoundPlayer.GetEnabled() ? 1 : 0; document.cookie = idString + "=" + soundEnable + expires + "; path=/" }; GameBase.prototype.ReadLeftHandModeCookie = function () { var gameid = this.cp; var idString = "lefthandmodecookie_" + gameid; var cookieValue = null; var getcookie = document.cookie.match("(^|;) ?" + idString + "=([^;]*)(;|$)"); if (getcookie) { cookieValue = Str.Unescape(getcookie[2]); return cookieValue == "1" } return false }; GameBase.prototype.SaveLeftHandModeCookie = function (value) { var amountOfDays = 1E3; var date = new Date; date.setTime(date.getTime() + amountOfDays * 24 * 60 * 60 * 1E3); var expires = "; expires=" + date.toGMTString(); var idString = "lefthandmodecookie_" + this.cp; var leftHandModeEnable = value ? 1 : 0; document.cookie = idString + "=" + leftHandModeEnable + expires + "; path=/"; return leftHandModeEnable }; GameBase.prototype.OnBalanceRefresh = function () { if (!this.C && this.gs == 0 && !this.cG) this.aZ.Send(Command.CREQSPBUYINSTATUS) }; function _Input() { } var inputSingleton = new _Input; function Input() { return inputSingleton }; _Input.prototype.addEvent = function (that) { if (that.T.dom.addEventListener !== undefined && !("ontouchstart" in window)) that.T.dom.addEventListener("click", that.aC, false); else if (that.T.dom.attachEvent !== undefined) that.T.dom.attachEvent("onclick", that.aC, false); else if (UAGENT_NO_TOUCH_SUPPORT || UAGENT_FIREFOX && !UAGENT_SAMSUNG_G_TAB) that.T.dom.addEventListener("click", that.aC, false); else that.ListenForTouch(that.aC) }; _Input.prototype.addEvent2 = function (that) { if (that.T.dom.addEventListener !== undefined && !("ontouchstart" in window)) that.T.dom.addEventListener("click", that.aC, false); else if (that.T.dom.attachEvent !== undefined) that.T.dom.attachEvent("onclick", that.aC, false); else if (UAGENT_NO_TOUCH_SUPPORT || UAGENT_FIREFOX && !UAGENT_SAMSUNG_G_TAB) that.T.dom.addEventListener("click", that.SetFocus, false); else that.ListenForTouch(that.SetFocus) }; _Input.prototype.addEvent3 = function (that, obj) { if (that.T.dom.addEventListener !== undefined && !("ontouchstart" in window)) obj.dom.addEventListener("click", that.aC, false); else if (that.T.dom.attachEvent !== undefined) obj.dom.attachEvent("onclick", that.aC, false); else if (UAGENT_NO_TOUCH_SUPPORT || UAGENT_FIREFOX && !UAGENT_SAMSUNG_G_TAB) obj.dom.addEventListener("click", that.aC, false); else that.ListenForTouch(that.aC, obj) }; _Input.prototype.removeEvent = function (that) { if (that.T.dom.addEventListener !== undefined && !("ontouchstart" in window)) that.T.dom.removeEventListener("click", that.aC, false); else if (that.T.dom.attachEvent !== undefined) that.T.dom.detachEvent("onclick", that.aC, false); else if (UAGENT_NO_TOUCH_SUPPORT || UAGENT_FIREFOX && !UAGENT_SAMSUNG_G_TAB) that.T.dom.removeEventListener("click", that.aC, false); else { that.T.dom.ontouchstart = null; that.T.dom.ontouchmove = null; that.T.dom.ontouchend = null; that.T.dom.ontouchcancel = null } }; _Input.prototype.removeEvent2 = function (that) { if (that.T.dom.addEventListener !== undefined && !("ontouchstart" in window)) that.T.dom.removeEventListener("click", that.aC, false); else if (that.T.dom.attachEvent !== undefined) that.T.dom.detachEvent("onclick", that.aC, false); else if (UAGENT_NO_TOUCH_SUPPORT || UAGENT_FIREFOX && !UAGENT_SAMSUNG_G_TAB) that.T.dom.removeEventListener("click", that.SetFocus, false); else { that.ld.dom.ontouchstart = null; that.ld.dom.ontouchmove = null; that.ld.dom.ontouchend = null; that.ld.dom.ontouchcancel = null; that.T.dom.ontouchstart = null; that.T.dom.ontouchmove = null; that.T.dom.ontouchend = null; that.T.dom.ontouchcancel = null } }; _Input.prototype.removeEvent3 = function (that, obj) { if (that.T.dom.addEventListener !== undefined && !("ontouchstart" in window)) obj.dom.removeEventListener("click", that.aC, false); else if (that.T.dom.attachEvent !== undefined) obj.dom.detachEvent("onclick", that.aC, false); else if (UAGENT_NO_TOUCH_SUPPORT || UAGENT_FIREFOX && !UAGENT_SAMSUNG_G_TAB) obj.dom.removeEventListener("click", that.aC, false); else { obj.dom.ontouchstart = null; obj.dom.ontouchmove = null; obj.dom.ontouchend = null; obj.dom.ontouchcancel = null } }; Orientation.iframewasshowing = false; var IE_LANDSCAPE_SCALE = 0.91; Orientation.GAME = undefined; Orientation.ORIENTATIONOBJECT = undefined; function Orientation(game) { var oB = false; var eZ; var G = game; var that = this; this.bF = true; var kv = false; this.cp = G.O.cp; Orientation.GAME = game; if (!UAGENT_IPHONE && !UAGENT_IPAD && !UAGENT_ANDROID_422) { if (screen.availHeight < screen.availWidth && (window.orientation == 0 || window.orientation == 180)) kv = true; if (screen.availHeight > screen.availWidth && (window.orientation == 90 || window.orientation == -90)) kv = true } var ResizeExternalPopup = function (src) { var iFrame = document.getElementById("extPopup"); if (iFrame != undefined) { var width = Utils.eD; if (!that.bF) width = Utils.eD == 640 ? 960 : 480; if (UAGENT_IPAD || UAGENT_SAMSUNG_G_TAB || UAGENT_FIREFOX) width = window.innerWidth; iFrame.style.width = width + "px"; hideAddressBar(); if (Orientation.iframewasshowing && game.O.gy) { game.O.gy.Show(true, src, true); Orientation.iframewasshowing = false } } }; var hideAddressBar = function () { if (navigator.userAgent.toLowerCase().indexOf("blackberry") > 0) setTimeout("window.scrollTo(0,1)", 800); else setTimeout("window.scrollTo(0,1)", 800) }; this.IEorientationChange = function (o) { if (oB) onOrientationChange(o) }; var onOrientationChange = function (o) { if (UAGENT_IPAD || UAGENT_IPHONE) { var inputfields = document.getElementsByClassName("form_style"); for (var i = 0; i < inputfields.length; i++) inputfields[i].blur() } if (game.O.gy && game.O.gy.fp) { Orientation.iframewasshowing = true; var src = game.O.gy.sT; game.O.gy.Show(false, undefined, true); ResizeExternalPopup(src); return } if (UAGENT_IE) window.orientation = o; if (window.orientation == eZ && window.orientation != undefined) return; if (!kv) switch (window.orientation) { case 0: that.bF = true; eZ = 0; break; case 180: that.bF = true; eZ = 180; break; case 90: that.bF = false; eZ = 90; break; case -90: that.bF = false; eZ = -90; break } else switch (window.orientation) { case 90: that.bF = true; eZ = 90; break; case -90: that.bF = true; eZ = -90; break; case 0: that.bF = false; eZ = 0; break; case 180: that.bF = false; eZ = 180; break } setTimeout(function () { G.HandleOrientationChange(o) }, 300); if (typeof ModalWin != "undefined") ModalWin.OnOrientationChange(that.bF); if (typeof IDSplash != "undefined") IDSplash.OnOrientationChange(that.bF) }; this.initOrientationCheck = function (desktopBrowser, landscape) { if (!Utils.OldGame(this.cp)) return; oB = true; if (desktopBrowser) if (landscape) { that.bF = false; G.HandleOrientationChange(window.orientation) } else { that.bF = true; G.HandleOrientationChange(window.orientation) } else { if (UAGENT_IE) return; onOrientationChange() } }; this.addOrientationListener = function () { if (Utils.OldGame(this.cp)) { var supportsOrientationChange = "onorientationchange" in window, orientationEvent = supportsOrientationChange ? "orientationchange" : "resize"; window.addEventListener(orientationEvent, onOrientationChange, false) } } }; Orientation.ChangeOrientation = function (orientation) { if (Orientation.GAME == undefined) { var orientation = orientation; setTimeout(function () { Orientation.ChangeOrientation(orientation) }, 100); return } if (orientation == "pt") Orientation.ORIENTATIONOBJECT.bF = true; else Orientation.ORIENTATIONOBJECT.bF = false; Orientation.GAME.HandleOrientationChange(); if (typeof ModalWin != "undefined") ModalWin.OnOrientationChange(Orientation.ORIENTATIONOBJECT.bF); if (typeof IDSplash != "undefined") IDSplash.OnOrientationChange(Orientation.ORIENTATIONOBJECT.bF) }; var N_ZERO = 0; var N_ONE = 1; var N_TWO = 2; var N_THREE = 3; var N_FOUR = 4; var N_FIVE = 5; var N_SIX = 6; var N_SEVEN = 7; var N_EIGHT = 8; var N_NINE = 9; var N_TEN = 10; var N_ELEVEN = 11; var N_TWELVE = 12; var N_THIRTEEN = 13; var N_FOURTEEN = 14; var N_FIFTEEN = 15; var N_SIXTEEN = 16; var N_SEVENTEEN = 17; var N_EIGHTEEN = 18; var N_NINETEEN = 19; var N_TWENTY = 20; var N_HALF = 0.5; var N_THREESIXTY = 360; var N_ONEEIGHTY = 180; var N_NINETY = 90; VALUES = {}; VALUES.MIN_HEIGHT = 834; VALUES.MAX_GP_SCALE_HEIGHT = 880; VALUES.TOPFILL = 466; function setMainValues() { if (DEVICE.orientation == "pt") { var uiscale = DEVICE[DEVICE.orientation].w / 800 * 1.25; gamepanel_pos.game_panel_layer_pos.pt.scale.x = uiscale; gamepanel_pos.buttons.pt.layer.scale.x = uiscale; if (gamepanel_pos.game_panel_layer_pos.pt.scale.x > 1) { gamepanel_pos.game_panel_layer_pos.pt.scale.y = gamepanel_pos.game_panel_layer_pos.pt.scale.x; gamepanel_pos.buttons.pt.layer.scale.y = gamepanel_pos.buttons.pt.layer.scale.x } else if (DEVICE[DEVICE.orientation].h >= VALUES.MIN_HEIGHT && DEVICE[DEVICE.orientation].h <= VALUES.MAX_GP_SCALE_HEIGHT) { gamepanel_pos.game_panel_layer_pos.pt.scale.y = (DEVICE[DEVICE.orientation].h - VALUES.MIN_HEIGHT) * (1 / 92) + 1; gamepanel_pos.buttons.pt.layer.scale.y = gamepanel_pos.game_panel_layer_pos.pt.scale.y; gamepanel_pos.textscale.pt.y = 1 - (gamepanel_pos.game_panel_layer_pos.pt.scale.y - 1) } else if (DEVICE[DEVICE.orientation].h > VALUES.MAX_GP_SCALE_HEIGHT) { gamepanel_pos.game_panel_layer_pos.pt.scale.y = 1.5; gamepanel_pos.buttons.pt.layer.scale.y = 1.5; gamepanel_pos.textscale.pt.y = 0.65 } else { gamepanel_pos.game_panel_layer_pos.pt.scale.y = 1; gamepanel_pos.textscale.pt.y = 1 } scale_layer_pos.pt.scale = DEVICE[DEVICE.orientation].w / 800; gamepanel_pos.game_panel_layer_pos.pt.x = DEVICE[DEVICE.orientation].w / 2 - gamepanel_pos.game_panel_layer_pos.pt.w / 2; gamepanel_pos.game_panel_layer_pos.pt.y = DEVICE[DEVICE.orientation].h - gamepanel_pos.game_panel_layer_pos.pt.h * 2; gamepanel_pos.buttons.pt.layer.x = DEVICE[DEVICE.orientation].w / 2 - gamepanel_pos.game_panel_layer_pos.pt.w / 2; gamepanel_pos.buttons.pt.layer.y = DEVICE[DEVICE.orientation].h - gamepanel_pos.game_panel_layer_pos.pt.h; gamepanel_pos.buttons.pt.layer.w = 640; gamepanel_pos.game_panel_shadow.pt.w = 640; VALUES.GAMEPANELDIFF = 132 - 132 * gamepanel_pos.game_panel_layer_pos.pt.scale.y; scale_layer_pos.pt.h = 1150; scale_layer_pos.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y - (1150 - VALUES.GAMEPANELDIFF); scale_layer_pos.pt.x = DEVICE[DEVICE.orientation].w / 2 - 1260 / 2; menu_pos.layer.pt.w = DEVICE[DEVICE.orientation].w; menu_pos.layer.pt.h = DEVICE[DEVICE.orientation].h; menu_pos.catpanel.layer.pt.scale.x = uiscale; menu_pos.catpanel.layer.pt.x = DEVICE[DEVICE.orientation].w / 2 - menu_pos.catpanel.layer.pt.w / 2; menu_pos.catpanel.layer.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y - (menu_pos.catpanel.layer.pt.h - VALUES.GAMEPANELDIFF); menu_pos.catpanel.btn.pos.scale.pt.x = 1 / uiscale; menu_pos.catpanel.btn.pos.cap_adj.pt.x = 64 / uiscale; menu_pos.contwin.layer.pt.w = 640; menu_pos.contwin.layer.pt.h = 834; if (DEVICE[DEVICE.orientation].w < 640) { menu_pos.contwin.layer.pt.scale.x = DEVICE[DEVICE.orientation].w / 640; menu_pos.contwin.layer.pt.scale.y = DEVICE[DEVICE.orientation].w / 640; menu_pos.contwin.layer.pt.y = -50 / menu_pos.contwin.layer.pt.scale.y } if (DEVICE[DEVICE.orientation].w > 640 && UAGENT_IE11) { menu_pos.contwin.layer.pt.scale.x = DEVICE[DEVICE.orientation].w / 640; menu_pos.contwin.layer.pt.scale.y = DEVICE[DEVICE.orientation].w / 640; menu_pos.contwin.layer.pt.y = 200 } menu_pos.contwin.layer.pt.x = DEVICE[DEVICE.orientation].w / 2 + 35 * menu_pos.contwin.layer.pt.scale.y - menu_pos.contwin.layer.pt.w / 2; menu_pos.contwin.bgr.pt.w = DEVICE[DEVICE.orientation].w * 2; menu_pos.contwin.bgr.pt.h = DEVICE[DEVICE.orientation].h; menu_pos.contwin.bgr.pt.x = -100; menu_pos.contwin.touch_area.h = DEVICE[DEVICE.orientation].h; menu_pos.contwin.layer_pos.slider.pt.x = menu_pos.contwin.frame.middle.scroll.pt.w + 10; menu_pos.contwin.layer_pos.slider.pt.y = DEVICE[DEVICE.orientation].h / 2 - 380; var contwiny = DEVICE[DEVICE.orientation].h / 2 - menu_pos.contwin.frame.middle.no_scroll.pt.h / 2 - 140; menu_pos.contwin.frame.middle.no_scroll.pt.y = contwiny; menu_pos.contwin.frame.left.no_scroll.pt.y = contwiny; menu_pos.contwin.frame.right.no_scroll.pt.y = contwiny; menu_pos.contwin.frame.middle.scroll.pt.h = DEVICE[DEVICE.orientation].h; content_window_pos.betdlg.layer.pt.y = contwiny - 80; content_window_pos.settingsdlg.layer.pt.y = contwiny - 80; if (UAGENT_IE11) { content_window_pos.betdlg.layer.pt.y = 200; content_window_pos.settingsdlg.layer.pt.y = 200 } modalwin_pos.layer.pt.scale.x = DEVICE[DEVICE.orientation].w / 640; modalwin_pos.layer.pt.scale.y = DEVICE[DEVICE.orientation].w / 640; modalwin_pos.layer.pt.x = DEVICE[DEVICE.orientation].w / 2 - modalwin_pos.background.size.w / 2; modalwin_pos.layer.pt.y = DEVICE[DEVICE.orientation].h / 2 - modalwin_pos.background.size.h / 2; modalwin_pos.layer.pt.w = 640; modalwin_pos.layer.pt.h = 640; modalwin_pos.disable.pt.pos.w = DEVICE[DEVICE.orientation].w; modalwin_pos.disable.pt.pos.h = DEVICE[DEVICE.orientation].h } else { gamepanel_pos.game_panel_layer_pos.ls.w = DEVICE[DEVICE.orientation].w; gamepanel_pos.game_panel_layer_pos.ls.y = DEVICE[DEVICE.orientation].h - 66; gamepanel_pos.game_panel_line.ls.w = DEVICE[DEVICE.orientation].w; gamepanel_pos.info_bar.ls.pos.w = DEVICE[DEVICE.orientation].w - gamepanel_pos.buttons.ls.size.w * 2 + 2; gamepanel_pos.info_bar.ls.info_text1_pos.x = gamepanel_pos.info_bar.ls.pos.x + 8; gamepanel_pos.info_bar.ls.info_text2_pos.x = gamepanel_pos.info_bar.ls.pos.w / 2; gamepanel_pos.info_bar.ls.info_text3_pos.x = gamepanel_pos.info_bar.ls.pos.x + gamepanel_pos.info_bar.ls.pos.w - gamepanel_pos.info_bar.ls.info_text3_pos.w - 4; gamepanel_pos.funds_bar.ls.pos.w = DEVICE[DEVICE.orientation].w - gamepanel_pos.buttons.ls.size.w * 2 + 2; gamepanel_pos.funds_bar.ls.win_text_pos.x = gamepanel_pos.funds_bar.ls.pos.w / 2 + gamepanel_pos.buttons.ls.size.w - 34; gamepanel_pos.funds_bar.ls.win_caption_pos.x = gamepanel_pos.funds_bar.ls.win_text_pos.x - gamepanel_pos.funds_bar.ls.win_caption_pos.w - 2; gamepanel_pos.funds_bar.ls.bet_text_pos.x = gamepanel_pos.funds_bar.ls.pos.x + gamepanel_pos.funds_bar.ls.pos.w - (gamepanel_pos.funds_bar.ls.bet_text_pos.w + 56); gamepanel_pos.funds_bar.ls.bet_caption_pos.x = gamepanel_pos.funds_bar.ls.bet_text_pos.x - gamepanel_pos.funds_bar.ls.bet_caption_pos.w - 10; gamepanel_pos.funds_bar.ls.clock_pos.x = DEVICE[DEVICE.orientation].w - gamepanel_pos.buttons.ls.menu_button.size.w - gamepanel_pos.funds_bar.ls.clock_pos.w; free_game.ls.bet_text.x = gamepanel_pos.funds_bar.ls.pos.x + gamepanel_pos.funds_bar.ls.pos.w - (free_game.ls.bet_text.w + 50); free_game.ls.bet_caption.x = free_game.ls.bet_text.x - free_game.ls.bet_caption.w; gamepanel_pos.buttons.ls.layer.y = DEVICE[DEVICE.orientation].h - 66; gamepanel_pos.buttons.ls.layer.w = DEVICE[DEVICE.orientation].w; gamepanel_pos.buttons.ls.lobby_button.pos.x = -2; gamepanel_pos.buttons.ls.menu_button.pos.x = DEVICE[DEVICE.orientation].w - gamepanel_pos.buttons.ls.menu_button.size.w; gamepanel_pos.buttons.ls.back_button.pos.x = DEVICE[DEVICE.orientation].w - gamepanel_pos.buttons.ls.back_button.size.w; gamepanel_pos.buttons.ls.menu_button.button_cap_pos.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 50; gamepanel_pos.buttons.ls.back_button.button_cap_pos.x = gamepanel_pos.buttons.ls.back_button.pos.x + 50; gamepanel_pos.buttons.ls.menu_button.icon.x = 12 + gamepanel_pos.buttons.ls.menu_button.pos.x; gamepanel_pos.buttons.ls.back_button.icon.x = 12 + gamepanel_pos.buttons.ls.back_button.pos.x; if (DEVICE.fullscreen && !UAGENT_IOS7) { gamepanel_pos.buttons.ls.lobby_button.icon.x = 94; gamepanel_pos.buttons.ls.lobby_button.icon.y = 0; gamepanel_pos.buttons.ls.lobby_button.button_cap_pos.x = 70; gamepanel_pos.buttons.ls.lobby_button.button_cap_pos.y = 20; gamepanel_pos.buttons.ls.menu_button.icon.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 24; gamepanel_pos.buttons.ls.menu_button.icon.y = 0; gamepanel_pos.buttons.ls.menu_button.button_cap_pos.x = gamepanel_pos.buttons.ls.menu_button.pos.x; gamepanel_pos.buttons.ls.menu_button.button_cap_pos.y = 20; gamepanel_pos.buttons.ls.back_button.icon.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 20; gamepanel_pos.buttons.ls.back_button.icon.y = 0; gamepanel_pos.buttons.ls.back_button.button_cap_pos.x = gamepanel_pos.buttons.ls.menu_button.pos.x; gamepanel_pos.buttons.ls.back_button.button_cap_pos.y = 20 } else { gamepanel_pos.buttons.ls.lobby_button.icon.x = 10; gamepanel_pos.buttons.ls.lobby_button.icon.y = 14; gamepanel_pos.buttons.ls.lobby_button.button_cap_pos.x = 50; gamepanel_pos.buttons.ls.lobby_button.button_cap_pos.y = 2; gamepanel_pos.buttons.ls.menu_button.icon.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 10; gamepanel_pos.buttons.ls.menu_button.icon.y = 14; gamepanel_pos.buttons.ls.menu_button.button_cap_pos.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 50; gamepanel_pos.buttons.ls.menu_button.button_cap_pos.y = 2; gamepanel_pos.buttons.ls.back_button.icon.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 10; gamepanel_pos.buttons.ls.back_button.icon.y = 14; gamepanel_pos.buttons.ls.back_button.button_cap_pos.x = gamepanel_pos.buttons.ls.menu_button.pos.x + 50; gamepanel_pos.buttons.ls.back_button.button_cap_pos.y = 2 } var balanceTextSize = gamepanel_pos.funds_bar.ls.win_text_pos.x - (gamepanel_pos.funds_bar.ls.balance_text_pos.x + 157) + 25; var winTextSize = gamepanel_pos.funds_bar.ls.bet_text_pos.x - (gamepanel_pos.funds_bar.ls.win_text_pos.x + 157); if (balanceTextSize > 0) gamepanel_pos.funds_bar.ls.balance_text_pos.w = 76 + balanceTextSize; if (winTextSize > 0) gamepanel_pos.funds_bar.ls.win_text_pos.w = 76 + winTextSize; gamepanel_pos.game_panel_shadow.ls.w = DEVICE[DEVICE.orientation].w; var s1 = (DEVICE[DEVICE.orientation].h - 66) / 510; var s2 = DEVICE[DEVICE.orientation].w / 960; scale_layer_pos.ls.scale = s1 < s2 ? s1 : s2; scale_layer_pos.ls.x = DEVICE[DEVICE.orientation].w / 2 - 1260 / 2; scale_layer_pos.ls.y = gamepanel_pos.game_panel_layer_pos.ls.y - 930; menu_pos.contwin.layer.ls.w = DEVICE[DEVICE.orientation].w; menu_pos.contwin.layer.ls.h = DEVICE[DEVICE.orientation].h; menu_pos.contwin.layer.ls.x = DEVICE[DEVICE.orientation].w / 2 - 556 / 2 + 60; menu_pos.catpanel.layer.ls.h = DEVICE[DEVICE.orientation].h; menu_pos.catpanel.div_bgr.background.ls.h = DEVICE[DEVICE.orientation].h; menu_pos.topbar.pos.ls.w = DEVICE[DEVICE.orientation].w; menu_pos.topbar.cat_title.ls.x = DEVICE[DEVICE.orientation].w / 2 - menu_pos.topbar.cat_title.ls.w / 2; menu_pos.contwin.bgr.ls.w = DEVICE[DEVICE.orientation].w; menu_pos.contwin.bgr.ls.h = DEVICE[DEVICE.orientation].h; menu_pos.contwin.bgr.ls.x = -menu_pos.contwin.layer.ls.x; menu_pos.contwin.layer_pos.slider.ls.x = DEVICE[DEVICE.orientation].w - menu_pos.contwin.layer.ls.x - 30; menu_pos.contwin.layer_pos.slider.ls.y = DEVICE[DEVICE.orientation].h / 2 - 250; menu_pos.contwin.frame.middle.scroll.ls.h = DEVICE[DEVICE.orientation].h; if (DEVICE[DEVICE.orientation].h < 520) { menu_pos.catpanel.layer.ls.scale.y = DEVICE[DEVICE.orientation].h / 520; menu_pos.contwin.layer.ls.scale.x = DEVICE[DEVICE.orientation].h / 540; menu_pos.contwin.layer.ls.scale.y = DEVICE[DEVICE.orientation].h / 540; menu_pos.contwin.layer.ls.y = DEVICE[DEVICE.orientation].h / 2 - 400 / 2 - 84; menu_pos.contwin.layer.ls.x = (DEVICE[DEVICE.orientation].w / 2 - 556 / 2 + 60) * menu_pos.contwin.layer.ls.scale.y; menu_pos.contwin.bgr.ls.w = 2E3; menu_pos.contwin.bgr.ls.h = 2E3 } modalwin_pos.layer.ls.x = DEVICE[DEVICE.orientation].w / 2 - modalwin_pos.background.size.w / 2; modalwin_pos.layer.ls.y = DEVICE[DEVICE.orientation].h / 2 - modalwin_pos.background.size.h / 2; modalwin_pos.disable.ls.pos.w = DEVICE[DEVICE.orientation].w; modalwin_pos.disable.ls.pos.h = DEVICE[DEVICE.orientation].h; modalwin_pos.layer.ls.w = DEVICE[DEVICE.orientation].w; modalwin_pos.layer.ls.h = DEVICE[DEVICE.orientation].h } idsplashscreen_pos.layers.containerlayer[DEVICE.orientation].scale = scale_layer_pos[[DEVICE.orientation]].scale; idsplashscreen_pos.layers.containerlayer[DEVICE.orientation].x = DEVICE[DEVICE.orientation].w / 2 - idsplashscreen_pos.layers.containerlayer[DEVICE.orientation].w / 2; idsplashscreen_pos.layers.containerlayer[DEVICE.orientation].y = DEVICE[DEVICE.orientation].h / 2 - idsplashscreen_pos.layers.containerlayer[DEVICE.orientation].h / 2 } Utils.eD = 640; Utils.sB = 834; var resolution = String(Utils.eD); function setImagePath(resourceroot) { if (!resourceroot) resourceroot = "mobile/"; image_path_game = resourceroot + "images/" + resolution + "/" + game_name + "/"; image_path_popup = resourceroot + "images/" + resolution + "/common/popup/"; image_path_menu = resourceroot + "images/" + resolution + "/common/menu/"; image_path_chips = resourceroot + "images/" + resolution + "/common/chips/"; image_path_cards = resourceroot + "images/" + resolution + "/common/cards/"; image_path_jackpot = resourceroot + "images/" + resolution + "/common/jackpot/"; image_path_coinshower = resourceroot + "images/" + resolution + "/common/coinshower/"; image_path_paylines = resourceroot + "images/" + resolution + "/common/paylines/"; image_path_paytable = resourceroot + "images/" + resolution + "/common/paytable/"; image_path_kenoui = resourceroot + "images/" + resolution + "/common/kenoui/"; image_path_videopoker = resourceroot + "images/" + resolution + "/common/videopoker/"; image_path_brands = resourceroot + "images/" + resolution + "/brands/"; image_path_tablegameui = resourceroot + "images/" + resolution + "/common/tablegamesui/"; image_path_htmlui = resourceroot + "images/" + resolution + "/common/htmlui/"; image_path_particles = resourceroot + "images/" + resolution + "/common/particles/"; if (typeof setSoundPathAndTimes == "function") { if (UAGENT_ANDROID && UAGENT_ANDROID3MINUS) resourceroot = setHttpSndPathForAndroid(resourceroot); setSoundPathAndTimes(resourceroot) } else { sfile = resourceroot + "sounds.mp3"; stime = [[0, 0], [1.92, 3.3], [4, 6.12], [6.88, 7.4]] } }; function setHttpSndPathForAndroid(resourceroot) { if (resourceroot.charAt(4) == "s") { var tmpFirstPart = resourceroot.substring(0, 4); var tmpSecondPart = resourceroot.substring(5); return tmpFirstPart.concat(tmpSecondPart) } return resourceroot } spinner_state_offset = { base: 268, enabled: 134, disabled: 0 }; spinner_drag_distance = 6; fade_distance = { start: 56, end: 80 }; spinner_top_solid = { xAdj: 10, yAdj: -22, w: 100, h: 28 }; spinner_bottom_solid = { xAdj: 10, yAdj: 126, w: 100, h: 28 }; special_paylines = undefined; paylines_cut_adjust = undefined; payboxamount = { x: [130, 292, 452, 616, 780], y: [190, 344, 494], w: 130, bg: bg = { x: 285, y: [150, 305, 455] } }; mini_loader = { w: 40, margin: 3, xoffset: 580, yoffset: 380 }; invalid_text_pos = { x: 10, y: 10, w: 620, h: 250 }; invalid_btn_pos = { x: 189, y: 360, w: 262, h: 60 }; invalid_btn_sprite_pos = { x: 179, y: 360, w: 282, h: 60 }; invalid_btn_Yoffset = 60; free_spin_layer_pos = { pt: pt = { x: 310, y: 450, w: 640, h: 834, scale: 1.2 }, ls: ls = { x: 310, y: 450, w: 640, h: 834, scale: 1.075 } }; scale_layer_pos = { pt: pt = { w: 1260, h: 1180, x: -220, y: -240, scale: 0.8 }, ls: ls = { w: 1260, h: 1180, x: 0, y: -400, scale: 0.925 } }; reels_layer_pos = { pt: pt = { w: 960, h: 590, x: 110, y: 320, scale: 1 }, ls: ls = { w: 960, h: 590, x: 110, y: 320, scale: 1 } }; reels_anim_layer_pos = { pt: pt = { w: 960, h: 610, x: 110, y: 320, scale: 1 }, ls: ls = { w: 960, h: 610, x: 110, y: 320, scale: 1 } }; paylines_layer_pos = { pt: pt = { w: 640, h: 580, x: 110, y: 318, scale: 1 }, ls: ls = { w: 960, h: 580, x: 110, y: 318, scale: 1 } }; gamepanel_pos = { textscale: textscale = { pt: pt = { x: undefined, y: 1 }, ls: ls = { x: undefined, y: 1 } }, game_panel_layer_pos: game_panel_layer_pos = { pt: pt = { x: 0, y: 0, w: 640, h: 66, scale: scale = { x: 1, y: 1 } }, ls: ls = { x: 0, y: 0, w: 0, h: 66, scale: scale = { x: 1, y: 1 } } }, game_panel_bg: game_panel_bg = { pt: pt = { x: 0, y: 0, w: 640, h: 132 }, ls: ls = { x: 0, y: 0, w: 960, h: 66 } }, game_panel_shadow: game_panel_shadow = { pt: pt = { x: 0, y: -10, w: 960, h: 10, css: css = "panelshadowgadient_bottom" }, ls: ls = { x: 0, y: -10, w: 960, h: 10, css: css = "panelshadowgadient_bottom" } }, game_panel_shadow_top: game_panel_shadow_top = { x: 0, y: 66, w: 960, h: 10, css: css = "panelshadowgadient_top" }, game_panel_line: game_panel_line = { pt: pt = { x: 0, y: 66, w: 960, h: 2 }, ls: ls = { x: 0, y: 66, w: 960, h: 2 } }, funds_bar: funds_bar = { pt: pt = { layer: layer = { x: 0, y: 38 }, size: size = { w: 640, h: 28 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h, scale: scale = { x: 1, y: 1 } }, offset: offset = { x: 0, y: 38 }, balance_caption_pos: balance_caption_pos = { x: 0, y: 0, w: 112, h: 28 }, win_caption_pos: win_caption_pos = { x: 230, y: 0, w: 50, h: 28 }, bet_caption_pos: bet_caption_pos = { x: 400, y: 0, w: 60, h: 28 }, balance_text_pos: balance_text_pos = { x: 117, y: 0, w: 112, h: 28 }, win_text_pos: win_text_pos = { x: 283, y: 0, w: 135, h: 28 }, bet_text_pos: bet_text_pos = { x: 463, y: 0, w: 134, h: 28 }, clock_pos: clock_pos = { x: 580, y: 0, w: 60, h: 28 } }, ls: ls = { layer: layer = { x: 0, y: 0 }, size: size = { w: 640, h: 28 }, pos: pos = { x: 160, y: 38, w: size.w, h: size.h, scale: scale = { x: 1, y: 1 } }, offset: offset = { x: 0, y: 38 }, balance_caption_pos: balance_caption_pos = { x: 160, y: 38, w: 112, h: 28 }, win_caption_pos: win_caption_pos = { x: 400, y: 38, w: 50, h: 28 }, bet_caption_pos: bet_caption_pos = { x: 570, y: 38, w: 60, h: 28 }, balance_text_pos: balance_text_pos = { x: 275, y: 38, w: 105, h: 28 }, win_text_pos: win_text_pos = { x: 442, y: 38, w: 155, h: 28 }, bet_text_pos: bet_text_pos = { x: 630, y: 38, w: 100, h: 28 }, clock_pos: clock_pos = { x: 740, y: 38, w: 60, h: 28 } } }, info_bar: info_bar = { pt: pt = { layer: layer = { x: 0, y: 0 }, size: size = { w: 640, h: 38 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h, scale: scale = { x: 1, y: 1 } }, info_text1_pos: info_text1_pos = { x: 10, y: 0, w: 130, h: 38 }, info_text2_pos: info_text2_pos = { x: 150, y: 0, w: 340, h: 38 }, info_text3_pos: info_text3_pos = { x: 500, y: 0, w: 130, h: 38 }, offset: offset = { x: 0, y: 0 } }, ls: ls = { layer: layer = { x: 0, y: 0 }, size: size = { w: 640, h: 38 }, pos: pos = { x: 160, y: 0, w: size.w, h: size.h, scale: scale = { x: 1, y: 1 } }, info_text1_pos: info_text1_pos = { x: 170, y: 0, w: 130, h: 38 }, info_text2_pos: info_text2_pos = { x: 310, y: 0, w: 340, h: 38 }, info_text3_pos: info_text3_pos = { x: 660, y: 0, w: 130, h: 38 }, offset: offset = { x: 0, y: 0 } } }, buttons: buttons = { icon_adjust: icon_adjust = { x: 12, y: 14 }, icon_size: icon_size = { w: 40, h: 40 }, pt: pt = { size: size = { w: 322, h: 66 }, layer: layer = { x: 0, y: 66, w: 640, h: 66, scale: scale = { x: 1, y: 1 }, origin: origin = { x: "center", y: "bottom" } }, lobby_button: lobby_button = { size: size = { w: 322, h: 66 }, offset: offset = { xon: 162, yon: 132, xoff: 162, yoff: 66, xenabled: 162, xdisabled: 162, yenabled: 66, ydisabled: 66 }, pos: pos = { x: -2, y: 0, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 66, disabled: 106 }, icon_symbol_offsets: icon_symbol_offsets = { lobby: 484, menu: 524, back: 564 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.lobby, y: icon_state_offsets.enabled } } }, menu_button: menu_button = { size: size = { w: 322, h: 66 }, offset: offset = { xon: 162, yon: 132, xoff: 162, yoff: 66, xenabled: 162, xdisabled: 162, yenabled: 66, ydisabled: 66 }, pos: pos = { x: 320, y: 0, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 66, disabled: 106 }, icon_symbol_offsets: icon_symbol_offsets = { lobby: 484, menu: 524, back: 564 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.menu, y: icon_state_offsets.enabled } } }, back_button: back_button = { size: size = { w: 322, h: 66 }, offset: offset = { xon: 162, yon: 132, xoff: 162, yoff: 66, xenabled: 162, xdisabled: 162, yenabled: 66, ydisabled: 66 }, pos: pos = { x: 320, y: 0, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 66, disabled: 106 }, icon_symbol_offsets: icon_symbol_offsets = { lobby: 484, menu: 524, back: 564 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.back, y: icon_state_offsets.enabled } } } }, ls: ls = { size: size = { w: 162, h: 66 }, layer: layer = { x: 0, y: 0, w: 960, h: 66, scale: scale = { x: 1, y: 1 }, origin: origin = { x: "center", y: "center" } }, lobby_button: lobby_button = { size: size = { w: 162, h: 66 }, offset: offset = { xon: 0, yon: 132, xoff: 0, yoff: 66, xenabled: 0, xdisabled: 162, yenabled: 66, ydisabled: 66 }, pos: pos = { x: -2, y: 0, w: size.w, h: size.h, offsets: offset }, button_cap_pos: button_cap_pos = { x: 50, y: 2, w: 86, h: 66 }, icon_state_offsets: icon_state_offsets = { enabled: 66, disabled: 106 }, icon_symbol_offsets: icon_symbol_offsets = { lobby: 484, menu: 524, back: 564 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.lobby, y: icon_state_offsets.enabled } } }, menu_button: menu_button = { size: size = { w: 162, h: 66 }, offset: offset = { xon: 0, yon: 132, xoff: 0, yoff: 66, xenabled: 162, xdisabled: 162, yenabled: 66, ydisabled: 66 }, pos: pos = { x: 800, y: 0, w: size.w, h: size.h, offsets: offset }, button_cap_pos: button_cap_pos = { x: 850, y: 2, w: 86, h: 66 }, icon_state_offsets: icon_state_offsets = { enabled: 66, disabled: 106 }, icon_symbol_offsets: icon_symbol_offsets = { lobby: 484, menu: 524, back: 564 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.menu, y: icon_state_offsets.enabled } } }, back_button: back_button = { size: size = { w: 162, h: 66 }, offset: offset = { xon: 0, yon: 132, xoff: 0, yoff: 66, xenabled: 162, xdisabled: 162, yenabled: 66, ydisabled: 66 }, pos: pos = { x: 800, y: 0, w: size.w, h: size.h, offsets: offset }, button_cap_pos: button_cap_pos = { x: 850, y: 2, w: 86, h: 66 }, icon_state_offsets: icon_state_offsets = { enabled: 66, disabled: 106 }, icon_symbol_offsets: icon_symbol_offsets = { lobby: 484, menu: 524, back: 564 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.back, y: icon_state_offsets.enabled } } } } } }; coins: coins = { x: 660, y: 300, w: 50, h: 50, s: 1, xadj: 160, yadj: -40 }; var coinCycles = []; for (var i = 0; i < 10; i++) coinCycles.push([[coins.w * 0, coins.h * i, coins.s], [coins.w * 1, coins.h * i, coins.s], [coins.w * 2, coins.h * i, coins.s], [coins.w * 3, coins.h * i, coins.s], [coins.w * 4, coins.h * i, coins.s], [coins.w * 5, coins.h * i, coins.s], [coins.w * 6, coins.h * i, coins.s], [coins.w * 7, coins.h * i, coins.s], [coins.w * 8, coins.h * i, coins.s]]); var sequences = [{ duration: 1300, points: [{ x: 480, y: 1100 }, { x: 440, y: 480 }, { x: 300, y: 200 }, { x: 300, y: 440 }] }, { duration: 1300, points: [{ x: 520, y: 1100 }, { x: 460, y: 480 }, { x: 310, y: 200 }, { x: 310, y: 440 }] }, { duration: 1300, points: [{ x: 460, y: 1100 }, { x: 420, y: 480 }, { x: 290, y: 200 }, { x: 290, y: 440 }] }, { duration: 1300, points: [{ x: 470, y: 1100 }, { x: 430, y: 480 }, { x: 270, y: 200 }, { x: 270, y: 440 }] }, { duration: 1300, points: [{ x: 510, y: 1100 }, { x: 450, y: 480 }, { x: 320, y: 200 }, { x: 320, y: 440 }] }, { duration: 1300, points: [{ x: 130, y: 1100 }, { x: 170, y: 480 }, { x: 290, y: 200 }, { x: 290, y: 440 }] }, { duration: 1300, points: [{ x: 180, y: 1100 }, { x: 220, y: 480 }, { x: 290, y: 200 }, { x: 300, y: 440 }] }, { duration: 1300, points: [{ x: 220, y: 1100 }, { x: 280, y: 480 }, { x: 320, y: 200 }, { x: 330, y: 440 }] }, { duration: 1300, points: [{ x: 170, y: 1100 }, { x: 210, y: 480 }, { x: 290, y: 200 }, { x: 270, y: 440 }] }, { duration: 1300, points: [{ x: 130, y: 1100 }, { x: 210, y: 480 }, { x: 160, y: 200 }, { x: 310, y: 440 }] }]; win_counter = { start_limit: 100, coins: coins, coinCycles: coinCycles, sequences: sequences, captions_font_size: captions_font_size = 27, counter_font_size: counter_font_size = 72, win_counter_layer_pos: win_counter_layer_pos = { pt: pt = { x: 360, y: 960, w: 1260, h: 320, scale: 1.2 }, ls: ls = { x: 150, y: 896, w: 1260, h: 320, scale: 1.075 } }, win_counter_holder_y: win_counter_holder_y = { pt: pt = -20, ls: ls = -17 }, win_counter_text_offset: 20, win_counter_text_pos: win_counter_text_pos = { pt: pt = { pos: 320 }, ls: ls = { pos: 480 } }, win_counter_text_upscale_y: win_counter_text_upscale_y = { start: start = -30, low: low = -27, normal: normal = -23, high: high = -17, higher: higher = -17 }, win_counter_holder_upscale_y: win_counter_holder_upscale_y = { start: start = -10, low: low = -14, normal: normal = -18, high: high = -25, higher: higher = -30 }, win_counter_shadow_x: win_counter_shadow_x = { pt_low: pt_low = -40, pt_high: pt_high = -120, ls_low: ls_low = 190, ls_high: ls_high = 100 }, win_counter_shadow_width: win_counter_shadow_width = { low: low = 600, high: high = 779 }, win_counter_shadow_offset: win_counter_shadow_offset = { pt: pt = { x: 260, y: 25 }, ls: ls = { x: 490, y: 25 } }, coin_shower: coin_shower = { w: 180, h: 100, s: 0 }, coin_shower_layer: coin_shower_layer = { x: 0, y: -450, w: 0, h: 0 }, opacity: opacity = { v: 0.6 }, pt: pt = { pos: pos = { x: -150, y: 0, w: 1260, h: 44 }, middle: middle = { x: 275, y: 0, w: 100, h: 44 }, left: left = { x: 160, y: 0, w: 100, h: 44 }, right: right = { x: 390, y: 0, w: 100, h: 44 }, info: info = { x: 0, y: 0, w: 640, h: 44 }, coin_shower: coin_shower = { x: middle.x, y: middle.y, w: coin_shower.w, h: coin_shower.h, xoffset: 0, yoffset: 0 } }, ls: ls = { pos: pos = { x: -150, y: 0, w: 1260, h: 44 }, left: left = { x: 300, y: 0, w: 100, h: 44 }, middle: middle = { x: 405, y: 0, w: 160, h: 44 }, right: right = { x: 565, y: 0, w: 100, h: 44 }, info: info = { x: 160, y: 0, w: 640, h: 44 }, coin_shower: coin_shower = { x: middle.x - coin_shower.h / 2, y: middle.y - coin_shower.w / 2, w: coin_shower.w, h: coin_shower.h, xoffset: 0, yoffset: 0 } } }; menu_pos = { layer: layer = { pt: pt = { x: 0, y: 0, w: 640, h: 0, scale: scale = { x: 1, y: 1 } }, ls: ls = { x: 0, y: 0, w: 960, h: 0, scale: scale = { x: 1, y: 1 } } }, topbar: topbar = { pos: pos = { pt: pt = { x: 0, y: 0, w: 960, h: 32, xoffset: 0, yoffset: 0 }, ls: ls = { x: 0, y: 0, w: 960, h: 32, xoffset: 0, yoffset: 0 } }, gametitle: gametitle = { x: 20, y: 0, w: 220, h: 32 }, cat_title: cat_title = { pt: pt = { x: 230, y: 0, w: 180, h: 32 }, ls: ls = { x: 390, y: 0, w: 180, h: 32 } } }, catpanel: catpanel = { layer: layer = { pt: pt = { x: 0, y: 542, w: 640, h: 140, scale: scale = { x: 1, y: 1 } }, ls: ls = { x: 0, y: 0, w: 244, h: 0, scale: scale = { x: 1, y: 1 } } }, btn: btn = { btn_offsets: btn_offsets = { xon: 0, yon: 102, xoff: 0, yoff: 32, xselected: 0, yselected: 172, xenabled: 0, yenabled: 32, xdisabled: 0, ydisabled: 32 }, arrow: arrow = { pos: pos = { x: 208, y: 22, w: 34, h: 90 }, adjust: adjust = { x: 0, y: 70 }, offset: offset = { xoffset: 216, yoffset: 32 } }, pos: pos = { start: start = { pt: pt = { x: 2, y: 0, w: 210, h: 70, offsets: btn_offsets }, ls: ls = { x: 0, y: 32, w: 210, h: 70 } }, cap_adj: cap_adj = { pt: pt = { x: 64, y: 0, w: -82, h: 0 }, ls: ls = { x: 64, y: 0, w: -72, h: 0 } }, adjust: adjust = { pt: pt = { x: 212, y: 70 }, ls: ls = { x: 0, y: 70 } }, scale: scale = { pt: pt = { x: 1, y: 1 }, ls: ls = { x: 1, y: 1 } } }, icon_offsets: icon_offsets = { y: 482, xbet: 0, xsettings: 40, xautoplay: 80, xpaytable: 120, xhistory: 160, xplayforreal: 200, xcashier: 240, xgamerules: 280 }, icon_pos: icon_pos = { xadj: 12, yadj: 14, w: 40, h: 40 } }, div_bgr: div_bgr = { background: background = { pt: pt = { x: 0, y: 0, w: 640, h: 160 }, ls: ls = { x: 0, y: 0, w: 210, h: 630 } }, divider: divider = { line: line = { pt: pt = { w: 640, h: 2 }, ls: ls = { x: 210, y: 0, w: 2, h: 630 } }, shadow: shadow = { pt: pt = { x: 0, y: -10, w: 640, h: 10 }, ls: ls = { x: -285, y: 340, w: 1E3, h: 10 } } } } }, contwin: contwin = { layer: layer = { pt: pt = { x: 0, y: 0, w: 572, h: 960, scale: scale = { x: 1, y: 1 } }, ls: ls = { x: 0, y: -24, w: 572, h: 900, scale: scale = { x: 1, y: 1 } } }, touch_area: touch_area = { x: 16, y: 30, w: 564, h: 480 }, layer_pos: layer_pos = { base: base = { pt: pt = { x: 0, y: 0 }, ls: ls = { x: 0, y: -24 } }, base_scroll: base_scroll = { pt: pt = { x: 0, y: -10 }, ls: ls = { x: -20, y: 0 } }, slider: slider = { pt: pt = { x: 0, y: 0 }, ls: ls = { x: 20, y: 14 } } }, bgr: bgr = { pt: pt = { x: 0, y: -20, w: 960, h: 570 }, ls: ls = { x: -280, y: -20, w: 960, h: 570 } }, frame: frame = { left: left = { offset: offset = { x: 320, y: 32 }, no_scroll: no_scroll = { pt: pt = { x: 0, y: 72, w: 16, h: 406, yscale: 1 }, ls: ls = { x: 34, y: 72, w: 16, h: 406, yscale: 1 } }, scroll: scroll = { pt: pt = { x: 14, y: 72, w: 16, h: 406, yscale: 1.5 }, ls: ls = { x: 14, y: 72, w: 16, h: 406, yscale: 1.5 } } }, middle: middle = { no_scroll: no_scroll = { pt: pt = { x: 16, y: 72, w: 540, h: 402 }, ls: ls = { x: 50, y: 72, w: 540, h: 402 } }, scroll: scroll = { pt: pt = { x: 0, y: 0, w: 572, h: 600 }, ls: ls = { x: 28, y: 0, w: 572, h: 600 } } }, right: right = { offset: offset = { x: 336, y: 32 }, no_scroll: no_scroll = { pt: pt = { x: 556, y: 72, w: 16, h: 406, yscale: 1 }, ls: ls = { x: 590, y: 72, w: 16, h: 406, yscale: 1 } }, scroll: scroll = { pt: pt = { x: 566, y: 72, w: 16, h: 406, yscale: 1.5 }, ls: ls = { x: 566, y: 72, w: 16, h: 406, yscale: 1.5 } } } }, checkbox: checkbox = { offsets: offsets = { x: x = 254, xoff: x, yoff: 32, xon: x, yon: 98, xenabled: x, yenabled: 32, xdisabled: x, ydisabled: 164, yenabled_unchecked: 32, ydisabled_unchecked: 164, ydisabled_checked: 230, ydisabled_cross: 296 }, pos: pos = { x: 490, y: 62 + topbar.pos.pt.h, w: 66, h: 66, offsets: offsets }, btn_pos: btn_pos = { x: 60, y: pos.y, w: 420, h: pos.h, offsets: offsets }, adj: adj = { x: 0, y: 90 } }, input: input = { pos: pos = { x: 432, y: 62 + topbar.pos.h, w: 120, h: 58 } }, input_gfx: input_gfx = { offsets: offsets = { x: x = 254, xoff: x, yoff: 32, xon: x, yon: 98, xenabled: x, yenabled: 32, xdisabled: x, ydisabled: 164 }, pos: pos = { x: 426, y: 62 + topbar.pos.h, w: 126, h: 58, offsets: offsets } }, glow: contentglw = { start_opacity: 1, fade_speed: 0.14 }, basetoucharea: basetoucharea = { x: 14, y: 0, w: 570, h: 600 }, touchscroll: touchscroll = { distance: 200 }, slider: slider = { scale: scale = { min: 0.2, max: 2 }, toucharea: toucharea = { x: 0, y: 30, w: 60, h: 480 }, base: base = { top: top = { pos: pos = { x: 0, y: 46, w: 22, h: 238 }, offset: offset = { x: 352, y: 32 } }, bottom: bottom = { pos: pos = { x: 0, y: 238, w: 22, h: 240 }, offset: offset = { x: 352, y: 270 } }, avail_area: avail_area = { h: 218 } }, handle: handle = { top: top = { notouch_offset: notouch_offset = { xoff: 218, yoff: 362 }, pos: pos = { x: 0, y: 44, w: 24, h: 40, offsets: notouch_offset }, offset: offset = { x: 218, y: 122 } }, middle: middle = { pos: pos = { x: 0, y: 84, w: 24, h: 150 }, offset: offset = { x: 218, y: 162 } }, bottom: bottom = { notouch_offset: notouch_offset = { xoff: 242, yoff: 362 }, pos: pos = { x: 0, y: 234, w: 24, h: 40, offsets: notouch_offset }, offset: offset = { x: 218, y: 312 } } } } } }; var menu_icon_offsets = [{ x: menu_pos.catpanel.btn.icon_offsets.xbet, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xsettings, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xautoplay, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xpaytable, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xhistory, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xcashier, y: menu_pos.catpanel.btn.icon_offsets.y }]; var menu_catPanel_captions = [Locale.IDS_MENU_BET_VSLOT, Locale.IDS_BTN_SETTINGS, Locale.IDS_BTN_AUTOPLAY, Locale.IDS_BTN_PAYTABLE, Locale.IDS_BTN_GAMEHISTORY, Locale.IDS_BTN_CASHIER]; var contentToUse_override = undefined; var pt_help_btn_cap = Locale.IDS_BTN_GAME_RULES; var pt_cashier_btn_cap = Locale.IDS_BTN_CASHIER; modalwin_pos = { layer: layer = { pt: pt = { x: 0, y: 0, w: 0, h: 0, scale: scale = { x: 1, y: 1 } }, ls: ls = { x: 0, y: 0, w: 0, h: 0, scale: scale = { x: 1, y: 1 } } }, disable: disable = { pt: pt = { pos: pos = { x: 0, y: 0, w: 1E3, h: 1E3 } }, ls: ls = { pos: pos = { x: 0, y: 0, w: 1E3, h: 1E3 } } }, background: background = { size: size = { w: 610, h: 316 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h }, pt: pt = { x: 0, y: 0 }, ls: ls = { x: 154, y: -30 } }, texts: texts = { title: title = { size: size = { w: 530, h: 50 }, pos: pos = { x: 40 + background.pos.x, y: 2 + background.pos.y, w: size.w, h: size.h } }, message: message = { size: size = { w: 530, h: 130 }, pos: pos = { x: 40 + background.pos.x, y: 52 + background.pos.y, w: size.w, h: size.h } } }, buttons: buttons = { button_size: button_size = { w: 218, h: 80 }, button_offset: button_offset = { xon: 218, yon: 316, xoff: 0, yoff: 316 }, icon_adjust: icon_adjust = { x: 20, y: 20 }, icon_size: icon_size = { w: 40, h: 40 }, caption_size: caption_size = { w: 140, h: 80, adjustx: 58 }, single_button: single_button = { size: size = { w: button_size.w, h: button_size.h }, offset: offset = button_offset, pos: pos = { x: 196 + background.pos.x, y: 190 + background.pos.y, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 316, disabled: 316 }, icon_symbol_offsets: icon_symbol_offsets = { check: 436, cross: 476 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.check, y: icon_state_offsets.enabled } }, caption: caption = { x: pos.x + caption_size.adjustx, y: pos.y, w: caption_size.w, h: caption_size.h } }, cancel_button: cancel_button = { size: size = { w: button_size.w, h: button_size.h }, offset: offset = button_offset, pos: pos = { x: 62 + background.pos.x, y: 190 + background.pos.y, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 316, disabled: 316 }, icon_symbol_offsets: icon_symbol_offsets = { check: 436, cross: 476 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.cross, y: icon_state_offsets.enabled } }, caption: caption = { x: pos.x + caption_size.adjustx, y: pos.y, w: caption_size.w, h: caption_size.h } }, confirm_button: confirm_button = { size: size = { w: button_size.w, h: button_size.h }, offset: offset = button_offset, pos: pos = { x: 330 + background.pos.x, y: 190 + background.pos.y, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 316, disabled: 316 }, icon_symbol_offsets: icon_symbol_offsets = { check: 436, cross: 476 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.check, y: icon_state_offsets.enabled } }, caption: caption = { x: pos.x + caption_size.adjustx, y: pos.y, w: caption_size.w, h: caption_size.h } }, cap_adj: cap_adj = { x: 64, y: 0, w: -72, h: 0 } } }; free_game: free_game = { pt: pt = { bet_caption: bet_caption = { x: 406, y: 0, w: 150, h: 28 }, bet_text: bet_tex = { x: 560, y: 0, w: 30, h: 28 } }, ls: ls = { bet_caption: bet_caption = { x: 556, y: 38, w: 150, h: 28 }, bet_text: bet_text = { x: 710, y: 38, w: 30, h: 28 } } }; cancel_icon_pos: cancel_icon_pos = { x: modalwin_pos.buttons.cancel_button.icon.x, y: modalwin_pos.buttons.cancel_button.icon.y, w: modalwin_pos.buttons.cancel_button.icon.w, h: modalwin_pos.buttons.cancel_button.icon.h, offsets: { x: menu_pos.catpanel.btn.icon_offsets.xcashier, y: menu_pos.catpanel.btn.icon_offsets.y } }; splashscreen_pos = { layers: layers = { bgrlayer: bgrlayer = { x: 0, y: 0, w: 1260, h: 1180, scale: 1 }, containerlayer: containerlayer = { pt: pt = { x: 183, y: 412, w: 890, h: 554, scale: 1 }, ls: ls = { x: 183, y: 412, w: 890, h: 554, scale: 1 } } }, content: content = { background: background = { x: 0, y: 0, w: 2E3, h: 100 }, gpbcover: gpbcover = { x: 0, y: 0, w: 2E3, h: 68 }, gpicover: gpicover = { x: 0, y: 0, w: 2E3, h: 68 }, template_solid: template_solid = { x: 0, y: 0, w: 890, h: 554 }, continue_btn: continue_btn = { x: 350, y: 425, w: 150, h: 74, xoffset: 0, yoffset: 242, offsets: offsets = { xenabled: 0, yenabled: 554, xon: 220, yon: 554, xoff: 0, yoff: 554 }, sprite: sprite = { x: 315, w: 220, h: 74 } }, checkbox: checkbox = { btn: btn = { x: 560, y: 424, w: 74, h: 74, offsets: offsets = { xon: 514, yon: 554, xoff: 440, yoff: 554 } }, textfield: textfield = { x: 620, y: 436, w: 150, h: 50 } } } }; idsplashscreen_pos = { layers: layers = { bgrlayer: bgrlayer = { x: 0, y: 0, w: 1260, h: 1180, scale: 1 }, containerlayer: containerlayer = { pt: pt = { x: 76, y: 100, w: 496, h: 262, scale: 1 }, ls: ls = { x: 200, y: 100, w: 496, h: 262, scale: 1 } } }, content: content = { bgr_sprite: bgr_sprite = { x: 0, y: 0, w: 496, h: 262, xoffset: 0, yoffset: 398 }, continue_btn: continue_btn = { x: 18, y: 190, w: 460, h: 52, xoffset: 0, yoffset: 660 }, text: text = { cap: cap = { x: 18, y: 24, w: 460, h: 40 }, ticketidcap: ticketidcap = { x: 34, y: 82, w: 160, h: 44 }, ticketid: ticketid = { x: ticketidcap.x + ticketidcap.w + 10, y: ticketidcap.y, w: 200, h: ticketidcap.h }, sessionidcap: sessionidcap = { x: ticketidcap.x, y: 122, w: ticketidcap.w, h: ticketidcap.h }, sessionid: sessionid = { x: ticketid.x, y: sessionidcap.y, w: ticketid.w, h: ticketid.h } } } }; if (UAGENT_IE) ie_plainTf_xAdj = 4; (function () { var root = this; var PIXI = PIXI || {}; PIXI.WEBGL_RENDERER = 0; PIXI.CANVAS_RENDERER = 1; PIXI.VERSION = "v1.6.1"; PIXI.blendModes = { NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16 }; PIXI.scaleModes = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }; PIXI._UID = 0; if (typeof Float32Array != "undefined") { PIXI.Float32Array = Float32Array; PIXI.Uint16Array = Uint16Array } else { PIXI.Float32Array = Array; PIXI.Uint16Array = Array } PIXI.INTERACTION_FREQUENCY = 30; PIXI.AUTO_PREVENT_DEFAULT = false; PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION = true; PIXI.RAD_TO_DEG = 180 / Math.PI; PIXI.DEG_TO_RAD = Math.PI / 180; PIXI.dontSayHello = true; PIXI.sayHello = function (type) { if (PIXI.dontSayHello) return; if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) { var args = ["%c %c %c Pixi.js " + PIXI.VERSION + " - " + type + "  %c " + " %c " + " http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 ", "background: #ff66a5", "background: #ff66a5", "color: #ff66a5; background: #030307;", "background: #ff66a5", "background: #ffc3dc", "background: #ff66a5", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff"]; console.log.apply(console, args) } else if (window["console"]) console.log("Pixi.js " + PIXI.VERSION + " - http://www.pixijs.com/"); PIXI.dontSayHello = true }; PIXI.Point = function (x, y) { this.x = x || 0; this.y = y || 0 }; PIXI.Point.prototype.clone = function () { return new PIXI.Point(this.x, this.y) }; PIXI.Point.prototype.set = function (x, y) { this.x = x || 0; this.y = y || (y !== 0 ? this.x : 0) }; PIXI.Point.prototype.constructor = PIXI.Point; PIXI.Rectangle = function (x, y, width, height) { this.x = x || 0; this.y = y || 0; this.width = width || 0; this.height = height || 0 }; PIXI.Rectangle.prototype.clone = function () { return new PIXI.Rectangle(this.x, this.y, this.width, this.height) }; PIXI.Rectangle.prototype.contains = function (x, y) { if (this.width <= 0 || this.height <= 0) return false; var x1 = this.x; if (x >= x1 && x <= x1 + this.width) { var y1 = this.y; if (y >= y1 && y <= y1 + this.height) return true } return false }; PIXI.Rectangle.prototype.constructor = PIXI.Rectangle; PIXI.EmptyRectangle = new PIXI.Rectangle(0, 0, 0, 0); PIXI.Polygon = function (points) { if (!(points instanceof Array)) points = Array.prototype.slice.call(arguments); if (typeof points[0] === "number") { var p = []; for (var i = 0, il = points.length; i < il; i += 2) p.push(new PIXI.Point(points[i], points[i + 1])); points = p } this.points = points }; PIXI.Polygon.prototype.clone = function () { var points = []; for (var i = 0; i < this.points.length; i++) points.push(this.points[i].clone()); return new PIXI.Polygon(points) }; PIXI.Polygon.prototype.contains = function (x, y) { var inside = false; for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) { var xi = this.points[i].x, yi = this.points[i].y, xj = this.points[j].x, yj = this.points[j].y, intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi; if (intersect) inside = !inside } return inside }; PIXI.Polygon.prototype.constructor = PIXI.Polygon; PIXI.Circle = function (x, y, radius) { this.x = x || 0; this.y = y || 0; this.radius = radius || 0 }; PIXI.Circle.prototype.clone = function () { return new PIXI.Circle(this.x, this.y, this.radius) }; PIXI.Circle.prototype.contains = function (x, y) { if (this.radius <= 0) return false; var dx = this.x - x, dy = this.y - y, r2 = this.radius * this.radius; dx *= dx; dy *= dy; return dx + dy <= r2 }; PIXI.Circle.prototype.getBounds = function () { return new PIXI.Rectangle(this.x - this.radius, this.y - this.radius, this.width, this.height) }; PIXI.Circle.prototype.constructor = PIXI.Circle; PIXI.Ellipse = function (x, y, width, height) { this.x = x || 0; this.y = y || 0; this.width = width || 0; this.height = height || 0 }; PIXI.Ellipse.prototype.clone = function () { return new PIXI.Ellipse(this.x, this.y, this.width, this.height) }; PIXI.Ellipse.prototype.contains = function (x, y) { if (this.width <= 0 || this.height <= 0) return false; var normx = (x - this.x) / this.width, normy = (y - this.y) / this.height; normx *= normx; normy *= normy; return normx + normy <= 1 }; PIXI.Ellipse.prototype.getBounds = function () { return new PIXI.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height) }; PIXI.Ellipse.prototype.constructor = PIXI.Ellipse; PIXI.Matrix = function () { this.a = 1; this.b = 0; this.c = 0; this.d = 1; this.tx = 0; this.ty = 0 }; PIXI.Matrix.prototype.fromArray = function (array) { this.a = array[0]; this.b = array[1]; this.c = array[3]; this.d = array[4]; this.tx = array[2]; this.ty = array[5] }; PIXI.Matrix.prototype.toArray = function (transpose) { if (!this.array) this.array = new Float32Array(9); var array = this.array; if (transpose) { array[0] = this.a; array[1] = this.c; array[2] = 0; array[3] = this.b; array[4] = this.d; array[5] = 0; array[6] = this.tx; array[7] = this.ty; array[8] = 1 } else { array[0] = this.a; array[1] = this.b; array[2] = this.tx; array[3] = this.c; array[4] = this.d; array[5] = this.ty; array[6] = 0; array[7] = 0; array[8] = 1 } return array }; PIXI.identityMatrix = new PIXI.Matrix; PIXI.determineMatrixArrayType = function () { return typeof Float32Array !== "undefined" ? Float32Array : Array }; PIXI.Matrix2 = PIXI.determineMatrixArrayType(); PIXI.DisplayObject = function () { this.position = new PIXI.Point; this.scale = new PIXI.Point(1, 1); this.pivot = new PIXI.Point(0, 0); this.skewX = Number(false); this.skewY = Number(false); this.alpha = 1; this.visible = true; this.hitArea = null; this.buttonMode = false; this.renderable = false; this.parent = null; this.stage = null; this.worldAlpha = 1; this._interactive = false; this.defaultCursor = "pointer"; this.worldTransform = new PIXI.Matrix; this.color = []; this.dynamic = true; this._skewXCache = Number(false); this._skewYCache = Number(false); this._cx = 1; this._cy = 1; this._sx = Number(false); this._sy = Number(false); this.filterArea = null; this._bounds = new PIXI.Rectangle(0, 0, 1, 1); this._currentBounds = null; this._mask = null; this._cacheAsBitmap = false; this._cacheIsDirty = false }; PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject; PIXI.DisplayObject.prototype.setInteractive = function (interactive) { this.interactive = interactive }; Object.defineProperty(PIXI.DisplayObject.prototype, "interactive", { get: function () { return this._interactive }, set: function (value) { this._interactive = value; if (this.stage) this.stage.dirty = true } }); Object.defineProperty(PIXI.DisplayObject.prototype, "worldVisible", { get: function () { var item = this; do { if (!item.visible) return false; item = item.parent } while (item); return true } }); Object.defineProperty(PIXI.DisplayObject.prototype, "mask", { get: function () { return this._mask }, set: function (value) { if (this._mask) this._mask.isMask = false; this._mask = value; if (this._mask) this._mask.isMask = true } }); Object.defineProperty(PIXI.DisplayObject.prototype, "filters", { get: function () { return this._filters }, set: function (value) { if (value) { var passes = []; for (var i = 0; i < value.length; i++) { var filterPasses = value[i].passes; for (var j = 0; j < filterPasses.length; j++) passes.push(filterPasses[j]) } this._filterBlock = { target: this, filterPasses: passes } } this._filters = value } }); Object.defineProperty(PIXI.DisplayObject.prototype, "cacheAsBitmap", { get: function () { return this._cacheAsBitmap }, set: function (value) { if (this._cacheAsBitmap === value) return; if (value) this._generateCachedSprite(); else this._destroyCachedSprite(); this._cacheAsBitmap = value } }); PIXI.DisplayObject.prototype.updateTransform = function (force) { if (this.skewX !== this._skewXCache || force) { this._skewXCache = this.skewX; this._cx = Math.cos(this.skewX); this._sx = Math.sin(this.skewX) } if (this.skewY !== this._skewYCache || force) { this._skewYCache = this.skewY; if (this.skewY === this.skewX) { this._cy = this._cx; this._sy = this._sx } else { this._cy = Math.cos(this.skewY); this._sy = Math.sin(this.skewY) } } var parentTransform = this.parent.worldTransform; var worldTransform = this.worldTransform; var px = this.pivot.x; var py = this.pivot.y; var a00 = this._cy * this.scale.x, a01 = -this._sx * this.scale.y, a10 = this._sy * this.scale.x, a11 = this._cx * this.scale.y, a02 = this.position.x + px - a00 * px - py * a01, a12 = this.position.y + py - a11 * py - px * a10, b00 = parentTransform.a, b01 = parentTransform.b, b10 = parentTransform.c, b11 = parentTransform.d; worldTransform.a = b00 * a00 + b01 * a10; worldTransform.b = b00 * a01 + b01 * a11; worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx; worldTransform.c = b10 * a00 + b11 * a10; worldTransform.d = b10 * a01 + b11 * a11; worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty; this.worldAlpha = this.alpha * this.parent.worldAlpha }; PIXI.DisplayObject.prototype.getBounds = function (matrix) { matrix = matrix; return PIXI.EmptyRectangle }; PIXI.DisplayObject.prototype.getLocalBounds = function () { return this.getBounds(PIXI.identityMatrix) }; PIXI.DisplayObject.prototype.setStageReference = function (stage) { this.stage = stage; if (this._interactive) this.stage.dirty = true }; PIXI.DisplayObject.prototype.generateTexture = function (renderer) { var bounds = this.getLocalBounds(); var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer); renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y)); return renderTexture }; PIXI.DisplayObject.prototype.generateGrayTexture = function () { var texture = this.generateTexture(); var img = texture.textureBuffer.context.getImageData(0, 0, texture.width, texture.height); var color; for (var i = 0; i < img.data.length; i += 4) { color = (img.data[i] + img.data[i + 1] + img.data[i + 2]) / 3; for (var u = 0; u < 3; u++) img.data[i + u] = color } texture.textureBuffer.context.putImageData(img, 0, 0); return texture }; PIXI.DisplayObject.prototype.generateGrayCopy = function () { return new PIXI.Sprite(this.generateGrayTexture()) }; PIXI.DisplayObject.prototype.updateCache = function () { this._generateCachedSprite() }; PIXI.DisplayObject.prototype._renderCachedSprite = function (renderSession) { this._cachedSprite.worldAlpha = this.worldAlpha; if (renderSession.gl) PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession); else PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession) }; PIXI.DisplayObject.prototype._generateCachedSprite = function () { this._cacheAsBitmap = false; var bounds = this.getLocalBounds(); if (!this._cachedSprite) { var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0); this._cachedSprite = new PIXI.Sprite(renderTexture); this._cachedSprite.worldTransform = this.worldTransform } else this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0); var tempFilters = this._filters; this._filters = null; this._cachedSprite.filters = tempFilters; this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y)); this._cachedSprite.anchor.x = -(bounds.x / bounds.width); this._cachedSprite.anchor.y = -(bounds.y / bounds.height); this._filters = tempFilters; this._cacheAsBitmap = true }; PIXI.DisplayObject.prototype._destroyCachedSprite = function () { if (!this._cachedSprite) return; this._cachedSprite.texture.destroy(true); this._cachedSprite = null }; PIXI.DisplayObject.prototype._renderWebGL = function (renderSession) { renderSession = renderSession }; PIXI.DisplayObject.prototype._renderCanvas = function (renderSession) { renderSession = renderSession }; Object.defineProperty(PIXI.DisplayObject.prototype, "x", { get: function () { return this.position.x }, set: function (value) { this.position.x = value } }); Object.defineProperty(PIXI.DisplayObject.prototype, "y", { get: function () { return this.position.y }, set: function (value) { this.position.y = value } }); Object.defineProperty(PIXI.DisplayObject.prototype, "scaleX", { get: function () { return this.scale.x }, set: function (value) { this.scale.x = value } }); Object.defineProperty(PIXI.DisplayObject.prototype, "scaleY", { get: function () { return this.scale.y }, set: function (value) { this.scale.y = value } }); Object.defineProperty(PIXI.DisplayObject.prototype, "rotation", { get: function () { if (this.skewX !== this.skewY) throw new Error("Rotation is not set."); return this.skewX }, set: function (value) { this.skewX = this.skewY = value } }); PIXI.DisplayObjectContainer = function () { PIXI.DisplayObject.call(this); this.children = [] }; PIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype); PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer; Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "width", { get: function () { return this.scale.x * this.getLocalBounds().width }, set: function (value) { var width = this.getLocalBounds().width; if (width !== 0) this.scale.x = value / (width / this.scale.x); else this.scale.x = 1; this._width = value } }); Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "height", { get: function () { return this.scale.y * this.getLocalBounds().height }, set: function (value) { var height = this.getLocalBounds().height; if (height !== 0) this.scale.y = value / (height / this.scale.y); else this.scale.y = 1; this._height = value } }); PIXI.DisplayObjectContainer.prototype.addChild = function (child) { return this.addChildAt(child, this.children.length) }; PIXI.DisplayObjectContainer.prototype.addChildAt = function (child, index) { if (index >= 0 && index <= this.children.length) { if (child.parent) child.parent.removeChild(child); child.parent = this; this.children.splice(index, 0, child); if (this.stage) child.setStageReference(this.stage); return child } else throw new Error(child + " The index " + index + " supplied is out of bounds " + this.children.length); }; PIXI.DisplayObjectContainer.prototype.swapChildren = function (child, child2) { if (child === child2) return; var index1 = this.children.indexOf(child); var index2 = this.children.indexOf(child2); if (index1 < 0 || index2 < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller."); this.children[index1] = child2; this.children[index2] = child }; PIXI.DisplayObjectContainer.prototype.getChildAt = function (index) { if (index >= 0 && index < this.children.length) return this.children[index]; else throw new Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller"); }; PIXI.DisplayObjectContainer.prototype.removeChild = function (child) { return this.removeChildAt(this.children.indexOf(child)) }; PIXI.DisplayObjectContainer.prototype.removeChildAt = function (index) { var child = this.getChildAt(index); if (this.stage) child.removeStageReference(); child.parent = undefined; this.children.splice(index, 1); return child }; PIXI.DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) { var begin = beginIndex || 0; var end = typeof endIndex === "number" ? endIndex : this.children.length; var range = end - begin; if (range > 0 && range <= end) { var removed = this.children.splice(begin, range); for (var i = 0; i < removed.length; i++) { var child = removed[i]; if (this.stage) child.removeStageReference(); child.parent = undefined } return removed } else throw new Error("Range Error, numeric values are outside the acceptable range"); }; PIXI.DisplayObjectContainer.prototype.updateTransform = function () { if (!this.visible) return; PIXI.DisplayObject.prototype.updateTransform.call(this); if (this._cacheAsBitmap) return; for (var i = 0, j = this.children.length; i < j; i++) this.children[i].updateTransform() }; PIXI.DisplayObjectContainer.prototype.getBounds = function (matrix) { if (this.children.length === 0) return PIXI.EmptyRectangle; if (matrix) { var matrixCache = this.worldTransform; this.worldTransform = matrix; this.updateTransform(); this.worldTransform = matrixCache } var minX = Infinity; var minY = Infinity; var maxX = -Infinity; var maxY = -Infinity; var childBounds; var childMaxX; var childMaxY; var childVisible = false; for (var i = 0, j = this.children.length; i < j; i++) { var child = this.children[i]; if (!child.visible) continue; childVisible = true; childBounds = this.children[i].getBounds(matrix); minX = minX < childBounds.x ? minX : childBounds.x; minY = minY < childBounds.y ? minY : childBounds.y; childMaxX = childBounds.width + childBounds.x; childMaxY = childBounds.height + childBounds.y; maxX = maxX > childMaxX ? maxX : childMaxX; maxY = maxY > childMaxY ? maxY : childMaxY } if (!childVisible) return PIXI.EmptyRectangle; var bounds = this._bounds; bounds.x = minX; bounds.y = minY; bounds.width = maxX - minX; bounds.height = maxY - minY; return bounds }; PIXI.DisplayObjectContainer.prototype.getLocalBounds = function () { var matrixCache = this.worldTransform; this.worldTransform = PIXI.identityMatrix; for (var i = 0, j = this.children.length; i < j; i++) this.children[i].updateTransform(); var bounds = this.getBounds(); this.worldTransform = matrixCache; return bounds }; PIXI.DisplayObjectContainer.prototype.setStageReference = function (stage) { this.stage = stage; if (this._interactive) this.stage.dirty = true; for (var i = 0, j = this.children.length; i < j; i++) { var child = this.children[i]; child.setStageReference(stage) } }; PIXI.DisplayObjectContainer.prototype.removeStageReference = function () { for (var i = 0, j = this.children.length; i < j; i++) { var child = this.children[i]; child.removeStageReference() } if (this._interactive) this.stage.dirty = true; this.stage = null }; PIXI.DisplayObjectContainer.prototype._renderWebGL = function (renderSession) { if (!this.visible || this.alpha <= 0) return; if (this._cacheAsBitmap) { this._renderCachedSprite(renderSession); return } var i, j; if (this._mask || this._filters) { if (this._filters) { renderSession.spriteBatch.flush(); renderSession.filterManager.pushFilter(this._filterBlock) } if (this._mask) { renderSession.spriteBatch.stop(); renderSession.maskManager.pushMask(this.mask, renderSession); renderSession.spriteBatch.start() } for (i = 0, j = this.children.length; i < j; i++) this.children[i]._renderWebGL(renderSession); renderSession.spriteBatch.stop(); if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession); if (this._filters) renderSession.filterManager.popFilter(); renderSession.spriteBatch.start() } else for (i = 0, j = this.children.length; i < j; i++) this.children[i]._renderWebGL(renderSession) }; PIXI.DisplayObjectContainer.prototype._renderCanvas = function (renderSession) { if (this.visible === false || this.alpha === 0) return; if (this._cacheAsBitmap) { this._renderCachedSprite(renderSession); return } if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession.context); for (var i = 0, j = this.children.length; i < j; i++) { var child = this.children[i]; child._renderCanvas(renderSession) } if (this._mask) renderSession.maskManager.popMask(renderSession.context) }; PIXI.Sprite = function (texture) { PIXI.DisplayObjectContainer.call(this); this.anchor = new PIXI.Point; this.texture = texture; this._width = 0; this._height = 0; this.tint = 16777215; this.blendMode = PIXI.blendModes.NORMAL; if (texture.baseTexture.hasLoaded) this.onTextureUpdate(); else { this.onTextureUpdateBind = this.onTextureUpdate.bind(this); this.texture.addEventListener("update", this.onTextureUpdateBind) } this.renderable = true }; PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Sprite.prototype.constructor = PIXI.Sprite; Object.defineProperty(PIXI.Sprite.prototype, "width", { get: function () { return this.scale.x * this.texture.frame.width }, set: function (value) { this.scale.x = value / this.texture.frame.width; this._width = value } }); Object.defineProperty(PIXI.Sprite.prototype, "height", { get: function () { return this.scale.y * this.texture.frame.height }, set: function (value) { this.scale.y = value / this.texture.frame.height; this._height = value } }); PIXI.Sprite.prototype.setTexture = function (texture) { this.texture = texture; this.cachedTint = 16777215; this.updateFrame = true }; PIXI.Sprite.prototype.onTextureUpdate = function () { if (this._width) this.scale.x = this._width / this.texture.frame.width; if (this._height) this.scale.y = this._height / this.texture.frame.height; this.updateFrame = true }; PIXI.Sprite.prototype.getBounds = function (matrix) { var width = this.texture.frame.width; var height = this.texture.frame.height; var w0 = width * (1 - this.anchor.x); var w1 = width * -this.anchor.x; var h0 = height * (1 - this.anchor.y); var h1 = height * -this.anchor.y; var worldTransform = matrix || this.worldTransform; var a = worldTransform.a; var b = worldTransform.c; var c = worldTransform.b; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 = a * w1 + c * h0 + tx; var y4 = d * h0 + b * w1 + ty; var maxX = -Infinity; var maxY = -Infinity; var minX = Infinity; var minY = Infinity; minX = x1 < minX ? x1 : minX; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y1 < minY ? y1 : minY; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x1 > maxX ? x1 : maxX; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y1 > maxY ? y1 : maxY; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; var bounds = this._bounds; bounds.x = minX; bounds.width = maxX - minX; bounds.y = minY; bounds.height = maxY - minY; this._currentBounds = bounds; return bounds }; PIXI.Sprite.prototype._renderWebGL = function (renderSession) { if (!this.visible || this.alpha <= 0) return; var i, j; if (this._mask || this._filters) { var spriteBatch = renderSession.spriteBatch; if (this._filters) { spriteBatch.flush(); renderSession.filterManager.pushFilter(this._filterBlock) } if (this._mask) { spriteBatch.stop(); renderSession.maskManager.pushMask(this.mask, renderSession); spriteBatch.start() } spriteBatch.render(this); for (i = 0, j = this.children.length; i < j; i++) this.children[i]._renderWebGL(renderSession); spriteBatch.stop(); if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession); if (this._filters) renderSession.filterManager.popFilter(); spriteBatch.start() } else { renderSession.spriteBatch.render(this); for (i = 0, j = this.children.length; i < j; i++) this.children[i]._renderWebGL(renderSession) } }; PIXI.Sprite.prototype._renderCanvas = function (renderSession) { if (this.visible === false || this.alpha === 0) return; if (this.blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = this.blendMode; renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode] } if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession.context); if (this.texture.valid) { renderSession.context.globalAlpha = this.worldAlpha; if (renderSession.roundPixels) renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx | 0, this.worldTransform.ty | 0); else renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx, this.worldTransform.ty); if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) { renderSession.scaleMode = this.texture.baseTexture.scaleMode; renderSession.context[renderSession.smoothProperty] = renderSession.scaleMode === PIXI.scaleModes.LINEAR } var source = this.texture.baseTexture.source; var dx = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width; var dy = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height; if (this.tint !== 16777215) { if (this.cachedTint !== this.tint) { this.cachedTint = this.tint; this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint) } source = this.tintedTexture } renderSession.context.drawImage(source, this.texture.crop.x, this.texture.crop.y, this.texture.crop.width, this.texture.crop.height, dx, dy, this.texture.crop.width, this.texture.crop.height) } for (var i = 0, j = this.children.length; i < j; i++) this.children[i]._renderCanvas(renderSession); if (this._mask) renderSession.maskManager.popMask(renderSession.context) }; PIXI.Sprite.fromFrame = function (frameId) { var texture = PIXI.TextureCache[frameId]; if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this); return new PIXI.Sprite(texture) }; PIXI.Sprite.fromImage = function (imageId, crossorigin, scaleMode) { var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode); return new PIXI.Sprite(texture) }; PIXI.SpriteBatch = function (texture) { PIXI.DisplayObjectContainer.call(this); this.textureThing = texture; this.ready = false }; PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.SpriteBatch.constructor = PIXI.SpriteBatch; PIXI.SpriteBatch.prototype.initWebGL = function (gl) { this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl); this.ready = true }; PIXI.SpriteBatch.prototype.updateTransform = function () { PIXI.DisplayObject.prototype.updateTransform.call(this) }; PIXI.SpriteBatch.prototype._renderWebGL = function (renderSession) { if (!this.visible || this.alpha <= 0 || !this.children.length) return; if (!this.ready) this.initWebGL(renderSession.gl); renderSession.spriteBatch.stop(); renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader); this.fastSpriteBatch.begin(this, renderSession); this.fastSpriteBatch.render(this); renderSession.spriteBatch.start() }; PIXI.SpriteBatch.prototype._renderCanvas = function (renderSession) { var context = renderSession.context; context.globalAlpha = this.worldAlpha; PIXI.DisplayObject.prototype.updateTransform.call(this); var transform = this.worldTransform; var isRotated = true; for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; if (!child.visible) continue; var texture = child.texture; var frame = texture.frame; context.globalAlpha = this.worldAlpha * child.alpha; if (child.rotation % (Math.PI * 2) === 0) { if (isRotated) { context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty); isRotated = false } context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width * child.scale.x + child.position.x + 0.5 | 0, child.anchor.y * -frame.height * child.scale.y + child.position.y + 0.5 | 0, frame.width * child.scale.x, frame.height * child.scale.y) } else { if (!isRotated) isRotated = true; PIXI.DisplayObject.prototype.updateTransform.call(child); var childTransform = child.worldTransform; if (renderSession.roundPixels) context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0); else context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty); context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width + 0.5 | 0, child.anchor.y * -frame.height + 0.5 | 0, frame.width, frame.height) } } }; PIXI.MovieClip = function (textures) { PIXI.Sprite.call(this, textures[0]); this.textures = textures; this.animationSpeed = 1; this.loop = true; this.onComplete = null; this.currentFrame = 0; this.playing = false }; PIXI.MovieClip.prototype = Object.create(PIXI.Sprite.prototype); PIXI.MovieClip.prototype.constructor = PIXI.MovieClip; Object.defineProperty(PIXI.MovieClip.prototype, "totalFrames", { get: function () { return this.textures.length } }); PIXI.MovieClip.prototype.stop = function () { this.playing = false }; PIXI.MovieClip.prototype.play = function () { this.playing = true }; PIXI.MovieClip.prototype.gotoAndStop = function (frameNumber) { this.playing = false; this.currentFrame = frameNumber; var round = this.currentFrame + 0.5 | 0; this.setTexture(this.textures[round % this.textures.length]) }; PIXI.MovieClip.prototype.gotoAndPlay = function (frameNumber) { this.currentFrame = frameNumber; this.playing = true }; PIXI.MovieClip.prototype.updateTransform = function () { PIXI.Sprite.prototype.updateTransform.call(this); if (!this.playing) return; this.currentFrame += this.animationSpeed * this.stage.time.timeScale; var round = this.currentFrame + 0.5 | 0; this.currentFrame = this.currentFrame % this.textures.length; if (this.loop || round < this.textures.length) this.setTexture(this.textures[round % this.textures.length]); else if (round >= this.textures.length) { this.gotoAndStop(this.textures.length - 1); if (this.onComplete) this.onComplete() } }; PIXI.MovieClip.fromFrames = function (frames) { var textures = []; for (var i = 0; i < frames.length; i++) textures.push(new PIXI.Texture.fromFrame(frames[i])); return new PIXI.MovieClip(textures) }; PIXI.MovieClip.fromImages = function (images) { var textures = []; for (var i = 0; i < images.length; i++) textures.push(new PIXI.Texture.fromImage(images[i])); return new PIXI.MovieClip(textures) }; PIXI.FilterBlock = function () { this.visible = true; this.renderable = true }; PIXI.Text = function (text, style) { this.canvas = document.createElement("canvas"); this.context = this.canvas.getContext("2d"); PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas)); this.setText(text); this.setStyle(style); this.updateText(); this.dirty = false }; PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype); PIXI.Text.prototype.constructor = PIXI.Text; Object.defineProperty(PIXI.Text.prototype, "width", { get: function () { if (this.dirty) { this.updateText(); this.dirty = false } return this.scale.x * this.texture.frame.width }, set: function (value) { this.scale.x = value / this.texture.frame.width; this._width = value } }); Object.defineProperty(PIXI.Text.prototype, "height", { get: function () { if (this.dirty) { this.updateText(); this.dirty = false } return this.scale.y * this.texture.frame.height }, set: function (value) { this.scale.y = value / this.texture.frame.height; this._height = value } }); PIXI.Text.prototype.setStyle = function (style) { style = style || {}; style.font = style.font || "bold 20pt Arial"; style.fill = style.fill || "black"; style.align = style.align || "left"; style.stroke = style.stroke || "black"; style.strokeThickness = style.strokeThickness || 0; style.wordWrap = style.wordWrap || false; style.wordWrapWidth = style.wordWrapWidth || 100; style.wordWrapWidth = style.wordWrapWidth || 100; style.dropShadow = style.dropShadow || false; style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6; style.dropShadowDistance = style.dropShadowDistance || 4; style.dropShadowColor = style.dropShadowColor || "black"; style.dropShadowBlur = style.dropShadowBlur || 0; this.style = style; this.dirty = true }; PIXI.Text.prototype.setText = function (text) { text = text.toString() || " "; if (this.text && text === this.text) return; this.text = text; this.dirty = true }; PIXI.Text.prototype.updateText = function () { this.context.font = this.style.font; var outputText = this.text; if (this.style.wordWrap) outputText = this.wordWrap(this.text); var lines = outputText.split(/(?:\r\n|\r|\n)/); var lineWidths = []; var maxLineWidth = 0; for (var i = 0; i < lines.length; i++) { var lineWidth = this.context.measureText(lines[i]).width; lineWidths[i] = lineWidth; maxLineWidth = Math.max(maxLineWidth, lineWidth) } var width = maxLineWidth + this.style.strokeThickness; if (this.style.dropShadow) width += this.style.dropShadowDistance; this._width = width; var lineHeight = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness; var height = lineHeight * lines.length; if (this.style.dropShadow) height += this.style.dropShadowDistance; this._height = height; if (this.canvas.width < Math.ceil(width) || this.canvas.height < Math.ceil(height)) { this.canvas.width = Math.ceil(width); this.canvas.height = Math.ceil(height) } else this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); this.context.font = this.style.font; this.context.strokeStyle = this.style.stroke; this.context.lineWidth = this.style.strokeThickness; this.context.textBaseline = "top"; var linePositionX; var linePositionY; this.context.fillStyle = this.style.fill; var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance; var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance; for (i = 0; i < lines.length; i++) { linePositionX = this.style.strokeThickness / 2; linePositionY = this.style.strokeThickness / 2 + i * lineHeight; if (this.style.dropShadow) { this.context.shadowColor = this.style.dropShadowColor; this.context.shadowOffsetX = xShadowOffset; this.context.shadowOffsetY = yShadowOffset; this.context.shadowBlur = this.style.dropShadowBlur } if (this.style.align === "right") linePositionX += maxLineWidth - lineWidths[i]; else if (this.style.align === "center") linePositionX += (maxLineWidth - lineWidths[i]) / 2; if (this.style.stroke && this.style.strokeThickness) this.context.strokeText(lines[i], linePositionX, linePositionY); if (this.style.fill) this.context.fillText(lines[i], linePositionX, linePositionY) } this.updateTexture() }; PIXI.Text.prototype.updateTexture = function () { this.texture.baseTexture.width = this._width; this.texture.baseTexture.height = this._height; this.texture.crop.width = this.texture.frame.width = this._width; this.texture.crop.height = this.texture.frame.height = this._height; this.requiresUpdate = true }; PIXI.Text.prototype._renderWebGL = function (renderSession) { if (this.requiresUpdate) { this.canvas.width = this._width; this.canvas.height = this._height; this.updateText(); this.requiresUpdate = false; PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl) } PIXI.Sprite.prototype._renderWebGL.call(this, renderSession) }; PIXI.Text.prototype.updateTransform = function () { if (this.dirty) { this.updateText(); this.dirty = false } PIXI.Sprite.prototype.updateTransform.call(this) }; PIXI.Text.prototype.determineFontHeight = function (fontStyle) { var result = PIXI.Text.heightCache[fontStyle]; if (!result) { var body = document.getElementsByTagName("body")[0]; var dummy = document.createElement("div"); var dummyText = document.createTextNode("M"); dummy.appendChild(dummyText); dummy.setAttribute("style", fontStyle + ";position:absolute;top:0;left:0"); body.appendChild(dummy); result = dummy.offsetHeight; PIXI.Text.heightCache[fontStyle] = result; body.removeChild(dummy) } return result }; PIXI.Text.prototype.wordWrap = function (text) { var result = ""; var lines = text.split("\n"); for (var i = 0; i < lines.length; i++) { var spaceLeft = this.style.wordWrapWidth; var words = lines[i].split(" "); for (var j = 0; j < words.length; j++) { var wordWidth = this.context.measureText(words[j]).width; var wordWidthWithSpace = wordWidth + this.context.measureText(" ").width; if (j === 0 || wordWidthWithSpace > spaceLeft) { if (j > 0) result += "\n"; result += words[j]; spaceLeft = this.style.wordWrapWidth - wordWidth } else { spaceLeft -= wordWidthWithSpace; result += " " + words[j] } } if (i < lines.length - 1) result += "\n" } return result }; PIXI.Text.prototype.destroy = function (destroyBaseTexture) { this.context = null; this.canvas = null; this.texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture) }; PIXI.Text.heightCache = {}; PIXI.BitmapText = function (text, style) { PIXI.DisplayObjectContainer.call(this); this._pool = []; this.setText(text); this.setStyle(style); this.updateText(); this.dirty = false }; PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.BitmapText.prototype.constructor = PIXI.BitmapText; PIXI.BitmapText.prototype.setText = function (text) { this.text = text || " "; this.dirty = true }; PIXI.BitmapText.prototype.setStyle = function (style) { style = style || {}; style.align = style.align || "left"; this.style = style; var font = style.font.split(" "); this.fontName = font[font.length - 1]; this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size; this.dirty = true; this.tint = style.tint }; PIXI.BitmapText.prototype.updateText = function () { var data = PIXI.BitmapText.fonts[this.fontName]; var pos = new PIXI.Point; var prevCharCode = null; var chars = []; var maxLineWidth = 0; var lineWidths = []; var line = 0; var scale = this.fontSize / data.size; for (var i = 0; i < this.text.length; i++) { var charCode = this.text.charCodeAt(i); if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) { lineWidths.push(pos.x); maxLineWidth = Math.max(maxLineWidth, pos.x); line++; pos.x = 0; pos.y += data.lineHeight; prevCharCode = null; continue } var charData = data.chars[charCode]; if (!charData) continue; if (prevCharCode && charData[prevCharCode]) pos.x += charData.kerning[prevCharCode]; chars.push({ texture: charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset) }); pos.x += charData.xAdvance; prevCharCode = charCode } lineWidths.push(pos.x); maxLineWidth = Math.max(maxLineWidth, pos.x); var lineAlignOffsets = []; for (i = 0; i <= line; i++) { var alignOffset = 0; if (this.style.align === "right") alignOffset = maxLineWidth - lineWidths[i]; else if (this.style.align === "center") alignOffset = (maxLineWidth - lineWidths[i]) / 2; lineAlignOffsets.push(alignOffset) } var lenChildren = this.children.length; var lenChars = chars.length; var tint = this.tint || 16777215; for (i = 0; i < lenChars; i++) { var c = i < lenChildren ? this.children[i] : this._pool.pop(); if (c) c.setTexture(chars[i].texture); else c = new PIXI.Sprite(chars[i].texture); c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale; c.position.y = chars[i].position.y * scale; c.scale.x = c.scale.y = scale; c.tint = tint; if (!c.parent) this.addChild(c) } while (this.children.length > lenChars) { var child = this.getChildAt(this.children.length - 1); this._pool.push(child); this.removeChild(child) } this.textWidth = maxLineWidth * scale; this.textHeight = (pos.y + data.lineHeight) * scale }; PIXI.BitmapText.prototype.updateTransform = function () { if (this.dirty) { this.updateText(); this.dirty = false } PIXI.DisplayObjectContainer.prototype.updateTransform.call(this) }; PIXI.BitmapText.fonts = {}; PIXI.InteractionData = function () { this.global = new PIXI.Point; this.target = null; this.originalEvent = null }; PIXI.InteractionData.prototype.getLocalPosition = function (displayObject) { var worldTransform = displayObject.worldTransform; var global = this.global; var a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx, a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty, id = 1 / (a00 * a11 + a01 * -a10); return new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id, a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id) }; PIXI.InteractionData.prototype.constructor = PIXI.InteractionData; PIXI.InteractionManager = function (stage) { this.stage = stage; this.mouse = new PIXI.InteractionData; this.touchs = {}; this.tempPoint = new PIXI.Point; this.mouseoverEnabled = true; this.pool = []; this.interactiveItems = []; this.interactionDOMElement = null; this.onMouseMove = this.onMouseMove.bind(this); this.onMouseDown = this.onMouseDown.bind(this); this.onMouseOut = this.onMouseOut.bind(this); this.onMouseUp = this.onMouseUp.bind(this); this.onTouchStart = this.onTouchStart.bind(this); this.onTouchEnd = this.onTouchEnd.bind(this); this.onTouchMove = this.onTouchMove.bind(this); this.last = 0; this.currentCursorStyle = "inherit"; this.mouseOut = false }; PIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager; PIXI.InteractionManager.prototype.collectInteractiveSprite = function (displayObject, iParent) { var children = displayObject.children; var length = children.length; for (var i = length - 1; i >= 0; i--) { var child = children[i]; if (child._interactive) { iParent.interactiveChildren = true; this.interactiveItems.push(child); if (child.children.length > 0) this.collectInteractiveSprite(child, child) } else { child.__iParent = null; if (child.children.length > 0) this.collectInteractiveSprite(child, iParent) } } }; PIXI.InteractionManager.prototype.setTarget = function (target) { this.target = target; if (this.interactionDOMElement === null) this.setTargetDomElement(target.view) }; PIXI.InteractionManager.prototype.setTargetDomElement = function (domElement) { this.removeEvents(); if (window.navigator.msPointerEnabled) { domElement.style["-ms-content-zooming"] = "none"; domElement.style["-ms-touch-action"] = "none" } this.interactionDOMElement = domElement; domElement.addEventListener("mousemove", this.onMouseMove, true); domElement.addEventListener("mousedown", this.onMouseDown, true); domElement.addEventListener("mouseout", this.onMouseOut, true); domElement.addEventListener("touchstart", this.onTouchStart, true); domElement.addEventListener("touchend", this.onTouchEnd, true); domElement.addEventListener("touchmove", this.onTouchMove, true); window.addEventListener("mouseup", this.onMouseUp, true) }; PIXI.InteractionManager.prototype.removeEvents = function () { if (!this.interactionDOMElement) return; this.interactionDOMElement.style["-ms-content-zooming"] = ""; this.interactionDOMElement.style["-ms-touch-action"] = ""; this.interactionDOMElement.removeEventListener("mousemove", this.onMouseMove, true); this.interactionDOMElement.removeEventListener("mousedown", this.onMouseDown, true); this.interactionDOMElement.removeEventListener("mouseout", this.onMouseOut, true); this.interactionDOMElement.removeEventListener("touchstart", this.onTouchStart, true); this.interactionDOMElement.removeEventListener("touchend", this.onTouchEnd, true); this.interactionDOMElement.removeEventListener("touchmove", this.onTouchMove, true); this.interactionDOMElement = null; window.removeEventListener("mouseup", this.onMouseUp, true) }; PIXI.InteractionManager.prototype.update = function () { if (!this.target) return; var now = Date.now(); var diff = now - this.last; diff = diff * PIXI.INTERACTION_FREQUENCY / 1E3; if (diff < 1) return; this.last = now; var i = 0; if (this.dirty) this.rebuildInteractiveGraph(); var length = this.interactiveItems.length; var cursor = "inherit"; var over = false; for (i = 0; i < length; i++) { var item = this.interactiveItems[i]; item.__hit = this.hitTest(item, this.mouse); this.mouse.target = item; if (item.__hit && !over) { if (item.buttonMode) cursor = item.defaultCursor; if (!item.interactiveChildren) over = true; if (!item.__isOver) { if (item.mouseover) item.mouseover(this.mouse); item.__isOver = true } } else if (item.__isOver) { if (item.mouseout) item.mouseout(this.mouse); item.__isOver = false } } if (this.currentCursorStyle !== cursor) { this.currentCursorStyle = cursor; this.interactionDOMElement.style.cursor = cursor } }; PIXI.InteractionManager.prototype.rebuildInteractiveGraph = function () { this.dirty = false; var len = this.interactiveItems.length; for (var i = 0; i < len; i++) this.interactiveItems[i].interactiveChildren = false; this.interactiveItems = []; if (this.stage.interactive) this.interactiveItems.push(this.stage); this.collectInteractiveSprite(this.stage, this.stage) }; PIXI.InteractionManager.prototype.onMouseMove = function (event) { if (this.dirty) this.rebuildInteractiveGraph(); this.mouse.originalEvent = event || window.event; var rect = this.interactionDOMElement.getBoundingClientRect(); this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width); this.mouse.global.y = (event.clientY - rect.top) * (this.target.height / rect.height); var length = this.interactiveItems.length; for (var i = 0; i < length; i++) { var item = this.interactiveItems[i]; if (item.mousemove) { item.mousemove(this.mouse); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) this.mouse.originalEvent.preventDefault() } } }; PIXI.InteractionManager.prototype.onMouseDown = function (event) { if (this.dirty) this.rebuildInteractiveGraph(); this.mouse.originalEvent = event || window.event; if (PIXI.AUTO_PREVENT_DEFAULT) this.mouse.originalEvent.preventDefault(); var length = this.interactiveItems.length; for (var i = 0; i < length; i++) { var item = this.interactiveItems[i]; if (item.mousedown || item.click) { item.__mouseIsDown = true; item.__hit = this.hitTest(item, this.mouse); if (item.__hit) { if (item.mousedown) { item.mousedown(this.mouse); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) this.mouse.originalEvent.preventDefault() } item.__isDown = true; if (!item.interactiveChildren) break } } } }; PIXI.InteractionManager.prototype.onMouseOut = function () { if (this.dirty) this.rebuildInteractiveGraph(); var length = this.interactiveItems.length; this.interactionDOMElement.style.cursor = "inherit"; for (var i = 0; i < length; i++) { var item = this.interactiveItems[i]; if (item.__isOver) { this.mouse.target = item; if (item.mouseout) { item.mouseout(this.mouse); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) this.mouse.originalEvent.preventDefault() } item.__isOver = false } } this.mouseOut = true; this.mouse.global.x = -1E4; this.mouse.global.y = -1E4 }; PIXI.InteractionManager.prototype.onMouseUp = function (event) { if (this.dirty) this.rebuildInteractiveGraph(); this.mouse.originalEvent = event || window.event; var length = this.interactiveItems.length; var up = false; for (var i = 0; i < length; i++) { var item = this.interactiveItems[i]; item.__hit = this.hitTest(item, this.mouse); if (item.__hit && !up) { if (item.mouseup) { item.mouseup(this.mouse); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) this.mouse.originalEvent.preventDefault() } if (item.__isDown) if (item.click) { item.click(this.mouse); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) this.mouse.originalEvent.preventDefault() } if (!item.interactiveChildren) up = true } else if (item.__isDown) if (item.mouseupoutside) { item.mouseupoutside(this.mouse); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) this.mouse.originalEvent.preventDefault() } item.__isDown = false } }; PIXI.InteractionManager.prototype.hitTest = function (item, interactionData) { var global = interactionData.global; if (!item.worldVisible) return false; var isSprite = item instanceof PIXI.Sprite, worldTransform = item.worldTransform, a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx, a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty, id = 1 / (a00 * a11 + a01 * -a10), x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id, y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id; interactionData.target = item; if (item.hitArea && item.hitArea.contains) { if (item.hitArea.contains(x, y)) { interactionData.target = item; return true } return false } else if (isSprite) { var width = item.texture.frame.width, height = item.texture.frame.height, x1 = -width * item.anchor.x, y1; if (x > x1 && x < x1 + width) { y1 = -height * item.anchor.y; if (y > y1 && y < y1 + height) { interactionData.target = item; return true } } } var length = item.children.length; for (var i = 0; i < length; i++) { var tempItem = item.children[i]; var hit = this.hitTest(tempItem, interactionData); if (hit) { interactionData.target = item; return true } } return false }; PIXI.InteractionManager.prototype.onTouchMove = function (event) { if (this.dirty) this.rebuildInteractiveGraph(); var rect = this.interactionDOMElement.getBoundingClientRect(); var changedTouches = event.changedTouches; var touchData; var i = 0; for (i = 0; i < changedTouches.length; i++) { var touchEvent = changedTouches[i]; if (touchEvent.target.id != "sjs") return; touchData = this.touchs[touchEvent.identifier]; touchData.originalEvent = event || window.event; touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width); touchData.global.y = (touchEvent.clientY - rect.top) * (this.target.height / rect.height); if (navigator.isCocoonJS) { touchData.global.x = touchEvent.clientX; touchData.global.y = touchEvent.clientY } for (var j = 0; j < this.interactiveItems.length; j++) { var item = this.interactiveItems[j]; if (item.touchmove && item.__touchData && item.__touchData[touchEvent.identifier]) { item.touchmove(touchData); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) event.preventDefault() } } } }; PIXI.InteractionManager.prototype.onTouchStart = function (event) { if (this.dirty) this.rebuildInteractiveGraph(); var rect = this.interactionDOMElement.getBoundingClientRect(); if (PIXI.AUTO_PREVENT_DEFAULT) event.preventDefault(); var changedTouches = event.changedTouches; for (var i = 0; i < changedTouches.length; i++) { var touchEvent = changedTouches[i]; var touchData = this.pool.pop(); if (!touchData) touchData = new PIXI.InteractionData; touchData.originalEvent = event || window.event; this.touchs[touchEvent.identifier] = touchData; touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width); touchData.global.y = (touchEvent.clientY - rect.top) * (this.target.height / rect.height); if (navigator.isCocoonJS) { touchData.global.x = touchEvent.clientX; touchData.global.y = touchEvent.clientY } var length = this.interactiveItems.length; for (var j = 0; j < length; j++) { var item = this.interactiveItems[j]; if (item.touchstart || item.tap) { item.__hit = this.hitTest(item, touchData); if (item.__hit) { if (item.touchstart) { item.touchstart(touchData); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) event.preventDefault() } item.__isDown = true; item.__touchData = item.__touchData || {}; item.__touchData[touchEvent.identifier] = touchData; if (!item.interactiveChildren) break } } } } }; PIXI.InteractionManager.prototype.onTouchEnd = function (event) { if (this.dirty) this.rebuildInteractiveGraph(); var rect = this.interactionDOMElement.getBoundingClientRect(); var changedTouches = event.changedTouches; for (var i = 0; i < changedTouches.length; i++) { var touchEvent = changedTouches[i]; var touchData = this.touchs[touchEvent.identifier]; var up = false; touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width); touchData.global.y = (touchEvent.clientY - rect.top) * (this.target.height / rect.height); if (navigator.isCocoonJS) { touchData.global.x = touchEvent.clientX; touchData.global.y = touchEvent.clientY } var length = this.interactiveItems.length; for (var j = 0; j < length; j++) { var item = this.interactiveItems[j]; if (item.__touchData && item.__touchData[touchEvent.identifier]) { item.__hit = this.hitTest(item, item.__touchData[touchEvent.identifier]); touchData.originalEvent = event || window.event; if (item.touchend || item.tap) { if (item.__hit && !up) { if (item.touchend) { item.touchend(touchData); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) event.preventDefault() } if (item.__isDown) if (item.tap) { item.tap(touchData); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) event.preventDefault() } if (!item.interactiveChildren) up = true } else if (item.__isDown) if (item.touchendoutside) { item.touchendoutside(touchData); if (PIXI.AUTO_PREVENT_DEFAULT_ON_INTERACTION) event.preventDefault() } item.__isDown = false } item.__touchData[touchEvent.identifier] = null } } this.pool.push(touchData); this.touchs[touchEvent.identifier] = null } }; PIXI.Stage = function (backgroundColor) { PIXI.DisplayObjectContainer.call(this); this.worldTransform = new PIXI.Matrix; this.interactive = true; this.interactionManager = new PIXI.InteractionManager(this); this.dirty = true; this.time = null; this.stage = this; this.stage.hitArea = new PIXI.Rectangle(0, 0, 1E5, 1E5); this.setBackgroundColor(backgroundColor) }; PIXI.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Stage.prototype.constructor = PIXI.Stage; PIXI.Stage.prototype.setInteractionDelegate = function (domElement) { this.interactionManager.setTargetDomElement(domElement) }; PIXI.Stage.prototype.updateTransform = function () { this.worldAlpha = 1; for (var i = 0, j = this.children.length; i < j; i++) this.children[i].updateTransform(); if (this.dirty) { this.dirty = false; this.interactionManager.dirty = true } }; PIXI.Stage.prototype.setBackgroundColor = function (backgroundColor) { this.backgroundColor = backgroundColor || 0; this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor); var hex = this.backgroundColor.toString(16); hex = "000000".substr(0, 6 - hex.length) + hex; this.backgroundColorString = "#" + hex }; PIXI.Stage.prototype.getMousePosition = function () { return this.interactionManager.mouse.global }; var lastTime = 0; var vendors = ["ms", "moz", "webkit", "o"]; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"]; window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"] } if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback) { var currTime = (new Date).getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function () { callback(currTime + timeToCall) }, timeToCall); lastTime = currTime + timeToCall; return id }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) { clearTimeout(id) }; window.requestAnimFrame = window.requestAnimationFrame; PIXI.hex2rgb = function (hex) { return [(hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255] }; PIXI.rgb2hex = function (rgb) { return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255 }; if (typeof Function.prototype.bind !== "function") Function.prototype.bind = function () { var slice = Array.prototype.slice; return function (thisArg) { var target = this, boundArgs = slice.call(arguments, 1); if (typeof target !== "function") throw new TypeError; function bound() { var args = boundArgs.concat(slice.call(arguments)); target.apply(this instanceof bound ? this : thisArg, args) } bound.prototype = function F(proto) { if (proto) F.prototype = proto; if (!(this instanceof F)) return new F }(target.prototype); return bound } }(); PIXI.AjaxRequest = function () { if (window.XMLHttpRequest) return new window.XMLHttpRequest; else return false }; PIXI.canUseNewCanvasBlendModes = function () { var canvas = document.createElement("canvas"); canvas.width = 1; canvas.height = 1; var context = canvas.getContext("2d"); context.fillStyle = "#000"; context.fillRect(0, 0, 1, 1); context.globalCompositeOperation = "multiply"; context.fillStyle = "#fff"; context.fillRect(0, 0, 1, 1); return context.getImageData(0, 0, 1, 1).data[0] === 0 }; PIXI.getNextPowerOfTwo = function (number) { if (number > 0 && (number & number - 1) === 0) return number; else { var result = 1; while (result < number) result <<= 1; return result } }; PIXI.EventTarget = function () { var listeners = {}; this.addEventListener = this.on = function (type, listener) { if (listeners[type] === undefined) listeners[type] = []; if (listeners[type].indexOf(listener) === -1) listeners[type].unshift(listener) }; this.dispatchEvent = this.emit = function (event) { if (!listeners[event.type] || !listeners[event.type].length) return; for (var i = listeners[event.type].length - 1; i >= 0; i--) listeners[event.type][i](event) }; this.removeEventListener = this.off = function (type, listener) { if (listeners[type] === undefined) return; var index = listeners[type].indexOf(listener); if (index !== -1) listeners[type].splice(index, 1) }; this.removeAllEventListeners = function (type) { var a = listeners[type]; if (a) a.length = 0 } }; PIXI.autoDetectRenderer = function (width, height, view, transparent, antialias, targetFrameRate, minFrameRate) { if (!width) width = 800; if (!height) height = 600; var webgl = function () { try { var canvas = document.createElement("canvas"); return ! !window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")) } catch (e) { return false } }(); if (webgl) return new PIXI.WebGLRenderer(width, height, view, transparent, antialias, targetFrameRate, minFrameRate); return new PIXI.CanvasRenderer(width, height, view, transparent, targetFrameRate, minFrameRate) }; PIXI.autoDetectRecommendedRenderer = function (width, height, view, transparent, antialias) { if (!width) width = 800; if (!height) height = 600; var webgl = function () { try { var canvas = document.createElement("canvas"); return ! !window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")) } catch (e) { return false } }(); var isAndroid = /Android/i.test(navigator.userAgent); if (webgl && !isAndroid) return new PIXI.WebGLRenderer(width, height, view, transparent, antialias); return new PIXI.CanvasRenderer(width, height, view, transparent) }; PIXI.PolyK = {}; PIXI.PolyK.Triangulate = function (p) { var sign = true; var n = p.length >> 1; if (n < 3) return []; var tgs = []; var avl = []; for (var i = 0; i < n; i++) avl.push(i); i = 0; var al = n; while (al > 3) { var i0 = avl[(i + 0) % al]; var i1 = avl[(i + 1) % al]; var i2 = avl[(i + 2) % al]; var ax = p[2 * i0], ay = p[2 * i0 + 1]; var bx = p[2 * i1], by = p[2 * i1 + 1]; var cx = p[2 * i2], cy = p[2 * i2 + 1]; var earFound = false; if (PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign)) { earFound = true; for (var j = 0; j < al; j++) { var vi = avl[j]; if (vi === i0 || vi === i1 || vi === i2) continue; if (PIXI.PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) { earFound = false; break } } } if (earFound) { tgs.push(i0, i1, i2); avl.splice((i + 1) % al, 1); al--; i = 0 } else if (i++ > 3 * al) if (sign) { tgs = []; avl = []; for (i = 0; i < n; i++) avl.push(i); i = 0; al = n; sign = false } else { window.console.log("PIXI Warning: shape too complex to fill"); return [] } } tgs.push(avl[0], avl[1], avl[2]); return tgs }; PIXI.PolyK._PointInTriangle = function (px, py, ax, ay, bx, by, cx, cy) { var v0x = cx - ax; var v0y = cy - ay; var v1x = bx - ax; var v1y = by - ay; var v2x = px - ax; var v2y = py - ay; var dot00 = v0x * v0x + v0y * v0y; var dot01 = v0x * v1x + v0y * v1y; var dot02 = v0x * v2x + v0y * v2y; var dot11 = v1x * v1x + v1y * v1y; var dot12 = v1x * v2x + v1y * v2y; var invDenom = 1 / (dot00 * dot11 - dot01 * dot01); var u = (dot11 * dot02 - dot01 * dot12) * invDenom; var v = (dot00 * dot12 - dot01 * dot02) * invDenom; return u >= 0 && v >= 0 && u + v < 1 }; PIXI.PolyK._convex = function (ax, ay, bx, by, cx, cy, sign) { return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0 === sign }; PIXI.Time = function (targetFrameRate, minFrameRate) { if (targetFrameRate !== undefined) this.setTargetFrameRate(targetFrameRate); if (minFrameRate !== undefined) this.setMinFrameRate(minFrameRate) }; PIXI.Time.prototype = { timeScale: 1, _tFrameRate: 60, _minFrameRate: 12, _tMilli: 1E3 / 60, _minMilli: 1E3 / 12, _prevMilli: Date.now(), setTargetFrameRate: function (framerate) { this._tFrameRate = framerate; this._tMilli = 1E3 / framerate }, getTargetFrameRate: function () { return this._tFrameRate }, setMinFrameRate: function (framerate) { if (framerate > this._tFrameRate) throw "Your target minimum framerate must be smaller than your target framerate: " + this._tFrameRate; else { this._minFrameRate = framerate; this._minMilli = 1E3 / framerate } }, getMinFrameRate: function () { return this._minFrameRate }, update: function () { var curMilli = Date.now(); var milliDif = curMilli - this._prevMilli; if (milliDif > this._minMilli) milliDif = this._minMilli; this.timeScale = milliDif / this._tMilli; this._prevMilli = curMilli } }; Object.defineProperty(PIXI.Time.prototype, "targetFrameRate", { get: PIXI.Time.getTargetFrameRate, set: PIXI.Time.setTargetFrameRate }); Object.defineProperty(PIXI.Time.prototype, "minFrameRate", { get: PIXI.Time.getMinFrameRate, set: PIXI.Time.setMinFrameRate }); PIXI.initDefaultShaders = function () { }; PIXI.CompileVertexShader = function (gl, shaderSrc) { return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER) }; PIXI.CompileFragmentShader = function (gl, shaderSrc) { return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER) }; PIXI._CompileShader = function (gl, shaderSrc, shaderType) { var src = shaderSrc.join("\n"); var shader = gl.createShader(shaderType); gl.shaderSource(shader, src); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { window.console.log(gl.getShaderInfoLog(shader)); return null } return shader }; PIXI.compileProgram = function (gl, vertexSrc, fragmentSrc) { var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc); var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc); var shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) window.console.log("Could not initialise shaders"); return shaderProgram }; PIXI.PixiShader = function (gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]; this.textureCount = 0; this.attributes = []; this.init() }; PIXI.PixiShader.prototype.init = function () { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc); gl.useProgram(program); this.uSampler = gl.getUniformLocation(program, "uSampler"); this.projectionVector = gl.getUniformLocation(program, "projectionVector"); this.offsetVector = gl.getUniformLocation(program, "offsetVector"); this.dimensions = gl.getUniformLocation(program, "dimensions"); this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord"); this.colorAttribute = gl.getAttribLocation(program, "aColor"); if (this.colorAttribute === -1) this.colorAttribute = 2; this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute]; for (var key in this.uniforms) this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key); this.initUniforms(); this.program = program }; PIXI.PixiShader.prototype.initUniforms = function () { this.textureCount = 1; var gl = this.gl; var uniform; for (var key in this.uniforms) { uniform = this.uniforms[key]; var type = uniform.type; if (type === "sampler2D") { uniform._init = false; if (uniform.value !== null) this.initSampler2D(uniform) } else if (type === "mat2" || type === "mat3" || type === "mat4") { uniform.glMatrix = true; uniform.glValueLength = 1; if (type === "mat2") uniform.glFunc = gl.uniformMatrix2fv; else if (type === "mat3") uniform.glFunc = gl.uniformMatrix3fv; else if (type === "mat4") uniform.glFunc = gl.uniformMatrix4fv } else { uniform.glFunc = gl["uniform" + type]; if (type === "2f" || type === "2i") uniform.glValueLength = 2; else if (type === "3f" || type === "3i") uniform.glValueLength = 3; else if (type === "4f" || type === "4i") uniform.glValueLength = 4; else uniform.glValueLength = 1 } } }; PIXI.PixiShader.prototype.initSampler2D = function (uniform) { if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded) return; var gl = this.gl; gl.activeTexture(gl["TEXTURE" + this.textureCount]); gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]); if (uniform.textureData) { var data = uniform.textureData; var magFilter = data.magFilter ? data.magFilter : gl.LINEAR; var minFilter = data.minFilter ? data.minFilter : gl.LINEAR; var wrapS = data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE; var wrapT = data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE; var format = data.luminance ? gl.LUMINANCE : gl.RGBA; if (data.repeat) { wrapS = gl.REPEAT; wrapT = gl.REPEAT } gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, ! !data.flipY); if (data.width) { var width = data.width ? data.width : 512; var height = data.height ? data.height : 2; var border = data.border ? data.border : 0; gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null) } else gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT) } gl.uniform1i(uniform.uniformLocation, this.textureCount); uniform._init = true; this.textureCount++ }; PIXI.PixiShader.prototype.syncUniforms = function () { this.textureCount = 1; var uniform; var gl = this.gl; for (var key in this.uniforms) { uniform = this.uniforms[key]; if (uniform.glValueLength === 1) if (uniform.glMatrix === true) uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value); else uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value); else if (uniform.glValueLength === 2) uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y); else if (uniform.glValueLength === 3) uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z); else if (uniform.glValueLength === 4) uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w); else if (uniform.type === "sampler2D") if (uniform._init) { gl.activeTexture(gl["TEXTURE" + this.textureCount]); gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(uniform.value.baseTexture, gl)); gl.uniform1i(uniform.uniformLocation, this.textureCount); this.textureCount++ } else this.initSampler2D(uniform) } }; PIXI.PixiShader.prototype.destroy = function () { this.gl.deleteProgram(this.program); this.uniforms = null; this.gl = null; this.attributes = null }; PIXI.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}"]; PIXI.PixiFastShader = function (gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]; this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"]; this.textureCount = 0; this.init() }; PIXI.PixiFastShader.prototype.init = function () { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.uSampler = gl.getUniformLocation(program, "uSampler"); this.projectionVector = gl.getUniformLocation(program, "projectionVector"); this.offsetVector = gl.getUniformLocation(program, "offsetVector"); this.dimensions = gl.getUniformLocation(program, "dimensions"); this.uMatrix = gl.getUniformLocation(program, "uMatrix"); this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); this.aPositionCoord = gl.getAttribLocation(program, "aPositionCoord"); this.aScale = gl.getAttribLocation(program, "aScale"); this.aRotation = gl.getAttribLocation(program, "aRotation"); this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord"); this.colorAttribute = gl.getAttribLocation(program, "aColor"); if (this.colorAttribute === -1) this.colorAttribute = 2; this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute]; this.program = program }; PIXI.PixiFastShader.prototype.destroy = function () { this.gl.deleteProgram(this.program); this.uniforms = null; this.gl = null; this.attributes = null }; PIXI.StripShader = function (gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}"]; this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"]; this.init() }; PIXI.StripShader.prototype.init = function () { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.uSampler = gl.getUniformLocation(program, "uSampler"); this.projectionVector = gl.getUniformLocation(program, "projectionVector"); this.offsetVector = gl.getUniformLocation(program, "offsetVector"); this.colorAttribute = gl.getAttribLocation(program, "aColor"); this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord"); this.attributes = [this.aVertexPosition, this.aTextureCoord]; this.translationMatrix = gl.getUniformLocation(program, "translationMatrix"); this.alpha = gl.getUniformLocation(program, "alpha"); this.program = program }; PIXI.PrimitiveShader = function (gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"]; this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"]; this.init() }; PIXI.PrimitiveShader.prototype.init = function () { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.projectionVector = gl.getUniformLocation(program, "projectionVector"); this.offsetVector = gl.getUniformLocation(program, "offsetVector"); this.tintColor = gl.getUniformLocation(program, "tint"); this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); this.colorAttribute = gl.getAttribLocation(program, "aColor"); this.attributes = [this.aVertexPosition, this.colorAttribute]; this.translationMatrix = gl.getUniformLocation(program, "translationMatrix"); this.alpha = gl.getUniformLocation(program, "alpha"); this.program = program }; PIXI.PrimitiveShader.prototype.destroy = function () { this.gl.deleteProgram(this.program); this.uniforms = null; this.gl = null; this.attribute = null }; PIXI.ComplexPrimitiveShader = function (gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"]; this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"]; this.init() }; PIXI.ComplexPrimitiveShader.prototype.init = function () { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.projectionVector = gl.getUniformLocation(program, "projectionVector"); this.offsetVector = gl.getUniformLocation(program, "offsetVector"); this.tintColor = gl.getUniformLocation(program, "tint"); this.color = gl.getUniformLocation(program, "color"); this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"); this.attributes = [this.aVertexPosition, this.colorAttribute]; this.translationMatrix = gl.getUniformLocation(program, "translationMatrix"); this.alpha = gl.getUniformLocation(program, "alpha"); this.program = program }; PIXI.ComplexPrimitiveShader.prototype.destroy = function () { this.gl.deleteProgram(this.program); this.uniforms = null; this.gl = null; this.attribute = null }; PIXI.WebGLGraphics = function () { }; PIXI.WebGLGraphics.renderGraphics = function (graphics, renderSession) { var gl = renderSession.gl; var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.primitiveShader, webGLData; if (graphics.dirty) PIXI.WebGLGraphics.updateGraphics(graphics, gl); var webGL = graphics._webGL[gl.id]; for (var i = 0; i < webGL.data.length; i++) if (webGL.data[i].mode === 1) { webGLData = webGL.data[i]; renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession); gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2); renderSession.stencilManager.popStencil(graphics, webGLData, renderSession); this.last = webGLData.mode } else { webGLData = webGL.data[i]; renderSession.shaderManager.setShader(shader); shader = renderSession.shaderManager.primitiveShader; gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true)); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)); gl.uniform1f(shader.alpha, graphics.worldAlpha); gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0); gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer); gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0) } }; PIXI.WebGLGraphics.updateGraphics = function (graphics, gl) { var webGL = graphics._webGL[gl.id]; if (!webGL) webGL = graphics._webGL[gl.id] = { lastIndex: 0, data: [], gl: gl }; graphics.dirty = false; var i; if (graphics.clearDirty) { graphics.clearDirty = false; for (i = 0; i < webGL.data.length; i++) { var graphicsData = webGL.data[i]; graphicsData.reset(); PIXI.WebGLGraphics.graphicsDataPool.push(graphicsData) } webGL.data = []; webGL.lastIndex = 0 } var webGLData; for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) { var data = graphics.graphicsData[i]; if (data.type === PIXI.Graphics.POLY) { if (data.fill) if (data.points.length > 6) if (data.points.length > 5 * 2) { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1); PIXI.WebGLGraphics.buildComplexPoly(data, webGLData) } else { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0); PIXI.WebGLGraphics.buildPoly(data, webGLData) } if (data.lineWidth > 0) { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0); PIXI.WebGLGraphics.buildLine(data, webGLData) } } else { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0); if (data.type === PIXI.Graphics.RECT) PIXI.WebGLGraphics.buildRectangle(data, webGLData); else if (data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP) PIXI.WebGLGraphics.buildCircle(data, webGLData); else if (data.type === PIXI.Graphics.RREC) PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData) } webGL.lastIndex++ } for (i = 0; i < webGL.data.length; i++) { webGLData = webGL.data[i]; if (webGLData.dirty) webGLData.upload() } }; PIXI.WebGLGraphics.switchMode = function (webGL, type) { var webGLData; if (!webGL.data.length) { webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl); webGLData.mode = type; webGL.data.push(webGLData) } else { webGLData = webGL.data[webGL.data.length - 1]; if (webGLData.mode !== type || type === 1) { webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl); webGLData.mode = type; webGL.data.push(webGLData) } } webGLData.dirty = true; return webGLData }; PIXI.WebGLGraphics.buildRectangle = function (graphicsData, webGLData) { var rectData = graphicsData.points; var x = rectData[0]; var y = rectData[1]; var width = rectData[2]; var height = rectData[3]; if (graphicsData.fill) { var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vertPos = verts.length / 6; verts.push(x, y); verts.push(r, g, b, alpha); verts.push(x + width, y); verts.push(r, g, b, alpha); verts.push(x, y + height); verts.push(r, g, b, alpha); verts.push(x + width, y + height); verts.push(r, g, b, alpha); indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3) } if (graphicsData.lineWidth) { var tempPoints = graphicsData.points; graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y]; PIXI.WebGLGraphics.buildLine(graphicsData, webGLData); graphicsData.points = tempPoints } }; PIXI.WebGLGraphics.buildRoundedRectangle = function (graphicsData, webGLData) { var points = graphicsData.points; var x = points[0]; var y = points[1]; var width = points[2]; var height = points[3]; var radius = points[4]; var recPoints = []; recPoints.push(x, y + radius); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height)); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius)); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y)); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius)); if (graphicsData.fill) { var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vecPos = verts.length / 6; var triangles = PIXI.PolyK.Triangulate(recPoints); var i = 0; for (i = 0; i < triangles.length; i += 3) { indices.push(triangles[i] + vecPos); indices.push(triangles[i] + vecPos); indices.push(triangles[i + 1] + vecPos); indices.push(triangles[i + 2] + vecPos); indices.push(triangles[i + 2] + vecPos) } for (i = 0; i < recPoints.length; i++) verts.push(recPoints[i], recPoints[++i], r, g, b, alpha) } if (graphicsData.lineWidth) { var tempPoints = graphicsData.points; graphicsData.points = recPoints; PIXI.WebGLGraphics.buildLine(graphicsData, webGLData); graphicsData.points = tempPoints } }; PIXI.WebGLGraphics.quadraticBezierCurve = function (fromX, fromY, cpX, cpY, toX, toY) { var xa, ya, xb, yb, x, y, n = 20, points = []; function getPt(n1, n2, perc) { var diff = n2 - n1; return n1 + diff * perc } var j = 0; for (var i = 0; i <= n; i++) { j = i / n; xa = getPt(fromX, cpX, j); ya = getPt(fromY, cpY, j); xb = getPt(cpX, toX, j); yb = getPt(cpY, toY, j); x = getPt(xa, xb, j); y = getPt(ya, yb, j); points.push(x, y) } return points }; PIXI.WebGLGraphics.buildCircle = function (graphicsData, webGLData) { var rectData = graphicsData.points; var x = rectData[0]; var y = rectData[1]; var width = rectData[2]; var height = rectData[3]; var totalSegs = 40; var seg = Math.PI * 2 / totalSegs; var i = 0; if (graphicsData.fill) { var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vecPos = verts.length / 6; indices.push(vecPos); for (i = 0; i < totalSegs + 1; i++) { verts.push(x, y, r, g, b, alpha); verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha); indices.push(vecPos++, vecPos++) } indices.push(vecPos - 1) } if (graphicsData.lineWidth) { var tempPoints = graphicsData.points; graphicsData.points = []; for (i = 0; i < totalSegs + 1; i++) graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height); PIXI.WebGLGraphics.buildLine(graphicsData, webGLData); graphicsData.points = tempPoints } }; PIXI.WebGLGraphics.buildLine = function (graphicsData, webGLData) { var i = 0; var points = graphicsData.points; if (points.length === 0) return; if (graphicsData.lineWidth % 2) for (i = 0; i < points.length; i++) points[i] += 0.5; var firstPoint = new PIXI.Point(points[0], points[1]); var lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]); if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) { points = points.slice(); points.pop(); points.pop(); lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]); var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5; var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5; points.unshift(midPointX, midPointY); points.push(midPointX, midPointY) } var verts = webGLData.points; var indices = webGLData.indices; var length = points.length / 2; var indexCount = points.length; var indexStart = verts.length / 6; var width = graphicsData.lineWidth / 2; var color = PIXI.hex2rgb(graphicsData.lineColor); var alpha = graphicsData.lineAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var px, py, p1x, p1y, p2x, p2y, p3x, p3y; var perpx, perpy, perp2x, perp2y, perp3x, perp3y; var a1, b1, c1, a2, b2, c2; var denom, pdist, dist; p1x = points[0]; p1y = points[1]; p2x = points[2]; p2y = points[3]; perpx = -(p1y - p2y); perpy = p1x - p2x; dist = Math.sqrt(perpx * perpx + perpy * perpy); perpx /= dist; perpy /= dist; perpx *= width; perpy *= width; verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha); verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha); for (i = 1; i < length - 1; i++) { p1x = points[(i - 1) * 2]; p1y = points[(i - 1) * 2 + 1]; p2x = points[i * 2]; p2y = points[i * 2 + 1]; p3x = points[(i + 1) * 2]; p3y = points[(i + 1) * 2 + 1]; perpx = -(p1y - p2y); perpy = p1x - p2x; dist = Math.sqrt(perpx * perpx + perpy * perpy); perpx /= dist; perpy /= dist; perpx *= width; perpy *= width; perp2x = -(p2y - p3y); perp2y = p2x - p3x; dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y); perp2x /= dist; perp2y /= dist; perp2x *= width; perp2y *= width; a1 = -perpy + p1y - (-perpy + p2y); b1 = -perpx + p2x - (-perpx + p1x); c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y); a2 = -perp2y + p3y - (-perp2y + p2y); b2 = -perp2x + p2x - (-perp2x + p3x); c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y); denom = a1 * b2 - a2 * b1; if (Math.abs(denom) < 0.1) { denom += 10.1; verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha); verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha); continue } px = (b1 * c2 - b2 * c1) / denom; py = (a2 * c1 - a1 * c2) / denom; pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y); if (pdist > 140 * 140) { perp3x = perpx - perp2x; perp3y = perpy - perp2y; dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y); perp3x /= dist; perp3y /= dist; perp3x *= width; perp3y *= width; verts.push(p2x - perp3x, p2y - perp3y); verts.push(r, g, b, alpha); verts.push(p2x + perp3x, p2y + perp3y); verts.push(r, g, b, alpha); verts.push(p2x - perp3x, p2y - perp3y); verts.push(r, g, b, alpha); indexCount++ } else { verts.push(px, py); verts.push(r, g, b, alpha); verts.push(p2x - (px - p2x), p2y - (py - p2y)); verts.push(r, g, b, alpha) } } p1x = points[(length - 2) * 2]; p1y = points[(length - 2) * 2 + 1]; p2x = points[(length - 1) * 2]; p2y = points[(length - 1) * 2 + 1]; perpx = -(p1y - p2y); perpy = p1x - p2x; dist = Math.sqrt(perpx * perpx + perpy * perpy); perpx /= dist; perpy /= dist; perpx *= width; perpy *= width; verts.push(p2x - perpx, p2y - perpy); verts.push(r, g, b, alpha); verts.push(p2x + perpx, p2y + perpy); verts.push(r, g, b, alpha); indices.push(indexStart); for (i = 0; i < indexCount; i++) indices.push(indexStart++); indices.push(indexStart - 1) }; PIXI.WebGLGraphics.buildComplexPoly = function (graphicsData, webGLData) { var points = graphicsData.points.slice(); if (points.length < 6) return; var indices = webGLData.indices; webGLData.points = points; webGLData.alpha = graphicsData.fillAlpha; webGLData.color = PIXI.hex2rgb(graphicsData.fillColor); var minX = Infinity; var maxX = -Infinity; var minY = Infinity; var maxY = -Infinity; var x, y; for (var i = 0; i < points.length; i += 2) { x = points[i]; y = points[i + 1]; minX = x < minX ? x : minX; maxX = x > maxX ? x : maxX; minY = y < minY ? y : minY; maxY = y > maxY ? y : maxY } points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY); var length = points.length / 2; for (i = 0; i < length; i++) indices.push(i) }; PIXI.WebGLGraphics.buildPoly = function (graphicsData, webGLData) { var points = graphicsData.points; if (points.length < 6) return; var verts = webGLData.points; var indices = webGLData.indices; var length = points.length / 2; var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var triangles = PIXI.PolyK.Triangulate(points); var vertPos = verts.length / 6; var i = 0; for (i = 0; i < triangles.length; i += 3) { indices.push(triangles[i] + vertPos); indices.push(triangles[i] + vertPos); indices.push(triangles[i + 1] + vertPos); indices.push(triangles[i + 2] + vertPos); indices.push(triangles[i + 2] + vertPos) } for (i = 0; i < length; i++) verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha) }; PIXI.WebGLGraphics.graphicsDataPool = []; PIXI.WebGLGraphicsData = function (gl) { this.gl = gl; this.color = [0, 0, 0]; this.points = []; this.indices = []; this.lastIndex = 0; this.buffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); this.mode = 1; this.alpha = 1; this.dirty = true }; PIXI.WebGLGraphicsData.prototype.reset = function () { this.points = []; this.indices = []; this.lastIndex = 0 }; PIXI.WebGLGraphicsData.prototype.upload = function () { var gl = this.gl; this.glPoints = new Float32Array(this.points); gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer); gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW); this.glIndicies = new Uint16Array(this.indices); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW); this.dirty = false }; PIXI.glContexts = []; PIXI.WebGLRenderer = function (width, height, view, transparent, antialias, preserveDrawingBuffer, targetFrameRate, minFrameRate) { if (!PIXI.defaultRenderer) { PIXI.sayHello("webGL"); PIXI.defaultRenderer = this } this.type = PIXI.WEBGL_RENDERER; this.transparent = ! !transparent; this.preserveDrawingBuffer = preserveDrawingBuffer; this.width = width || 800; this.height = height || 600; this.view = view || document.createElement("canvas"); this.view.width = this.width; this.view.height = this.height; this.contextLost = this.handleContextLost.bind(this); this.contextRestoredLost = this.handleContextRestored.bind(this); this.view.addEventListener("webglcontextlost", this.contextLost, false); this.view.addEventListener("webglcontextrestored", this.contextRestoredLost, false); this.options = { alpha: this.transparent, antialias: ! !antialias, premultipliedAlpha: ! !transparent, stencil: true, preserveDrawingBuffer: preserveDrawingBuffer }; var gl = null;["experimental-webgl", "webgl"].forEach(function (name) { try { gl = gl || this.view.getContext(name, this.options) } catch (e) { } }, this); this.time = new PIXI.Time(targetFrameRate, minFrameRate); if (!gl) throw new Error("This browser does not support webGL. Try using the canvas renderer" + this); this.gl = gl; this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++; PIXI.glContexts[this.glContextId] = gl; if (!PIXI.blendModesWebGL) { PIXI.blendModesWebGL = []; PIXI.blendModesWebGL[PIXI.blendModes.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.ADD] = [gl.SRC_ALPHA, gl.DST_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.SCREEN] = [gl.SRC_ALPHA, gl.ONE]; PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA] } this.projection = new PIXI.Point; this.projection.x = this.width / 2; this.projection.y = -this.height / 2; this.offset = new PIXI.Point(0, 0); this.resize(this.width, this.height); this.contextLost = false; this.shaderManager = new PIXI.WebGLShaderManager(gl); this.spriteBatch = new PIXI.WebGLSpriteBatch(gl); this.maskManager = new PIXI.WebGLMaskManager(gl); this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent); this.stencilManager = new PIXI.WebGLStencilManager(gl); this.blendModeManager = new PIXI.WebGLBlendModeManager(gl); this.renderSession = {}; this.renderSession.gl = this.gl; this.renderSession.drawCount = 0; this.renderSession.shaderManager = this.shaderManager; this.renderSession.maskManager = this.maskManager; this.renderSession.filterManager = this.filterManager; this.renderSession.blendModeManager = this.blendModeManager; this.renderSession.spriteBatch = this.spriteBatch; this.renderSession.stencilManager = this.stencilManager; this.renderSession.renderer = this; gl.useProgram(this.shaderManager.defaultShader.program); gl.disable(gl.DEPTH_TEST); gl.disable(gl.CULL_FACE); gl.enable(gl.BLEND); gl.colorMask(true, true, true, this.transparent) }; PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer; PIXI.WebGLRenderer.prototype.render = function (stage) { if (this.contextLost) return; if (this.__stage !== stage) { if (stage.interactive) stage.interactionManager.removeEvents(); this.__stage = stage } PIXI.WebGLRenderer.updateTextures(); stage.updateTransform(); if (stage._interactive) if (!stage._interactiveEventsAdded) { stage._interactiveEventsAdded = true; stage.interactionManager.setTarget(this) } var gl = this.gl; gl.viewport(0, 0, this.width, this.height); gl.bindFramebuffer(gl.FRAMEBUFFER, null); if (this.transparent) gl.clearColor(0, 0, 0, 0); else gl.clearColor(stage.backgroundColorSplit[0], stage.backgroundColorSplit[1], stage.backgroundColorSplit[2], 1); gl.clear(gl.COLOR_BUFFER_BIT); this.renderDisplayObject(stage, this.projection); if (stage.interactive) { if (!stage._interactiveEventsAdded) { stage._interactiveEventsAdded = true; stage.interactionManager.setTarget(this) } } else if (stage._interactiveEventsAdded) { stage._interactiveEventsAdded = false; stage.interactionManager.setTarget(this) } }; PIXI.WebGLRenderer.prototype.renderDisplayObject = function (displayObject, projection, buffer) { this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL); this.renderSession.drawCount = 0; this.renderSession.currentBlendMode = 9999; this.renderSession.projection = projection; this.renderSession.offset = this.offset; this.spriteBatch.begin(this.renderSession); displayObject.time = this.time; this.filterManager.begin(this.renderSession, buffer); displayObject._renderWebGL(this.renderSession); this.spriteBatch.end(); this.time.update() }; PIXI.WebGLRenderer.updateTextures = function () { var i = 0; for (i = 0; i < PIXI.Texture.frameUpdates.length; i++) PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]); for (i = 0; i < PIXI.texturesToDestroy.length; i++) PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]); PIXI.texturesToUpdate.length = 0; PIXI.texturesToDestroy.length = 0; PIXI.Texture.frameUpdates.length = 0 }; PIXI.WebGLRenderer.destroyTexture = function (texture) { for (var i = texture._glTextures.length - 1; i >= 0; i--) { var glTexture = texture._glTextures[i]; var gl = PIXI.glContexts[i]; if (gl && glTexture) gl.deleteTexture(glTexture) } texture._glTextures.length = 0 }; PIXI.WebGLRenderer.updateTextureFrame = function (texture) { texture._updateWebGLuvs() }; PIXI.WebGLRenderer.prototype.resize = function (width, height) { this.width = width; this.height = height; this.view.width = width; this.view.height = height; this.gl.viewport(0, 0, this.width, this.height); this.projection.x = this.width / 2; this.projection.y = -this.height / 2 }; PIXI.createWebGLTexture = function (texture, gl) { if (texture.hasLoaded) { texture._glTextures[gl.id] = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]); gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); if (!texture._powerOf2) { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE) } else { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT) } gl.bindTexture(gl.TEXTURE_2D, null); texture._dirty[gl.id] = false } return texture._glTextures[gl.id] }; PIXI.updateWebGLTexture = function (texture, gl) { if (texture._glTextures[gl.id]) { gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]); gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); if (!texture._powerOf2) { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE) } else { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT) } texture._dirty[gl.id] = false } }; PIXI.WebGLRenderer.prototype.handleContextLost = function (event) { event.preventDefault(); this.contextLost = true }; PIXI.WebGLRenderer.prototype.handleContextRestored = function () { try { this.gl = this.view.getContext("experimental-webgl", this.options) } catch (e) { try { this.gl = this.view.getContext("webgl", this.options) } catch (e2) { throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this); } } var gl = this.gl; gl.id = PIXI.WebGLRenderer.glContextId++; this.shaderManager.setContext(gl); this.spriteBatch.setContext(gl); this.primitiveBatch.setContext(gl); this.maskManager.setContext(gl); this.filterManager.setContext(gl); this.renderSession.gl = this.gl; gl.disable(gl.DEPTH_TEST); gl.disable(gl.CULL_FACE); gl.enable(gl.BLEND); gl.colorMask(true, true, true, this.transparent); this.gl.viewport(0, 0, this.width, this.height); for (var key in PIXI.TextureCache) { var texture = PIXI.TextureCache[key].baseTexture; texture._glTextures = [] } this.contextLost = false }; PIXI.WebGLRenderer.prototype.destroy = function () { this.view.removeEventListener("webglcontextlost", this.contextLost); this.view.removeEventListener("webglcontextrestored", this.contextRestoredLost); PIXI.glContexts[this.glContextId] = null; this.projection = null; this.offset = null; this.shaderManager.destroy(); this.spriteBatch.destroy(); this.primitiveBatch.destroy(); this.maskManager.destroy(); this.filterManager.destroy(); this.shaderManager = null; this.spriteBatch = null; this.maskManager = null; this.filterManager = null; this.gl = null; this.renderSession = null }; PIXI.WebGLRenderer.glContextId = 0; PIXI.WebGLBlendModeManager = function (gl) { this.gl = gl; this.currentBlendMode = 99999 }; PIXI.WebGLBlendModeManager.prototype.setBlendMode = function (blendMode) { if (this.currentBlendMode === blendMode) return false; this.currentBlendMode = blendMode; var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode]; this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]); return true }; PIXI.WebGLBlendModeManager.prototype.destroy = function () { this.gl = null }; PIXI.WebGLMaskManager = function (gl) { this.maskStack = []; this.maskPosition = 0; this.setContext(gl); this.reverse = false; this.count = 0 }; PIXI.WebGLMaskManager.prototype.setContext = function (gl) { this.gl = gl }; PIXI.WebGLMaskManager.prototype.pushMask = function (maskData, renderSession) { var gl = renderSession.gl; if (maskData.dirty) PIXI.WebGLGraphics.updateGraphics(maskData, gl); if (!maskData._webGL[gl.id].data.length) return; renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession) }; PIXI.WebGLMaskManager.prototype.popMask = function (maskData, renderSession) { var gl = this.gl; renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession) }; PIXI.WebGLMaskManager.prototype.destroy = function () { this.maskStack = null; this.gl = null }; PIXI.WebGLStencilManager = function (gl) { this.stencilStack = []; this.setContext(gl); this.reverse = true; this.count = 0 }; PIXI.WebGLStencilManager.prototype.setContext = function (gl) { this.gl = gl }; PIXI.WebGLStencilManager.prototype.pushStencil = function (graphics, webGLData, renderSession) { var gl = this.gl; this.bindGraphics(graphics, webGLData, renderSession); if (this.stencilStack.length === 0) { gl.enable(gl.STENCIL_TEST); gl.clear(gl.STENCIL_BUFFER_BIT); this.reverse = true; this.count = 0 } this.stencilStack.push(webGLData); var level = this.count; gl.colorMask(false, false, false, false); gl.stencilFunc(gl.ALWAYS, 0, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT); if (webGLData.mode === 1) { gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0); if (this.reverse) { gl.stencilFunc(gl.EQUAL, 255 - level, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR) } else { gl.stencilFunc(gl.EQUAL, level, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR) } gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2); if (this.reverse) gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255); else gl.stencilFunc(gl.EQUAL, level + 1, 255); this.reverse = !this.reverse } else { if (!this.reverse) { gl.stencilFunc(gl.EQUAL, 255 - level, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR) } else { gl.stencilFunc(gl.EQUAL, level, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR) } gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0); if (!this.reverse) gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255); else gl.stencilFunc(gl.EQUAL, level + 1, 255) } gl.colorMask(true, true, true, true); gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); this.count++ }; PIXI.WebGLStencilManager.prototype.bindGraphics = function (graphics, webGLData, renderSession) { this._currentGraphics = graphics; var gl = this.gl; var projection = renderSession.projection, offset = renderSession.offset, shader; if (webGLData.mode === 1) { shader = renderSession.shaderManager.complexPrimativeShader; renderSession.shaderManager.setShader(shader); gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true)); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)); gl.uniform3fv(shader.color, webGLData.color); gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha); gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer) } else { shader = renderSession.shaderManager.primitiveShader; renderSession.shaderManager.setShader(shader); gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true)); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)); gl.uniform1f(shader.alpha, graphics.worldAlpha); gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0); gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer) } }; PIXI.WebGLStencilManager.prototype.popStencil = function (graphics, webGLData, renderSession) { var gl = this.gl; this.stencilStack.pop(); this.count--; if (this.stencilStack.length === 0) gl.disable(gl.STENCIL_TEST); else { var level = this.count; this.bindGraphics(graphics, webGLData, renderSession); gl.colorMask(false, false, false, false); if (webGLData.mode === 1) { this.reverse = !this.reverse; if (this.reverse) { gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR) } else { gl.stencilFunc(gl.EQUAL, level + 1, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR) } gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2); gl.stencilFunc(gl.ALWAYS, 0, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT); gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0); if (!this.reverse) gl.stencilFunc(gl.EQUAL, 255 - level, 255); else gl.stencilFunc(gl.EQUAL, level, 255) } else { if (!this.reverse) { gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR) } else { gl.stencilFunc(gl.EQUAL, level + 1, 255); gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR) } gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0); if (!this.reverse) gl.stencilFunc(gl.EQUAL, 255 - level, 255); else gl.stencilFunc(gl.EQUAL, level, 255) } gl.colorMask(true, true, true, true); gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP) } }; PIXI.WebGLStencilManager.prototype.destroy = function () { this.maskStack = null; this.gl = null }; PIXI.WebGLShaderManager = function (gl) { this.maxAttibs = 10; this.attribState = []; this.tempAttribState = []; this.shaderMap = []; for (var i = 0; i < this.maxAttibs; i++) this.attribState[i] = false; this.setContext(gl) }; PIXI.WebGLShaderManager.prototype.setContext = function (gl) { this.gl = gl; this.primitiveShader = new PIXI.PrimitiveShader(gl); this.complexPrimativeShader = new PIXI.ComplexPrimitiveShader(gl); this.defaultShader = new PIXI.PixiShader(gl); this.fastShader = new PIXI.PixiFastShader(gl); this.stripShader = new PIXI.StripShader(gl); this.setShader(this.defaultShader) }; PIXI.WebGLShaderManager.prototype.setAttribs = function (attribs) { var i; for (i = 0; i < this.tempAttribState.length; i++) this.tempAttribState[i] = false; for (i = 0; i < attribs.length; i++) { var attribId = attribs[i]; this.tempAttribState[attribId] = true } var gl = this.gl; for (i = 0; i < this.attribState.length; i++) if (this.attribState[i] !== this.tempAttribState[i]) { this.attribState[i] = this.tempAttribState[i]; if (this.tempAttribState[i]) gl.enableVertexAttribArray(i); else gl.disableVertexAttribArray(i) } }; PIXI.WebGLShaderManager.prototype.setShader = function (shader) { if (this._currentId === shader._UID) return false; this._currentId = shader._UID; this.currentShader = shader; this.gl.useProgram(shader.program); this.setAttribs(shader.attributes); return true }; PIXI.WebGLShaderManager.prototype.destroy = function () { this.attribState = null; this.tempAttribState = null; this.primitiveShader.destroy(); this.defaultShader.destroy(); this.fastShader.destroy(); this.stripShader.destroy(); this.gl = null }; PIXI.WebGLSpriteBatch = function (gl) { this.vertSize = 6; this.size = 2E3; var numVerts = this.size * 4 * this.vertSize; var numIndices = this.size * 6; this.vertices = new Float32Array(numVerts); this.indices = new Uint16Array(numIndices); this.lastIndexCount = 0; for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) { this.indices[i + 0] = j + 0; this.indices[i + 1] = j + 1; this.indices[i + 2] = j + 2; this.indices[i + 3] = j + 0; this.indices[i + 4] = j + 2; this.indices[i + 5] = j + 3 } this.drawing = false; this.currentBatchSize = 0; this.currentBaseTexture = null; this.setContext(gl); this.dirty = true; this.textures = []; this.blendModes = [] }; PIXI.WebGLSpriteBatch.prototype.setContext = function (gl) { this.gl = gl; this.vertexBuffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW); this.currentBlendMode = 99999 }; PIXI.WebGLSpriteBatch.prototype.begin = function (renderSession) { this.renderSession = renderSession; this.shader = this.renderSession.shaderManager.defaultShader; this.start() }; PIXI.WebGLSpriteBatch.prototype.end = function () { this.flush() }; PIXI.WebGLSpriteBatch.prototype.render = function (sprite) { var texture = sprite.texture; if (this.currentBatchSize >= this.size) { this.flush(); this.currentBaseTexture = texture.baseTexture } var uvs = texture._uvs; if (!uvs) return; var alpha = sprite.worldAlpha; var tint = sprite.tint; var verticies = this.vertices; var aX = sprite.anchor.x; var aY = sprite.anchor.y; var w0, w1, h0, h1; if (texture.trim) { var trim = texture.trim; w1 = trim.x - aX * trim.width; w0 = w1 + texture.crop.width; h1 = trim.y - aY * trim.height; h0 = h1 + texture.crop.height } else { w0 = texture.frame.width * (1 - aX); w1 = texture.frame.width * -aX; h0 = texture.frame.height * (1 - aY); h1 = texture.frame.height * -aY } var index = this.currentBatchSize * 4 * this.vertSize; var worldTransform = sprite.worldTransform; var a = worldTransform.a; var b = worldTransform.c; var c = worldTransform.b; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; verticies[index++] = a * w1 + c * h1 + tx; verticies[index++] = d * h1 + b * w1 + ty; verticies[index++] = uvs.x0; verticies[index++] = uvs.y0; verticies[index++] = alpha; verticies[index++] = tint; verticies[index++] = a * w0 + c * h1 + tx; verticies[index++] = d * h1 + b * w0 + ty; verticies[index++] = uvs.x1; verticies[index++] = uvs.y1; verticies[index++] = alpha; verticies[index++] = tint; verticies[index++] = a * w0 + c * h0 + tx; verticies[index++] = d * h0 + b * w0 + ty; verticies[index++] = uvs.x2; verticies[index++] = uvs.y2; verticies[index++] = alpha; verticies[index++] = tint; verticies[index++] = a * w1 + c * h0 + tx; verticies[index++] = d * h0 + b * w1 + ty; verticies[index++] = uvs.x3; verticies[index++] = uvs.y3; verticies[index++] = alpha; verticies[index++] = tint; this.textures[this.currentBatchSize] = sprite.texture.baseTexture; this.blendModes[this.currentBatchSize] = sprite.blendMode; this.currentBatchSize++ }; PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function (tilingSprite) { var texture = tilingSprite.tilingTexture; if (this.currentBatchSize >= this.size) { this.flush(); this.currentBaseTexture = texture.baseTexture } if (!tilingSprite._uvs) tilingSprite._uvs = new PIXI.TextureUvs; var uvs = tilingSprite._uvs; tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x; tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y; var offsetX = tilingSprite.tilePosition.x / (texture.baseTexture.width * tilingSprite.tileScaleOffset.x); var offsetY = tilingSprite.tilePosition.y / (texture.baseTexture.height * tilingSprite.tileScaleOffset.y); var scaleX = tilingSprite.width / texture.baseTexture.width / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x); var scaleY = tilingSprite.height / texture.baseTexture.height / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y); uvs.x0 = 0 - offsetX; uvs.y0 = 0 - offsetY; uvs.x1 = 1 * scaleX - offsetX; uvs.y1 = 0 - offsetY; uvs.x2 = 1 * scaleX - offsetX; uvs.y2 = 1 * scaleY - offsetY; uvs.x3 = 0 - offsetX; uvs.y3 = 1 * scaleY - offsetY; var alpha = tilingSprite.worldAlpha; var tint = tilingSprite.tint; var verticies = this.vertices; var width = tilingSprite.width; var height = tilingSprite.height; var aX = tilingSprite.anchor.x; var aY = tilingSprite.anchor.y; var w0 = width * (1 - aX); var w1 = width * -aX; var h0 = height * (1 - aY); var h1 = height * -aY; var index = this.currentBatchSize * 4 * this.vertSize; var worldTransform = tilingSprite.worldTransform; var a = worldTransform.a; var b = worldTransform.c; var c = worldTransform.b; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; verticies[index++] = a * w1 + c * h1 + tx; verticies[index++] = d * h1 + b * w1 + ty; verticies[index++] = uvs.x0; verticies[index++] = uvs.y0; verticies[index++] = alpha; verticies[index++] = tint; verticies[index++] = a * w0 + c * h1 + tx; verticies[index++] = d * h1 + b * w0 + ty; verticies[index++] = uvs.x1; verticies[index++] = uvs.y1; verticies[index++] = alpha; verticies[index++] = tint; verticies[index++] = a * w0 + c * h0 + tx; verticies[index++] = d * h0 + b * w0 + ty; verticies[index++] = uvs.x2; verticies[index++] = uvs.y2; verticies[index++] = alpha; verticies[index++] = tint; verticies[index++] = a * w1 + c * h0 + tx; verticies[index++] = d * h0 + b * w1 + ty; verticies[index++] = uvs.x3; verticies[index++] = uvs.y3; verticies[index++] = alpha; verticies[index++] = tint; this.textures[this.currentBatchSize] = texture.baseTexture; this.blendModes[this.currentBatchSize] = tilingSprite.blendMode; this.currentBatchSize++ }; PIXI.WebGLSpriteBatch.prototype.flush = function () { if (this.currentBatchSize === 0) return; var gl = this.gl; this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader); if (this.dirty) { this.dirty = false; gl.activeTexture(gl.TEXTURE0); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); var projection = this.renderSession.projection; gl.uniform2f(this.shader.projectionVector, projection.x, projection.y); var stride = this.vertSize * 4; gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0); gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4); gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4) } if (this.currentBatchSize > this.size * 0.5) gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); else { var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize); gl.bufferSubData(gl.ARRAY_BUFFER, 0, view) } var nextTexture, nextBlendMode; var batchSize = 0; var start = 0; var currentBaseTexture = null; var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode; for (var i = 0, j = this.currentBatchSize; i < j; i++) { nextTexture = this.textures[i]; nextBlendMode = this.blendModes[i]; if (currentBaseTexture !== nextTexture || currentBlendMode !== nextBlendMode) { this.renderBatch(currentBaseTexture, batchSize, start); start = i; batchSize = 0; currentBaseTexture = nextTexture; currentBlendMode = nextBlendMode; this.renderSession.blendModeManager.setBlendMode(currentBlendMode) } batchSize++ } this.renderBatch(currentBaseTexture, batchSize, start); this.currentBatchSize = 0 }; PIXI.WebGLSpriteBatch.prototype.renderBatch = function (texture, size, startIndex) { if (size === 0) return; var gl = this.gl; gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id] || PIXI.createWebGLTexture(texture, gl)); if (texture._dirty[gl.id]) PIXI.updateWebGLTexture(this.currentBaseTexture, gl); gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2); this.renderSession.drawCount++ }; PIXI.WebGLSpriteBatch.prototype.stop = function () { this.flush() }; PIXI.WebGLSpriteBatch.prototype.start = function () { this.dirty = true }; PIXI.WebGLSpriteBatch.prototype.destroy = function () { this.vertices = null; this.indices = null; this.gl.deleteBuffer(this.vertexBuffer); this.gl.deleteBuffer(this.indexBuffer); this.currentBaseTexture = null; this.gl = null }; PIXI.WebGLFastSpriteBatch = function (gl) { this.vertSize = 10; this.maxSize = 6E3; this.size = this.maxSize; var numVerts = this.size * 4 * this.vertSize; var numIndices = this.maxSize * 6; this.vertices = new Float32Array(numVerts); this.indices = new Uint16Array(numIndices); this.vertexBuffer = null; this.indexBuffer = null; this.lastIndexCount = 0; for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) { this.indices[i + 0] = j + 0; this.indices[i + 1] = j + 1; this.indices[i + 2] = j + 2; this.indices[i + 3] = j + 0; this.indices[i + 4] = j + 2; this.indices[i + 5] = j + 3 } this.drawing = false; this.currentBatchSize = 0; this.currentBaseTexture = null; this.currentBlendMode = 0; this.renderSession = null; this.shader = null; this.matrix = null; this.setContext(gl) }; PIXI.WebGLFastSpriteBatch.prototype.setContext = function (gl) { this.gl = gl; this.vertexBuffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW) }; PIXI.WebGLFastSpriteBatch.prototype.begin = function (spriteBatch, renderSession) { this.renderSession = renderSession; this.shader = this.renderSession.shaderManager.fastShader; this.matrix = spriteBatch.worldTransform.toArray(true); this.start() }; PIXI.WebGLFastSpriteBatch.prototype.end = function () { this.flush() }; PIXI.WebGLFastSpriteBatch.prototype.render = function (spriteBatch) { var children = spriteBatch.children; var sprite = children[0]; if (!sprite.texture._uvs) return; this.currentBaseTexture = sprite.texture.baseTexture; if (sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode) { this.flush(); this.renderSession.blendModeManager.setBlendMode(sprite.blendMode) } for (var i = 0, j = children.length; i < j; i++) this.renderSprite(children[i]); this.flush() }; PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function (sprite) { if (!sprite.visible) return; if (sprite.texture.baseTexture !== this.currentBaseTexture) { this.flush(); this.currentBaseTexture = sprite.texture.baseTexture; if (!sprite.texture._uvs) return } var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index; uvs = sprite.texture._uvs; width = sprite.texture.frame.width; height = sprite.texture.frame.height; if (sprite.texture.trim) { var trim = sprite.texture.trim; w1 = trim.x - sprite.anchor.x * trim.width; w0 = w1 + sprite.texture.crop.width; h1 = trim.y - sprite.anchor.y * trim.height; h0 = h1 + sprite.texture.crop.height } else { w0 = sprite.texture.frame.width * (1 - sprite.anchor.x); w1 = sprite.texture.frame.width * -sprite.anchor.x; h0 = sprite.texture.frame.height * (1 - sprite.anchor.y); h1 = sprite.texture.frame.height * -sprite.anchor.y } index = this.currentBatchSize * 4 * this.vertSize; verticies[index++] = w1; verticies[index++] = h1; verticies[index++] = sprite.position.x; verticies[index++] = sprite.position.y; verticies[index++] = sprite.scale.x; verticies[index++] = sprite.scale.y; verticies[index++] = sprite.rotation; verticies[index++] = uvs.x0; verticies[index++] = uvs.y1; verticies[index++] = sprite.alpha; verticies[index++] = w0; verticies[index++] = h1; verticies[index++] = sprite.position.x; verticies[index++] = sprite.position.y; verticies[index++] = sprite.scale.x; verticies[index++] = sprite.scale.y; verticies[index++] = sprite.rotation; verticies[index++] = uvs.x1; verticies[index++] = uvs.y1; verticies[index++] = sprite.alpha; verticies[index++] = w0; verticies[index++] = h0; verticies[index++] = sprite.position.x; verticies[index++] = sprite.position.y; verticies[index++] = sprite.scale.x; verticies[index++] = sprite.scale.y; verticies[index++] = sprite.rotation; verticies[index++] = uvs.x2; verticies[index++] = uvs.y2; verticies[index++] = sprite.alpha; verticies[index++] = w1; verticies[index++] = h0; verticies[index++] = sprite.position.x; verticies[index++] = sprite.position.y; verticies[index++] = sprite.scale.x; verticies[index++] = sprite.scale.y; verticies[index++] = sprite.rotation; verticies[index++] = uvs.x3; verticies[index++] = uvs.y3; verticies[index++] = sprite.alpha; this.currentBatchSize++; if (this.currentBatchSize >= this.size) this.flush() }; PIXI.WebGLFastSpriteBatch.prototype.flush = function () { if (this.currentBatchSize === 0) return; var gl = this.gl; if (!this.currentBaseTexture._glTextures[gl.id]) PIXI.createWebGLTexture(this.currentBaseTexture, gl); gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]); if (this.currentBatchSize > this.size * 0.5) gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); else { var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize); gl.bufferSubData(gl.ARRAY_BUFFER, 0, view) } gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0); this.currentBatchSize = 0; this.renderSession.drawCount++ }; PIXI.WebGLFastSpriteBatch.prototype.stop = function () { this.flush() }; PIXI.WebGLFastSpriteBatch.prototype.start = function () { var gl = this.gl; gl.activeTexture(gl.TEXTURE0); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); var projection = this.renderSession.projection; gl.uniform2f(this.shader.projectionVector, projection.x, projection.y); gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix); var stride = this.vertSize * 4; gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0); gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4); gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4); gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4); gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4); gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4) }; PIXI.WebGLFilterManager = function (gl, transparent) { this.transparent = transparent; this.filterStack = []; this.offsetX = 0; this.offsetY = 0; this.setContext(gl) }; PIXI.WebGLFilterManager.prototype.setContext = function (gl) { this.gl = gl; this.texturePool = []; this.initShaderBuffers() }; PIXI.WebGLFilterManager.prototype.begin = function (renderSession, buffer) { this.renderSession = renderSession; this.defaultShader = renderSession.shaderManager.defaultShader; var projection = this.renderSession.projection; this.width = projection.x * 2; this.height = -projection.y * 2; this.buffer = buffer }; PIXI.WebGLFilterManager.prototype.pushFilter = function (filterBlock) { var gl = this.gl; var projection = this.renderSession.projection; var offset = this.renderSession.offset; filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds(); this.filterStack.push(filterBlock); var filter = filterBlock.filterPasses[0]; this.offsetX += filterBlock._filterArea.x; this.offsetY += filterBlock._filterArea.y; var texture = this.texturePool.pop(); if (!texture) texture = new PIXI.FilterTexture(this.gl, this.width, this.height); else texture.resize(this.width, this.height); gl.bindTexture(gl.TEXTURE_2D, texture.texture); var filterArea = filterBlock._filterArea; var padding = filter.padding; filterArea.x -= padding; filterArea.y -= padding; filterArea.width += padding * 2; filterArea.height += padding * 2; if (filterArea.x < 0) filterArea.x = 0; if (filterArea.width > this.width) filterArea.width = this.width; if (filterArea.y < 0) filterArea.y = 0; if (filterArea.height > this.height) filterArea.height = this.height; gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer); gl.viewport(0, 0, filterArea.width, filterArea.height); projection.x = filterArea.width / 2; projection.y = -filterArea.height / 2; offset.x = -filterArea.x; offset.y = -filterArea.y; this.renderSession.shaderManager.setShader(this.defaultShader); gl.uniform2f(this.defaultShader.projectionVector, filterArea.width / 2, -filterArea.height / 2); gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y); gl.colorMask(true, true, true, true); gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT); filterBlock._glFilterTexture = texture }; PIXI.WebGLFilterManager.prototype.popFilter = function () { var gl = this.gl; var filterBlock = this.filterStack.pop(); var filterArea = filterBlock._filterArea; var texture = filterBlock._glFilterTexture; var projection = this.renderSession.projection; var offset = this.renderSession.offset; if (filterBlock.filterPasses.length > 1) { gl.viewport(0, 0, filterArea.width, filterArea.height); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); this.vertexArray[0] = 0; this.vertexArray[1] = filterArea.height; this.vertexArray[2] = filterArea.width; this.vertexArray[3] = filterArea.height; this.vertexArray[4] = 0; this.vertexArray[5] = 0; this.vertexArray[6] = filterArea.width; this.vertexArray[7] = 0; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); this.uvArray[2] = filterArea.width / this.width; this.uvArray[5] = filterArea.height / this.height; this.uvArray[6] = filterArea.width / this.width; this.uvArray[7] = filterArea.height / this.height; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray); var inputTexture = texture; var outputTexture = this.texturePool.pop(); if (!outputTexture) outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height); outputTexture.resize(this.width, this.height); gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer); gl.clear(gl.COLOR_BUFFER_BIT); gl.disable(gl.BLEND); for (var i = 0; i < filterBlock.filterPasses.length - 1; i++) { var filterPass = filterBlock.filterPasses[i]; gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture); this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height); var temp = inputTexture; inputTexture = outputTexture; outputTexture = temp } gl.enable(gl.BLEND); texture = inputTexture; this.texturePool.push(outputTexture) } var filter = filterBlock.filterPasses[filterBlock.filterPasses.length - 1]; this.offsetX -= filterArea.x; this.offsetY -= filterArea.y; var sizeX = this.width; var sizeY = this.height; var offsetX = 0; var offsetY = 0; var buffer = this.buffer; if (this.filterStack.length === 0) gl.colorMask(true, true, true, true); else { var currentFilter = this.filterStack[this.filterStack.length - 1]; filterArea = currentFilter._filterArea; sizeX = filterArea.width; sizeY = filterArea.height; offsetX = filterArea.x; offsetY = filterArea.y; buffer = currentFilter._glFilterTexture.frameBuffer } projection.x = sizeX / 2; projection.y = -sizeY / 2; offset.x = offsetX; offset.y = offsetY; filterArea = filterBlock._filterArea; var x = filterArea.x - offsetX; var y = filterArea.y - offsetY; gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); this.vertexArray[0] = x; this.vertexArray[1] = y + filterArea.height; this.vertexArray[2] = x + filterArea.width; this.vertexArray[3] = y + filterArea.height; this.vertexArray[4] = x; this.vertexArray[5] = y; this.vertexArray[6] = x + filterArea.width; this.vertexArray[7] = y; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); this.uvArray[2] = filterArea.width / this.width; this.uvArray[5] = filterArea.height / this.height; this.uvArray[6] = filterArea.width / this.width; this.uvArray[7] = filterArea.height / this.height; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray); gl.viewport(0, 0, sizeX, sizeY); gl.bindFramebuffer(gl.FRAMEBUFFER, buffer); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture.texture); this.applyFilterPass(filter, filterArea, sizeX, sizeY); this.renderSession.shaderManager.setShader(this.defaultShader); gl.uniform2f(this.defaultShader.projectionVector, sizeX / 2, -sizeY / 2); gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY); this.texturePool.push(texture); filterBlock._glFilterTexture = null }; PIXI.WebGLFilterManager.prototype.applyFilterPass = function (filter, filterArea, width, height) { var gl = this.gl; var shader = filter.shaders[gl.id]; if (!shader) { shader = new PIXI.PixiShader(gl); shader.fragmentSrc = filter.fragmentSrc; shader.uniforms = filter.uniforms; shader.init(); filter.shaders[gl.id] = shader } this.renderSession.shaderManager.setShader(shader); gl.uniform2f(shader.projectionVector, width / 2, -height / 2); gl.uniform2f(shader.offsetVector, 0, 0); if (filter.uniforms.dimensions) { filter.uniforms.dimensions.value[0] = this.width; filter.uniforms.dimensions.value[1] = this.height; filter.uniforms.dimensions.value[2] = this.vertexArray[0]; filter.uniforms.dimensions.value[3] = this.vertexArray[5] } shader.syncUniforms(); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer); gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); this.renderSession.drawCount++ }; PIXI.WebGLFilterManager.prototype.initShaderBuffers = function () { var gl = this.gl; this.vertexBuffer = gl.createBuffer(); this.uvBuffer = gl.createBuffer(); this.colorBuffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW); this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW); this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]); gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), gl.STATIC_DRAW) }; PIXI.WebGLFilterManager.prototype.destroy = function () { var gl = this.gl; this.filterStack = null; this.offsetX = 0; this.offsetY = 0; for (var i = 0; i < this.texturePool.length; i++) this.texturePool[i].destroy(); this.texturePool = null; gl.deleteBuffer(this.vertexBuffer); gl.deleteBuffer(this.uvBuffer); gl.deleteBuffer(this.colorBuffer); gl.deleteBuffer(this.indexBuffer) }; PIXI.FilterTexture = function (gl, width, height, scaleMode) { this.gl = gl; this.frameBuffer = gl.createFramebuffer(); this.texture = gl.createTexture(); scaleMode = scaleMode || PIXI.scaleModes.DEFAULT; gl.bindTexture(gl.TEXTURE_2D, this.texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer); gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0); this.renderBuffer = gl.createRenderbuffer(); gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer); gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer); this.resize(width, height) }; PIXI.FilterTexture.prototype.clear = function () { var gl = this.gl; gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT) }; PIXI.FilterTexture.prototype.resize = function (width, height) { if (this.width === width && this.height === height) return; this.width = width; this.height = height; var gl = this.gl; gl.bindTexture(gl.TEXTURE_2D, this.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height) }; PIXI.FilterTexture.prototype.destroy = function () { var gl = this.gl; gl.deleteFramebuffer(this.frameBuffer); gl.deleteTexture(this.texture); this.frameBuffer = null; this.texture = null }; PIXI.CanvasMaskManager = function () { }; PIXI.CanvasMaskManager.prototype.pushMask = function (maskData, context) { context.save(); var cacheAlpha = maskData.alpha; var transform = maskData.worldTransform; context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty); PIXI.CanvasGraphics.renderGraphicsMask(maskData, context); context.clip(); maskData.worldAlpha = cacheAlpha }; PIXI.CanvasMaskManager.prototype.popMask = function (context) { context.restore() }; PIXI.CanvasTinter = function () { }; PIXI.CanvasTinter.cache = {}; PIXI.CanvasTinter.getTintedTexture = function (sprite, color) { var texture = sprite.texture; color = PIXI.CanvasTinter.roundColor(color); var stringColor = "#" + ("00000" + (color | 0).toString(16)).substr(-6); var spriteSheetCache; if (PIXI.CanvasTinter.cache[texture.baseTexture.id]) spriteSheetCache = PIXI.CanvasTinter.cache[texture.baseTexture.id]; else { spriteSheetCache = {}; PIXI.CanvasTinter.cache[texture.baseTexture.id] = spriteSheetCache } if (spriteSheetCache[stringColor]) return spriteSheetCache[stringColor]; var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas"); PIXI.CanvasTinter.tintMethod(texture, color, canvas); if (PIXI.CanvasTinter.convertTintToImage) { var tintImage = new Image; tintImage.src = canvas.toDataURL(); spriteSheetCache[stringColor] = tintImage } else { spriteSheetCache[stringColor] = canvas; PIXI.CanvasTinter.canvas = null } return canvas }; PIXI.CanvasTinter.tintWithMultiply = function (texture, color, canvas) { var context = canvas.getContext("2d"); canvas.width = texture.baseTexture.width; canvas.height = texture.baseTexture.height; context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6); context.fillRect(0, 0, canvas.width, canvas.height); context.globalCompositeOperation = "multiply"; context.drawImage(texture.baseTexture.source, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height); context.globalCompositeOperation = "destination-atop"; context.drawImage(texture.baseTexture.source, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height) }; PIXI.CanvasTinter.tintWithOverlay = function (texture, color, canvas) { var context = canvas.getContext("2d"); canvas.width = texture.baseTexture.width; canvas.height = texture.baseTexture.height; context.globalCompositeOperation = "copy"; context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6); context.fillRect(0, 0, canvas.width, canvas.height); context.globalCompositeOperation = "destination-atop"; context.drawImage(texture.baseTexture.source, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height) }; PIXI.CanvasTinter.tintWithPerPixel = function (texture, color, canvas) { var context = canvas.getContext("2d"); canvas.width = texture.baseTexture.width; canvas.height = texture.baseTexture.height; context.globalCompositeOperation = "copy"; context.drawImage(texture.baseTexture.source, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height); var rgbValues = PIXI.hex2rgb(color); var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2]; var pixelData = context.getImageData(0, 0, canvas.width, canvas.height); var pixels = pixelData.data; for (var i = 0; i < pixels.length; i += 4) { pixels[i + 0] *= r; pixels[i + 1] *= g; pixels[i + 2] *= b } context.putImageData(pixelData, 0, 0) }; PIXI.CanvasTinter.roundColor = function (color) { var step = PIXI.CanvasTinter.cacheStepsPerColorChannel; var rgbValues = PIXI.hex2rgb(color); rgbValues[0] = Math.min(255, rgbValues[0] / step * step); rgbValues[1] = Math.min(255, rgbValues[1] / step * step); rgbValues[2] = Math.min(255, rgbValues[2] / step * step); return PIXI.rgb2hex(rgbValues) }; PIXI.CanvasTinter.cacheStepsPerColorChannel = 8; PIXI.CanvasTinter.convertTintToImage = false; PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes(); PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel; PIXI.CanvasRenderer = function (width, height, view, transparent, targetFrameRate, minFrameRate) { if (!PIXI.defaultRenderer) { PIXI.sayHello("Canvas"); PIXI.defaultRenderer = this } this.type = PIXI.CANVAS_RENDERER; this.clearBeforeRender = true; this.transparent = ! !transparent; if (!PIXI.blendModesCanvas) { PIXI.blendModesCanvas = []; if (PIXI.canUseNewCanvasBlendModes()) { PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter"; PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply"; PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "screen"; PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "overlay"; PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "darken"; PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "lighten"; PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge"; PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn"; PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light"; PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light"; PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference"; PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion"; PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "hue"; PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation"; PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "color"; PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity" } else { PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter"; PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "source-over"; PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over" } } this.width = width || 800; this.height = height || 600; this.view = view || document.createElement("canvas"); this.context = this.view.getContext("2d", { alpha: this.transparent }); this.time = new PIXI.Time(targetFrameRate, minFrameRate); this.refresh = true; this.view.width = this.width; this.view.height = this.height; this.count = 0; this.maskManager = new PIXI.CanvasMaskManager; this.renderSession = { context: this.context, maskManager: this.maskManager, scaleMode: null, smoothProperty: null, roundPixels: false }; if ("imageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "imageSmoothingEnabled"; else if ("webkitImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "webkitImageSmoothingEnabled"; else if ("mozImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "mozImageSmoothingEnabled"; else if ("oImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "oImageSmoothingEnabled" }; PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer; PIXI.CanvasRenderer.prototype.render = function (stage) { stage.time = this.time; PIXI.texturesToUpdate.length = 0; PIXI.texturesToDestroy.length = 0; stage.updateTransform(); this.context.setTransform(1, 0, 0, 1, 0, 0); this.context.globalAlpha = 1; if (navigator.isCocoonJS && this.view.screencanvas) { this.context.fillStyle = "black"; this.context.clear() } if (!this.transparent && this.clearBeforeRender) { this.context.fillStyle = stage.backgroundColorString; this.context.fillRect(0, 0, this.width, this.height) } else if (this.transparent && this.clearBeforeRender) this.context.clearRect(0, 0, this.width, this.height); this.renderDisplayObject(stage); if (stage.interactive) if (!stage._interactiveEventsAdded) { stage._interactiveEventsAdded = true; stage.interactionManager.setTarget(this) } if (PIXI.Texture.frameUpdates.length > 0) PIXI.Texture.frameUpdates.length = 0; this.time.update() }; PIXI.CanvasRenderer.prototype.resize = function (width, height) { this.width = width; this.height = height; this.view.width = width; this.view.height = height }; PIXI.CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context) { this.renderSession.context = context || this.context; displayObject._renderCanvas(this.renderSession) }; PIXI.CanvasRenderer.prototype.renderStripFlat = function (strip) { var context = this.context; var verticies = strip.verticies; var length = verticies.length / 2; this.count++; context.beginPath(); for (var i = 1; i < length - 2; i++) { var index = i * 2; var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4]; var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5]; context.moveTo(x0, y0); context.lineTo(x1, y1); context.lineTo(x2, y2) } context.fillStyle = "#FF0000"; context.fill(); context.closePath() }; PIXI.CanvasRenderer.prototype.renderStrip = function (strip) { var context = this.context; var verticies = strip.verticies; var uvs = strip.uvs; var length = verticies.length / 2; this.count++; for (var i = 1; i < length - 2; i++) { var index = i * 2; var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4]; var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5]; var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width; var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height; context.save(); context.beginPath(); context.moveTo(x0, y0); context.lineTo(x1, y1); context.lineTo(x2, y2); context.closePath(); context.clip(); var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2; var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2; var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2; var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2; var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2; var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2; var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2; context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta); context.drawImage(strip.texture.baseTexture.source, 0, 0); context.restore() } }; PIXI.CanvasBuffer = function (width, height) { this.width = width; this.height = height; this.canvas = document.createElement("canvas"); this.context = this.canvas.getContext("2d"); this.canvas.width = width; this.canvas.height = height }; PIXI.CanvasBuffer.prototype.clear = function () { this.context.clearRect(0, 0, this.width, this.height) }; PIXI.CanvasBuffer.prototype.resize = function (width, height) { this.width = this.canvas.width = width; this.height = this.canvas.height = height }; PIXI.CanvasGraphics = function () { }; PIXI.CanvasGraphics.renderGraphics = function (graphics, context) { var worldAlpha = graphics.worldAlpha; var color = ""; for (var i = 0; i < graphics.graphicsData.length; i++) { var data = graphics.graphicsData[i]; var points = data.points; context.strokeStyle = color = "#" + ("00000" + (data.lineColor | 0).toString(16)).substr(-6); context.lineWidth = data.lineWidth; if (data.type === PIXI.Graphics.POLY) { context.beginPath(); context.moveTo(points[0], points[1]); for (var j = 1; j < points.length / 2; j++) context.lineTo(points[j * 2], points[j * 2 + 1]); if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) context.closePath(); if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6); context.fill() } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.stroke() } } else if (data.type === PIXI.Graphics.RECT) { if (data.fillColor || data.fillColor === 0) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6); context.fillRect(points[0], points[1], points[2], points[3]) } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.strokeRect(points[0], points[1], points[2], points[3]) } } else if (data.type === PIXI.Graphics.CIRC) { context.beginPath(); context.arc(points[0], points[1], points[2], 0, 2 * Math.PI); context.closePath(); if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6); context.fill() } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.stroke() } } else if (data.type === PIXI.Graphics.ELIP) { var ellipseData = data.points; var w = ellipseData[2] * 2; var h = ellipseData[3] * 2; var x = ellipseData[0] - w / 2; var y = ellipseData[1] - h / 2; context.beginPath(); var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2; context.moveTo(x, ym); context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y); context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym); context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye); context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym); context.closePath(); if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6); context.fill() } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.stroke() } } else if (data.type === PIXI.Graphics.RREC) { var rx = points[0]; var ry = points[1]; var width = points[2]; var height = points[3]; var radius = points[4]; var maxRadius = Math.min(width, height) / 2 | 0; radius = radius > maxRadius ? maxRadius : radius; context.beginPath(); context.moveTo(rx, ry + radius); context.lineTo(rx, ry + height - radius); context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height); context.lineTo(rx + width - radius, ry + height); context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius); context.lineTo(rx + width, ry + radius); context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry); context.lineTo(rx + radius, ry); context.quadraticCurveTo(rx, ry, rx, ry + radius); context.closePath(); if (data.fillColor || data.fillColor === 0) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6); context.fill() } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.stroke() } } } }; PIXI.CanvasGraphics.renderGraphicsMask = function (graphics, context) { var len = graphics.graphicsData.length; if (len === 0) return; if (len > 1) { len = 1; window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object") } for (var i = 0; i < 1; i++) { var data = graphics.graphicsData[i]; var points = data.points; if (data.type === PIXI.Graphics.POLY) { context.beginPath(); context.moveTo(points[0], points[1]); for (var j = 1; j < points.length / 2; j++) context.lineTo(points[j * 2], points[j * 2 + 1]); if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) context.closePath() } else if (data.type === PIXI.Graphics.RECT) { context.beginPath(); context.rect(points[0], points[1], points[2], points[3]); context.closePath() } else if (data.type === PIXI.Graphics.CIRC) { context.beginPath(); context.arc(points[0], points[1], points[2], 0, 2 * Math.PI); context.closePath() } else if (data.type === PIXI.Graphics.ELIP) { var ellipseData = data.points; var w = ellipseData[2] * 2; var h = ellipseData[3] * 2; var x = ellipseData[0] - w / 2; var y = ellipseData[1] - h / 2; context.beginPath(); var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2; context.moveTo(x, ym); context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y); context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym); context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye); context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym); context.closePath() } else if (data.type === PIXI.Graphics.RREC) { var rx = points[0]; var ry = points[1]; var width = points[2]; var height = points[3]; var radius = points[4]; var maxRadius = Math.min(width, height) / 2 | 0; radius = radius > maxRadius ? maxRadius : radius; context.beginPath(); context.moveTo(rx, ry + radius); context.lineTo(rx, ry + height - radius); context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height); context.lineTo(rx + width - radius, ry + height); context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius); context.lineTo(rx + width, ry + radius); context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry); context.lineTo(rx + radius, ry); context.quadraticCurveTo(rx, ry, rx, ry + radius); context.closePath() } } }; PIXI.Graphics = function () { PIXI.DisplayObjectContainer.call(this); this.renderable = true; this.fillAlpha = 1; this.lineWidth = 0; this.lineColor = "black"; this.graphicsData = []; this.tint = 16777215; this.blendMode = PIXI.blendModes.NORMAL; this.currentPath = { points: [] }; this._webGL = []; this.isMask = false; this.bounds = null; this.boundsPadding = 10; this.dirty = true }; PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Graphics.prototype.constructor = PIXI.Graphics; Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", { get: function () { return this._cacheAsBitmap }, set: function (value) { this._cacheAsBitmap = value; if (this._cacheAsBitmap) this._generateCachedSprite(); else { this.destroyCachedSprite(); this.dirty = true } } }); PIXI.Graphics.prototype.lineStyle = function (lineWidth, color, alpha) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.lineWidth = lineWidth || 0; this.lineColor = color || 0; this.lineAlpha = arguments.length < 3 ? 1 : alpha; this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [], type: PIXI.Graphics.POLY }; this.graphicsData.push(this.currentPath); return this }; PIXI.Graphics.prototype.moveTo = function (x, y) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.currentPath = this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [], type: PIXI.Graphics.POLY }; this.currentPath.points.push(x, y); this.graphicsData.push(this.currentPath); return this }; PIXI.Graphics.prototype.lineTo = function (x, y) { this.currentPath.points.push(x, y); this.dirty = true; return this }; PIXI.Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) { if (this.currentPath.points.length === 0) this.moveTo(0, 0); var xa, ya, n = 20, points = this.currentPath.points; if (points.length === 0) this.moveTo(0, 0); var fromX = points[points.length - 2]; var fromY = points[points.length - 1]; var j = 0; for (var i = 1; i <= n; i++) { j = i / n; xa = fromX + (cpX - fromX) * j; ya = fromY + (cpY - fromY) * j; points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j) } this.dirty = true; return this }; PIXI.Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) { if (this.currentPath.points.length === 0) this.moveTo(0, 0); var n = 20, dt, dt2, dt3, t2, t3, points = this.currentPath.points; var fromX = points[points.length - 2]; var fromY = points[points.length - 1]; var j = 0; for (var i = 1; i < n; i++) { j = i / n; dt = 1 - j; dt2 = dt * dt; dt3 = dt2 * dt; t2 = j * j; t3 = t2 * j; points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY) } this.dirty = true; return this }; PIXI.Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) { if (this.currentPath.points.length === 0) this.moveTo(x1, y1); var points = this.currentPath.points; var fromX = points[points.length - 2]; var fromY = points[points.length - 1]; var a1 = fromY - y1; var b1 = fromX - x1; var a2 = y2 - y1; var b2 = x2 - x1; var mm = Math.abs(a1 * b2 - b1 * a2); if (mm < 1.0E-8 || radius === 0) points.push(x1, y1); else { var dd = a1 * a1 + b1 * b1; var cc = a2 * a2 + b2 * b2; var tt = a1 * a2 + b1 * b2; var k1 = radius * Math.sqrt(dd) / mm; var k2 = radius * Math.sqrt(cc) / mm; var j1 = k1 * tt / dd; var j2 = k2 * tt / cc; var cx = k1 * b2 + k2 * b1; var cy = k1 * a2 + k2 * a1; var px = b1 * (k2 + j1); var py = a1 * (k2 + j1); var qx = b2 * (k1 + j2); var qy = a2 * (k1 + j2); var startAngle = Math.atan2(py - cy, px - cx); var endAngle = Math.atan2(qy - cy, qx - cx); this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1) } this.dirty = true; return this }; PIXI.Graphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) { var startX = cx + Math.cos(startAngle) * radius; var startY = cy + Math.sin(startAngle) * radius; var points = this.currentPath.points; if (points.length !== 0 && points[points.length - 2] !== startX || points[points.length - 1] !== startY) { this.moveTo(startX, startY); points = this.currentPath.points } if (startAngle === endAngle) return this; if (!anticlockwise && endAngle <= startAngle) endAngle += Math.PI * 2; else if (anticlockwise && startAngle <= endAngle) startAngle += Math.PI * 2; var sweep = anticlockwise ? (startAngle - endAngle) * -1 : endAngle - startAngle; var segs = Math.abs(sweep) / (Math.PI * 2) * 40; if (sweep === 0) return this; var theta = sweep / (segs * 2); var theta2 = theta * 2; var cTheta = Math.cos(theta); var sTheta = Math.sin(theta); var segMinus = segs - 1; var remainder = segMinus % 1 / segMinus; for (var i = 0; i <= segMinus; i++) { var real = i + remainder * i; var angle = theta + startAngle + theta2 * real; var c = Math.cos(angle); var s = -Math.sin(angle); points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy) } this.dirty = true; return this }; PIXI.Graphics.prototype.drawPath = function (path) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.currentPath = this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [], type: PIXI.Graphics.POLY }; this.graphicsData.push(this.currentPath); this.currentPath.points = this.currentPath.points.concat(path); this.dirty = true; return this }; PIXI.Graphics.prototype.beginFill = function (color, alpha) { this.filling = true; this.fillColor = color || 0; this.fillAlpha = arguments.length < 2 ? 1 : alpha; return this }; PIXI.Graphics.prototype.endFill = function () { this.filling = false; this.fillColor = null; this.fillAlpha = 1; return this }; PIXI.Graphics.prototype.drawRect = function (x, y, width, height) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [x, y, width, height], type: PIXI.Graphics.RECT }; this.graphicsData.push(this.currentPath); this.dirty = true; return this }; PIXI.Graphics.prototype.drawRoundedRect = function (x, y, width, height, radius) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [x, y, width, height, radius], type: PIXI.Graphics.RREC }; this.graphicsData.push(this.currentPath); this.dirty = true; return this }; PIXI.Graphics.prototype.drawCircle = function (x, y, radius) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [x, y, radius, radius], type: PIXI.Graphics.CIRC }; this.graphicsData.push(this.currentPath); this.dirty = true; return this }; PIXI.Graphics.prototype.drawEllipse = function (x, y, width, height) { if (!this.currentPath.points.length) this.graphicsData.pop(); this.currentPath = { lineWidth: this.lineWidth, lineColor: this.lineColor, lineAlpha: this.lineAlpha, fillColor: this.fillColor, fillAlpha: this.fillAlpha, fill: this.filling, points: [x, y, width, height], type: PIXI.Graphics.ELIP }; this.graphicsData.push(this.currentPath); this.dirty = true; return this }; PIXI.Graphics.prototype.clear = function () { this.lineWidth = 0; this.filling = false; this.dirty = true; this.clearDirty = true; this.graphicsData = []; this.bounds = null; return this }; PIXI.Graphics.prototype.generateTexture = function () { var bounds = this.getBounds(); var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height); var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas); canvasBuffer.context.translate(-bounds.x, -bounds.y); PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context); return texture }; PIXI.Graphics.prototype._renderWebGL = function (renderSession) { if (this.visible === false || this.alpha === 0 || this.isMask === true) return; if (this._cacheAsBitmap) { if (this.dirty) { this._generateCachedSprite(); PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl); this.dirty = false } this._cachedSprite.alpha = this.alpha; PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession); return } else { renderSession.spriteBatch.stop(); renderSession.blendModeManager.setBlendMode(this.blendMode); if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession); if (this._filters) renderSession.filterManager.pushFilter(this._filterBlock); if (this.blendMode !== renderSession.spriteBatch.currentBlendMode) { renderSession.spriteBatch.currentBlendMode = this.blendMode; var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode]; renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]) } PIXI.WebGLGraphics.renderGraphics(this, renderSession); if (this.children.length) { renderSession.spriteBatch.start(); for (var i = 0, j = this.children.length; i < j; i++) this.children[i]._renderWebGL(renderSession); renderSession.spriteBatch.stop() } if (this._filters) renderSession.filterManager.popFilter(); if (this._mask) renderSession.maskManager.popMask(this.mask, renderSession); renderSession.drawCount++; renderSession.spriteBatch.start() } }; PIXI.Graphics.prototype._renderCanvas = function (renderSession) { if (this.visible === false || this.alpha === 0 || this.isMask === true) return; var context = renderSession.context; var transform = this.worldTransform; if (this.blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = this.blendMode; context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode] } if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession.context); context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty); PIXI.CanvasGraphics.renderGraphics(this, context); for (var i = 0, j = this.children.length; i < j; i++) this.children[i]._renderCanvas(renderSession); if (this._mask) renderSession.maskManager.popMask(renderSession.context) }; PIXI.Graphics.prototype.getBounds = function (matrix) { if (!this.bounds) this.updateBounds(); var w0 = this.bounds.x; var w1 = this.bounds.width + this.bounds.x; var h0 = this.bounds.y; var h1 = this.bounds.height + this.bounds.y; var worldTransform = matrix || this.worldTransform; var a = worldTransform.a; var b = worldTransform.c; var c = worldTransform.b; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 = a * w1 + c * h0 + tx; var y4 = d * h0 + b * w1 + ty; var maxX = x1; var maxY = y1; var minX = x1; var minY = y1; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; var bounds = this._bounds; bounds.x = minX; bounds.width = maxX - minX; bounds.y = minY; bounds.height = maxY - minY; return bounds }; PIXI.Graphics.prototype.updateBounds = function () { var minX = Infinity; var maxX = -Infinity; var minY = Infinity; var maxY = -Infinity; var points, x, y, w, h; for (var i = 0; i < this.graphicsData.length; i++) { var data = this.graphicsData[i]; var type = data.type; var lineWidth = data.lineWidth; points = data.points; if (type === PIXI.Graphics.RECT) { x = points[0] - lineWidth / 2; y = points[1] - lineWidth / 2; w = points[2] + lineWidth; h = points[3] + lineWidth; minX = x < minX ? x : minX; maxX = x + w > maxX ? x + w : maxX; minY = y < minY ? x : minY; maxY = y + h > maxY ? y + h : maxY } else if (type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP) { x = points[0]; y = points[1]; w = points[2] + lineWidth / 2; h = points[3] + lineWidth / 2; minX = x - w < minX ? x - w : minX; maxX = x + w > maxX ? x + w : maxX; minY = y - h < minY ? y - h : minY; maxY = y + h > maxY ? y + h : maxY } else for (var j = 0; j < points.length; j += 2) { x = points[j]; y = points[j + 1]; minX = x - lineWidth < minX ? x - lineWidth : minX; maxX = x + lineWidth > maxX ? x + lineWidth : maxX; minY = y - lineWidth < minY ? y - lineWidth : minY; maxY = y + lineWidth > maxY ? y + lineWidth : maxY } } var padding = this.boundsPadding; this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, maxX - minX + padding * 2, maxY - minY + padding * 2) }; PIXI.Graphics.prototype._generateCachedSprite = function () { var bounds = this.getLocalBounds(); if (!this._cachedSprite) { var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height); var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas); this._cachedSprite = new PIXI.Sprite(texture); this._cachedSprite.buffer = canvasBuffer; this._cachedSprite.worldTransform = this.worldTransform } else this._cachedSprite.buffer.resize(bounds.width, bounds.height); this._cachedSprite.anchor.x = -(bounds.x / bounds.width); this._cachedSprite.anchor.y = -(bounds.y / bounds.height); this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y); PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context); this._cachedSprite.alpha = this.alpha }; PIXI.Graphics.prototype.destroyCachedSprite = function () { this._cachedSprite.texture.destroy(true); this._cachedSprite = null }; PIXI.Graphics.POLY = 0; PIXI.Graphics.RECT = 1; PIXI.Graphics.CIRC = 2; PIXI.Graphics.ELIP = 3; PIXI.Graphics.RREC = 4; PIXI.Strip = function (texture) { PIXI.DisplayObjectContainer.call(this); this.texture = texture; this.uvs = new PIXI.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]); this.verticies = new PIXI.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]); this.colors = new PIXI.Float32Array([1, 1, 1, 1]); this.indices = new PIXI.Uint16Array([0, 1, 2, 3]); this.dirty = true }; PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Strip.prototype.constructor = PIXI.Strip; PIXI.Strip.prototype._renderWebGL = function (renderSession) { if (!this.visible || this.alpha <= 0) return; renderSession.spriteBatch.stop(); if (!this._vertexBuffer) this._initWebGL(renderSession); renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader); this._renderStrip(renderSession); renderSession.spriteBatch.start() }; PIXI.Strip.prototype._initWebGL = function (renderSession) { var gl = renderSession.gl; this._vertexBuffer = gl.createBuffer(); this._indexBuffer = gl.createBuffer(); this._uvBuffer = gl.createBuffer(); this._colorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW) }; PIXI.Strip.prototype._renderStrip = function (renderSession) { var gl = renderSession.gl; var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.stripShader; gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true)); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform1f(shader.alpha, 1); if (!this.dirty) { gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl)); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer) } else { this.dirty = false; gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.STATIC_DRAW); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl)); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW) } gl.drawElements(gl.TRIANGLE_STRIP, this.indices.length, gl.UNSIGNED_SHORT, 0) }; PIXI.Strip.prototype._renderCanvas = function (renderSession) { var context = renderSession.context; var transform = this.worldTransform; if (renderSession.roundPixels) renderSession.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0); else renderSession.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty); var strip = this; var verticies = strip.verticies; var uvs = strip.uvs; var length = verticies.length / 2; this.count++; for (var i = 0; i < length - 2; i++) { var index = i * 2; var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4]; var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5]; if (true) { var centerX = (x0 + x1 + x2) / 3; var centerY = (y0 + y1 + y2) / 3; var normX = x0 - centerX; var normY = y0 - centerY; var dist = Math.sqrt(normX * normX + normY * normY); x0 = centerX + normX / dist * (dist + 3); y0 = centerY + normY / dist * (dist + 3); normX = x1 - centerX; normY = y1 - centerY; dist = Math.sqrt(normX * normX + normY * normY); x1 = centerX + normX / dist * (dist + 3); y1 = centerY + normY / dist * (dist + 3); normX = x2 - centerX; normY = y2 - centerY; dist = Math.sqrt(normX * normX + normY * normY); x2 = centerX + normX / dist * (dist + 3); y2 = centerY + normY / dist * (dist + 3) } var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width; var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height; context.save(); context.beginPath(); context.moveTo(x0, y0); context.lineTo(x1, y1); context.lineTo(x2, y2); context.closePath(); context.clip(); var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2; var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2; var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2; var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2; var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2; var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2; var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2; context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta); context.drawImage(strip.texture.baseTexture.source, 0, 0); context.restore() } }; PIXI.Strip.prototype.onTextureUpdate = function () { this.updateFrame = true }; PIXI.Rope = function (texture, points) { PIXI.Strip.call(this, texture); this.points = points; this.verticies = new PIXI.Float32Array(points.length * 4); this.uvs = new PIXI.Float32Array(points.length * 4); this.colors = new PIXI.Float32Array(points.length * 2); this.indices = new PIXI.Uint16Array(points.length * 2); this.refresh() }; PIXI.Rope.prototype = Object.create(PIXI.Strip.prototype); PIXI.Rope.prototype.constructor = PIXI.Rope; PIXI.Rope.prototype.refresh = function () { var points = this.points; if (points.length < 1) return; var uvs = this.uvs; var lastPoint = points[0]; var indices = this.indices; var colors = this.colors; this.count -= 0.2; uvs[0] = 0; uvs[1] = 0; uvs[2] = 0; uvs[3] = 1; colors[0] = 1; colors[1] = 1; indices[0] = 0; indices[1] = 1; var total = points.length, point, index, amount; for (var i = 1; i < total; i++) { point = points[i]; index = i * 4; amount = i / (total - 1); if (i % 2) { uvs[index] = amount; uvs[index + 1] = 0; uvs[index + 2] = amount; uvs[index + 3] = 1 } else { uvs[index] = amount; uvs[index + 1] = 0; uvs[index + 2] = amount; uvs[index + 3] = 1 } index = i * 2; colors[index] = 1; colors[index + 1] = 1; index = i * 2; indices[index] = index; indices[index + 1] = index + 1; lastPoint = point } }; PIXI.Rope.prototype.updateTransform = function () { var points = this.points; if (points.length < 1) return; var lastPoint = points[0]; var nextPoint; var perp = { x: 0, y: 0 }; this.count -= 0.2; var verticies = this.verticies; var total = points.length, point, index, ratio, perpLength, num; for (var i = 0; i < total; i++) { point = points[i]; index = i * 4; if (i < points.length - 1) nextPoint = points[i + 1]; else nextPoint = point; perp.y = -(nextPoint.x - lastPoint.x); perp.x = nextPoint.y - lastPoint.y; ratio = (1 - i / (total - 1)) * 10; if (ratio > 1) ratio = 1; perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y); num = this.texture.height / 2; perp.x /= perpLength; perp.y /= perpLength; perp.x *= num; perp.y *= num; verticies[index] = point.x + perp.x; verticies[index + 1] = point.y + perp.y; verticies[index + 2] = point.x - perp.x; verticies[index + 3] = point.y - perp.y; lastPoint = point } PIXI.DisplayObjectContainer.prototype.updateTransform.call(this) }; PIXI.Rope.prototype.setTexture = function (texture) { this.texture = texture }; PIXI.TilingSprite = function (texture, width, height) { PIXI.Sprite.call(this, texture); this._width = width || 100; this._height = height || 100; this.tileScale = new PIXI.Point(1, 1); this.tileScaleOffset = new PIXI.Point(1, 1); this.tilePosition = new PIXI.Point(0, 0); this.renderable = true; this.tint = 16777215; this.blendMode = PIXI.blendModes.NORMAL }; PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype); PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite; Object.defineProperty(PIXI.TilingSprite.prototype, "width", { get: function () { return this._width }, set: function (value) { this._width = value } }); Object.defineProperty(PIXI.TilingSprite.prototype, "height", { get: function () { return this._height }, set: function (value) { this._height = value } }); PIXI.TilingSprite.prototype.setTexture = function (texture) { if (this.texture === texture) return; this.texture = texture; this.refreshTexture = true; this.cachedTint = 16777215 }; PIXI.TilingSprite.prototype._renderWebGL = function (renderSession) { if (this.visible === false || this.alpha === 0) return; var i, j; if (this._mask) { renderSession.spriteBatch.stop(); renderSession.maskManager.pushMask(this.mask, renderSession); renderSession.spriteBatch.start() } if (this._filters) { renderSession.spriteBatch.flush(); renderSession.filterManager.pushFilter(this._filterBlock) } if (!this.tilingTexture || this.refreshTexture) { this.generateTilingTexture(true); if (this.tilingTexture && this.tilingTexture.needsUpdate) { PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl); this.tilingTexture.needsUpdate = false } } else renderSession.spriteBatch.renderTilingSprite(this); for (i = 0, j = this.children.length; i < j; i++) this.children[i]._renderWebGL(renderSession); renderSession.spriteBatch.stop(); if (this._filters) renderSession.filterManager.popFilter(); if (this._mask) renderSession.maskManager.popMask(renderSession); renderSession.spriteBatch.start() }; PIXI.TilingSprite.prototype._renderCanvas = function (renderSession) { if (this.visible === false || this.alpha === 0) return; var context = renderSession.context; if (this._mask) renderSession.maskManager.pushMask(this._mask, context); context.globalAlpha = this.worldAlpha; var transform = this.worldTransform; var i, j; context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty); if (!this.__tilePattern || this.refreshTexture) { this.generateTilingTexture(false); if (this.tilingTexture) this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, "repeat"); else return } if (this.blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = this.blendMode; context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode] } var tilePosition = this.tilePosition; var tileScale = this.tileScale; tilePosition.x %= this.tilingTexture.baseTexture.width; tilePosition.y %= this.tilingTexture.baseTexture.height; context.scale(tileScale.x, tileScale.y); context.translate(tilePosition.x, tilePosition.y); context.fillStyle = this.__tilePattern; context.fillRect(-tilePosition.x + this.anchor.x * -this._width, -tilePosition.y + this.anchor.y * -this._height, this._width / tileScale.x, this._height / tileScale.y); context.scale(1 / tileScale.x, 1 / tileScale.y); context.translate(-tilePosition.x, -tilePosition.y); if (this._mask) renderSession.maskManager.popMask(renderSession.context); for (i = 0, j = this.children.length; i < j; i++) this.children[i]._renderCanvas(renderSession) }; PIXI.TilingSprite.prototype.getBounds = function () { var width = this._width; var height = this._height; var w0 = width * (1 - this.anchor.x); var w1 = width * -this.anchor.x; var h0 = height * (1 - this.anchor.y); var h1 = height * -this.anchor.y; var worldTransform = this.worldTransform; var a = worldTransform.a; var b = worldTransform.c; var c = worldTransform.b; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 = a * w1 + c * h0 + tx; var y4 = d * h0 + b * w1 + ty; var maxX = -Infinity; var maxY = -Infinity; var minX = Infinity; var minY = Infinity; minX = x1 < minX ? x1 : minX; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y1 < minY ? y1 : minY; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x1 > maxX ? x1 : maxX; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y1 > maxY ? y1 : maxY; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; var bounds = this._bounds; bounds.x = minX; bounds.width = maxX - minX; bounds.y = minY; bounds.height = maxY - minY; this._currentBounds = bounds; return bounds }; PIXI.TilingSprite.prototype.onTextureUpdate = function () { }; PIXI.TilingSprite.prototype.generateTilingTexture = function (forcePowerOfTwo) { if (!this.texture.baseTexture.hasLoaded) return; var texture = this.texture; var frame = texture.frame; var targetWidth, targetHeight; var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height; var newTextureRequired = false; if (!forcePowerOfTwo) { if (isFrame) { targetWidth = frame.width; targetHeight = frame.height; newTextureRequired = true } } else { targetWidth = PIXI.getNextPowerOfTwo(frame.width); targetHeight = PIXI.getNextPowerOfTwo(frame.height); if (frame.width !== targetWidth || frame.height !== targetHeight) newTextureRequired = true } if (newTextureRequired) { var canvasBuffer; if (this.tilingTexture && this.tilingTexture.isTiling) { canvasBuffer = this.tilingTexture.canvasBuffer; canvasBuffer.resize(targetWidth, targetHeight); this.tilingTexture.baseTexture.width = targetWidth; this.tilingTexture.baseTexture.height = targetHeight; this.tilingTexture.needsUpdate = true } else { canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight); this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas); this.tilingTexture.canvasBuffer = canvasBuffer; this.tilingTexture.isTiling = true } canvasBuffer.context.drawImage(texture.baseTexture.source, texture.crop.x, texture.crop.y, texture.crop.width, texture.crop.height, 0, 0, targetWidth, targetHeight); this.tileScaleOffset.x = frame.width / targetWidth; this.tileScaleOffset.y = frame.height / targetHeight } else { if (this.tilingTexture && this.tilingTexture.isTiling) this.tilingTexture.destroy(true); this.tileScaleOffset.x = 1; this.tileScaleOffset.y = 1; this.tilingTexture = texture } this.refreshTexture = false; this.tilingTexture.baseTexture._powerOf2 = true }; var spine = {}; spine.BoneData = function (name, parent) { this.name = name; this.parent = parent }; spine.BoneData.prototype = { length: 0, x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 }; spine.SlotData = function (name, boneData) { this.name = name; this.boneData = boneData }; spine.SlotData.prototype = { r: 1, g: 1, b: 1, a: 1, attachmentName: null }; spine.Bone = function (boneData, parent) { this.data = boneData; this.parent = parent; this.setToSetupPose() }; spine.Bone.yDown = false; spine.Bone.prototype = { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, m00: 0, m01: 0, worldX: 0, m10: 0, m11: 0, worldY: 0, worldRotation: 0, worldScaleX: 1, worldScaleY: 1, updateWorldTransform: function (flipX, flipY) { var parent = this.parent; if (parent != null) { this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX; this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY; this.worldScaleX = parent.worldScaleX * this.scaleX; this.worldScaleY = parent.worldScaleY * this.scaleY; this.worldRotation = parent.worldRotation + this.rotation } else { this.worldX = this.x; this.worldY = this.y; this.worldScaleX = this.scaleX; this.worldScaleY = this.scaleY; this.worldRotation = this.rotation } var radians = this.worldRotation * Math.PI / 180; var cos = Math.cos(radians); var sin = Math.sin(radians); this.m00 = cos * this.worldScaleX; this.m10 = sin * this.worldScaleX; this.m01 = -sin * this.worldScaleY; this.m11 = cos * this.worldScaleY; if (flipX) { this.m00 = -this.m00; this.m01 = -this.m01 } if (flipY) { this.m10 = -this.m10; this.m11 = -this.m11 } if (spine.Bone.yDown) { this.m10 = -this.m10; this.m11 = -this.m11 } }, setToSetupPose: function () { var data = this.data; this.x = data.x; this.y = data.y; this.rotation = data.rotation; this.scaleX = data.scaleX; this.scaleY = data.scaleY } }; spine.Slot = function (slotData, skeleton, bone) { this.data = slotData; this.skeleton = skeleton; this.bone = bone; this.setToSetupPose() }; spine.Slot.prototype = { r: 1, g: 1, b: 1, a: 1, _attachmentTime: 0, attachment: null, setAttachment: function (attachment) { this.attachment = attachment; this._attachmentTime = this.skeleton.time }, setAttachmentTime: function (time) { this._attachmentTime = this.skeleton.time - time }, getAttachmentTime: function () { return this.skeleton.time - this._attachmentTime }, setToSetupPose: function () { var data = this.data; this.r = data.r; this.g = data.g; this.b = data.b; this.a = data.a; var slotDatas = this.skeleton.data.slots; for (var i = 0, n = slotDatas.length; i < n; i++) if (slotDatas[i] == data) { this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName)); break } } }; spine.Skin = function (name) { this.name = name; this.attachments = {} }; spine.Skin.prototype = { addAttachment: function (slotIndex, name, attachment) { this.attachments[slotIndex + ":" + name] = attachment }, getAttachment: function (slotIndex, name) { return this.attachments[slotIndex + ":" + name] }, _attachAll: function (skeleton, oldSkin) { for (var key in oldSkin.attachments) { var colon = key.indexOf(":"); var slotIndex = parseInt(key.substring(0, colon), 10); var name = key.substring(colon + 1); var slot = skeleton.slots[slotIndex]; if (slot.attachment && slot.attachment.name == name) { var attachment = this.getAttachment(slotIndex, name); if (attachment) slot.setAttachment(attachment) } } } }; spine.Animation = function (name, timelines, duration) { this.name = name; this.timelines = timelines; this.duration = duration }; spine.Animation.prototype = { apply: function (skeleton, time, loop) { if (loop && this.duration) time %= this.duration; var timelines = this.timelines; for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, time, 1) }, mix: function (skeleton, time, loop, alpha) { if (loop && this.duration) time %= this.duration; var timelines = this.timelines; for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, time, alpha) } }; spine.binarySearch = function (values, target, step) { var low = 0; var high = Math.floor(values.length / step) - 2; if (!high) return step; var current = high >>> 1; while (true) { if (values[(current + 1) * step] <= target) low = current + 1; else high = current; if (low == high) return (low + 1) * step; current = low + high >>> 1 } }; spine.linearSearch = function (values, target, step) { for (var i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i; return -1 }; spine.Curves = function (frameCount) { this.curves = []; this.curves.length = (frameCount - 1) * 6 }; spine.Curves.prototype = { setLinear: function (frameIndex) { this.curves[frameIndex * 6] = 0 }, setStepped: function (frameIndex) { this.curves[frameIndex * 6] = -1 }, setCurve: function (frameIndex, cx1, cy1, cx2, cy2) { var subdiv_step = 1 / 10; var subdiv_step2 = subdiv_step * subdiv_step; var subdiv_step3 = subdiv_step2 * subdiv_step; var pre1 = 3 * subdiv_step; var pre2 = 3 * subdiv_step2; var pre4 = 6 * subdiv_step2; var pre5 = 6 * subdiv_step3; var tmp1x = -cx1 * 2 + cx2; var tmp1y = -cy1 * 2 + cy2; var tmp2x = (cx1 - cx2) * 3 + 1; var tmp2y = (cy1 - cy2) * 3 + 1; var i = frameIndex * 6; var curves = this.curves; curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3; curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3; curves[i + 2] = tmp1x * pre4 + tmp2x * pre5; curves[i + 3] = tmp1y * pre4 + tmp2y * pre5; curves[i + 4] = tmp2x * pre5; curves[i + 5] = tmp2y * pre5 }, getCurvePercent: function (frameIndex, percent) { percent = percent < 0 ? 0 : percent > 1 ? 1 : percent; var curveIndex = frameIndex * 6; var curves = this.curves; var dfx = curves[curveIndex]; if (!dfx) return percent; if (dfx == -1) return 0; var dfy = curves[curveIndex + 1]; var ddfx = curves[curveIndex + 2]; var ddfy = curves[curveIndex + 3]; var dddfx = curves[curveIndex + 4]; var dddfy = curves[curveIndex + 5]; var x = dfx, y = dfy; var i = 10 - 2; while (true) { if (x >= percent) { var lastX = x - dfx; var lastY = y - dfy; return lastY + (y - lastY) * (percent - lastX) / (x - lastX) } if (!i) break; i--; dfx += ddfx; dfy += ddfy; ddfx += dddfx; ddfy += dddfy; x += dfx; y += dfy } return y + (1 - y) * (percent - x) / (1 - x) } }; spine.RotateTimeline = function (frameCount) { this.curves = new spine.Curves(frameCount); this.frames = []; this.frames.length = frameCount * 2 }; spine.RotateTimeline.prototype = { boneIndex: 0, getFrameCount: function () { return this.frames.length / 2 }, setFrame: function (frameIndex, time, angle) { frameIndex *= 2; this.frames[frameIndex] = time; this.frames[frameIndex + 1] = angle }, apply: function (skeleton, time, alpha) { var frames = this.frames, amount; if (time < frames[0]) return; var bone = skeleton.bones[this.boneIndex]; if (time >= frames[frames.length - 2]) { amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation; while (amount > 180) amount -= 360; while (amount < -180) amount += 360; bone.rotation += amount * alpha; return } var frameIndex = spine.binarySearch(frames, time, 2); var lastFrameValue = frames[frameIndex - 1]; var frameTime = frames[frameIndex]; var percent = 1 - (time - frameTime) / (frames[frameIndex - 2] - frameTime); percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent); amount = frames[frameIndex + 1] - lastFrameValue; while (amount > 180) amount -= 360; while (amount < -180) amount += 360; amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation; while (amount > 180) amount -= 360; while (amount < -180) amount += 360; bone.rotation += amount * alpha } }; spine.TranslateTimeline = function (frameCount) { this.curves = new spine.Curves(frameCount); this.frames = []; this.frames.length = frameCount * 3 }; spine.TranslateTimeline.prototype = { boneIndex: 0, getFrameCount: function () { return this.frames.length / 3 }, setFrame: function (frameIndex, time, x, y) { frameIndex *= 3; this.frames[frameIndex] = time; this.frames[frameIndex + 1] = x; this.frames[frameIndex + 2] = y }, apply: function (skeleton, time, alpha) { var frames = this.frames; if (time < frames[0]) return; var bone = skeleton.bones[this.boneIndex]; if (time >= frames[frames.length - 3]) { bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha; bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha; return } var frameIndex = spine.binarySearch(frames, time, 3); var lastFrameX = frames[frameIndex - 2]; var lastFrameY = frames[frameIndex - 1]; var frameTime = frames[frameIndex]; var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime); percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent); bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1] - lastFrameX) * percent - bone.x) * alpha; bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2] - lastFrameY) * percent - bone.y) * alpha } }; spine.ScaleTimeline = function (frameCount) { this.curves = new spine.Curves(frameCount); this.frames = []; this.frames.length = frameCount * 3 }; spine.ScaleTimeline.prototype = { boneIndex: 0, getFrameCount: function () { return this.frames.length / 3 }, setFrame: function (frameIndex, time, x, y) { frameIndex *= 3; this.frames[frameIndex] = time; this.frames[frameIndex + 1] = x; this.frames[frameIndex + 2] = y }, apply: function (skeleton, time, alpha) { var frames = this.frames; if (time < frames[0]) return; var bone = skeleton.bones[this.boneIndex]; if (time >= frames[frames.length - 3]) { bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha; bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha; return } var frameIndex = spine.binarySearch(frames, time, 3); var lastFrameX = frames[frameIndex - 2]; var lastFrameY = frames[frameIndex - 1]; var frameTime = frames[frameIndex]; var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime); percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent); bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1] - lastFrameX) * percent - bone.scaleX) * alpha; bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2] - lastFrameY) * percent - bone.scaleY) * alpha } }; spine.ColorTimeline = function (frameCount) { this.curves = new spine.Curves(frameCount); this.frames = []; this.frames.length = frameCount * 5 }; spine.ColorTimeline.prototype = { slotIndex: 0, getFrameCount: function () { return this.frames.length / 5 }, setFrame: function (frameIndex, time, r, g, b, a) { frameIndex *= 5; this.frames[frameIndex] = time; this.frames[frameIndex + 1] = r; this.frames[frameIndex + 2] = g; this.frames[frameIndex + 3] = b; this.frames[frameIndex + 4] = a }, apply: function (skeleton, time, alpha) { var frames = this.frames; if (time < frames[0]) return; var slot = skeleton.slots[this.slotIndex]; if (time >= frames[frames.length - 5]) { var i = frames.length - 1; slot.r = frames[i - 3]; slot.g = frames[i - 2]; slot.b = frames[i - 1]; slot.a = frames[i]; return } var frameIndex = spine.binarySearch(frames, time, 5); var lastFrameR = frames[frameIndex - 4]; var lastFrameG = frames[frameIndex - 3]; var lastFrameB = frames[frameIndex - 2]; var lastFrameA = frames[frameIndex - 1]; var frameTime = frames[frameIndex]; var percent = 1 - (time - frameTime) / (frames[frameIndex - 5] - frameTime); percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent); var r = lastFrameR + (frames[frameIndex + 1] - lastFrameR) * percent; var g = lastFrameG + (frames[frameIndex + 2] - lastFrameG) * percent; var b = lastFrameB + (frames[frameIndex + 3] - lastFrameB) * percent; var a = lastFrameA + (frames[frameIndex + 4] - lastFrameA) * percent; if (alpha < 1) { slot.r += (r - slot.r) * alpha; slot.g += (g - slot.g) * alpha; slot.b += (b - slot.b) * alpha; slot.a += (a - slot.a) * alpha } else { slot.r = r; slot.g = g; slot.b = b; slot.a = a } } }; spine.AttachmentTimeline = function (frameCount) { this.curves = new spine.Curves(frameCount); this.frames = []; this.frames.length = frameCount; this.attachmentNames = []; this.attachmentNames.length = frameCount }; spine.AttachmentTimeline.prototype = { slotIndex: 0, getFrameCount: function () { return this.frames.length }, setFrame: function (frameIndex, time, attachmentName) { this.frames[frameIndex] = time; this.attachmentNames[frameIndex] = attachmentName }, apply: function (skeleton, time, alpha) { var frames = this.frames; if (time < frames[0]) return; var frameIndex; if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1; else frameIndex = spine.binarySearch(frames, time, 1) - 1; var attachmentName = this.attachmentNames[frameIndex]; skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName)) } }; spine.SkeletonData = function () { this.bones = []; this.slots = []; this.skins = []; this.animations = [] }; spine.SkeletonData.prototype = { defaultSkin: null, findBone: function (boneName) { var bones = this.bones; for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return bones[i]; return null }, findBoneIndex: function (boneName) { var bones = this.bones; for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i; return -1 }, findSlot: function (slotName) { var slots = this.slots; for (var i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return slot[i]; return null }, findSlotIndex: function (slotName) { var slots = this.slots; for (var i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i; return -1 }, findSkin: function (skinName) { var skins = this.skins; for (var i = 0, n = skins.length; i < n; i++) if (skins[i].name == skinName) return skins[i]; return null }, findAnimation: function (animationName) { var animations = this.animations; for (var i = 0, n = animations.length; i < n; i++) if (animations[i].name == animationName) return animations[i]; return null } }; spine.Skeleton = function (skeletonData) { this.data = skeletonData; this.bones = []; for (var i = 0, n = skeletonData.bones.length; i < n; i++) { var boneData = skeletonData.bones[i]; var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)]; this.bones.push(new spine.Bone(boneData, parent)) } this.slots = []; this.drawOrder = []; for (i = 0, n = skeletonData.slots.length; i < n; i++) { var slotData = skeletonData.slots[i]; var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)]; var slot = new spine.Slot(slotData, this, bone); this.slots.push(slot); this.drawOrder.push(slot) } }; spine.Skeleton.prototype = { x: 0, y: 0, skin: null, r: 1, g: 1, b: 1, a: 1, time: 0, flipX: false, flipY: false, updateWorldTransform: function () { var flipX = this.flipX; var flipY = this.flipY; var bones = this.bones; for (var i = 0, n = bones.length; i < n; i++) bones[i].updateWorldTransform(flipX, flipY) }, setToSetupPose: function () { this.setBonesToSetupPose(); this.setSlotsToSetupPose() }, setBonesToSetupPose: function () { var bones = this.bones; for (var i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose() }, setSlotsToSetupPose: function () { var slots = this.slots; for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose(i) }, getRootBone: function () { return this.bones.length ? this.bones[0] : null }, findBone: function (boneName) { var bones = this.bones; for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return bones[i]; return null }, findBoneIndex: function (boneName) { var bones = this.bones; for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i; return -1 }, findSlot: function (slotName) { var slots = this.slots; for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return slots[i]; return null }, findSlotIndex: function (slotName) { var slots = this.slots; for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i; return -1 }, setSkinByName: function (skinName) { var skin = this.data.findSkin(skinName); if (!skin) throw "Skin not found: " + skinName; this.setSkin(skin) }, setSkin: function (newSkin) { if (this.skin && newSkin) newSkin._attachAll(this, this.skin); this.skin = newSkin }, getAttachmentBySlotName: function (slotName, attachmentName) { return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName) }, getAttachmentBySlotIndex: function (slotIndex, attachmentName) { if (this.skin) { var attachment = this.skin.getAttachment(slotIndex, attachmentName); if (attachment) return attachment } if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName); return null }, setAttachment: function (slotName, attachmentName) { var slots = this.slots; for (var i = 0, n = slots.size; i < n; i++) { var slot = slots[i]; if (slot.data.name == slotName) { var attachment = null; if (attachmentName) { attachment = this.getAttachment(i, attachmentName); if (attachment == null) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName; } slot.setAttachment(attachment); return } } throw "Slot not found: " + slotName; }, update: function (delta) { time += delta } }; spine.AttachmentType = { region: 0 }; spine.RegionAttachment = function () { this.offset = []; this.offset.length = 8; this.uvs = []; this.uvs.length = 8 }; spine.RegionAttachment.prototype = { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, width: 0, height: 0, rendererObject: null, regionOffsetX: 0, regionOffsetY: 0, regionWidth: 0, regionHeight: 0, regionOriginalWidth: 0, regionOriginalHeight: 0, setUVs: function (u, v, u2, v2, rotate) { var uvs = this.uvs; if (rotate) { uvs[2] = u; uvs[3] = v2; uvs[4] = u; uvs[5] = v; uvs[6] = u2; uvs[7] = v; uvs[0] = u2; uvs[1] = v2 } else { uvs[0] = u; uvs[1] = v2; uvs[2] = u; uvs[3] = v; uvs[4] = u2; uvs[5] = v; uvs[6] = u2; uvs[7] = v2 } }, updateOffset: function () { var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX; var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY; var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX; var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY; var localX2 = localX + this.regionWidth * regionScaleX; var localY2 = localY + this.regionHeight * regionScaleY; var radians = this.rotation * Math.PI / 180; var cos = Math.cos(radians); var sin = Math.sin(radians); var localXCos = localX * cos + this.x; var localXSin = localX * sin; var localYCos = localY * cos + this.y; var localYSin = localY * sin; var localX2Cos = localX2 * cos + this.x; var localX2Sin = localX2 * sin; var localY2Cos = localY2 * cos + this.y; var localY2Sin = localY2 * sin; var offset = this.offset; offset[0] = localXCos - localYSin; offset[1] = localYCos + localXSin; offset[2] = localXCos - localY2Sin; offset[3] = localY2Cos + localXSin; offset[4] = localX2Cos - localY2Sin; offset[5] = localY2Cos + localX2Sin; offset[6] = localX2Cos - localYSin; offset[7] = localYCos + localX2Sin }, computeVertices: function (x, y, bone, vertices) { x += bone.worldX; y += bone.worldY; var m00 = bone.m00; var m01 = bone.m01; var m10 = bone.m10; var m11 = bone.m11; var offset = this.offset; vertices[0] = offset[0] * m00 + offset[1] * m01 + x; vertices[1] = offset[0] * m10 + offset[1] * m11 + y; vertices[2] = offset[2] * m00 + offset[3] * m01 + x; vertices[3] = offset[2] * m10 + offset[3] * m11 + y; vertices[4] = offset[4] * m00 + offset[5] * m01 + x; vertices[5] = offset[4] * m10 + offset[5] * m11 + y; vertices[6] = offset[6] * m00 + offset[7] * m01 + x; vertices[7] = offset[6] * m10 + offset[7] * m11 + y } }; spine.AnimationStateData = function (skeletonData) { this.skeletonData = skeletonData; this.animationToMixTime = {} }; spine.AnimationStateData.prototype = { defaultMix: 0, setMixByName: function (fromName, toName, duration) { var from = this.skeletonData.findAnimation(fromName); if (!from) throw "Animation not found: " + fromName; var to = this.skeletonData.findAnimation(toName); if (!to) throw "Animation not found: " + toName; this.setMix(from, to, duration) }, setMix: function (from, to, duration) { this.animationToMixTime[from.name + ":" + to.name] = duration }, getMix: function (from, to) { var time = this.animationToMixTime[from.name + ":" + to.name]; return time ? time : this.defaultMix } }; spine.AnimationState = function (stateData) { this.data = stateData; this.queue = [] }; spine.AnimationState.prototype = { animationSpeed: 1, current: null, previous: null, currentTime: 0, previousTime: 0, currentLoop: false, previousLoop: false, mixTime: 0, mixDuration: 0, update: function (delta) { this.currentTime += delta * this.animationSpeed; this.previousTime += delta; this.mixTime += delta; if (this.queue.length > 0) { var entry = this.queue[0]; if (this.currentTime >= entry.delay) { this._setAnimation(entry.animation, entry.loop); this.queue.shift() } } }, apply: function (skeleton) { if (!this.current) return; if (this.previous) { this.previous.apply(skeleton, this.previousTime, this.previousLoop); var alpha = this.mixTime / this.mixDuration; if (alpha >= 1) { alpha = 1; this.previous = null } this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha) } else this.current.apply(skeleton, this.currentTime, this.currentLoop) }, clearAnimation: function () { this.previous = null; this.current = null; this.queue.length = 0 }, _setAnimation: function (animation, loop) { this.previous = null; if (animation && this.current) { this.mixDuration = this.data.getMix(this.current, animation); if (this.mixDuration > 0) { this.mixTime = 0; this.previous = this.current; this.previousTime = this.currentTime; this.previousLoop = this.currentLoop } } this.current = animation; this.currentLoop = loop; this.currentTime = 0 }, setAnimationByName: function (animationName, loop) { var animation = this.data.skeletonData.findAnimation(animationName); if (!animation) throw "Animation not found: " + animationName; this.setAnimation(animation, loop) }, setAnimation: function (animation, loop) { this.queue.length = 0; this._setAnimation(animation, loop) }, addAnimationByName: function (animationName, loop, delay) { var animation = this.data.skeletonData.findAnimation(animationName); if (!animation) throw "Animation not found: " + animationName; this.addAnimation(animation, loop, delay) }, addAnimation: function (animation, loop, delay) { var entry = {}; entry.animation = animation; entry.loop = loop; if (!delay || delay <= 0) { var previousAnimation = this.queue.length ? this.queue[this.queue.length - 1].animation : this.current; if (previousAnimation != null) delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0); else delay = 0 } entry.delay = delay; this.queue.push(entry) }, isComplete: function () { return !this.current || this.currentTime >= this.current.duration } }; spine.SkeletonJson = function (attachmentLoader) { this.attachmentLoader = attachmentLoader }; spine.SkeletonJson.prototype = { scale: 1, readSkeletonData: function (root) { var skeletonData = new spine.SkeletonData, boneData; var bones = root["bones"]; for (var i = 0, n = bones.length; i < n; i++) { var boneMap = bones[i]; var parent = null; if (boneMap["parent"]) { parent = skeletonData.findBone(boneMap["parent"]); if (!parent) throw "Parent bone not found: " + boneMap["parent"]; } boneData = new spine.BoneData(boneMap["name"], parent); boneData.length = (boneMap["length"] || 0) * this.scale; boneData.x = (boneMap["x"] || 0) * this.scale; boneData.y = (boneMap["y"] || 0) * this.scale; boneData.rotation = boneMap["rotation"] || 0; boneData.scaleX = boneMap["scaleX"] || 1; boneData.scaleY = boneMap["scaleY"] || 1; skeletonData.bones.push(boneData) } var slots = root["slots"]; for (i = 0, n = slots.length; i < n; i++) { var slotMap = slots[i]; boneData = skeletonData.findBone(slotMap["bone"]); if (!boneData) throw "Slot bone not found: " + slotMap["bone"]; var slotData = new spine.SlotData(slotMap["name"], boneData); var color = slotMap["color"]; if (color) { slotData.r = spine.SkeletonJson.toColor(color, 0); slotData.g = spine.SkeletonJson.toColor(color, 1); slotData.b = spine.SkeletonJson.toColor(color, 2); slotData.a = spine.SkeletonJson.toColor(color, 3) } slotData.attachmentName = slotMap["attachment"]; skeletonData.slots.push(slotData) } var skins = root["skins"]; for (var skinName in skins) { if (!skins.hasOwnProperty(skinName)) continue; var skinMap = skins[skinName]; var skin = new spine.Skin(skinName); for (var slotName in skinMap) { if (!skinMap.hasOwnProperty(slotName)) continue; var slotIndex = skeletonData.findSlotIndex(slotName); var slotEntry = skinMap[slotName]; for (var attachmentName in slotEntry) { if (!slotEntry.hasOwnProperty(attachmentName)) continue; var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]); if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment) } } skeletonData.skins.push(skin); if (skin.name == "default") skeletonData.defaultSkin = skin } var animations = root["animations"]; for (var animationName in animations) { if (!animations.hasOwnProperty(animationName)) continue; this.readAnimation(animationName, animations[animationName], skeletonData) } return skeletonData }, readAttachment: function (skin, name, map) { name = map["name"] || name; var type = spine.AttachmentType[map["type"] || "region"]; if (type == spine.AttachmentType.region) { var attachment = new spine.RegionAttachment; attachment.x = (map["x"] || 0) * this.scale; attachment.y = (map["y"] || 0) * this.scale; attachment.scaleX = map["scaleX"] || 1; attachment.scaleY = map["scaleY"] || 1; attachment.rotation = map["rotation"] || 0; attachment.width = (map["width"] || 32) * this.scale; attachment.height = (map["height"] || 32) * this.scale; attachment.updateOffset(); attachment.rendererObject = {}; attachment.rendererObject.name = name; attachment.rendererObject.scale = {}; attachment.rendererObject.scale.x = attachment.scaleX; attachment.rendererObject.scale.y = attachment.scaleY; attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180; return attachment } throw "Unknown attachment type: " + type; }, readAnimation: function (name, map, skeletonData) { var timelines = []; var duration = 0; var frameIndex, timeline, timelineName, valueMap, values, i, n; var bones = map["bones"]; for (var boneName in bones) { if (!bones.hasOwnProperty(boneName)) continue; var boneIndex = skeletonData.findBoneIndex(boneName); if (boneIndex == -1) throw "Bone not found: " + boneName; var boneMap = bones[boneName]; for (timelineName in boneMap) { if (!boneMap.hasOwnProperty(timelineName)) continue; values = boneMap[timelineName]; if (timelineName == "rotate") { timeline = new spine.RotateTimeline(values.length); timeline.boneIndex = boneIndex; frameIndex = 0; for (i = 0, n = values.length; i < n; i++) { valueMap = values[i]; timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]); spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap); frameIndex++ } timelines.push(timeline); duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]) } else if (timelineName == "translate" || timelineName == "scale") { var timelineScale = 1; if (timelineName == "scale") timeline = new spine.ScaleTimeline(values.length); else { timeline = new spine.TranslateTimeline(values.length); timelineScale = this.scale } timeline.boneIndex = boneIndex; frameIndex = 0; for (i = 0, n = values.length; i < n; i++) { valueMap = values[i]; var x = (valueMap["x"] || 0) * timelineScale; var y = (valueMap["y"] || 0) * timelineScale; timeline.setFrame(frameIndex, valueMap["time"], x, y); spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap); frameIndex++ } timelines.push(timeline); duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]) } else throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")"; } } var slots = map["slots"]; for (var slotName in slots) { if (!slots.hasOwnProperty(slotName)) continue; var slotMap = slots[slotName]; var slotIndex = skeletonData.findSlotIndex(slotName); for (timelineName in slotMap) { if (!slotMap.hasOwnProperty(timelineName)) continue; values = slotMap[timelineName]; if (timelineName == "color") { timeline = new spine.ColorTimeline(values.length); timeline.slotIndex = slotIndex; frameIndex = 0; for (i = 0, n = values.length; i < n; i++) { valueMap = values[i]; var color = valueMap["color"]; var r = spine.SkeletonJson.toColor(color, 0); var g = spine.SkeletonJson.toColor(color, 1); var b = spine.SkeletonJson.toColor(color, 2); var a = spine.SkeletonJson.toColor(color, 3); timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a); spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap); frameIndex++ } timelines.push(timeline); duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]) } else if (timelineName == "attachment") { timeline = new spine.AttachmentTimeline(values.length); timeline.slotIndex = slotIndex; frameIndex = 0; for (i = 0, n = values.length; i < n; i++) { valueMap = values[i]; timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]) } timelines.push(timeline); duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]) } else throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")"; } } skeletonData.animations.push(new spine.Animation(name, timelines, duration)) } }; spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) { var curve = valueMap["curve"]; if (!curve) return; if (curve == "stepped") timeline.curves.setStepped(frameIndex); else if (curve instanceof Array) timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]) }; spine.SkeletonJson.toColor = function (hexString, colorIndex) { if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString; return parseInt(hexString.substr(colorIndex * 2, 2), 16) / 255 }; spine.Atlas = function (atlasText, textureLoader) { this.textureLoader = textureLoader; this.pages = []; this.regions = []; var reader = new spine.AtlasReader(atlasText); var tuple = []; tuple.length = 4; var page = null; while (true) { var line = reader.readLine(); if (line == null) break; line = reader.trim(line); if (!line.length) page = null; else if (!page) { page = new spine.AtlasPage; page.name = line; page.format = spine.Atlas.Format[reader.readValue()]; reader.readTuple(tuple); page.minFilter = spine.Atlas.TextureFilter[tuple[0]]; page.magFilter = spine.Atlas.TextureFilter[tuple[1]]; var direction = reader.readValue(); page.uWrap = spine.Atlas.TextureWrap.clampToEdge; page.vWrap = spine.Atlas.TextureWrap.clampToEdge; if (direction == "x") page.uWrap = spine.Atlas.TextureWrap.repeat; else if (direction == "y") page.vWrap = spine.Atlas.TextureWrap.repeat; else if (direction == "xy") page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat; textureLoader.load(page, line); this.pages.push(page) } else { var region = new spine.AtlasRegion; region.name = line; region.page = page; region.rotate = reader.readValue() == "true"; reader.readTuple(tuple); var x = parseInt(tuple[0], 10); var y = parseInt(tuple[1], 10); reader.readTuple(tuple); var width = parseInt(tuple[0], 10); var height = parseInt(tuple[1], 10); region.u = x / page.width; region.v = y / page.height; if (region.rotate) { region.u2 = (x + height) / page.width; region.v2 = (y + width) / page.height } else { region.u2 = (x + width) / page.width; region.v2 = (y + height) / page.height } region.x = x; region.y = y; region.width = Math.abs(width); region.height = Math.abs(height); if (reader.readTuple(tuple) == 4) { region.splits = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)]; if (reader.readTuple(tuple) == 4) { region.pads = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)]; reader.readTuple(tuple) } } region.originalWidth = parseInt(tuple[0], 10); region.originalHeight = parseInt(tuple[1], 10); reader.readTuple(tuple); region.offsetX = parseInt(tuple[0], 10); region.offsetY = parseInt(tuple[1], 10); region.index = parseInt(reader.readValue(), 10); this.regions.push(region) } } }; spine.Atlas.prototype = { findRegion: function (name) { var regions = this.regions; for (var i = 0, n = regions.length; i < n; i++) if (regions[i].name == name) return regions[i]; return null }, dispose: function () { var pages = this.pages; for (var i = 0, n = pages.length; i < n; i++) this.textureLoader.unload(pages[i].rendererObject) }, updateUVs: function (page) { var regions = this.regions; for (var i = 0, n = regions.length; i < n; i++) { var region = regions[i]; if (region.page != page) continue; region.u = region.x / page.width; region.v = region.y / page.height; if (region.rotate) { region.u2 = (region.x + region.height) / page.width; region.v2 = (region.y + region.width) / page.height } else { region.u2 = (region.x + region.width) / page.width; region.v2 = (region.y + region.height) / page.height } } } }; spine.Atlas.Format = { alpha: 0, intensity: 1, luminanceAlpha: 2, rgb565: 3, rgba4444: 4, rgb888: 5, rgba8888: 6 }; spine.Atlas.TextureFilter = { nearest: 0, linear: 1, mipMap: 2, mipMapNearestNearest: 3, mipMapLinearNearest: 4, mipMapNearestLinear: 5, mipMapLinearLinear: 6 }; spine.Atlas.TextureWrap = { mirroredRepeat: 0, clampToEdge: 1, repeat: 2 }; spine.AtlasPage = function () { }; spine.AtlasPage.prototype = { name: null, format: null, minFilter: null, magFilter: null, uWrap: null, vWrap: null, rendererObject: null, width: 0, height: 0 }; spine.AtlasRegion = function () { }; spine.AtlasRegion.prototype = { page: null, name: null, x: 0, y: 0, width: 0, height: 0, u: 0, v: 0, u2: 0, v2: 0, offsetX: 0, offsetY: 0, originalWidth: 0, originalHeight: 0, index: 0, rotate: false, splits: null, pads: null }; spine.AtlasReader = function (text) { this.lines = text.split(/\r\n|\r|\n/) }; spine.AtlasReader.prototype = { index: 0, trim: function (value) { return value.replace(/^\s+|\s+$/g, "") }, readLine: function () { if (this.index >= this.lines.length) return null; return this.lines[this.index++] }, readValue: function () { var line = this.readLine(); var colon = line.indexOf(":"); if (colon == -1) throw "Invalid line: " + line; return this.trim(line.substring(colon + 1)) }, readTuple: function (tuple) { var line = this.readLine(); var colon = line.indexOf(":"); if (colon == -1) throw "Invalid line: " + line; var i = 0, lastMatch = colon + 1; for (; i < 3; i++) { var comma = line.indexOf(",", lastMatch); if (comma == -1) { if (!i) throw "Invalid line: " + line; break } tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch)); lastMatch = comma + 1 } tuple[i] = this.trim(line.substring(lastMatch)); return i + 1 } }; spine.AtlasAttachmentLoader = function (atlas) { this.atlas = atlas }; spine.AtlasAttachmentLoader.prototype = { newAttachment: function (skin, type, name) { switch (type) { case spine.AttachmentType.region: var region = this.atlas.findRegion(name); if (!region) throw "Region not found in atlas: " + name + " (" + type + ")"; var attachment = new spine.RegionAttachment(name); attachment.rendererObject = region; attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate); attachment.regionOffsetX = region.offsetX; attachment.regionOffsetY = region.offsetY; attachment.regionWidth = region.width; attachment.regionHeight = region.height; attachment.regionOriginalWidth = region.originalWidth; attachment.regionOriginalHeight = region.originalHeight; return attachment } throw "Unknown attachment type: " + type; } }; spine.Bone.yDown = true; PIXI.AnimCache = {}; PIXI.Spine = function (url) { PIXI.DisplayObjectContainer.call(this); this.spineData = PIXI.AnimCache[url]; if (!this.spineData) throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + url); this.skeleton = new spine.Skeleton(this.spineData); this.skeleton.updateWorldTransform(); this.stateData = new spine.AnimationStateData(this.spineData); this.state = new spine.AnimationState(this.stateData); this.slotContainers = []; for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) { var slot = this.skeleton.drawOrder[i]; var attachment = slot.attachment; var slotContainer = new PIXI.DisplayObjectContainer; this.slotContainers.push(slotContainer); this.addChild(slotContainer); if (!(attachment instanceof spine.RegionAttachment)) continue; var spriteName = attachment.rendererObject.name; var sprite = this.createSprite(slot, attachment.rendererObject); slot.currentSprite = sprite; slot.currentSpriteName = spriteName; slotContainer.addChild(sprite) } }; PIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Spine.prototype.constructor = PIXI.Spine; PIXI.Spine.prototype.updateTransform = function () { this.lastTime = this.lastTime || Date.now(); var timeDelta = (Date.now() - this.lastTime) * 0.001; this.lastTime = Date.now(); this.state.update(timeDelta); this.state.apply(this.skeleton); this.skeleton.updateWorldTransform(); var drawOrder = this.skeleton.drawOrder; for (var i = 0, n = drawOrder.length; i < n; i++) { var slot = drawOrder[i]; var attachment = slot.attachment; var slotContainer = this.slotContainers[i]; if (!(attachment instanceof spine.RegionAttachment)) { slotContainer.visible = false; continue } if (attachment.rendererObject) if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) { var spriteName = attachment.rendererObject.name; if (slot.currentSprite !== undefined) slot.currentSprite.visible = false; slot.sprites = slot.sprites || {}; if (slot.sprites[spriteName] !== undefined) slot.sprites[spriteName].visible = true; else { var sprite = this.createSprite(slot, attachment.rendererObject); slotContainer.addChild(sprite) } slot.currentSprite = slot.sprites[spriteName]; slot.currentSpriteName = spriteName } slotContainer.visible = true; var bone = slot.bone; slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01; slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11; slotContainer.scale.x = bone.worldScaleX; slotContainer.scale.y = bone.worldScaleY; slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180); slotContainer.alpha = slot.a; slot.currentSprite.tint = PIXI.rgb2hex([slot.r, slot.g, slot.b]) } PIXI.DisplayObjectContainer.prototype.updateTransform.call(this) }; PIXI.Spine.prototype.createSprite = function (slot, descriptor) { var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + ".png"; var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name)); sprite.scale = descriptor.scale; sprite.rotation = descriptor.rotation; sprite.anchor.x = sprite.anchor.y = 0.5; slot.sprites = slot.sprites || {}; slot.sprites[descriptor.name] = sprite; return sprite }; PIXI.BaseTextureCache = {}; PIXI.texturesToUpdate = []; PIXI.texturesToDestroy = []; PIXI.BaseTextureCacheIdGenerator = 0; PIXI.BaseTexture = function (source, scaleMode) { PIXI.EventTarget.call(this); this.width = 100; this.height = 100; this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT; this.hasLoaded = false; this.source = source; this.id = PIXI.BaseTextureCacheIdGenerator++; this.premultipliedAlpha = true; this._glTextures = []; this._dirty = []; if (!source) return; if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) { this.hasLoaded = true; this.width = this.source.width; this.height = this.source.height; PIXI.texturesToUpdate.push(this) } else { var scope = this; this.source.onload = function () { scope.hasLoaded = true; scope.width = scope.source.width; scope.height = scope.source.height; for (var i = 0; i < scope._glTextures.length; i++) scope._dirty[i] = true; scope.dispatchEvent({ type: "loaded", content: scope }) }; this.source.onerror = function () { scope.dispatchEvent({ type: "error", content: scope }) } } this.imageUrl = null; this._powerOf2 = false }; PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture; PIXI.BaseTexture.prototype.destroy = function () { if (this.imageUrl) { delete PIXI.BaseTextureCache[this.imageUrl]; delete PIXI.TextureCache[this.imageUrl]; this.imageUrl = null; this.source.src = null } else if (this.source && this.source._pixiId) delete PIXI.BaseTextureCache[this.source._pixiId]; this.source = null; PIXI.texturesToDestroy.push(this) }; PIXI.BaseTexture.prototype.updateSourceImage = function (newSrc) { this.hasLoaded = false; this.source.src = null; this.source.src = newSrc }; PIXI.BaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode) { var baseTexture = PIXI.BaseTextureCache[imageUrl]; if (crossorigin === undefined && imageUrl.indexOf("data:") === -1) crossorigin = true; if (!baseTexture) { var image = new Image; if (crossorigin) image.crossOrigin = ""; image.src = imageUrl; baseTexture = new PIXI.BaseTexture(image, scaleMode); baseTexture.imageUrl = imageUrl; PIXI.BaseTextureCache[imageUrl] = baseTexture } return baseTexture }; PIXI.BaseTexture.fromCanvas = function (canvas, scaleMode) { if (!canvas._pixiId) canvas._pixiId = "canvas_" + PIXI.TextureCacheIdGenerator++; var baseTexture = PIXI.BaseTextureCache[canvas._pixiId]; if (!baseTexture) { baseTexture = new PIXI.BaseTexture(canvas, scaleMode); PIXI.BaseTextureCache[canvas._pixiId] = baseTexture } return baseTexture }; PIXI.BaseTexture.fromBase64 = function (id, base64String, scaleMode) { var baseTexture = PIXI.BaseTextureCache[id]; if (!baseTexture) { var image = new Image; image.src = base64String; baseTexture = new PIXI.BaseTexture(image, scaleMode); baseTexture.imageUrl = id; PIXI.BaseTextureCache[id] = baseTexture } return baseTexture }; PIXI.TextureCache = {}; PIXI.FrameCache = {}; PIXI.TextureCacheIdGenerator = 0; PIXI.Texture = function (baseTexture, frame) { PIXI.EventTarget.call(this); this.noFrame = false; if (!frame) { this.noFrame = true; frame = new PIXI.Rectangle(0, 0, 1, 1) } if (baseTexture instanceof PIXI.Texture) baseTexture = baseTexture.baseTexture; this.baseTexture = baseTexture; this.frame = frame; this.trim = null; this.valid = false; this.scope = this; this._uvs = null; this.width = 0; this.height = 0; this.crop = new PIXI.Rectangle(0, 0, 1, 1); if (baseTexture.hasLoaded) { if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height); this.setFrame(frame) } else { var scope = this; baseTexture.addEventListener("loaded", function () { scope.onBaseTextureLoaded() }) } }; PIXI.Texture.prototype.constructor = PIXI.Texture; PIXI.Texture.prototype.onBaseTextureLoaded = function () { var baseTexture = this.baseTexture; baseTexture.removeEventListener("loaded", this.onLoaded); if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height); this.setFrame(this.frame); this.scope.dispatchEvent({ type: "update", content: this }) }; PIXI.Texture.prototype.destroy = function (destroyBase) { if (destroyBase) this.baseTexture.destroy(); this.valid = false }; PIXI.Texture.prototype.setFrame = function (frame) { this.noFrame = false; this.frame = frame; this.width = frame.width; this.height = frame.height; this.crop.x = frame.x; this.crop.y = frame.y; this.crop.width = frame.width; this.crop.height = frame.height; if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this); this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded; if (this.trim) { this.width = this.trim.width; this.height = this.trim.height; this.frame.width = this.trim.width; this.frame.height = this.trim.height } if (this.valid) PIXI.Texture.frameUpdates.push(this) }; PIXI.Texture.prototype._updateWebGLuvs = function () { if (!this._uvs) this._uvs = new PIXI.TextureUvs; var frame = this.crop; var tw = this.baseTexture.width; var th = this.baseTexture.height; this._uvs.x0 = frame.x / tw; this._uvs.y0 = frame.y / th; this._uvs.x1 = (frame.x + frame.width) / tw; this._uvs.y1 = frame.y / th; this._uvs.x2 = (frame.x + frame.width) / tw; this._uvs.y2 = (frame.y + frame.height) / th; this._uvs.x3 = frame.x / tw; this._uvs.y3 = (frame.y + frame.height) / th }; PIXI.Texture.fromImage = function (imageUrl, crossorigin, scaleMode) { var texture = PIXI.TextureCache[imageUrl]; if (!texture) { texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode)); PIXI.TextureCache[imageUrl] = texture } return texture }; PIXI.Texture.fromBase64 = function (id, base64String, scaleMode) { var texture = PIXI.TextureCache[id]; if (!texture) { texture = new PIXI.Texture(PIXI.BaseTexture.fromBase64(id, base64String, scaleMode)); PIXI.TextureCache[id] = texture } return texture }; PIXI.Texture.fromFrame = function (frameId) { var texture = PIXI.TextureCache[frameId]; if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache '); return texture }; PIXI.Texture.fromCanvas = function (canvas, scaleMode) { var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode); return new PIXI.Texture(baseTexture) }; PIXI.Texture.addTextureToCache = function (texture, id) { PIXI.TextureCache[id] = texture }; PIXI.Texture.removeTextureFromCache = function (id) { var texture = PIXI.TextureCache[id]; delete PIXI.TextureCache[id]; delete PIXI.BaseTextureCache[id]; return texture }; PIXI.Texture.frameUpdates = []; PIXI.TextureUvs = function () { this.x0 = 0; this.y0 = 0; this.x1 = 0; this.y1 = 0; this.x2 = 0; this.y2 = 0; this.x3 = 0; this.y3 = 0 }; PIXI.RenderTexture = function (width, height, renderer, scaleMode) { PIXI.EventTarget.call(this); this.width = width || 100; this.height = height || 100; this.frame = new PIXI.Rectangle(0, 0, this.width, this.height); this.crop = new PIXI.Rectangle(0, 0, this.width, this.height); this.baseTexture = new PIXI.BaseTexture; this.baseTexture.width = this.width; this.baseTexture.height = this.height; this.baseTexture._glTextures = []; this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT; this.baseTexture.hasLoaded = true; this.renderer = renderer || PIXI.defaultRenderer; if (this.renderer.type === PIXI.WEBGL_RENDERER) { var gl = this.renderer.gl; this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode); this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture; this.render = this.renderWebGL; this.projection = new PIXI.Point(this.width / 2, -this.height / 2) } else { this.render = this.renderCanvas; this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height); this.baseTexture.source = this.textureBuffer.canvas } this.valid = true; PIXI.Texture.frameUpdates.push(this) }; PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype); PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture; PIXI.RenderTexture.prototype.resize = function (width, height, updateBase) { if (width === this.width && height === this.height) return; this.width = this.frame.width = this.crop.width = width; this.height = this.frame.height = this.crop.height = height; if (updateBase) { this.baseTexture.width = this.width; this.baseTexture.height = this.height } if (this.renderer.type === PIXI.WEBGL_RENDERER) { this.projection.x = this.width / 2; this.projection.y = -this.height / 2 } this.textureBuffer.resize(this.width, this.height) }; PIXI.RenderTexture.prototype.clear = function () { if (this.renderer.type === PIXI.WEBGL_RENDERER) this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer); this.textureBuffer.clear() }; PIXI.RenderTexture.prototype.renderWebGL = function (displayObject, position, clear) { var gl = this.renderer.gl; gl.colorMask(true, true, true, true); gl.viewport(0, 0, this.width, this.height); gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer); if (clear) this.textureBuffer.clear(); var children = displayObject.children; var originalWorldTransform = displayObject.worldTransform; displayObject.worldTransform = PIXI.RenderTexture.tempMatrix; displayObject.worldTransform.d = -1; displayObject.worldTransform.ty = this.projection.y * -2; if (position) { displayObject.worldTransform.tx = position.x; displayObject.worldTransform.ty -= position.y } for (var i = 0, j = children.length; i < j; i++) children[i].updateTransform(); PIXI.WebGLRenderer.updateTextures(); this.renderer.spriteBatch.dirty = true; this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer); displayObject.worldTransform = originalWorldTransform; this.renderer.spriteBatch.dirty = true }; PIXI.RenderTexture.prototype.renderCanvas = function (displayObject, position, clear) { var children = displayObject.children; var originalWorldTransform = displayObject.worldTransform; displayObject.worldTransform = PIXI.RenderTexture.tempMatrix; if (position) { displayObject.worldTransform.tx = position.x; displayObject.worldTransform.ty = position.y } else { displayObject.worldTransform.tx = 0; displayObject.worldTransform.ty = 0 } for (var i = 0, j = children.length; i < j; i++) children[i].updateTransform(); if (clear) this.textureBuffer.clear(); var context = this.textureBuffer.context; this.renderer.renderDisplayObject(displayObject, context); context.setTransform(1, 0, 0, 1, 0, 0); displayObject.worldTransform = originalWorldTransform }; PIXI.RenderTexture.tempMatrix = new PIXI.Matrix; PIXI.AssetLoader = function (assetURLs, crossorigin) { PIXI.EventTarget.call(this); this.assetURLs = assetURLs; this.crossorigin = crossorigin; this.loadersByType = { "jpg": PIXI.ImageLoader, "jpeg": PIXI.ImageLoader, "png": PIXI.ImageLoader, "gif": PIXI.ImageLoader, "webp": PIXI.ImageLoader, "json": PIXI.JsonLoader, "atlas": PIXI.AtlasLoader, "anim": PIXI.SpineLoader, "xml": PIXI.BitmapFontLoader, "fnt": PIXI.BitmapFontLoader } }; PIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader; PIXI.AssetLoader.prototype._getDataType = function (str) { var test = "data:"; var start = str.slice(0, test.length).toLowerCase(); if (start === test) { var data = str.slice(test.length); var sepIdx = data.indexOf(","); if (sepIdx === -1) return null; var info = data.slice(0, sepIdx).split(";")[0]; if (!info || info.toLowerCase() === "text/plain") return "txt"; return info.split("/").pop().toLowerCase() } return null }; PIXI.AssetLoader.prototype.load = function () { var scope = this; function onLoad(evt) { scope.onAssetLoaded(evt.content) } this.loadCount = this.assetURLs.length; for (var i = 0; i < this.assetURLs.length; i++) { var fileName = this.assetURLs[i]; var fileType = this._getDataType(fileName); if (!fileType) fileType = fileName.split("?").shift().split(".").pop().toLowerCase(); var Constructor = this.loadersByType[fileType]; if (!Constructor) throw new Error(fileType + " is an unsupported file type"); var loader = new Constructor(fileName, this.crossorigin); loader.addEventListener("loaded", onLoad); loader.load() } }; PIXI.AssetLoader.prototype.onAssetLoaded = function (loader) { this.loadCount--; this.dispatchEvent({ type: "onProgress", content: this, loader: loader }); if (this.onProgress) this.onProgress(loader); if (!this.loadCount) { this.dispatchEvent({ type: "onComplete", content: this }); if (this.onComplete) this.onComplete() } }; PIXI.JsonLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.url = url; this.crossorigin = crossorigin; this.baseUrl = url.replace(/[^\/]*$/, ""); this.loaded = false }; PIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader; PIXI.JsonLoader.prototype.load = function () { var scope = this; if (window.XDomainRequest && scope.crossorigin) { this.ajaxRequest = new window.XDomainRequest; this.ajaxRequest.timeout = 3E3; this.ajaxRequest.onerror = function () { scope.onError() }; this.ajaxRequest.ontimeout = function () { scope.onError() }; this.ajaxRequest.onprogress = function () { } } else if (window.XMLHttpRequest) this.ajaxRequest = new window.XMLHttpRequest; else this.ajaxRequest = new window.ActiveXObject("Microsoft.XMLHTTP"); this.ajaxRequest.onload = function () { scope.onJSONLoaded() }; this.ajaxRequest.open("GET", this.url, true); this.ajaxRequest.send() }; PIXI.JsonLoader.prototype.onJSONLoaded = function () { if (!this.ajaxRequest.responseText) { this.onError(); return } this.json = JSON.parse(this.ajaxRequest.responseText); if (this.json.frames) { var scope = this; var textureUrl = this.baseUrl + this.json.meta.image; var image = new PIXI.ImageLoader(textureUrl, this.crossorigin); var frameData = this.json.frames; this.texture = image.texture.baseTexture; image.addEventListener("loaded", function () { scope.onLoaded() }); for (var i in frameData) { var rect = frameData[i].frame; if (rect) { PIXI.TextureCache[i] = new PIXI.Texture(this.texture, { x: rect.x, y: rect.y, width: rect.w, height: rect.h }); PIXI.TextureCache[i].crop = new PIXI.Rectangle(rect.x, rect.y, rect.w, rect.h); if (frameData[i].trimmed) { var actualSize = frameData[i].sourceSize; var realSize = frameData[i].spriteSourceSize; PIXI.TextureCache[i].trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h) } } } image.load() } else if (this.json.bones) { var spineJsonParser = new spine.SkeletonJson; var skeletonData = spineJsonParser.readSkeletonData(this.json); PIXI.AnimCache[this.url] = skeletonData; this.onLoaded() } else this.onLoaded() }; PIXI.JsonLoader.prototype.onLoaded = function () { this.loaded = true; this.dispatchEvent({ type: "loaded", content: this }) }; PIXI.JsonLoader.prototype.onError = function () { this.dispatchEvent({ type: "error", content: this }) }; PIXI.AtlasLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.url = url; this.baseUrl = url.replace(/[^\/]*$/, ""); this.crossorigin = crossorigin; this.loaded = false }; PIXI.AtlasLoader.constructor = PIXI.AtlasLoader; PIXI.AtlasLoader.prototype.load = function () { this.ajaxRequest = new PIXI.AjaxRequest; this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this); this.ajaxRequest.open("GET", this.url, true); if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType("application/json"); this.ajaxRequest.send(null) }; PIXI.AtlasLoader.prototype.onAtlasLoaded = function () { if (this.ajaxRequest.readyState === 4) if (this.ajaxRequest.status === 200 || window.location.href.indexOf("http") === -1) { this.atlas = { meta: { image: [] }, frames: [] }; var result = this.ajaxRequest.responseText.split(/\r?\n/); var lineCount = -3; var currentImageId = 0; var currentFrame = null; var nameInNextLine = false; var i = 0, j = 0, selfOnLoaded = this.onLoaded.bind(this); for (i = 0; i < result.length; i++) { result[i] = result[i].replace(/^\s+|\s+$/g, ""); if (result[i] === "") nameInNextLine = i + 1; if (result[i].length > 0) { if (nameInNextLine === i) { this.atlas.meta.image.push(result[i]); currentImageId = this.atlas.meta.image.length - 1; this.atlas.frames.push({}); lineCount = -3 } else if (lineCount > 0) if (lineCount % 7 === 1) { if (currentFrame != null) this.atlas.frames[currentImageId][currentFrame.name] = currentFrame; currentFrame = { name: result[i], frame: {} } } else { var text = result[i].split(" "); if (lineCount % 7 === 3) { currentFrame.frame.x = Number(text[1].replace(",", "")); currentFrame.frame.y = Number(text[2]) } else if (lineCount % 7 === 4) { currentFrame.frame.w = Number(text[1].replace(",", "")); currentFrame.frame.h = Number(text[2]) } else if (lineCount % 7 === 5) { var realSize = { x: 0, y: 0, w: Number(text[1].replace(",", "")), h: Number(text[2]) }; if (realSize.w > currentFrame.frame.w || realSize.h > currentFrame.frame.h) { currentFrame.trimmed = true; currentFrame.realSize = realSize } else currentFrame.trimmed = false } } lineCount++ } } if (currentFrame != null) this.atlas.frames[currentImageId][currentFrame.name] = currentFrame; if (this.atlas.meta.image.length > 0) { this.images = []; for (j = 0; j < this.atlas.meta.image.length; j++) { var textureUrl = this.baseUrl + this.atlas.meta.image[j]; var frameData = this.atlas.frames[j]; this.images.push(new PIXI.ImageLoader(textureUrl, this.crossorigin)); for (i in frameData) { var rect = frameData[i].frame; if (rect) { PIXI.TextureCache[i] = new PIXI.Texture(this.images[j].texture.baseTexture, { x: rect.x, y: rect.y, width: rect.w, height: rect.h }); if (frameData[i].trimmed) { PIXI.TextureCache[i].realSize = frameData[i].realSize; PIXI.TextureCache[i].trim.x = 0; PIXI.TextureCache[i].trim.y = 0 } } } } this.currentImageId = 0; for (j = 0; j < this.images.length; j++) this.images[j].addEventListener("loaded", selfOnLoaded); this.images[this.currentImageId].load() } else this.onLoaded() } else this.onError() }; PIXI.AtlasLoader.prototype.onLoaded = function () { if (this.images.length - 1 > this.currentImageId) { this.currentImageId++; this.images[this.currentImageId].load() } else { this.loaded = true; this.dispatchEvent({ type: "loaded", content: this }) } }; PIXI.AtlasLoader.prototype.onError = function () { this.dispatchEvent({ type: "error", content: this }) }; PIXI.SpriteSheetLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.url = url; this.crossorigin = crossorigin; this.baseUrl = url.replace(/[^\/]*$/, ""); this.texture = null; this.frames = {} }; PIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader; PIXI.SpriteSheetLoader.prototype.load = function () { var scope = this; var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin); jsonLoader.addEventListener("loaded", function (event) { scope.json = event.content.json; scope.onLoaded() }); jsonLoader.load() }; PIXI.SpriteSheetLoader.prototype.onLoaded = function () { this.dispatchEvent({ type: "loaded", content: this }) }; PIXI.ImageLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.texture = PIXI.Texture.fromImage(url, crossorigin); this.frames = [] }; PIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader; PIXI.ImageLoader.prototype.load = function () { if (!this.texture.baseTexture.hasLoaded) { var scope = this; this.texture.baseTexture.addEventListener("loaded", function () { scope.onLoaded() }) } else this.onLoaded() }; PIXI.ImageLoader.prototype.onLoaded = function () { this.dispatchEvent({ type: "loaded", content: this }) }; PIXI.ImageLoader.prototype.loadFramedSpriteSheet = function (frameWidth, frameHeight, textureName) { this.frames = []; var cols = Math.floor(this.texture.width / frameWidth); var rows = Math.floor(this.texture.height / frameHeight); var i = 0; for (var y = 0; y < rows; y++) for (var x = 0; x < cols; x++, i++) { var texture = new PIXI.Texture(this.texture, { x: x * frameWidth, y: y * frameHeight, width: frameWidth, height: frameHeight }); this.frames.push(texture); if (textureName) PIXI.TextureCache[textureName + "-" + i] = texture } if (!this.texture.baseTexture.hasLoaded) { var scope = this; this.texture.baseTexture.addEventListener("loaded", function () { scope.onLoaded() }) } else this.onLoaded() }; PIXI.BitmapFontLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.url = url; this.crossorigin = crossorigin; this.baseUrl = url.replace(/[^\/]*$/, ""); this.texture = null }; PIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader; PIXI.BitmapFontLoader.prototype.load = function () { this.ajaxRequest = new PIXI.AjaxRequest; var scope = this; this.ajaxRequest.onreadystatechange = function () { scope.onXMLLoaded() }; this.ajaxRequest.open("GET", this.url, true); if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType("application/xml"); this.ajaxRequest.send(null) }; PIXI.BitmapFontLoader.prototype.onXMLLoaded = function () { if (this.ajaxRequest.readyState === 4) if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf("http") === -1) { var responseXML = this.ajaxRequest.responseXML; if (!responseXML || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) if (typeof window.DOMParser === "function") { var domparser = new DOMParser; responseXML = domparser.parseFromString(this.ajaxRequest.responseText, "text/xml") } else { var div = document.createElement("div"); div.innerHTML = this.ajaxRequest.responseText; responseXML = div } this.parseXML(responseXML) } }; PIXI.BitmapFontLoader.prototype.parseXML = function (responseXML) { var textureUrl = this.baseUrl + responseXML.getElementsByTagName("page")[0].getAttribute("file"); textureUrl = textureUrl.trim(); var image = new PIXI.ImageLoader(textureUrl, this.crossorigin); this.texture = image.texture.baseTexture; var data = {}; var info = responseXML.getElementsByTagName("info")[0]; var common = responseXML.getElementsByTagName("common")[0]; data.font = info.getAttribute("face"); data.size = parseInt(info.getAttribute("size"), 10); data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10); data.chars = {}; var letters = responseXML.getElementsByTagName("char"); for (var i = 0; i < letters.length; i++) { var charCode = parseInt(letters[i].getAttribute("id"), 10); var textureRect = new PIXI.Rectangle(parseInt(letters[i].getAttribute("x"), 10), parseInt(letters[i].getAttribute("y"), 10), parseInt(letters[i].getAttribute("width"), 10), parseInt(letters[i].getAttribute("height"), 10)); data.chars[charCode] = { xOffset: parseInt(letters[i].getAttribute("xoffset"), 10), yOffset: parseInt(letters[i].getAttribute("yoffset"), 10), xAdvance: parseInt(letters[i].getAttribute("xadvance"), 10), kerning: {}, texture: PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect) } } var kernings = responseXML.getElementsByTagName("kerning"); for (i = 0; i < kernings.length; i++) { var first = parseInt(kernings[i].getAttribute("first"), 10); var second = parseInt(kernings[i].getAttribute("second"), 10); var amount = parseInt(kernings[i].getAttribute("amount"), 10); data.chars[second].kerning[first] = amount } PIXI.BitmapText.fonts[data.font] = data; var scope = this; image.addEventListener("loaded", function () { scope.onLoaded() }); image.load() }; PIXI.BitmapFontLoader.prototype.onLoaded = function () { this.dispatchEvent({ type: "loaded", content: this }) }; PIXI.SpineLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.url = url; this.crossorigin = crossorigin; this.loaded = false }; PIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader; PIXI.SpineLoader.prototype.load = function () { var scope = this; var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin); jsonLoader.addEventListener("loaded", function (event) { scope.json = event.content.json; scope.onLoaded() }); jsonLoader.load() }; PIXI.SpineLoader.prototype.onLoaded = function () { this.loaded = true; this.dispatchEvent({ type: "loaded", content: this }) }; PIXI.AbstractFilter = function (fragmentSrc, uniforms) { this.passes = [this]; this.shaders = []; this.dirty = true; this.padding = 0; this.uniforms = uniforms || {}; this.fragmentSrc = fragmentSrc || [] }; PIXI.AlphaMaskFilter = function (texture) { PIXI.AbstractFilter.call(this); this.passes = [this]; texture.baseTexture._powerOf2 = true; this.uniforms = { mask: { type: "sampler2D", value: texture }, mapDimensions: { type: "2f", value: { x: 1, y: 5112 } }, dimensions: { type: "4fv", value: [0, 0, 0, 0] } }; if (texture.baseTexture.hasLoaded) { this.uniforms.mask.value.x = texture.width; this.uniforms.mask.value.y = texture.height } else { this.boundLoadedFunction = this.onTextureLoaded.bind(this); texture.baseTexture.on("loaded", this.boundLoadedFunction) } this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D mask;", "uniform sampler2D uSampler;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   mapCords *= dimensions.xy / mapDimensions;", "   vec4 original =  texture2D(uSampler, vTextureCoord);", "   float maskAlpha =  texture2D(mask, mapCords).r;", "   original *= maskAlpha;", "   gl_FragColor =  original;", "}"] }; PIXI.AlphaMaskFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.AlphaMaskFilter.prototype.constructor = PIXI.AlphaMaskFilter; PIXI.AlphaMaskFilter.prototype.onTextureLoaded = function () { this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width; this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height; this.uniforms.mask.value.baseTexture.off("loaded", this.boundLoadedFunction) }; Object.defineProperty(PIXI.AlphaMaskFilter.prototype, "map", { get: function () { return this.uniforms.mask.value }, set: function (value) { this.uniforms.mask.value = value } }); PIXI.ColorMatrixFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { matrix: { type: "mat4", value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform mat4 matrix;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;", "}"] }; PIXI.ColorMatrixFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.ColorMatrixFilter.prototype.constructor = PIXI.ColorMatrixFilter; Object.defineProperty(PIXI.ColorMatrixFilter.prototype, "matrix", { get: function () { return this.uniforms.matrix.value }, set: function (value) { this.uniforms.matrix.value = value } }); PIXI.GrayFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { gray: { type: "1f", value: 1 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float gray;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);", "}"] }; PIXI.GrayFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.GrayFilter.prototype.constructor = PIXI.GrayFilter; Object.defineProperty(PIXI.GrayFilter.prototype, "gray", { get: function () { return this.uniforms.gray.value }, set: function (value) { this.uniforms.gray.value = value } }); PIXI.DisplacementFilter = function (texture) { PIXI.AbstractFilter.call(this); this.passes = [this]; texture.baseTexture._powerOf2 = true; this.uniforms = { displacementMap: { type: "sampler2D", value: texture }, scale: { type: "2f", value: { x: 30, y: 30 } }, offset: { type: "2f", value: { x: 0, y: 0 } }, mapDimensions: { type: "2f", value: { x: 1, y: 5112 } }, dimensions: { type: "4fv", value: [0, 0, 0, 0] } }; if (texture.baseTexture.hasLoaded) { this.uniforms.mapDimensions.value.x = texture.width; this.uniforms.mapDimensions.value.y = texture.height } else { this.boundLoadedFunction = this.onTextureLoaded.bind(this); texture.baseTexture.on("loaded", this.boundLoadedFunction) } this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D displacementMap;", "uniform sampler2D uSampler;", "uniform vec2 scale;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   vec2 matSample = texture2D(displacementMap, mapCords).xy;", "   matSample -= 0.5;", "   matSample *= scale;", "   matSample /= mapDimensions;", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));", "   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);", "   vec2 cord = vTextureCoord;", "}"] }; PIXI.DisplacementFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.DisplacementFilter.prototype.constructor = PIXI.DisplacementFilter; PIXI.DisplacementFilter.prototype.onTextureLoaded = function () { this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width; this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height; this.uniforms.displacementMap.value.baseTexture.off("loaded", this.boundLoadedFunction) }; Object.defineProperty(PIXI.DisplacementFilter.prototype, "map", { get: function () { return this.uniforms.displacementMap.value }, set: function (value) { this.uniforms.displacementMap.value = value } }); Object.defineProperty(PIXI.DisplacementFilter.prototype, "scale", { get: function () { return this.uniforms.scale.value }, set: function (value) { this.uniforms.scale.value = value } }); Object.defineProperty(PIXI.DisplacementFilter.prototype, "offset", { get: function () { return this.uniforms.offset.value }, set: function (value) { this.uniforms.offset.value = value } }); PIXI.PixelateFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { invert: { type: "1f", value: 0 }, dimensions: { type: "4fv", value: new Float32Array([1E4, 100, 10, 10]) }, pixelSize: { type: "2f", value: { x: 10, y: 10 } } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 testDim;", "uniform vec4 dimensions;", "uniform vec2 pixelSize;", "uniform sampler2D uSampler;", "void main(void) {", "   vec2 coord = vTextureCoord;", "   vec2 size = dimensions.xy/pixelSize;", "   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;", "   gl_FragColor = texture2D(uSampler, color);", "}"] }; PIXI.PixelateFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.PixelateFilter.prototype.constructor = PIXI.PixelateFilter; Object.defineProperty(PIXI.PixelateFilter.prototype, "size", { get: function () { return this.uniforms.pixelSize.value }, set: function (value) { this.dirty = true; this.uniforms.pixelSize.value = value } }); PIXI.BlurXFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { blur: { type: "1f", value: 1 / 512 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;", "   gl_FragColor = sum;", "}"] }; PIXI.BlurXFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.BlurXFilter.prototype.constructor = PIXI.BlurXFilter; Object.defineProperty(PIXI.BlurXFilter.prototype, "blur", { get: function () { return this.uniforms.blur.value / (1 / 7E3) }, set: function (value) { this.dirty = true; this.uniforms.blur.value = 1 / 7E3 * value } }); PIXI.BlurYFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { blur: { type: "1f", value: 1 / 512 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;", "   gl_FragColor = sum;", "}"] }; PIXI.BlurYFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.BlurYFilter.prototype.constructor = PIXI.BlurYFilter; Object.defineProperty(PIXI.BlurYFilter.prototype, "blur", { get: function () { return this.uniforms.blur.value / (1 / 7E3) }, set: function (value) { this.uniforms.blur.value = 1 / 7E3 * value } }); PIXI.BlurFilter = function () { this.blurXFilter = new PIXI.BlurXFilter; this.blurYFilter = new PIXI.BlurYFilter; this.passes = [this.blurXFilter, this.blurYFilter] }; Object.defineProperty(PIXI.BlurFilter.prototype, "blur", { get: function () { return this.blurXFilter.blur }, set: function (value) { this.blurXFilter.blur = this.blurYFilter.blur = value } }); Object.defineProperty(PIXI.BlurFilter.prototype, "blurX", { get: function () { return this.blurXFilter.blur }, set: function (value) { this.blurXFilter.blur = value } }); Object.defineProperty(PIXI.BlurFilter.prototype, "blurY", { get: function () { return this.blurYFilter.blur }, set: function (value) { this.blurYFilter.blur = value } }); PIXI.InvertFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { invert: { type: "1f", value: 1 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);", "}"] }; PIXI.InvertFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.InvertFilter.prototype.constructor = PIXI.InvertFilter; Object.defineProperty(PIXI.InvertFilter.prototype, "invert", { get: function () { return this.uniforms.invert.value }, set: function (value) { this.uniforms.invert.value = value } }); PIXI.SepiaFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { sepia: { type: "1f", value: 1 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float sepia;", "uniform sampler2D uSampler;", "const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);", "}"] }; PIXI.SepiaFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.SepiaFilter.prototype.constructor = PIXI.SepiaFilter; Object.defineProperty(PIXI.SepiaFilter.prototype, "sepia", { get: function () { return this.uniforms.sepia.value }, set: function (value) { this.uniforms.sepia.value = value } }); PIXI.TwistFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { radius: { type: "1f", value: 0.5 }, angle: { type: "1f", value: 5 }, offset: { type: "2f", value: { x: 0.5, y: 0.5 } } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "uniform float radius;", "uniform float angle;", "uniform vec2 offset;", "void main(void) {", "   vec2 coord = vTextureCoord - offset;", "   float distance = length(coord);", "   if (distance < radius) {", "       float ratio = (radius - distance) / radius;", "       float angleMod = ratio * ratio * angle;", "       float s = sin(angleMod);", "       float c = cos(angleMod);", "       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);", "   }", "   gl_FragColor = texture2D(uSampler, coord+offset);", "}"] }; PIXI.TwistFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.TwistFilter.prototype.constructor = PIXI.TwistFilter; Object.defineProperty(PIXI.TwistFilter.prototype, "offset", { get: function () { return this.uniforms.offset.value }, set: function (value) { this.dirty = true; this.uniforms.offset.value = value } }); Object.defineProperty(PIXI.TwistFilter.prototype, "radius", { get: function () { return this.uniforms.radius.value }, set: function (value) { this.dirty = true; this.uniforms.radius.value = value } }); Object.defineProperty(PIXI.TwistFilter.prototype, "angle", { get: function () { return this.uniforms.angle.value }, set: function (value) { this.dirty = true; this.uniforms.angle.value = value } }); PIXI.ColorStepFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { step: { type: "1f", value: 5 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float step;", "void main(void) {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   color = floor(color * step) / step;", "   gl_FragColor = color;", "}"] }; PIXI.ColorStepFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.ColorStepFilter.prototype.constructor = PIXI.ColorStepFilter; Object.defineProperty(PIXI.ColorStepFilter.prototype, "step", { get: function () { return this.uniforms.step.value }, set: function (value) { this.uniforms.step.value = value } }); PIXI.DotScreenFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { scale: { type: "1f", value: 1 }, angle: { type: "1f", value: 5 }, dimensions: { type: "4fv", value: [0, 0, 0, 0] } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "uniform float angle;", "uniform float scale;", "float pattern() {", "   float s = sin(angle), c = cos(angle);", "   vec2 tex = vTextureCoord * dimensions.xy;", "   vec2 point = vec2(", "       c * tex.x - s * tex.y,", "       s * tex.x + c * tex.y", "   ) * scale;", "   return (sin(point.x) * sin(point.y)) * 4.0;", "}", "void main() {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   float average = (color.r + color.g + color.b) / 3.0;", "   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);", "}"] }; PIXI.DotScreenFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.DotScreenFilter.prototype.constructor = PIXI.DotScreenFilter; Object.defineProperty(PIXI.DotScreenFilter.prototype, "scale", { get: function () { return this.uniforms.scale.value }, set: function (value) { this.dirty = true; this.uniforms.scale.value = value } }); Object.defineProperty(PIXI.DotScreenFilter.prototype, "angle", { get: function () { return this.uniforms.angle.value }, set: function (value) { this.dirty = true; this.uniforms.angle.value = value } }); PIXI.CrossHatchFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { blur: { type: "1f", value: 1 / 512 } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);", "    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);", "    if (lum < 1.00) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.75) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.50) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.3) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "}"] }; PIXI.CrossHatchFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.CrossHatchFilter.prototype.constructor = PIXI.BlurYFilter; Object.defineProperty(PIXI.CrossHatchFilter.prototype, "blur", { get: function () { return this.uniforms.blur.value / (1 / 7E3) }, set: function (value) { this.uniforms.blur.value = 1 / 7E3 * value } }); PIXI.RGBSplitFilter = function () { PIXI.AbstractFilter.call(this); this.passes = [this]; this.uniforms = { red: { type: "2f", value: { x: 20, y: 20 } }, green: { type: "2f", value: { x: -20, y: 20 } }, blue: { type: "2f", value: { x: 20, y: -20 } }, dimensions: { type: "4fv", value: [0, 0, 0, 0] } }; this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 red;", "uniform vec2 green;", "uniform vec2 blue;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;", "   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;", "   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;", "   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;", "}"] }; PIXI.RGBSplitFilter.prototype = Object.create(PIXI.AbstractFilter.prototype); PIXI.RGBSplitFilter.prototype.constructor = PIXI.RGBSplitFilter; Object.defineProperty(PIXI.RGBSplitFilter.prototype, "angle", { get: function () { return this.uniforms.blur.value / (1 / 7E3) }, set: function (value) { this.uniforms.blur.value = 1 / 7E3 * value } }); if (typeof exports !== "undefined") { if (typeof module !== "undefined" && module.exports) exports = module.exports = PIXI; exports.PIXI = PIXI } else if (typeof define !== "undefined" && define.amd) define(PIXI); else root.PIXI = PIXI }).call(this); var __extends = this.__extends || function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() { this.constructor = d } __.prototype = b.prototype; d.prototype = new __ }; var dragonBones; (function (dragonBones) { (function (geom) { var Point = function () { function Point(x, y) { if (typeof x === "undefined") x = 0; if (typeof y === "undefined") y = 0; this.x = x; this.y = y } Point.prototype.toString = function () { return "[Point (x=" + this.x + " y=" + this.y + ")]" }; return Point }(); geom.Point = Point; var Rectangle = function () { function Rectangle(x, y, width, height) { if (typeof x === "undefined") x = 0; if (typeof y === "undefined") y = 0; if (typeof width === "undefined") width = 0; if (typeof height === "undefined") height = 0; this.x = x; this.y = y; this.width = width; this.height = height } return Rectangle }(); geom.Rectangle = Rectangle; var Matrix = function () { function Matrix() { this.a = 1; this.b = 0; this.c = 0; this.d = 1; this.tx = 0; this.ty = 0 } Matrix.prototype.invert = function () { var a1 = this.a; var b1 = this.b; var c1 = this.c; var d1 = this.d; var tx1 = this.tx; var n = a1 * d1 - b1 * c1; this.a = d1 / n; this.b = -b1 / n; this.c = -c1 / n; this.d = a1 / n; this.tx = (c1 * this.ty - d1 * tx1) / n; this.ty = -(a1 * this.ty - b1 * tx1) / n }; return Matrix }(); geom.Matrix = Matrix; var ColorTransform = function () { function ColorTransform() { this.alphaMultiplier = 0; this.alphaOffset = 0; this.blueMultiplier = 0; this.blueOffset = 0; this.greenMultiplier = 0; this.greenOffset = 0; this.redMultiplier = 0; this.redOffset = 0 } return ColorTransform }(); geom.ColorTransform = ColorTransform })(dragonBones.geom || (dragonBones.geom = {})); var geom = dragonBones.geom; (function (events) { var Event = function () { function Event(type) { this.type = type } return Event }(); events.Event = Event; var AnimationEvent = function (_super) { __extends(AnimationEvent, _super); function AnimationEvent(type) { _super.call(this, type) }; AnimationEvent.FADE_IN = "fadeIn"; AnimationEvent.FADE_OUT = "fadeOut"; AnimationEvent.START = "start"; AnimationEvent.COMPLETE = "complete"; AnimationEvent.LOOP_COMPLETE = "loopComplete"; AnimationEvent.FADE_IN_COMPLETE = "fadeInComplete"; AnimationEvent.FADE_OUT_COMPLETE = "fadeOutComplete"; return AnimationEvent }(Event); events.AnimationEvent = AnimationEvent; var ArmatureEvent = function (_super) { __extends(ArmatureEvent, _super); function ArmatureEvent(type) { _super.call(this, type) } ArmatureEvent.Z_ORDER_UPDATED = "zOrderUpdated"; return ArmatureEvent }(Event); events.ArmatureEvent = ArmatureEvent; var FrameEvent = function (_super) { __extends(FrameEvent, _super); function FrameEvent(type) { _super.call(this, type) } FrameEvent.ANIMATION_FRAME_EVENT = "animationFrameEvent"; FrameEvent.BONE_FRAME_EVENT = "boneFrameEvent"; return FrameEvent }(Event); events.FrameEvent = FrameEvent; var EventDispatcher = function () { function EventDispatcher() { } EventDispatcher.prototype.hasEventListener = function (type) { if (this._listenersMap && this._listenersMap[type]) return true; return false }; EventDispatcher.prototype.addEventListener = function (type, listener) { if (type && listener) { if (!this._listenersMap) this._listenersMap = {}; var listeners = this._listenersMap[type]; if (listeners) this.removeEventListener(type, listener); if (listeners) listeners.push(listener); else this._listenersMap[type] = [listener] } }; EventDispatcher.prototype.removeEventListener = function (type, listener) { if (!this._listenersMap || !type || !listener) return; var listeners = this._listenersMap[type]; if (listeners) { var length = listeners.length; for (var i = 0; i < length; i++) if (listeners[i] == listener) if (length == 1) { listeners.length = 0; delete this._listenersMap[type] } else listeners.splice(i, 1) } }; EventDispatcher.prototype.removeAllEventListeners = function (type) { if (type) delete this._listenersMap[type]; else this._listenersMap = null }; EventDispatcher.prototype.dispatchEvent = function (event) { if (event) { var listeners = this._listenersMap[event.type]; if (listeners) { event.target = this; var listenersCopy = listeners.concat(); var length = listeners.length; for (var i = 0; i < length; i++) listenersCopy[i](event) } } }; return EventDispatcher }(); events.EventDispatcher = EventDispatcher })(dragonBones.events || (dragonBones.events = {})); var events = dragonBones.events; (function (animation) { var WorldClock = function () { function WorldClock() { this.timeScale = 1; this.time = (new Date).getTime() * 0.001; this._animatableList = [] } WorldClock.prototype.contains = function (animatable) { return this._animatableList.indexOf(animatable) >= 0 }; WorldClock.prototype.add = function (animatable) { if (animatable && this._animatableList.indexOf(animatable) == -1) this._animatableList.push(animatable) }; WorldClock.prototype.remove = function (animatable) { var index = this._animatableList.indexOf(animatable); if (index >= 0) this._animatableList[index] = null }; WorldClock.prototype.clear = function () { this._animatableList.length = 0 }; WorldClock.prototype.advanceTime = function (passedTime) { if (passedTime < 0) { var currentTime = getTimer() * 0.001; passedTime = currentTime - this.time; this.time = currentTime } passedTime *= this.timeScale; var length = this._animatableList.length; if (length == 0) return; var currentIndex = 0; for (var i = 0; i < length; i++) { var animatable = this._animatableList[i]; if (animatable) { if (currentIndex != i) { this._animatableList[currentIndex] = animatable; this._animatableList[i] = null } animatable.advanceTime(passedTime); currentIndex++ } } if (currentIndex != i) { length = this._animatableList.length; while (i < length) this._animatableList[currentIndex++] = this._animatableList[i++]; this._animatableList.length = currentIndex } }; WorldClock.clock = new WorldClock; return WorldClock }(); animation.WorldClock = WorldClock; var TimelineState = function () { function TimelineState() { this.transform = new objects.DBTransform; this.pivot = new geom.Point; this._durationTransform = new objects.DBTransform; this._durationPivot = new geom.Point; this._durationColor = new geom.ColorTransform } TimelineState._borrowObject = function () { if (TimelineState._pool.length == 0) return new TimelineState; return TimelineState._pool.pop() }; TimelineState._returnObject = function (timeline) { if (TimelineState._pool.indexOf(timeline) < 0) TimelineState._pool[TimelineState._pool.length] = timeline; timeline.clear() }; TimelineState._clear = function () { var i = TimelineState._pool.length; while (i--) TimelineState._pool[i].clear(); TimelineState._pool.length = 0 }; TimelineState.getEaseValue = function (value, easing) { if (easing > 1) { var valueEase = 0.5 * (1 - Math.cos(value * Math.PI)) - value; easing -= 1 } else if (easing > 0) valueEase = Math.sin(value * TimelineState.HALF_PI) - value; else if (easing < 0) { valueEase = 1 - Math.cos(value * TimelineState.HALF_PI) - value; easing *= -1 } return valueEase * easing + value }; TimelineState.prototype.fadeIn = function (bone, animationState, timeline) { this._bone = bone; this._animationState = animationState; this._timeline = timeline; this._originTransform = this._timeline.originTransform; this._originPivot = this._timeline.originPivot; this._tweenTransform = false; this._tweenColor = false; this._totalTime = this._animationState.totalTime; this.transform.x = 0; this.transform.y = 0; this.transform.scaleX = 0; this.transform.scaleY = 0; this.transform.skewX = 0; this.transform.skewY = 0; this.pivot.x = 0; this.pivot.y = 0; this._durationTransform.x = 0; this._durationTransform.y = 0; this._durationTransform.scaleX = 0; this._durationTransform.scaleY = 0; this._durationTransform.skewX = 0; this._durationTransform.skewY = 0; this._durationPivot.x = 0; this._durationPivot.y = 0; this._currentFrame = null; switch (this._timeline.getFrameList().length) { case 0: this._bone._arriveAtFrame(null, this, this._animationState, false); this._updateState = 0; break; case 1: this._updateState = -1; break; default: this._updateState = 1; break } }; TimelineState.prototype.fadeOut = function () { this.transform.skewX = utils.TransformUtil.formatRadian(this.transform.skewX); this.transform.skewY = utils.TransformUtil.formatRadian(this.transform.skewY) }; TimelineState.prototype.update = function (progress) { if (this._updateState) if (this._updateState > 0) { if (this._timeline.scale == 0) progress = 1; else progress /= this._timeline.scale; if (progress == 1) progress = 0.99999999; progress += this._timeline.offset; var loopCount = Math.floor(progress); progress -= loopCount; var playedTime = this._totalTime * progress; var isArrivedFrame = false; var frameIndex; while (!this._currentFrame || playedTime > this._currentFramePosition + this._currentFrameDuration || playedTime < this._currentFramePosition) { if (isArrivedFrame) this._bone._arriveAtFrame(this._currentFrame, this, this._animationState, true); isArrivedFrame = true; if (this._currentFrame) { frameIndex = this._timeline.getFrameList().indexOf(this._currentFrame) + 1; if (frameIndex >= this._timeline.getFrameList().length) frameIndex = 0; this._currentFrame = this._timeline.getFrameList()[frameIndex] } else { frameIndex = 0; this._currentFrame = this._timeline.getFrameList()[0] } this._currentFrameDuration = this._currentFrame.duration; this._currentFramePosition = this._currentFrame.position } if (isArrivedFrame) { this.tweenActive = this._currentFrame.displayIndex >= 0; frameIndex++; if (frameIndex >= this._timeline.getFrameList().length) frameIndex = 0; var nextFrame = this._timeline.getFrameList()[frameIndex]; if (frameIndex == 0 && this._animationState.loop && this._animationState.loopCount >= Math.abs(this._animationState.loop) - 1 && ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + loopCount - this._timeline.offset) * this._timeline.scale > 0.99999999) { this._updateState = 0; this._tweenEasing = NaN } else if (this._currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0 || !this._animationState.tweenEnabled) this._tweenEasing = NaN; else if (isNaN(this._animationState.clip.tweenEasing)) this._tweenEasing = this._currentFrame.tweenEasing; else this._tweenEasing = this._animationState.clip.tweenEasing; if (isNaN(this._tweenEasing)) { this._tweenTransform = false; this._tweenColor = false } else { this._durationTransform.x = nextFrame.transform.x - this._currentFrame.transform.x; this._durationTransform.y = nextFrame.transform.y - this._currentFrame.transform.y; this._durationTransform.skewX = nextFrame.transform.skewX - this._currentFrame.transform.skewX; this._durationTransform.skewY = nextFrame.transform.skewY - this._currentFrame.transform.skewY; this._durationTransform.scaleX = nextFrame.transform.scaleX - this._currentFrame.transform.scaleX; this._durationTransform.scaleY = nextFrame.transform.scaleY - this._currentFrame.transform.scaleY; if (frameIndex == 0) { this._durationTransform.skewX = utils.TransformUtil.formatRadian(this._durationTransform.skewX); this._durationTransform.skewY = utils.TransformUtil.formatRadian(this._durationTransform.skewY) } this._durationPivot.x = nextFrame.pivot.x - this._currentFrame.pivot.x; this._durationPivot.y = nextFrame.pivot.y - this._currentFrame.pivot.y; if (this._durationTransform.x != 0 || this._durationTransform.y != 0 || this._durationTransform.skewX != 0 || this._durationTransform.skewY != 0 || this._durationTransform.scaleX != 0 || this._durationTransform.scaleY != 0 || this._durationPivot.x != 0 || this._durationPivot.y != 0) this._tweenTransform = true; else this._tweenTransform = false; if (this._currentFrame.color && nextFrame.color) { this._durationColor.alphaOffset = nextFrame.color.alphaOffset - this._currentFrame.color.alphaOffset; this._durationColor.redOffset = nextFrame.color.redOffset - this._currentFrame.color.redOffset; this._durationColor.greenOffset = nextFrame.color.greenOffset - this._currentFrame.color.greenOffset; this._durationColor.blueOffset = nextFrame.color.blueOffset - this._currentFrame.color.blueOffset; this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - this._currentFrame.color.alphaMultiplier; this._durationColor.redMultiplier = nextFrame.color.redMultiplier - this._currentFrame.color.redMultiplier; this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - this._currentFrame.color.greenMultiplier; this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - this._currentFrame.color.blueMultiplier; if (this._durationColor.alphaOffset != 0 || this._durationColor.redOffset != 0 || this._durationColor.greenOffset != 0 || this._durationColor.blueOffset != 0 || this._durationColor.alphaMultiplier != 0 || this._durationColor.redMultiplier != 0 || this._durationColor.greenMultiplier != 0 || this._durationColor.blueMultiplier != 0) this._tweenColor = true; else this._tweenColor = false } else if (this._currentFrame.color) { this._tweenColor = true; this._durationColor.alphaOffset = -this._currentFrame.color.alphaOffset; this._durationColor.redOffset = -this._currentFrame.color.redOffset; this._durationColor.greenOffset = -this._currentFrame.color.greenOffset; this._durationColor.blueOffset = -this._currentFrame.color.blueOffset; this._durationColor.alphaMultiplier = 1 - this._currentFrame.color.alphaMultiplier; this._durationColor.redMultiplier = 1 - this._currentFrame.color.redMultiplier; this._durationColor.greenMultiplier = 1 - this._currentFrame.color.greenMultiplier; this._durationColor.blueMultiplier = 1 - this._currentFrame.color.blueMultiplier } else if (nextFrame.color) { this._tweenColor = true; this._durationColor.alphaOffset = nextFrame.color.alphaOffset; this._durationColor.redOffset = nextFrame.color.redOffset; this._durationColor.greenOffset = nextFrame.color.greenOffset; this._durationColor.blueOffset = nextFrame.color.blueOffset; this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - 1; this._durationColor.redMultiplier = nextFrame.color.redMultiplier - 1; this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - 1; this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - 1 } else this._tweenColor = false } if (!this._tweenTransform) if (this._animationState.blend) { this.transform.x = this._originTransform.x + this._currentFrame.transform.x; this.transform.y = this._originTransform.y + this._currentFrame.transform.y; this.transform.skewX = this._originTransform.skewX + this._currentFrame.transform.skewX; this.transform.skewY = this._originTransform.skewY + this._currentFrame.transform.skewY; this.transform.scaleX = this._originTransform.scaleX + this._currentFrame.transform.scaleX; this.transform.scaleY = this._originTransform.scaleY + this._currentFrame.transform.scaleY; this.pivot.x = this._originPivot.x + this._currentFrame.pivot.x; this.pivot.y = this._originPivot.y + this._currentFrame.pivot.y } else { this.transform.x = this._currentFrame.transform.x; this.transform.y = this._currentFrame.transform.y; this.transform.skewX = this._currentFrame.transform.skewX; this.transform.skewY = this._currentFrame.transform.skewY; this.transform.scaleX = this._currentFrame.transform.scaleX; this.transform.scaleY = this._currentFrame.transform.scaleY; this.pivot.x = this._currentFrame.pivot.x; this.pivot.y = this._currentFrame.pivot.y } if (!this._tweenColor) if (this._currentFrame.color) this._bone._updateColor(this._currentFrame.color.alphaOffset, this._currentFrame.color.redOffset, this._currentFrame.color.greenOffset, this._currentFrame.color.blueOffset, this._currentFrame.color.alphaMultiplier, this._currentFrame.color.redMultiplier, this._currentFrame.color.greenMultiplier, this._currentFrame.color.blueMultiplier, true); else if (this._bone._isColorChanged) this._bone._updateColor(0, 0, 0, 0, 1, 1, 1, 1, false); this._bone._arriveAtFrame(this._currentFrame, this, this._animationState, false) } if (this._tweenTransform || this._tweenColor) { progress = (playedTime - this._currentFramePosition) / this._currentFrameDuration; if (this._tweenEasing) progress = TimelineState.getEaseValue(progress, this._tweenEasing) } if (this._tweenTransform) { var currentTransform = this._currentFrame.transform; var currentPivot = this._currentFrame.pivot; if (this._animationState.blend) { this.transform.x = this._originTransform.x + currentTransform.x + this._durationTransform.x * progress; this.transform.y = this._originTransform.y + currentTransform.y + this._durationTransform.y * progress; this.transform.skewX = this._originTransform.skewX + currentTransform.skewX + this._durationTransform.skewX * progress; this.transform.skewY = this._originTransform.skewY + currentTransform.skewY + this._durationTransform.skewY * progress; this.transform.scaleX = this._originTransform.scaleX + currentTransform.scaleX + this._durationTransform.scaleX * progress; this.transform.scaleY = this._originTransform.scaleY + currentTransform.scaleY + this._durationTransform.scaleY * progress; this.pivot.x = this._originPivot.x + currentPivot.x + this._durationPivot.x * progress; this.pivot.y = this._originPivot.y + currentPivot.y + this._durationPivot.y * progress } else { this.transform.x = currentTransform.x + this._durationTransform.x * progress; this.transform.y = currentTransform.y + this._durationTransform.y * progress; this.transform.skewX = currentTransform.skewX + this._durationTransform.skewX * progress; this.transform.skewY = currentTransform.skewY + this._durationTransform.skewY * progress; this.transform.scaleX = currentTransform.scaleX + this._durationTransform.scaleX * progress; this.transform.scaleY = currentTransform.scaleY + this._durationTransform.scaleY * progress; this.pivot.x = currentPivot.x + this._durationPivot.x * progress; this.pivot.y = currentPivot.y + this._durationPivot.y * progress } } if (this._tweenColor) if (this._currentFrame.color) this._bone._updateColor(this._currentFrame.color.alphaOffset + this._durationColor.alphaOffset * progress, this._currentFrame.color.redOffset + this._durationColor.redOffset * progress, this._currentFrame.color.greenOffset + this._durationColor.greenOffset * progress, this._currentFrame.color.blueOffset + this._durationColor.blueOffset * progress, this._currentFrame.color.alphaMultiplier + this._durationColor.alphaMultiplier * progress, this._currentFrame.color.redMultiplier + this._durationColor.redMultiplier * progress, this._currentFrame.color.greenMultiplier + this._durationColor.greenMultiplier * progress, this._currentFrame.color.blueMultiplier + this._durationColor.blueMultiplier * progress, true); else this._bone._updateColor(this._durationColor.alphaOffset * progress, this._durationColor.redOffset * progress, this._durationColor.greenOffset * progress, this._durationColor.blueOffset * progress, 1 + this._durationColor.alphaMultiplier * progress, 1 + this._durationColor.redMultiplier * progress, 1 + this._durationColor.greenMultiplier * progress, 1 + this._durationColor.blueMultiplier * progress, true) } else { this._updateState = 0; if (this._animationState.blend) { this.transform.copy(this._originTransform); this.pivot.x = this._originPivot.x; this.pivot.y = this._originPivot.y } else { this.transform.x = this.transform.y = this.transform.skewX = this.transform.skewY = this.transform.scaleX = this.transform.scaleY = 0; this.pivot.x = 0; this.pivot.y = 0 } this._currentFrame = this._timeline.getFrameList()[0]; this.tweenActive = this._currentFrame.displayIndex >= 0; if (this._currentFrame.color) this._bone._updateColor(this._currentFrame.color.alphaOffset, this._currentFrame.color.redOffset, this._currentFrame.color.greenOffset, this._currentFrame.color.blueOffset, this._currentFrame.color.alphaMultiplier, this._currentFrame.color.redMultiplier, this._currentFrame.color.greenMultiplier, this._currentFrame.color.blueMultiplier, true); else this._bone._updateColor(0, 0, 0, 0, 1, 1, 1, 1, false); this._bone._arriveAtFrame(this._currentFrame, this, this._animationState, false) } }; TimelineState.prototype.clear = function () { this._updateState = 0; this._bone = null; this._animationState = null; this._timeline = null; this._currentFrame = null; this._originTransform = null; this._originPivot = null }; TimelineState.HALF_PI = Math.PI * 0.5; TimelineState._pool = []; return TimelineState }(); animation.TimelineState = TimelineState; var AnimationState = function () { function AnimationState() { this.loop = 0; this.layer = 0; this._timelineStates = {} } AnimationState._borrowObject = function () { if (AnimationState._pool.length == 0) return new AnimationState; return AnimationState._pool.pop() }; AnimationState._returnObject = function (animationState) { if (AnimationState._pool.indexOf(animationState) < 0) AnimationState._pool[AnimationState._pool.length] = animationState; animationState.clear() }; AnimationState._clear = function () { var i = AnimationState._pool.length; while (i--) AnimationState._pool[i].clear(); AnimationState._pool.length = 0 }; AnimationState.prototype.fadeIn = function (armature, clip, fadeInTime, timeScale, loop, layer, displayControl, pauseBeforeFadeInComplete) { this.layer = layer; this.clip = clip; this.name = this.clip.name; this.totalTime = this.clip.duration; this._armature = armature; if (Math.round(this.clip.duration * this.clip.frameRate) < 2 || timeScale == Infinity) { this.timeScale = 1; this.currentTime = this.totalTime; if (this.loop >= 0) this.loop = 1; else this.loop = -1 } else { this.timeScale = timeScale; this.currentTime = 0; this.loop = loop } this._pauseBeforeFadeInComplete = pauseBeforeFadeInComplete; this._fadeInTime = fadeInTime * this.timeScale; this._fadeState = 1; this._fadeOutBeginTime = 0; this._fadeOutWeight = -1; this._fadeWeight = 0; this._fadeIn = true; this._fadeOut = false; this.loopCount = -1; this.displayControl = displayControl; this.isPlaying = true; this.isComplete = false; this.weight = 1; this.blend = true; this.enabled = true; this.tweenEnabled = true; this.updateTimelineStates() }; AnimationState.prototype.fadeOut = function (fadeOutTime, pause) { if (typeof pause === "undefined") pause = false; if (!this._armature || this._fadeOutWeight >= 0) return; this._fadeState = -1; this._fadeOutWeight = this._fadeWeight; this._fadeOutTime = fadeOutTime * this.timeScale; this._fadeOutBeginTime = this.currentTime; this._fadeOut = true; this.isPlaying = !pause; this.displayControl = false; for (var index in this._timelineStates) this._timelineStates[index].fadeOut(); this.enabled = true }; AnimationState.prototype.play = function () { this.isPlaying = true }; AnimationState.prototype.stop = function () { this.isPlaying = false }; AnimationState.prototype.getMixingTransform = function (timelineName) { if (this._mixingTransforms) return Number(this._mixingTransforms[timelineName]); return -1 }; AnimationState.prototype.addMixingTransform = function (timelineName, type, recursive) { if (typeof type === "undefined") type = 2; if (typeof recursive === "undefined") recursive = true; if (this.clip && this.clip.getTimeline(timelineName)) { if (!this._mixingTransforms) this._mixingTransforms = {}; if (recursive) { var i = this._armature._boneList.length; var bone; var currentBone; while (i--) { bone = this._armature._boneList[i]; if (bone.name == timelineName) currentBone = bone; if (currentBone && (currentBone == bone || currentBone.contains(bone))) this._mixingTransforms[bone.name] = type } } else this._mixingTransforms[timelineName] = type; this.updateTimelineStates() } else throw new Error; }; AnimationState.prototype.removeMixingTransform = function (timelineName, recursive) { if (typeof timelineName === "undefined") timelineName = null; if (typeof recursive === "undefined") recursive = true; if (timelineName) { if (recursive) { var i = this._armature._boneList.length; var bone; var currentBone; while (i--) { bone = this._armature._boneList[i]; if (bone.name == timelineName) currentBone = bone; if (currentBone && (currentBone == bone || currentBone.contains(bone))) delete this._mixingTransforms[bone.name] } } else delete this._mixingTransforms[timelineName]; for (var index in this._mixingTransforms) { var hasMixing = true; break } if (!hasMixing) this._mixingTransforms = null } else this._mixingTransforms = null; this.updateTimelineStates() }; AnimationState.prototype.advanceTime = function (passedTime) { if (!this.enabled) return false; var event; var isComplete; if (this._fadeIn) { this._fadeIn = false; if (this._armature.hasEventListener(events.AnimationEvent.FADE_IN)) { event = new events.AnimationEvent(events.AnimationEvent.FADE_IN); event.animationState = this; this._armature._eventList.push(event) } } if (this._fadeOut) { this._fadeOut = false; if (this._armature.hasEventListener(events.AnimationEvent.FADE_OUT)) { event = new events.AnimationEvent(events.AnimationEvent.FADE_OUT); event.animationState = this; this._armature._eventList.push(event) } } this.currentTime += passedTime * this.timeScale; if (this.isPlaying && !this.isComplete) { var progress; var currentLoopCount; if (this._pauseBeforeFadeInComplete) { this._pauseBeforeFadeInComplete = false; this.isPlaying = false; progress = 0; currentLoopCount = Math.floor(progress) } else { progress = this.currentTime / this.totalTime; currentLoopCount = Math.floor(progress); if (currentLoopCount != this.loopCount) { if (this.loopCount == -1) if (this._armature.hasEventListener(events.AnimationEvent.START)) { event = new events.AnimationEvent(events.AnimationEvent.START); event.animationState = this; this._armature._eventList.push(event) } this.loopCount = currentLoopCount; if (this.loopCount) if (this.loop && this.loopCount * this.loopCount >= this.loop * this.loop - 1) { isComplete = true; progress = 1; currentLoopCount = 0; if (this._armature.hasEventListener(events.AnimationEvent.COMPLETE)) { event = new events.AnimationEvent(events.AnimationEvent.COMPLETE); event.animationState = this; this._armature._eventList.push(event) } } else if (this._armature.hasEventListener(events.AnimationEvent.LOOP_COMPLETE)) { event = new events.AnimationEvent(events.AnimationEvent.LOOP_COMPLETE); event.animationState = this; this._armature._eventList.push(event) } } } for (var index in this._timelineStates) this._timelineStates[index].update(progress); var frameList = this.clip.getFrameList(); if (frameList.length > 0) { var playedTime = this.totalTime * (progress - currentLoopCount); var isArrivedFrame = false; var frameIndex; while (!this._currentFrame || playedTime > this._currentFrame.position + this._currentFrame.duration || playedTime < this._currentFrame.position) { if (isArrivedFrame) this._armature._arriveAtFrame(this._currentFrame, null, this, true); isArrivedFrame = true; if (this._currentFrame) { frameIndex = frameList.indexOf(this._currentFrame); frameIndex++; if (frameIndex >= frameList.length) frameIndex = 0; this._currentFrame = frameList[frameIndex] } else this._currentFrame = frameList[0] } if (isArrivedFrame) this._armature._arriveAtFrame(this._currentFrame, null, this, false) } } if (this._fadeState > 0) if (this._fadeInTime == 0) { this._fadeWeight = 1; this._fadeState = 0; this.isPlaying = true; if (this._armature.hasEventListener(events.AnimationEvent.FADE_IN_COMPLETE)) { event = new events.AnimationEvent(events.AnimationEvent.FADE_IN_COMPLETE); event.animationState = this; this._armature._eventList.push(event) } } else { this._fadeWeight = this.currentTime / this._fadeInTime; if (this._fadeWeight >= 1) { this._fadeWeight = 1; this._fadeState = 0; if (!this.isPlaying) this.currentTime -= this._fadeInTime; this.isPlaying = true; if (this._armature.hasEventListener(events.AnimationEvent.FADE_IN_COMPLETE)) { event = new events.AnimationEvent(events.AnimationEvent.FADE_IN_COMPLETE); event.animationState = this; this._armature._eventList.push(event) } } } else if (this._fadeState < 0) if (this._fadeOutTime == 0) { this._fadeWeight = 0; this._fadeState = 0; if (this._armature.hasEventListener(events.AnimationEvent.FADE_OUT_COMPLETE)) { event = new events.AnimationEvent(events.AnimationEvent.FADE_OUT_COMPLETE); event.animationState = this; this._armature._eventList.push(event) } return true } else { this._fadeWeight = (1 - (this.currentTime - this._fadeOutBeginTime) / this._fadeOutTime) * this._fadeOutWeight; if (this._fadeWeight <= 0) { this._fadeWeight = 0; this._fadeState = 0; if (this._armature.hasEventListener(events.AnimationEvent.FADE_OUT_COMPLETE)) { event = new events.AnimationEvent(events.AnimationEvent.FADE_OUT_COMPLETE); event.animationState = this; this._armature._eventList.push(event) } return true } } if (isComplete) { this.isComplete = true; if (this.loop < 0) this.fadeOut((this._fadeOutWeight || this._fadeInTime) / this.timeScale, true) } return false }; AnimationState.prototype.updateTimelineStates = function () { if (this._mixingTransforms) { for (var timelineName in this._timelineStates) if (this._mixingTransforms[timelineName] == null) this.removeTimelineState(timelineName); for (timelineName in this._mixingTransforms) if (!this._timelineStates[timelineName]) this.addTimelineState(timelineName) } else for (timelineName in this.clip.getTimelines()) if (!this._timelineStates[timelineName]) this.addTimelineState(timelineName) }; AnimationState.prototype.addTimelineState = function (timelineName) { var bone = this._armature.getBone(timelineName); if (bone) { var timelineState = TimelineState._borrowObject(); var timeline = this.clip.getTimeline(timelineName); timelineState.fadeIn(bone, this, timeline); this._timelineStates[timelineName] = timelineState } }; AnimationState.prototype.removeTimelineState = function (timelineName) { TimelineState._returnObject(this._timelineStates[timelineName]); delete this._timelineStates[timelineName] }; AnimationState.prototype.clear = function () { this.clip = null; this.enabled = false; this._armature = null; this._currentFrame = null; this._mixingTransforms = null; for (var timelineName in this._timelineStates) this.removeTimelineState(timelineName) }; AnimationState._pool = []; return AnimationState }(); animation.AnimationState = AnimationState; var Animation = function () { function Animation(armature) { this._armature = armature; this._animationLayer = []; this._isPlaying = false; this.animationNameList = []; this.tweenEnabled = true; this.timeScale = 1 } Animation.prototype.getLastAnimationName = function () { return this._lastAnimationState ? this._lastAnimationState.name : null }; Animation.prototype.getLastAnimationState = function () { return this._lastAnimationState }; Animation.prototype.getAnimationDataList = function () { return this._animationDataList }; Animation.prototype.setAnimationDataList = function (value) { this._animationDataList = value; this.animationNameList.length = 0; for (var index in this._animationDataList) this.animationNameList[this.animationNameList.length] = this._animationDataList[index].name }; Animation.prototype.getIsPlaying = function () { return this._isPlaying && !this.getIsComplete() }; Animation.prototype.getIsComplete = function () { if (this._lastAnimationState) { if (!this._lastAnimationState.isComplete) return false; var j = this._animationLayer.length; while (j--) { var animationStateList = this._animationLayer[j]; var i = animationStateList.length; while (i--) if (!animationStateList[i].isComplete) return false } return true } return false }; Animation.prototype.dispose = function () { if (!this._armature) return; this.stop(); var i = this._animationLayer.length; while (i--) { var animationStateList = this._animationLayer[i]; var j = animationStateList.length; while (j--) AnimationState._returnObject(animationStateList[j]); animationStateList.length = 0 } this._animationLayer.length = 0; this.animationNameList.length = 0; this._armature = null; this._animationLayer = null; this._animationDataList = null; this.animationNameList = null }; Animation.prototype.gotoAndPlay = function (animationName, fadeInTime, duration, loop, layer, group, fadeOutMode, displayControl, pauseFadeOut, pauseFadeIn) { if (typeof fadeInTime === "undefined") fadeInTime = -1; if (typeof duration === "undefined") duration = -1; if (typeof loop === "undefined") loop = NaN; if (typeof layer === "undefined") layer = 0; if (typeof group === "undefined") group = null; if (typeof fadeOutMode === "undefined") fadeOutMode = Animation.SAME_LAYER_AND_GROUP; if (typeof displayControl === "undefined") displayControl = true; if (typeof pauseFadeOut === "undefined") pauseFadeOut = true; if (typeof pauseFadeIn === "undefined") pauseFadeIn = true; if (!this._animationDataList) return null; var i = this._animationDataList.length; var animationData; while (i--) if (this._animationDataList[i].name == animationName) { animationData = this._animationDataList[i]; break } if (!animationData) return null; this._isPlaying = true; fadeInTime = fadeInTime < 0 ? animationData.fadeInTime < 0 ? 0.3 : animationData.fadeInTime : fadeInTime; var durationScale; if (duration < 0) durationScale = animationData.scale < 0 ? 1 : animationData.scale; else durationScale = duration / animationData.duration; loop = isNaN(loop) ? animationData.loop : loop; layer = this.addLayer(layer); var animationState; var animationStateList; switch (fadeOutMode) { case Animation.NONE: break; case Animation.SAME_LAYER: animationStateList = this._animationLayer[layer]; i = animationStateList.length; while (i--) { animationState = animationStateList[i]; animationState.fadeOut(fadeInTime, pauseFadeOut) } break; case Animation.SAME_GROUP: j = this._animationLayer.length; while (j--) { animationStateList = this._animationLayer[j]; i = animationStateList.length; while (i--) { animationState = animationStateList[i]; if (animationState.group == group) animationState.fadeOut(fadeInTime, pauseFadeOut) } } break; case Animation.ALL: var j = this._animationLayer.length; while (j--) { animationStateList = this._animationLayer[j]; i = animationStateList.length; while (i--) { animationState = animationStateList[i]; animationState.fadeOut(fadeInTime, pauseFadeOut) } } break; case Animation.SAME_LAYER_AND_GROUP: default: animationStateList = this._animationLayer[layer]; i = animationStateList.length; while (i--) { animationState = animationStateList[i]; if (animationState.group == group) animationState.fadeOut(fadeInTime, pauseFadeOut) } break } this._lastAnimationState = AnimationState._borrowObject(); this._lastAnimationState.group = group; this._lastAnimationState.tweenEnabled = this.tweenEnabled; this._lastAnimationState.fadeIn(this._armature, animationData, fadeInTime, 1 / durationScale, loop, layer, displayControl, pauseFadeIn); this.addState(this._lastAnimationState); var slotList = this._armature._slotList; var slot; var childArmature; i = slotList.length; while (i--) { slot = slotList[i]; childArmature = slot.getChildArmature(); if (childArmature) childArmature.animation.gotoAndPlay(animationName, fadeInTime) } return this._lastAnimationState }; Animation.prototype.play = function () { if (!this._animationDataList || this._animationDataList.length == 0) return; if (!this._lastAnimationState) this.gotoAndPlay(this._animationDataList[0].name); else if (!this._isPlaying) this._isPlaying = true; else this.gotoAndPlay(this._lastAnimationState.name) }; Animation.prototype.stop = function () { this._isPlaying = false }; Animation.prototype.getState = function (name, layer) { if (typeof layer === "undefined") layer = 0; var l = this._animationLayer.length; if (l == 0) return null; else if (layer >= l) layer = l - 1; var animationStateList = this._animationLayer[layer]; if (!animationStateList) return null; var i = animationStateList.length; while (i--) if (animationStateList[i].name == name) return animationStateList[i]; return null }; Animation.prototype.hasAnimation = function (animationName) { var i = this._animationDataList.length; while (i--) if (this._animationDataList[i].name == animationName) return true; return false }; Animation.prototype.advanceTime = function (passedTime) { if (!this._isPlaying) return; passedTime *= this.timeScale; var l = this._armature._boneList.length; var i; var j; var k = l; var stateListLength; var bone; var boneName; var weigthLeft; var x; var y; var skewX; var skewY; var scaleX; var scaleY; var pivotX; var pivotY; var layerTotalWeight; var animationStateList; var animationState; var timelineState; var weight; var transform; var pivot; l--; while (k--) { bone = this._armature._boneList[k]; boneName = bone.name; weigthLeft = 1; x = 0; y = 0; skewX = 0; skewY = 0; scaleX = 0; scaleY = 0; pivotX = 0; pivotY = 0; i = this._animationLayer.length; while (i--) { layerTotalWeight = 0; animationStateList = this._animationLayer[i]; stateListLength = animationStateList.length; for (j = 0; j < stateListLength; j++) { animationState = animationStateList[j]; if (k == l) if (animationState.advanceTime(passedTime)) { this.removeState(animationState); j--; stateListLength--; continue } timelineState = animationState._timelineStates[boneName]; if (timelineState && timelineState.tweenActive) { weight = animationState._fadeWeight * animationState.weight * weigthLeft; transform = timelineState.transform; pivot = timelineState.pivot; x += transform.x * weight; y += transform.y * weight; skewX += transform.skewX * weight; skewY += transform.skewY * weight; scaleX += transform.scaleX * weight; scaleY += transform.scaleY * weight; pivotX += pivot.x * weight; pivotY += pivot.y * weight; layerTotalWeight += weight } } if (layerTotalWeight >= weigthLeft) break; else weigthLeft -= layerTotalWeight } transform = bone.tween; pivot = bone._tweenPivot; transform.x = x; transform.y = y; transform.skewX = skewX; transform.skewY = skewY; transform.scaleX = scaleX; transform.scaleY = scaleY; pivot.x = pivotX; pivot.y = pivotY } }; Animation.prototype.addLayer = function (layer) { if (layer >= this._animationLayer.length) { layer = this._animationLayer.length; this._animationLayer[layer] = [] } return layer }; Animation.prototype.addState = function (animationState) { var animationStateList = this._animationLayer[animationState.layer]; animationStateList.push(animationState) }; Animation.prototype.removeState = function (animationState) { var layer = animationState.layer; var animationStateList = this._animationLayer[layer]; animationStateList.splice(animationStateList.indexOf(animationState), 1); AnimationState._returnObject(animationState); if (animationStateList.length == 0 && layer == this._animationLayer.length - 1) this._animationLayer.length-- }; Animation.NONE = "none"; Animation.SAME_LAYER = "sameLayer"; Animation.SAME_GROUP = "sameGroup"; Animation.SAME_LAYER_AND_GROUP = "sameLayerAndGroup"; Animation.ALL = "all"; return Animation }(); animation.Animation = Animation })(dragonBones.animation || (dragonBones.animation = {})); var animation = dragonBones.animation; (function (objects) { var DBTransform = function () { function DBTransform() { var instance = DBTransform.pool.shift(); if (instance) return instance; this.x = 0; this.y = 0; this.skewX = 0; this.skewY = 0; this.scaleX = 1; this.scaleY = 1 } DBTransform.pool = []; DBTransform.prototype.getRotation = function () { return this.skewX }; DBTransform.prototype.setRotation = function (value) { this.skewX = this.skewY = value }; DBTransform.prototype.copy = function (transform) { this.x = transform.x; this.y = transform.y; this.skewX = transform.skewX; this.skewY = transform.skewY; this.scaleX = transform.scaleX; this.scaleY = transform.scaleY }; DBTransform.prototype.dispose = function () { DBTransform.pool.push(this); this.x = 0; this.y = 0; this.skewX = 0; this.skewY = 0; this.scaleX = 1; this.scaleY = 1 }; DBTransform.prototype.toString = function () { return "[DBTransform (x=" + this.x + " y=" + this.y + " skewX=" + this.skewX + " skewY=" + this.skewY + " scaleX=" + this.scaleX + " scaleY=" + this.scaleY + ")]" }; return DBTransform }(); objects.DBTransform = DBTransform; var Frame = function () { function Frame() { this.position = 0; this.duration = 0 } Frame.prototype.dispose = function () { }; return Frame }(); objects.Frame = Frame; var TransformFrame = function (_super) { __extends(TransformFrame, _super); function TransformFrame() { _super.call(this); this.tweenEasing = 0; this.tweenRotate = 0; this.displayIndex = 0; this.zOrder = NaN; this.visible = true; this.global = new DBTransform; this.transform = new DBTransform; this.pivot = new geom.Point } TransformFrame.prototype.dispose = function () { _super.prototype.dispose.call(this); this.global = null; this.transform = null; this.pivot = null; this.color = null }; return TransformFrame }(Frame); objects.TransformFrame = TransformFrame; var Timeline = function () { function Timeline() { this._frameList = []; this.duration = 0; this.scale = 1 } Timeline.prototype.getFrameList = function () { return this._frameList }; Timeline.prototype.dispose = function () { var i = this._frameList.length; while (i--) this._frameList[i].dispose(); this._frameList.length = 0; this._frameList = null }; Timeline.prototype.addFrame = function (frame) { if (!frame) throw new Error; if (this._frameList.indexOf(frame) < 0) this._frameList[this._frameList.length] = frame; else throw new Error; }; return Timeline }(); objects.Timeline = Timeline; var TransformTimeline = function (_super) { __extends(TransformTimeline, _super); function TransformTimeline() { _super.call(this); this.originTransform = new DBTransform; this.originPivot = new geom.Point; this.offset = 0; this.transformed = false } TransformTimeline.prototype.dispose = function () { if (this == TransformTimeline.HIDE_TIMELINE) return; _super.prototype.dispose.call(this); this.originTransform = null; this.originPivot = null }; TransformTimeline.HIDE_TIMELINE = new TransformTimeline; return TransformTimeline }(Timeline); objects.TransformTimeline = TransformTimeline; var AnimationData = function (_super) { __extends(AnimationData, _super); function AnimationData() { _super.call(this); this.frameRate = 0; this.loop = 0; this.tweenEasing = NaN; this.fadeInTime = 0; this._timelines = {} } AnimationData.prototype.getTimelines = function () { return this._timelines }; AnimationData.prototype.dispose = function () { _super.prototype.dispose.call(this); for (var timelineName in this._timelines) this._timelines[timelineName].dispose(); this._timelines = null }; AnimationData.prototype.getTimeline = function (timelineName) { return this._timelines[timelineName] }; AnimationData.prototype.addTimeline = function (timeline, timelineName) { if (!timeline) throw new Error; this._timelines[timelineName] = timeline }; return AnimationData }(Timeline); objects.AnimationData = AnimationData; var DisplayData = function () { function DisplayData() { this.transform = new DBTransform } DisplayData.prototype.dispose = function () { this.transform = null; this.pivot = null }; DisplayData.ARMATURE = "armature"; DisplayData.IMAGE = "image"; return DisplayData }(); objects.DisplayData = DisplayData; var SlotData = function () { function SlotData() { this._displayDataList = []; this.zOrder = 0; this.blendMode = "normal" } SlotData.prototype.getDisplayDataList = function () { return this._displayDataList }; SlotData.prototype.dispose = function () { var i = this._displayDataList.length; while (i--) this._displayDataList[i].dispose(); this._displayDataList.length = 0; this._displayDataList = null }; SlotData.prototype.addDisplayData = function (displayData) { if (!displayData) throw new Error; if (this._displayDataList.indexOf(displayData) < 0) this._displayDataList[this._displayDataList.length] = displayData; else throw new Error; }; SlotData.prototype.getDisplayData = function (displayName) { var i = this._displayDataList.length; while (i--) if (this._displayDataList[i].name == displayName) return this._displayDataList[i]; return null }; return SlotData }(); objects.SlotData = SlotData; var BoneData = function () { function BoneData() { this.length = 0; this.global = new DBTransform; this.transform = new DBTransform } BoneData.prototype.dispose = function () { this.global = null; this.transform = null }; return BoneData }(); objects.BoneData = BoneData; var SkinData = function () { function SkinData() { this._slotDataList = [] } SkinData.prototype.getSlotDataList = function () { return this._slotDataList }; SkinData.prototype.dispose = function () { var i = this._slotDataList.length; while (i--) this._slotDataList[i].dispose(); this._slotDataList.length = 0; this._slotDataList = null }; SkinData.prototype.getSlotData = function (slotName) { var i = this._slotDataList.length; while (i--) if (this._slotDataList[i].name == slotName) return this._slotDataList[i]; return null }; SkinData.prototype.addSlotData = function (slotData) { if (!slotData) throw new Error; if (this._slotDataList.indexOf(slotData) < 0) this._slotDataList[this._slotDataList.length] = slotData; else throw new Error; }; return SkinData }(); objects.SkinData = SkinData; var ArmatureData = function () { function ArmatureData() { this._boneDataList = []; this._skinDataList = []; this._animationDataList = [] } ArmatureData.prototype.getBoneDataList = function () { return this._boneDataList }; ArmatureData.prototype.getSkinDataList = function () { return this._skinDataList }; ArmatureData.prototype.getAnimationDataList = function () { return this._animationDataList }; ArmatureData.prototype.dispose = function () { var i = this._boneDataList.length; while (i--) this._boneDataList[i].dispose(); i = this._skinDataList.length; while (i--) this._skinDataList[i].dispose(); i = this._animationDataList.length; while (i--) this._animationDataList[i].dispose(); this._boneDataList.length = 0; this._skinDataList.length = 0; this._animationDataList.length = 0; this._boneDataList = null; this._skinDataList = null; this._animationDataList = null }; ArmatureData.prototype.getBoneData = function (boneName) { var i = this._boneDataList.length; while (i--) if (this._boneDataList[i].name == boneName) return this._boneDataList[i]; return null }; ArmatureData.prototype.getSkinData = function (skinName) { if (!skinName) return this._skinDataList[0]; var i = this._skinDataList.length; while (i--) if (this._skinDataList[i].name == skinName) return this._skinDataList[i]; return null }; ArmatureData.prototype.getAnimationData = function (animationName) { var i = this._animationDataList.length; while (i--) if (this._animationDataList[i].name == animationName) return this._animationDataList[i]; return null }; ArmatureData.prototype.addBoneData = function (boneData) { if (!boneData) throw new Error; if (this._boneDataList.indexOf(boneData) < 0) this._boneDataList[this._boneDataList.length] = boneData; else throw new Error; }; ArmatureData.prototype.addSkinData = function (skinData) { if (!skinData) throw new Error; if (this._skinDataList.indexOf(skinData) < 0) this._skinDataList[this._skinDataList.length] = skinData; else throw new Error; }; ArmatureData.prototype.addAnimationData = function (animationData) { if (!animationData) throw new Error; if (this._animationDataList.indexOf(animationData) < 0) this._animationDataList[this._animationDataList.length] = animationData }; ArmatureData.prototype.sortBoneDataList = function () { var i = this._boneDataList.length; if (i == 0) return; var helpArray = []; while (i--) { var boneData = this._boneDataList[i]; var level = 0; var parentData = boneData; while (parentData && parentData.parent) { level++; parentData = this.getBoneData(parentData.parent) } helpArray[i] = { level: level, boneData: boneData } } helpArray.sort(this.sortBoneData); i = helpArray.length; while (i--) this._boneDataList[i] = helpArray[i].boneData }; ArmatureData.prototype.sortBoneData = function (object1, object2) { return object1.level > object2.level ? 1 : -1 }; return ArmatureData }(); objects.ArmatureData = ArmatureData; var SkeletonData = function () { function SkeletonData() { this._armatureDataList = []; this._subTexturePivots = {} } SkeletonData.prototype.getArmatureNames = function () { var nameList = []; for (var armatureDataIndex in this._armatureDataList) nameList[nameList.length] = this._armatureDataList[armatureDataIndex].name; return nameList }; SkeletonData.prototype.getArmatureDataList = function () { return this._armatureDataList }; SkeletonData.prototype.dispose = function () { for (var armatureDataIndex in this._armatureDataList) this._armatureDataList[armatureDataIndex].dispose(); this._armatureDataList.length = 0; this._armatureDataList = null; this._subTexturePivots = null }; SkeletonData.prototype.getArmatureData = function (armatureName) { var i = this._armatureDataList.length; while (i--) if (this._armatureDataList[i].name == armatureName) return this._armatureDataList[i]; return null }; SkeletonData.prototype.addArmatureData = function (armatureData) { if (!armatureData) throw new Error; if (this._armatureDataList.indexOf(armatureData) < 0) this._armatureDataList[this._armatureDataList.length] = armatureData; else throw new Error; }; SkeletonData.prototype.removeArmatureData = function (armatureData) { var index = this._armatureDataList.indexOf(armatureData); if (index >= 0) this._armatureDataList.splice(index, 1) }; SkeletonData.prototype.removeArmatureDataByName = function (armatureName) { var i = this._armatureDataList.length; while (i--) if (this._armatureDataList[i].name == armatureName) this._armatureDataList.splice(i, 1) }; SkeletonData.prototype.getSubTexturePivot = function (subTextureName) { return this._subTexturePivots[subTextureName] }; SkeletonData.prototype.addSubTexturePivot = function (x, y, subTextureName) { var point = this._subTexturePivots[subTextureName]; if (point) { point.x = x; point.y = y } else this._subTexturePivots[subTextureName] = point = new geom.Point(x, y); return point }; SkeletonData.prototype.removeSubTexturePivot = function (subTextureName) { if (subTextureName) delete this._subTexturePivots[subTextureName]; else for (subTextureName in this._subTexturePivots) delete this._subTexturePivots[subTextureName] }; return SkeletonData }(); objects.SkeletonData = SkeletonData; var DataParser = function () { function DataParser() { } DataParser.parseTextureAtlasData = function (rawData, scale) { if (typeof scale === "undefined") scale = 1; if (!rawData) throw new Error; var textureAtlasData = {}; textureAtlasData.__name = rawData[utils.ConstValues.A_NAME]; var subTextureList = rawData[utils.ConstValues.SUB_TEXTURE]; for (var index in subTextureList) { var subTextureObject = subTextureList[index]; var subTextureName = subTextureObject[utils.ConstValues.A_NAME]; var subTextureData = new geom.Rectangle(Number(subTextureObject[utils.ConstValues.A_X]) / scale, Number(subTextureObject[utils.ConstValues.A_Y]) / scale, Number(subTextureObject[utils.ConstValues.A_WIDTH]) / scale, Number(subTextureObject[utils.ConstValues.A_HEIGHT]) / scale); textureAtlasData[subTextureName] = subTextureData } return textureAtlasData }; DataParser.parseSkeletonData = function (rawData) { if (!rawData) throw new Error; var frameRate = Number(rawData[utils.ConstValues.A_FRAME_RATE]); var data = new SkeletonData; data.name = rawData[utils.ConstValues.A_NAME]; var armatureObjectList = rawData[utils.ConstValues.ARMATURE]; for (var index in armatureObjectList) { var armatureObject = armatureObjectList[index]; data.addArmatureData(DataParser.parseArmatureData(armatureObject, data, frameRate)) } return data }; DataParser.parseArmatureData = function (armatureObject, data, frameRate) { var armatureData = new ArmatureData; armatureData.name = armatureObject[utils.ConstValues.A_NAME]; var boneObjectList = armatureObject[utils.ConstValues.BONE]; for (var index in boneObjectList) { var boneObject = boneObjectList[index]; armatureData.addBoneData(DataParser.parseBoneData(boneObject)) } var skinObjectList = armatureObject[utils.ConstValues.SKIN]; for (var index in skinObjectList) { var skinObject = skinObjectList[index]; armatureData.addSkinData(DataParser.parseSkinData(skinObject, data)) } utils.DBDataUtil.transformArmatureData(armatureData); armatureData.sortBoneDataList(); var animationObjectList = armatureObject[utils.ConstValues.ANIMATION]; for (var index in animationObjectList) { var animationObject = animationObjectList[index]; armatureData.addAnimationData(DataParser.parseAnimationData(animationObject, armatureData, frameRate)) } return armatureData }; DataParser.parseBoneData = function (boneObject) { var boneData = new BoneData; boneData.name = boneObject[utils.ConstValues.A_NAME]; boneData.parent = boneObject[utils.ConstValues.A_PARENT]; boneData.length = Number(boneObject[utils.ConstValues.A_LENGTH]) || 0; DataParser.parseTransform(boneObject[utils.ConstValues.TRANSFORM], boneData.global); boneData.transform.copy(boneData.global); return boneData }; DataParser.parseSkinData = function (skinObject, data) { var skinData = new SkinData; skinData.name = skinObject[utils.ConstValues.A_NAME]; var slotObjectList = skinObject[utils.ConstValues.SLOT]; for (var index in slotObjectList) { var slotObject = slotObjectList[index]; skinData.addSlotData(DataParser.parseSlotData(slotObject, data)) } return skinData }; DataParser.parseSlotData = function (slotObject, data) { var slotData = new SlotData; slotData.name = slotObject[utils.ConstValues.A_NAME]; slotData.parent = slotObject[utils.ConstValues.A_PARENT]; slotData.zOrder = Number(slotObject[utils.ConstValues.A_Z_ORDER]); slotData.blendMode = slotObject[utils.ConstValues.A_BLENDMODE]; if (!slotData.blendMode) slotData.blendMode = "normal"; var displayObjectList = slotObject[utils.ConstValues.DISPLAY]; for (var index in displayObjectList) { var displayObject = displayObjectList[index]; slotData.addDisplayData(DataParser.parseDisplayData(displayObject, data)) } return slotData }; DataParser.parseDisplayData = function (displayObject, data) { var displayData = new DisplayData; displayData.name = displayObject[utils.ConstValues.A_NAME]; displayData.type = displayObject[utils.ConstValues.A_TYPE]; displayData.pivot = data.addSubTexturePivot(0, 0, displayData.name); DataParser.parseTransform(displayObject[utils.ConstValues.TRANSFORM], displayData.transform, displayData.pivot); return displayData }; DataParser.parseAnimationData = function (animationObject, armatureData, frameRate) { var animationData = new AnimationData; animationData.name = animationObject[utils.ConstValues.A_NAME]; animationData.frameRate = frameRate; animationData.loop = Number(animationObject[utils.ConstValues.A_LOOP]) || 0; animationData.fadeInTime = Number(animationObject[utils.ConstValues.A_FADE_IN_TIME]); animationData.duration = Number(animationObject[utils.ConstValues.A_DURATION]) / frameRate; animationData.scale = Number(animationObject[utils.ConstValues.A_SCALE]); if (animationObject.hasOwnProperty(utils.ConstValues.A_TWEEN_EASING)) { var tweenEase = animationObject[utils.ConstValues.A_TWEEN_EASING]; if (tweenEase == undefined || tweenEase == null) animationData.tweenEasing = NaN; else animationData.tweenEasing = Number(tweenEase) } else animationData.tweenEasing = NaN; DataParser.parseTimeline(animationObject, animationData, DataParser.parseMainFrame, frameRate); var timeline; var timelineName; var timelineObjectList = animationObject[utils.ConstValues.TIMELINE]; for (var index in timelineObjectList) { var timelineObject = timelineObjectList[index]; timeline = DataParser.parseTransformTimeline(timelineObject, animationData.duration, frameRate); timelineName = timelineObject[utils.ConstValues.A_NAME]; animationData.addTimeline(timeline, timelineName) } utils.DBDataUtil.addHideTimeline(animationData, armatureData); utils.DBDataUtil.transformAnimationData(animationData, armatureData); return animationData }; DataParser.parseTimeline = function (timelineObject, timeline, frameParser, frameRate) { var position = 0; var frame; var frameObjectList = timelineObject[utils.ConstValues.FRAME]; for (var index in frameObjectList) { var frameObject = frameObjectList[index]; frame = frameParser(frameObject, frameRate); frame.position = position; timeline.addFrame(frame); position += frame.duration } if (frame) frame.duration = timeline.duration - frame.position }; DataParser.parseTransformTimeline = function (timelineObject, duration, frameRate) { var timeline = new TransformTimeline; timeline.duration = duration; DataParser.parseTimeline(timelineObject, timeline, DataParser.parseTransformFrame, frameRate); timeline.scale = Number(timelineObject[utils.ConstValues.A_SCALE]); timeline.offset = Number(timelineObject[utils.ConstValues.A_OFFSET]); return timeline }; DataParser.parseFrame = function (frameObject, frame, frameRate) { frame.duration = Number(frameObject[utils.ConstValues.A_DURATION]) / frameRate; frame.action = frameObject[utils.ConstValues.A_ACTION]; frame.event = frameObject[utils.ConstValues.A_EVENT] }; DataParser.parseMainFrame = function (frameObject, frameRate) { var frame = new Frame; DataParser.parseFrame(frameObject, frame, frameRate); return frame }; DataParser.parseTransformFrame = function (frameObject, frameRate) { var frame = new TransformFrame; DataParser.parseFrame(frameObject, frame, frameRate); frame.visible = Number(frameObject[utils.ConstValues.A_HIDE]) != 1; if (frameObject.hasOwnProperty(utils.ConstValues.A_TWEEN_EASING)) { var tweenEase = frameObject[utils.ConstValues.A_TWEEN_EASING]; if (tweenEase == undefined || tweenEase == null) frame.tweenEasing = NaN; else frame.tweenEasing = Number(tweenEase) } else frame.tweenEasing = 0; frame.tweenRotate = Number(frameObject[utils.ConstValues.A_TWEEN_ROTATE]) || 0; frame.displayIndex = Number(frameObject[utils.ConstValues.A_DISPLAY_INDEX]) || 0; frame.zOrder = Number(frameObject[utils.ConstValues.A_Z_ORDER]) || 0; DataParser.parseTransform(frameObject[utils.ConstValues.TRANSFORM], frame.global, frame.pivot); frame.transform.copy(frame.global); var colorTransformObject = frameObject[utils.ConstValues.COLOR_TRANSFORM]; if (colorTransformObject) { frame.color = new geom.ColorTransform; frame.color.alphaOffset = Number(colorTransformObject[utils.ConstValues.A_ALPHA_OFFSET]); frame.color.redOffset = Number(colorTransformObject[utils.ConstValues.A_RED_OFFSET]); frame.color.greenOffset = Number(colorTransformObject[utils.ConstValues.A_GREEN_OFFSET]); frame.color.blueOffset = Number(colorTransformObject[utils.ConstValues.A_BLUE_OFFSET]); frame.color.alphaMultiplier = Number(colorTransformObject[utils.ConstValues.A_ALPHA_MULTIPLIER]) * 0.01; frame.color.redMultiplier = Number(colorTransformObject[utils.ConstValues.A_RED_MULTIPLIER]) * 0.01; frame.color.greenMultiplier = Number(colorTransformObject[utils.ConstValues.A_GREEN_MULTIPLIER]) * 0.01; frame.color.blueMultiplier = Number(colorTransformObject[utils.ConstValues.A_BLUE_MULTIPLIER]) * 0.01 } return frame }; DataParser.parseTransform = function (transformObject, transform, pivot) { if (typeof pivot === "undefined") pivot = null; if (transformObject) { if (transform) { transform.x = Number(transformObject[utils.ConstValues.A_X]); transform.y = Number(transformObject[utils.ConstValues.A_Y]); transform.skewX = Number(transformObject[utils.ConstValues.A_SKEW_X]) * utils.ConstValues.ANGLE_TO_RADIAN; transform.skewY = Number(transformObject[utils.ConstValues.A_SKEW_Y]) * utils.ConstValues.ANGLE_TO_RADIAN; transform.scaleX = Number(transformObject[utils.ConstValues.A_SCALE_X]); transform.scaleY = Number(transformObject[utils.ConstValues.A_SCALE_Y]) } if (pivot) { pivot.x = Number(transformObject[utils.ConstValues.A_PIVOT_X]); pivot.y = Number(transformObject[utils.ConstValues.A_PIVOT_Y]) } } }; return DataParser }(); objects.DataParser = DataParser })(dragonBones.objects || (dragonBones.objects = {})); var objects = dragonBones.objects; (function (factorys) { var BaseFactory = function (_super) { __extends(BaseFactory, _super); function BaseFactory() { _super.call(this); this._dataDic = {}; this._textureAtlasDic = {}; this._textureAtlasLoadingDic = {} } BaseFactory.prototype.getSkeletonData = function (name) { return this._dataDic[name] }; BaseFactory.prototype.addSkeletonData = function (data, name) { if (!data) throw new Error; name = name || data.name; if (!name) throw new Error("Unnamed data!"); if (this._dataDic[name]); this._dataDic[name] = data }; BaseFactory.prototype.removeSkeletonData = function (name) { delete this._dataDic[name] }; BaseFactory.prototype.getTextureAtlas = function (name) { return this._textureAtlasDic[name] }; BaseFactory.prototype.addTextureAtlas = function (textureAtlas, name) { if (!textureAtlas) throw new Error; name = name || textureAtlas.name; if (!name) throw new Error("Unnamed data!"); if (this._textureAtlasDic[name]); this._textureAtlasDic[name] = textureAtlas }; BaseFactory.prototype.removeTextureAtlas = function (name) { delete this._textureAtlasDic[name] }; BaseFactory.prototype.dispose = function (disposeData) { if (typeof disposeData === "undefined") disposeData = true; if (disposeData) { for (var i in this._dataDic) this._dataDic[i].dispose(); for (var i in this._textureAtlasDic) this._textureAtlasDic[i].dispose() } this._dataDic = null; this._textureAtlasDic = null; this._textureAtlasLoadingDic = null; this._currentDataName = null; this._currentTextureAtlasName = null }; BaseFactory.prototype.buildArmature = function (armatureName, animationName, skeletonName, textureAtlasName, skinName) { if (skeletonName) { var data = this._dataDic[skeletonName]; if (data) var armatureData = data.getArmatureData(armatureName) } else for (skeletonName in this._dataDic) { data = this._dataDic[skeletonName]; armatureData = data.getArmatureData(armatureName); if (armatureData) break } if (!armatureData) return null; this._currentDataName = skeletonName; this._currentTextureAtlasName = textureAtlasName || skeletonName; var armature = this._generateArmature(); armature.name = armatureName; var bone; var boneData; var boneDataList = armatureData.getBoneDataList(); for (var index in boneDataList) { boneData = boneDataList[index]; bone = new dragonBones.Bone; bone.name = boneData.name; bone.origin.copy(boneData.transform); if (armatureData.getBoneData(boneData.parent)) armature.addChild(bone, boneData.parent); else armature.addChild(bone, null) } if (animationName && animationName != armatureName) { var animationArmatureData = data.getArmatureData(animationName); if (!animationArmatureData) for (skeletonName in this._dataDic) { data = this._dataDic[skeletonName]; animationArmatureData = data.getArmatureData(animationName); if (animationArmatureData) break } } if (animationArmatureData) armature.animation.setAnimationDataList(animationArmatureData.getAnimationDataList()); else armature.animation.setAnimationDataList(armatureData.getAnimationDataList()); var skinData = armatureData.getSkinData(skinName); if (!skinData) throw new Error; var slot; var displayData; var childArmature; var i; var helpArray = []; var slotData; var slotDataList = skinData.getSlotDataList(); var displayDataList; for (var index in slotDataList) { slotData = slotDataList[index]; bone = armature.getBone(slotData.parent); if (!bone) continue; displayDataList = slotData.getDisplayDataList(); slot = this._generateSlot(); slot.name = slotData.name; slot._blendMode = slotData.blendMode; slot._originZOrder = slotData.zOrder; slot._dislayDataList = displayDataList; helpArray.length = 0; i = displayDataList.length; while (i--) { displayData = displayDataList[i]; switch (displayData.type) { case objects.DisplayData.ARMATURE: childArmature = this.buildArmature(displayData.name, null, this._currentDataName, this._currentTextureAtlasName, null); if (childArmature) helpArray[i] = childArmature; break; case objects.DisplayData.IMAGE: default: helpArray[i] = this._generateDisplay(this._textureAtlasDic[this._currentTextureAtlasName], displayData.name, displayData.pivot.x, displayData.pivot.y); break } } slot.setDisplayList(helpArray); slot._changeDisplay(0); bone.addChild(slot) } armature._slotsZOrderChanged = true; armature.advanceTime(0); return armature }; BaseFactory.prototype.getTextureDisplay = function (textureName, textureAtlasName, pivotX, pivotY) { if (textureAtlasName) var textureAtlas = this._textureAtlasDic[textureAtlasName]; if (!textureAtlas && !textureAtlasName) for (textureAtlasName in this._textureAtlasDic) { textureAtlas = this._textureAtlasDic[textureAtlasName]; if (textureAtlas.getRegion(textureName)) break; textureAtlas = null } if (textureAtlas) { if (isNaN(pivotX) || isNaN(pivotY)) { var data = this._dataDic[textureAtlasName]; if (data) { var pivot = data.getSubTexturePivot(textureName); if (pivot) { pivotX = pivot.x; pivotY = pivot.y } } } return this._generateDisplay(textureAtlas, textureName, pivotX, pivotY) } return null }; BaseFactory.prototype._generateArmature = function () { return null }; BaseFactory.prototype._generateSlot = function () { return null }; BaseFactory.prototype._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) { return null }; return BaseFactory }(events.EventDispatcher); factorys.BaseFactory = BaseFactory })(dragonBones.factorys || (dragonBones.factorys = {})); var factorys = dragonBones.factorys; (function (utils) { var ConstValues = function () { function ConstValues() { } ConstValues.ANGLE_TO_RADIAN = Math.PI / 180; ConstValues.DRAGON_BONES = "dragonBones"; ConstValues.ARMATURE = "armature"; ConstValues.SKIN = "skin"; ConstValues.BONE = "bone"; ConstValues.SLOT = "slot"; ConstValues.DISPLAY = "display"; ConstValues.ANIMATION = "animation"; ConstValues.TIMELINE = "timeline"; ConstValues.FRAME = "frame"; ConstValues.TRANSFORM = "transform"; ConstValues.COLOR_TRANSFORM = "colorTransform"; ConstValues.TEXTURE_ATLAS = "TextureAtlas"; ConstValues.SUB_TEXTURE = "SubTexture"; ConstValues.A_VERSION = "version"; ConstValues.A_IMAGE_PATH = "imagePath"; ConstValues.A_FRAME_RATE = "frameRate"; ConstValues.A_NAME = "name"; ConstValues.A_PARENT = "parent"; ConstValues.A_LENGTH = "length"; ConstValues.A_TYPE = "type"; ConstValues.A_FADE_IN_TIME = "fadeInTime"; ConstValues.A_DURATION = "duration"; ConstValues.A_SCALE = "scale"; ConstValues.A_OFFSET = "offset"; ConstValues.A_LOOP = "loop"; ConstValues.A_EVENT = "event"; ConstValues.A_ACTION = "action"; ConstValues.A_HIDE = "hide"; ConstValues.A_TWEEN_EASING = "tweenEasing"; ConstValues.A_TWEEN_ROTATE = "tweenRotate"; ConstValues.A_DISPLAY_INDEX = "displayIndex"; ConstValues.A_Z_ORDER = "z"; ConstValues.A_BLENDMODE = "blendMode"; ConstValues.A_WIDTH = "width"; ConstValues.A_HEIGHT = "height"; ConstValues.A_X = "x"; ConstValues.A_Y = "y"; ConstValues.A_SKEW_X = "skX"; ConstValues.A_SKEW_Y = "skY"; ConstValues.A_SCALE_X = "scX"; ConstValues.A_SCALE_Y = "scY"; ConstValues.A_PIVOT_X = "pX"; ConstValues.A_PIVOT_Y = "pY"; ConstValues.A_ALPHA_OFFSET = "aO"; ConstValues.A_RED_OFFSET = "rO"; ConstValues.A_GREEN_OFFSET = "gO"; ConstValues.A_BLUE_OFFSET = "bO"; ConstValues.A_ALPHA_MULTIPLIER = "aM"; ConstValues.A_RED_MULTIPLIER = "rM"; ConstValues.A_GREEN_MULTIPLIER = "gM"; ConstValues.A_BLUE_MULTIPLIER = "bM"; return ConstValues }(); utils.ConstValues = ConstValues; var TransformUtil = function () { function TransformUtil() { } TransformUtil.transformPointWithParent = function (transform, parent) { var helpMatrix = TransformUtil._helpMatrix; TransformUtil.transformToMatrix(parent, helpMatrix); helpMatrix.invert(); var x = transform.x; var y = transform.y; transform.x = helpMatrix.a * x + helpMatrix.c * y + helpMatrix.tx; transform.y = helpMatrix.d * y + helpMatrix.b * x + helpMatrix.ty; transform.skewX = TransformUtil.formatRadian(transform.skewX - parent.skewX); transform.skewY = TransformUtil.formatRadian(transform.skewY - parent.skewY) }; TransformUtil.transformToMatrix = function (transform, matrix) { matrix.a = transform.scaleX * Math.cos(transform.skewY); matrix.b = transform.scaleX * Math.sin(transform.skewY); matrix.c = -transform.scaleY * Math.sin(transform.skewX); matrix.d = transform.scaleY * Math.cos(transform.skewX); matrix.tx = transform.x; matrix.ty = transform.y }; TransformUtil.formatRadian = function (radian) { radian %= TransformUtil.DOUBLE_PI; if (radian > Math.PI) radian -= TransformUtil.DOUBLE_PI; if (radian < -Math.PI) radian += TransformUtil.DOUBLE_PI; return radian }; TransformUtil.DOUBLE_PI = Math.PI * 2; TransformUtil._helpMatrix = new geom.Matrix; return TransformUtil }(); utils.TransformUtil = TransformUtil; var DBDataUtil = function () { function DBDataUtil() { } DBDataUtil.transformArmatureData = function (armatureData) { var boneDataList = armatureData.getBoneDataList(); var i = boneDataList.length; var boneData; var parentBoneData; while (i--) { boneData = boneDataList[i]; if (boneData.parent) { parentBoneData = armatureData.getBoneData(boneData.parent); if (parentBoneData) { boneData.transform.copy(boneData.global); TransformUtil.transformPointWithParent(boneData.transform, parentBoneData.global) } } } }; DBDataUtil.transformArmatureDataAnimations = function (armatureData) { var animationDataList = armatureData.getAnimationDataList(); var i = animationDataList.length; while (i--) DBDataUtil.transformAnimationData(animationDataList[i], armatureData) }; DBDataUtil.transformAnimationData = function (animationData, armatureData) { var skinData = armatureData.getSkinData(null); var boneDataList = armatureData.getBoneDataList(); var slotDataList = skinData.getSlotDataList(); var i = boneDataList.length; var boneData; var timeline; var slotData; var displayData; var parentTimeline; var frameList; var originTransform; var originPivot; var prevFrame; var frame; var frameListLength; while (i--) { boneData = boneDataList[i]; timeline = animationData.getTimeline(boneData.name); if (!timeline) continue; slotData = null; for (var slotIndex in slotDataList) { slotData = slotDataList[slotIndex]; if (slotData.parent == boneData.name) break } parentTimeline = boneData.parent ? animationData.getTimeline(boneData.parent) : null; frameList = timeline.getFrameList(); originTransform = null; originPivot = null; prevFrame = null; frameListLength = frameList.length; for (var j = 0; j < frameListLength; j++) { frame = frameList[j]; if (parentTimeline) { DBDataUtil._helpTransform1.copy(frame.global); DBDataUtil.getTimelineTransform(parentTimeline, frame.position, DBDataUtil._helpTransform2); TransformUtil.transformPointWithParent(DBDataUtil._helpTransform1, DBDataUtil._helpTransform2); frame.transform.copy(DBDataUtil._helpTransform1) } else frame.transform.copy(frame.global); frame.transform.x -= boneData.transform.x; frame.transform.y -= boneData.transform.y; frame.transform.skewX -= boneData.transform.skewX; frame.transform.skewY -= boneData.transform.skewY; frame.transform.scaleX -= boneData.transform.scaleX; frame.transform.scaleY -= boneData.transform.scaleY; if (!timeline.transformed) if (slotData) frame.zOrder -= slotData.zOrder; if (!originTransform) { originTransform = timeline.originTransform; originTransform.copy(frame.transform); originTransform.skewX = TransformUtil.formatRadian(originTransform.skewX); originTransform.skewY = TransformUtil.formatRadian(originTransform.skewY); originPivot = timeline.originPivot; originPivot.x = frame.pivot.x; originPivot.y = frame.pivot.y } frame.transform.x -= originTransform.x; frame.transform.y -= originTransform.y; frame.transform.skewX = TransformUtil.formatRadian(frame.transform.skewX - originTransform.skewX); frame.transform.skewY = TransformUtil.formatRadian(frame.transform.skewY - originTransform.skewY); frame.transform.scaleX -= originTransform.scaleX; frame.transform.scaleY -= originTransform.scaleY; if (!timeline.transformed) { frame.pivot.x -= originPivot.x; frame.pivot.y -= originPivot.y } if (prevFrame) { var dLX = frame.transform.skewX - prevFrame.transform.skewX; if (prevFrame.tweenRotate) if (prevFrame.tweenRotate > 0) { if (dLX < 0) { frame.transform.skewX += Math.PI * 2; frame.transform.skewY += Math.PI * 2 } if (prevFrame.tweenRotate > 1) { frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate - 1); frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate - 1) } } else { if (dLX > 0) { frame.transform.skewX -= Math.PI * 2; frame.transform.skewY -= Math.PI * 2 } if (prevFrame.tweenRotate < 1) { frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate + 1); frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate + 1) } } else { frame.transform.skewX = prevFrame.transform.skewX + TransformUtil.formatRadian(frame.transform.skewX - prevFrame.transform.skewX); frame.transform.skewY = prevFrame.transform.skewY + TransformUtil.formatRadian(frame.transform.skewY - prevFrame.transform.skewY) } } prevFrame = frame } timeline.transformed = true } }; DBDataUtil.getTimelineTransform = function (timeline, position, retult) { var frameList = timeline.getFrameList(); var i = frameList.length; var currentFrame; var tweenEasing; var progress; var nextFrame; while (i--) { currentFrame = frameList[i]; if (currentFrame.position <= position && currentFrame.position + currentFrame.duration > position) { tweenEasing = currentFrame.tweenEasing; if (i == frameList.length - 1 || isNaN(tweenEasing) || position == currentFrame.position) retult.copy(currentFrame.global); else { progress = (position - currentFrame.position) / currentFrame.duration; if (tweenEasing) progress = animation.TimelineState.getEaseValue(progress, tweenEasing); nextFrame = frameList[i + 1]; retult.x = currentFrame.global.x + (nextFrame.global.x - currentFrame.global.x) * progress; retult.y = currentFrame.global.y + (nextFrame.global.y - currentFrame.global.y) * progress; retult.skewX = TransformUtil.formatRadian(currentFrame.global.skewX + (nextFrame.global.skewX - currentFrame.global.skewX) * progress); retult.skewY = TransformUtil.formatRadian(currentFrame.global.skewY + (nextFrame.global.skewY - currentFrame.global.skewY) * progress); retult.scaleX = currentFrame.global.scaleX + (nextFrame.global.scaleX - currentFrame.global.scaleX) * progress; retult.scaleY = currentFrame.global.scaleY + (nextFrame.global.scaleY - currentFrame.global.scaleY) * progress } break } } }; DBDataUtil.addHideTimeline = function (animationData, armatureData) { var boneDataList = armatureData.getBoneDataList(); var i = boneDataList.length; var boneData; var boneName; while (i--) { boneData = boneDataList[i]; boneName = boneData.name; if (!animationData.getTimeline(boneName)) animationData.addTimeline(objects.TransformTimeline.HIDE_TIMELINE, boneName) } }; DBDataUtil._helpTransform1 = new objects.DBTransform; DBDataUtil._helpTransform2 = new objects.DBTransform; return DBDataUtil }(); utils.DBDataUtil = DBDataUtil })(dragonBones.utils || (dragonBones.utils = {})); var utils = dragonBones.utils; var DBObject = function () { function DBObject() { this.global = new objects.DBTransform; this.origin = new objects.DBTransform; this.offset = new objects.DBTransform; this.tween = new objects.DBTransform; this.tween.scaleX = this.tween.scaleY = 0; this._globalTransformMatrix = new geom.Matrix; this._visible = true; this._isColorChanged = false; this._isDisplayOnStage = false; this._scaleType = 0; this.fixedRotation = false } DBObject.prototype.getVisible = function () { return this._visible }; DBObject.prototype.setVisible = function (value) { this._visible = value }; DBObject.prototype._setParent = function (value) { this.parent = value }; DBObject.prototype._setArmature = function (value) { if (this.armature) this.armature._removeDBObject(this); this.armature = value; if (this.armature) this.armature._addDBObject(this) }; DBObject.prototype.dispose = function () { this.parent = null; this.armature = null; this.global.dispose(); this.origin.dispose(); this.offset.dispose(); this.tween.dispose(); this.global = null; this.origin = null; this.offset = null; this.tween = null; this._globalTransformMatrix = null }; DBObject.prototype._update = function () { this.global.scaleX = (this.origin.scaleX + this.tween.scaleX) * this.offset.scaleX; this.global.scaleY = (this.origin.scaleY + this.tween.scaleY) * this.offset.scaleY; if (this.parent) { var x = this.origin.x + this.offset.x + this.tween.x; var y = this.origin.y + this.offset.y + this.tween.y; var parentMatrix = this.parent._globalTransformMatrix; this._globalTransformMatrix.tx = this.global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx; this._globalTransformMatrix.ty = this.global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty; if (this.fixedRotation) { this.global.skewX = this.origin.skewX + this.offset.skewX + this.tween.skewX; this.global.skewY = this.origin.skewY + this.offset.skewY + this.tween.skewY } else { this.global.skewX = this.origin.skewX + this.offset.skewX + this.tween.skewX + this.parent.global.skewX; this.global.skewY = this.origin.skewY + this.offset.skewY + this.tween.skewY + this.parent.global.skewY } if (this.parent.scaleMode >= this._scaleType) { this.global.scaleX *= this.parent.global.scaleX; this.global.scaleY *= this.parent.global.scaleY } } else { this._globalTransformMatrix.tx = this.global.x = this.origin.x + this.offset.x + this.tween.x; this._globalTransformMatrix.ty = this.global.y = this.origin.y + this.offset.y + this.tween.y; this.global.skewX = this.origin.skewX + this.offset.skewX + this.tween.skewX; this.global.skewY = this.origin.skewY + this.offset.skewY + this.tween.skewY } this._globalTransformMatrix.a = this.global.scaleX * Math.cos(this.global.skewY); this._globalTransformMatrix.b = this.global.scaleX * Math.sin(this.global.skewY); this._globalTransformMatrix.c = -this.global.scaleY * Math.sin(this.global.skewX); this._globalTransformMatrix.d = this.global.scaleY * Math.cos(this.global.skewX) }; return DBObject }(); dragonBones.DBObject = DBObject; var Slot = function (_super) { __extends(Slot, _super); function Slot(displayBrideg) { _super.call(this); this._displayBridge = displayBrideg; this._displayList = []; this._displayIndex = -1; this._scaleType = 1; this._originZOrder = 0; this._tweenZorder = 0; this._offsetZOrder = 0; this._isDisplayOnStage = false; this._isHideDisplay = false; this._blendMode = "normal"; this._displayBridge.updateBlendMode(this._blendMode) } Slot.prototype.getZOrder = function () { return this._originZOrder + this._tweenZorder + this._offsetZOrder }; Slot.prototype.setZOrder = function (value) { if (this.getZOrder() != value) { this._offsetZOrder = value - this._originZOrder - this._tweenZorder; if (this.armature) this.armature._slotsZOrderChanged = true } }; Slot.prototype.getDisplay = function () { var display = this._displayList[this._displayIndex]; if (display instanceof Armature) return display.getDisplay(); return display }; Slot.prototype.getArmature = function () { var display = this._displayList[this._displayIndex]; if (display instanceof Armature) return display; return null }; Slot.prototype.gotoAndPlay = function () { var armature = this.getArmature(); if (armature == null) throw Error("No armature found!"); return armature.animation.gotoAndPlay.apply(armature.animation, arguments) }; Slot.prototype.setDisplay = function (value) { this._displayList[this._displayIndex] = value; this._setDisplay(value) }; Slot.prototype.getBlendMode = function () { return this._blendMode }; Slot.prototype.setBlendMode = function (value) { if (this._blendMode != value) { this._blendMode = value; if (this._displayBridge.getDisplay()) this._displayBridge.updateBlendMode(this._blendMode) } }; Slot.prototype.getChildArmature = function () { var display = this._displayList[this._displayIndex]; if (display instanceof Armature) return display; return null }; Slot.prototype.setChildArmature = function (value) { this._displayList[this._displayIndex] = value; if (value) this._setDisplay(value.getDisplay()) }; Slot.prototype.getDisplayList = function () { return this._displayList }; Slot.prototype.setDisplayList = function (value) { if (!value) throw new Error; var i = this._displayList.length = value.length; while (i--) this._displayList[i] = value[i]; if (this._displayIndex >= 0) { var displayIndexBackup = this._displayIndex; this._displayIndex = -1; this._changeDisplay(displayIndexBackup) } }; Slot.prototype._setDisplay = function (display) { if (this._displayBridge.getDisplay()) this._displayBridge.setDisplay(display); else { this._displayBridge.setDisplay(display); if (this.armature) { this._displayBridge.addDisplay(this.armature.getDisplay(), -1); this.armature._slotsZOrderChanged = true } } this.updateChildArmatureAnimation(); if (display) this._displayBridge.updateBlendMode(this._blendMode); if (!this._isHideDisplay && this._displayBridge.getDisplay()) this._isDisplayOnStage = true; else this._isDisplayOnStage = false }; Slot.prototype._changeDisplay = function (displayIndex) { if (displayIndex < 0) { if (!this._isHideDisplay) { this._isHideDisplay = true; this._displayBridge.removeDisplay(); this.updateChildArmatureAnimation() } } else { if (this._isHideDisplay) { this._isHideDisplay = false; var changeShowState = true; if (this.armature) { this._displayBridge.addDisplay(this.armature.getDisplay(), -1); this.armature._slotsZOrderChanged = true } } var length = this._displayList.length; if (displayIndex >= length && length > 0) displayIndex = length - 1; if (this._displayIndex != displayIndex) { this._displayIndex = displayIndex; var display = this._displayList[this._displayIndex]; if (display instanceof Armature) this._setDisplay(display.getDisplay()); else this._setDisplay(display); if (this._dislayDataList && this._displayIndex <= this._dislayDataList.length) this.origin.copy(this._dislayDataList[this._displayIndex].transform) } else if (changeShowState) this.updateChildArmatureAnimation() } if (!this._isHideDisplay && this._displayBridge.getDisplay()) this._isDisplayOnStage = true; else this._isDisplayOnStage = false }; Slot.prototype.setVisible = function (value) { if (value != this._visible) { this._visible = value; this._updateVisible(this._visible) } }; Slot.prototype._setArmature = function (value) { _super.prototype._setArmature.call(this, value); if (this.armature) { this.armature._slotsZOrderChanged = true; this._displayBridge.addDisplay(this.armature.getDisplay(), -1) } else this._displayBridge.removeDisplay() }; Slot.prototype.dispose = function () { if (!this._displayBridge) return; _super.prototype.dispose.call(this); this._displayBridge.dispose(); this._displayList.length = 0; this._displayBridge = null; this._displayList = null; this._dislayDataList = null }; Slot.prototype._update = function () { _super.prototype._update.call(this); if (this._isDisplayOnStage) { var pivotX = this.parent._tweenPivot.x; var pivotY = this.parent._tweenPivot.y; if (pivotX || pivotY) { var parentMatrix = this.parent._globalTransformMatrix; this._globalTransformMatrix.tx += parentMatrix.a * pivotX + parentMatrix.c * pivotY; this._globalTransformMatrix.ty += parentMatrix.b * pivotX + parentMatrix.d * pivotY } this._displayBridge.updateTransform(this._globalTransformMatrix, this.global) } }; Slot.prototype._updateVisible = function (value) { this._displayBridge.setVisible(this.parent.getVisible() && this._visible && value) }; Slot.prototype.updateChildArmatureAnimation = function () { var childArmature = this.getChildArmature(); if (childArmature) if (this._isHideDisplay) { childArmature.animation.stop(); childArmature.animation._lastAnimationState = null } else { var lastAnimationName = this.armature ? this.armature.animation.getLastAnimationName() : null; if (lastAnimationName && childArmature.animation.hasAnimation(lastAnimationName)) childArmature.animation.gotoAndPlay(lastAnimationName); else childArmature.animation.play() } }; return Slot }(DBObject); dragonBones.Slot = Slot; var Bone = function (_super) { __extends(Bone, _super); function Bone() { _super.call(this); this._children = []; this._scaleType = 2; this._tweenPivot = new geom.Point; this.scaleMode = 1 } Bone.prototype.setVisible = function (value) { if (this._visible != value) { this._visible = value; var i = this._children.length; while (i--) { var child = this._children[i]; if (child instanceof Slot) child._updateVisible(this._visible) } } }; Bone.prototype._setArmature = function (value) { _super.prototype._setArmature.call(this, value); var i = this._children.length; while (i--) this._children[i]._setArmature(this.armature) }; Bone.prototype.dispose = function () { if (!this._children) return; _super.prototype.dispose.call(this); var i = this._children.length; while (i--) this._children[i].dispose(); this._children.length = 0; this._children = null; this._tweenPivot = null; this.slot = null }; Bone.prototype.contains = function (child) { if (!child) throw new Error; if (child == this) return false; var ancestor = child; while (!(ancestor == this || ancestor == null)) ancestor = ancestor.parent; return ancestor == this }; Bone.prototype.addChild = function (child) { if (!child) throw new Error; if (child == this || child instanceof Bone && child.contains(this)) throw new Error("An Bone cannot be added as a child to itself or one of its children (or children's children, etc.)"); if (child.parent) child.parent.removeChild(child); this._children[this._children.length] = child; child._setParent(this); child._setArmature(this.armature); if (!this.slot && child instanceof Slot) this.slot = child }; Bone.prototype.removeChild = function (child) { if (!child) throw new Error; var index = this._children.indexOf(child); if (index >= 0) { this._children.splice(index, 1); child._setParent(null); child._setArmature(null); if (child == this.slot) this.slot = null } else throw new Error; }; Bone.prototype.getSlots = function () { var slotList = []; var i = this._children.length; while (i--) if (this._children[i] instanceof Slot) slotList.unshift(this._children[i]); return slotList }; Bone.prototype._arriveAtFrame = function (frame, timelineState, animationState, isCross) { if (frame) { var mixingType = animationState.getMixingTransform(this.name); if (animationState.displayControl && (mixingType == 2 || mixingType == -1)) if (!this.displayController || this.displayController == animationState.name) { var tansformFrame = frame; if (this.slot) { var displayIndex = tansformFrame.displayIndex; if (displayIndex >= 0) if (!isNaN(tansformFrame.zOrder) && tansformFrame.zOrder != this.slot._tweenZorder) { this.slot._tweenZorder = tansformFrame.zOrder; this.armature._slotsZOrderChanged = true } this.slot._changeDisplay(displayIndex); this.slot._updateVisible(tansformFrame.visible) } } if (frame.event && this.armature.hasEventListener(events.FrameEvent.BONE_FRAME_EVENT)) { var frameEvent = new events.FrameEvent(events.FrameEvent.BONE_FRAME_EVENT); frameEvent.bone = this; frameEvent.animationState = animationState; frameEvent.frameLabel = frame.event; this.armature._eventList.push(frameEvent) } if (frame.action) for (var index in this._children) if (this._children[index] instanceof Slot) { var childArmature = this._children[index].getChildArmature(); if (childArmature) childArmature.animation.gotoAndPlay(frame.action) } } else if (this.slot) this.slot._changeDisplay(-1) }; Bone.prototype._updateColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, isColorChanged) { if (isColorChanged || this._isColorChanged) this.slot._displayBridge.updateColor(aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier); this._isColorChanged = isColorChanged }; return Bone }(DBObject); dragonBones.Bone = Bone; var Armature = function (_super) { __extends(Armature, _super); function Armature(display) { _super.call(this); this.animation = new animation.Animation(this); this._display = display; this._slotsZOrderChanged = false; this._slotList = []; this._boneList = []; this._eventList = [] } Armature.prototype.getDisplay = function () { return this._display }; Armature.prototype.dispose = function () { if (!this.animation) return; dragonBones.animation.WorldClock.clock.remove(this); this.animation.dispose(); var i = this._slotList.length; while (i--) this._slotList[i].dispose(); i = this._boneList.length; while (i--) this._boneList[i].dispose(); this._slotList.length = 0; this._boneList.length = 0; this._eventList.length = 0; this._slotList = null; this._boneList = null; this._eventList = null; this._display = null; this.animation = null }; Armature.prototype.advanceTime = function (passedTime) { this.animation.advanceTime(passedTime); passedTime *= this.animation.timeScale; var i = this._boneList.length; while (i--) this._boneList[i]._update(); i = this._slotList.length; var slot; while (i--) { slot = this._slotList[i]; slot._update() } if (this._slotsZOrderChanged) { this.updateSlotsZOrder(); if (this.hasEventListener(events.ArmatureEvent.Z_ORDER_UPDATED)) this.dispatchEvent(new events.ArmatureEvent(events.ArmatureEvent.Z_ORDER_UPDATED)) } if (this._eventList.length) { var copy = this._eventList.concat(); this._eventList.length = 0; var length = copy.length; for (i = 0; i < length; i++) this.dispatchEvent(copy[i]) } }; Armature.prototype.getSlots = function (returnCopy) { if (typeof returnCopy === "undefined") returnCopy = true; return returnCopy ? this._slotList.concat() : this._slotList }; Armature.prototype.getBones = function (returnCopy) { if (typeof returnCopy === "undefined") returnCopy = true; return returnCopy ? this._boneList.concat() : this._boneList }; Armature.prototype.getSlot = function (slotName) { var i = this._slotList.length; while (i--) if (this._slotList[i].name == slotName) return this._slotList[i]; return null }; Armature.prototype.getSlotByDisplay = function (display) { if (display) { var i = this._slotList.length; while (i--) if (this._slotList[i].getDisplay() == display) return this._slotList[i] } return null }; Armature.prototype.removeSlot = function (slot) { if (!slot) throw new Error; if (this._slotList.indexOf(slot) >= 0) slot.parent.removeChild(slot); else throw new Error; }; Armature.prototype.removeSlotByName = function (slotName) { if (!slotName) return; var slot = this.getSlot(slotName); if (slot) this.removeSlot(slot) }; Armature.prototype.getBone = function (boneName) { var i = this._boneList.length; while (i--) if (this._boneList[i].name == boneName) return this._boneList[i]; return null }; Armature.prototype.getBoneByDisplay = function (display) { var slot = this.getSlotByDisplay(display); return slot ? slot.parent : null }; Armature.prototype.removeBone = function (bone) { if (!bone) throw new Error; if (this._boneList.indexOf(bone) >= 0) if (bone.parent) bone.parent.removeChild(bone); else bone._setArmature(null); else throw new Error; }; Armature.prototype.removeBoneByName = function (boneName) { if (!boneName) return; var bone = this.getBone(boneName); if (bone) this.removeBone(bone) }; Armature.prototype.gotoAndPlay = function () { return this.animation.gotoAndPlay.apply(this.animation, arguments) }; Armature.prototype.addChild = function (object, parentName) { if (!object) throw new Error; if (parentName) { var boneParent = this.getBone(parentName); if (boneParent) boneParent.addChild(object); else throw new Error; } else { if (object.parent) object.parent.removeChild(object); object._setArmature(this) } }; Armature.prototype.updateSlotsZOrder = function () { this._slotList.sort(this.sortSlot); var i = this._slotList.length; var slot; while (i--) { slot = this._slotList[i]; if (slot._isDisplayOnStage) slot._displayBridge.addDisplay(this._display, -1) } this._slotsZOrderChanged = false }; Armature.prototype._addDBObject = function (object) { if (object instanceof Slot) { var slot = object; if (this._slotList.indexOf(slot) < 0) this._slotList[this._slotList.length] = slot } else if (object instanceof Bone) { var bone = object; if (this._boneList.indexOf(bone) < 0) { this._boneList[this._boneList.length] = bone; this._sortBoneList() } } }; Armature.prototype._removeDBObject = function (object) { if (object instanceof Slot) { var slot = object; var index = this._slotList.indexOf(slot); if (index >= 0) this._slotList.splice(index, 1) } else if (object instanceof Bone) { var bone = object; index = this._boneList.indexOf(bone); if (index >= 0) this._boneList.splice(index, 1) } }; Armature.prototype._sortBoneList = function () { var i = this._boneList.length; if (i == 0) return; var helpArray = []; var level; var bone; var boneParent; while (i--) { level = 0; bone = this._boneList[i]; boneParent = bone; while (boneParent) { level++; boneParent = boneParent.parent } helpArray[i] = { level: level, bone: bone } } helpArray.sort(this.sortBone); i = helpArray.length; while (i--) this._boneList[i] = helpArray[i].bone }; Armature.prototype._arriveAtFrame = function (frame, timelineState, animationState, isCross) { if (frame.event && this.hasEventListener(events.FrameEvent.ANIMATION_FRAME_EVENT)) { var frameEvent = new events.FrameEvent(events.FrameEvent.ANIMATION_FRAME_EVENT); frameEvent.animationState = animationState; frameEvent.frameLabel = frame.event; this._eventList.push(frameEvent) } if (frame.action) if (animationState.isPlaying) this.animation.gotoAndPlay(frame.action) }; Armature.prototype.sortSlot = function (slot1, slot2) { return slot1.getZOrder() < slot2.getZOrder() ? 1 : -1 }; Armature.prototype.sortBone = function (object1, object2) { return object1.level < object2.level ? 1 : -1 }; Armature.prototype.setCacheAsBitmap = function (bCacheAsBitmap) { this._display.cacheAsBitmap = bCacheAsBitmap }; Armature.prototype.getSJSSprite = function (layer) { if (this._display.children.length > 0) { var frame = this._display.children[0].texture.crop; var btexture = this._display.children[0].texture.baseTexture; var bounds = { x: 0, y: 0, w: frame.width, h: frame.height }; var sprite = new sjs.Sprite(btexture.imageUrl, layer, undefined, bounds); sprite.offset(frame.x, frame.y); return sprite } return null }; Armature.prototype.getPIXISprite = function () { if (this._display.children.length > 0) { var frame = this._display.children[0].texture.crop; var btexture = this._display.children[0].texture.baseTexture; return new PIXI.Sprite(new PIXI.Texture(btexture, frame)) } return null }; return Armature }(events.EventDispatcher); dragonBones.Armature = Armature })(dragonBones || (dragonBones = {})); ResourceManager = { loaders: [], started: false }; ResourceManager.start = function () { ResourceManager.started = true; var a = ResourceManager.loaders; var l = a.length; for (var i = 0; i < l; i++) a[i].start() }; ResourceManager.addLoader = function (loader) { var that = this; ResourceManager.loaders.push(loader); loader.onComplete = function () { that.loaderComplete } }; ResourceManager.loaderComplete = function () { if (this.isReady()) sjs._spritesLoaded = true }; ResourceManager.getPercentage = function () { if (!ResourceManager.started) return 0; var a = ResourceManager.loaders; var l = a.length; if (l == 0) return 1; var p = 0; for (var i = 0; i < l; i++) p += a[i].getPercentage(); return p / l }; ResourceManager.isReady = function () { if (!ResourceManager.started) return false; var a = ResourceManager.loaders; var l = a.length; for (var i = 0; i < l; i++) if (!a[i].isReady()) return false; return true }; PixiAssetWrapper = function (loader) { this.loader = loader; var that = this }; PixiAssetWrapper.prototype = Object.create(PixiAssetWrapper); PixiAssetWrapper.prototype.constructor = PixiAssetWrapper; PixiAssetWrapper.prototype.getPercentage = function () { if (this.loader.loadCount == 0) return 1; else return 1 - this.loader.loadCount / this.loader.assetURLs.length }; PixiAssetWrapper.prototype.isReady = function () { return this.getPercentage() >= 1 }; PixiAssetWrapper.prototype.start = function () { this.loader.load() }; function Button(layer, pos, clickHandler, img, caption, textColor, style, multiline, icon, iconPos, iconScale, ieShadow, ieShadowSize, verttouchadj, createDynText) { var that = this; if (this.constructor !== arguments.callee) return new Button; this.rG = img; this.ad = false; this.oX = false; this.aP = true; this.oR = 0.1; this.mH = false; this.kN = iconPos; this.L = pos; if (this.L.offsets != undefined) this.as = pos.offsets; if (pos.offsets != undefined) { this.as = pos.offsets; if (pos.offsets.xenabled != undefined); this.sx = pos.offsets.xenabled; if (pos.offsets.xdisabled != undefined); this.nG = pos.offsets.xdisabled; if (pos.offsets.yenabled != undefined); this.rF = pos.offsets.yenabled; if (pos.offsets.ydisabled != undefined); this.pm = pos.offsets.ydisabled } if (pos.xoffset_on != undefined) this.pd = pos.xoffset_on; if (pos.yoffset_on != undefined) this.pi = pos.yoffset_on; if (pos.xoffset_off != undefined) this.oP = pos.xoffset_off; if (pos.yoffset_off != undefined) this.oJ = pos.yoffset_off; if (img != null) { this.H = new sjs.Sprite(img, layer); this.H.x = pos.x; this.H.y = pos.y } if (this.L.offsets != undefined) { this.H.xoffset = this.as.xoff; this.H.yoffset = this.as.yoff; this.H.w = this.L.w; this.H.h = this.L.h; this.H.update() } if (this.L.offsets != undefined) if (this.L.offsets.glow != undefined) { this.ak = new sjs.Sprite(img, layer); this.ak.x = pos.x; this.ak.y = pos.y; this.ak.w = this.L.w; this.ak.h = this.L.h; this.ak.xoffset = this.as.glow.xglow; this.ak.yoffset = this.as.glow.yglow; this.ak.update(); this.jZ = false } if (icon != undefined && iconPos != undefined) { this.bO = new sjs.Sprite(icon, layer, undefined, iconPos); if (this.kN.offsets != undefined) { this.bO.xoffset = this.kN.offsets.x; this.bO.yoffset = this.kN.offsets.y } if (iconScale != undefined) { this.bO.xscale = iconScale.x; this.bO.yscale = iconScale.y } } if (createDynText) this.ln = new sjs.Sprite(null, layer, undefined, pos); this.T = new sjs.Sprite(null, layer, undefined, pos); this.SetTextProperties(caption, multiline, pos, textColor, style, this.T); if (createDynText) this.SetTextProperties(caption, multiline, pos, textColor, style, this.ln); this.oG = "#333333"; this.SetClickListener(clickHandler); if (this.bO) this.SetClickListener(clickHandler, true); Button.elements.push(this); this.Enable2(true); if (pos.caption_offset) this.SetCaptionOffset(pos) } Button.prototype.constructor = Button; Button.elements = []; Button.Ticker = function () { for (i = 0; i < Button.elements.length; i++) Button.elements[i].Ticker() }; Button.prototype.SetTextProperties = function (caption, multiline, pos, textColor, style, tf) { if (caption != undefined) { tf.text = caption; this.fo = textColor; tf.verticalAlign = true; if (multiline == undefined) multiline = false; tf.multiline = multiline; tf.setStyle(style) } else if (pos.touchOffset) { tf.x -= pos.touchOffset.x / 2; tf.y -= pos.touchOffset.y / 2; tf.w += pos.touchOffset.x; tf.h += pos.touchOffset.y } }; Button.prototype.Offset = function (x, y) { this.H.xoffset = x; this.H.yoffset = y; this.H.update() }; Button.prototype.Checked = function (b) { if (!this.ad || this.as == undefined) return; this.oX = b; if (b) { this.H.xoffset = this.as.xon; this.H.yoffset = this.as.yon } else { this.H.xoffset = this.as.xoff; this.H.yoffset = this.as.yoff } this.H.update() }; Button.prototype.SetDynText = function (text) { this.ln.text = text; this.ln.update() }; Button.prototype.SetText = function (text) { this.T.text = text; this.T.update() }; Button.prototype.ListenForTouch = function (f, specifiedObj) { var obj = specifiedObj ? specifiedObj : this.T; var that = this; that.aC = f; obj.view.mousedown = obj.view.touchstart = function (e) { if (e.originalEvent.preventDefault) e.originalEvent.preventDefault(); that.betX = e.getLocalPosition(this).x; that.betY = e.getLocalPosition(this).y; that.moved = false; that.Checked(true); obj.view.mousemove = obj.view.touchmove = function (e) { var pos = e.getLocalPosition(this); if (e.originalEvent.preventDefault) e.originalEvent.preventDefault(); if (Math.abs(pos.x - that.betX) > 20 || Math.abs(pos.y - that.betY) > 20) { that.moved = true; that.Checked(false) } else { that.moved = false; that.Checked(true) } }; obj.view.mouseup = obj.view.touchend = function (e) { if (e.originalEvent.preventDefault) e.originalEvent.preventDefault(); if (!that.moved && that.ad) { that.Checked(false); that.aC() } obj.view.mousemove = obj.view.touchmove = undefined }; obj.view.mouseupoutside = obj.view.touchendoutside = function (e) { if (e.originalEvent.preventDefault) e.originalEvent.preventDefault(); that.moved = false; that.Checked(false); obj.view.mousemove = obj.view.touchmove = undefined } } }; Button.prototype.SetClickListener = function (f, setForIcon) { var obj = setForIcon ? this.bO : this.T; if (obj == undefined) return; this.ListenForTouch(f, obj) }; Button.prototype.handleClick = function (data) { event = data.originalEvent; if (event.which === 3 || event.button === 2) return; if (event.preventDefault) event.preventDefault(); if (this.aC && this.ad) this.aC() }; Button.prototype.GetPos = function () { var pos = this.T.getBounds(); if (this.H) pos.x = this.H.getBounds().x; return pos }; Button.prototype.SetPos = function (pos, centerIcon) { if (this.H) { if (pos.x != undefined) this.H.x = pos.x; if (pos.y != undefined) this.H.y = pos.y; this.H.update() } if (this.ak) { if (pos.x != undefined) this.ak.x = pos.x; if (pos.y != undefined) this.ak.y = pos.y; this.ak.update() } if (this.bO != undefined) { if (centerIcon == undefined) centerIcon = true; if (this.H) { var baseBounds = this.H.getBounds(); if (centerIcon) { if (baseBounds.x != undefined && baseBounds.w != undefined) this.bO.x = baseBounds.x + (baseBounds.w / 2 - this.bO.getBounds().w / 2) } else if (pos.x != undefined) this.bO.x = pos.x; if (baseBounds.y != undefined && baseBounds.h != undefined) this.bO.y = baseBounds.y + (baseBounds.h / 2 - this.bO.getBounds().h / 2) } else { if (pos.x != undefined) this.bO.x = pos.x; if (pos.y != undefined) this.bO.y = pos.y } this.bO.update() } this.T.setBounds(pos); if (pos.caption_offset) this.SetCaptionOffset(pos); this.T.update() }; Button.prototype.SetCaptionOffset = function (pos) { }; Button.prototype.SetScale = function (scale, scaleText) { if (this.H) { if (scale.x != undefined) this.H.xscale = scale.x; if (scale.y != undefined) this.H.yscale = scale.y; this.H.update() } if (this.bO) { if (scale.x != undefined) this.bO.xscale = scale.x; if (scale.y != undefined) this.bO.yscale = scale.y; this.bO.update() } if (this.T && scaleText) { if (scale.x != undefined) this.T.xscale = scale.x; if (scale.y != undefined) this.T.yscale = scale.y; this.T.update() } if (this.ak) { if (scale.x != undefined) this.ak.xscale = scale.x; if (scale.y != undefined) this.ak.yscale = scale.y; this.ak.update() } }; Button.prototype.SetVisible = function (b) { if (this.H) this.H.Visible(b); if (this.bO) this.bO.Visible(b); this.T.Visible(b, true); if (this.qc != undefined) this.qc.sU.Visible(b, true); this.aP = b }; Button.prototype.Enable2 = function (b) { if (this.ad != b) { this.ad = b; if (b) { if (this.as != undefined) { if (this.as.xenabled != undefined) this.H.xoffset = this.as.xenabled; if (this.as.xenabled != undefined) this.H.yoffset = this.as.yenabled } } else if (this.as != undefined) { if (this.as.xenabled != undefined) this.H.xoffset = this.as.xdisabled; if (this.as.xenabled != undefined) this.H.yoffset = this.as.ydisabled } } }; Button.prototype.Enable = function (b, offsetInstead) { if (this.ad != b) { this.ad = b; if (!b) { if (this.nG != undefined) this.H.xoffset = this.nG; if (this.pm != undefined) this.H.yoffset = this.pm; if (this.oP != undefined) this.H.xoffset = this.oP; if (this.oJ != undefined) this.H.yoffset = this.oJ; this.oR = 0.1; if (this.H && offsetInstead != true) this.H.opacity = 0; if (this.bO && offsetInstead != true) this.bO.opacity = 0; if (this.aP) { if (this.fo) this.T.textColor = this.oG; if (!this.fo && offsetInstead != true) this.T.opacity = 0 } } else { if (this.H) { if (this.pd != undefined) this.H.xoffset = this.pd; if (this.pi != undefined) this.H.yoffset = this.pi } this.oR = -0.1; if (this.H) this.H.opacity = 1; if (this.bO) this.bO.opacity = 1; if (this.aP) { if (this.fo) this.T.textColor = this.fo; if (!this.fo) this.T.opacity = 1 } } if (this.H) this.H.update(); if (this.bO) this.bO.update(); this.T.update() } }; Button.prototype.SetTextColor = function (color, disabled) { this.fo = color; this.oG = disabled; this.T.textColor = color; this.T.update() }; Button.prototype.BtnFadeCb = function () { var tmpAlpha; if (this.jZ) tmpAlpha = [[0, 1], [0, 700]]; else tmpAlpha = [[1, 0], [0, 700]]; this.ak.aR.J = []; this.ak.aR.AddSequence({ duration: 700, alpha: [tmpAlpha], callback: { alpha: alpha = Utils.delegate(this, this.BtnFadeCb) } }); this.ak.aR.RunSequence(); this.jZ = !this.jZ }; Button.prototype.Animate = function (b, repeat) { if (b) if (this.ak.aR == undefined) { this.ak.AddAnimationHandler(); this.BtnFadeCb() } this.mH = b }; Button.prototype.Ticker = function () { if (this.mH && this.ad && this.ak) this.ak.aR.Ticker() }; Button.prototype.RemoveShadowCss = function (style) { }; Button.prototype.update = function () { }; Object.defineProperty(Button.prototype, "x", { get: function () { return this.H.x }, set: function (value) { this.H.x = value } }); Object.defineProperty(Button.prototype, "y", { get: function () { return this.H.y }, set: function (value) { this.H.y = value } }); function Textfield(layer, pos, caption, textColor, style, multiline, verticalAlign, ieShadow, scalableBgrImg) { if (this.constructor !== arguments.callee) return new Textfield; this.L = pos; if (scalableBgrImg != null) { this.cg = new sjs.Sprite(scalableBgrImg, layer, undefined, pos.scalable_bgr); this.cg.xoffset = pos.scalable_bgr.xoffset; this.cg.yoffset = pos.scalable_bgr.yoffset; this.cg.Origin("left", "top") } this.T = new sjs.Sprite(null, layer, undefined, pos, style); if (caption != undefined) this.T.text = caption; this.fo = textColor; if (verticalAlign == undefined) verticalAlign = "middle"; this.T.verticalAlign = verticalAlign; if (multiline == undefined) multiline = false; this.T.multiline = multiline } Textfield.prototype.constructor = Textfield; Object.defineProperty(Textfield.prototype, "actualWidth", { get: function () { return this.T.textContainer.actualWidth } }); Object.defineProperty(Textfield.prototype, "actualHeight", { get: function () { return this.T.textContainer.actualHeight } }); Textfield.prototype.SetOpacity = function (opacity) { this.T.opacity = opacity; this.T.update() }; Textfield.prototype.SetStyle = function (style) { this.T.setStyle(style) }; Textfield.prototype.GetPos = function () { var pos = T.getBounds(); return pos }; Textfield.prototype.Scale = function (scale) { if (scale.x != undefined) this.T.xscale = scale.x; if (scale.y != undefined) this.T.yscale = scale.y; this.T.update() }; Textfield.prototype.rotate = function (v) { this.T.rotate(v); this.T.update() }; Textfield.prototype.SetPos = function (pos) { this.T.setBounds(pos); this.T.update(); this.SetCaptionBgrPos() }; Textfield.prototype.SetCaptionBgrPos = function () { if (this.cg != null) { this.T.textContainer.updateText(); var bgrX = null; var bgrY = this.T.y - this.L.scalable_bgr.yspacing; var bgrWantedWidth; if (this.L.minwidth && this.L.minwidth > this.T.textContainer._width * this.T.textContainer.scale.x + this.L.scalable_bgr.xspacing * 2) bgrWantedWidth = this.L.minwidth; else bgrWantedWidth = this.T.textContainer._width * this.T.textContainer.scale.x + this.L.scalable_bgr.xspacing * 2; var bgrWantedHeight = this.L.scalable_bgr.h; if (this.L.scalable_bgr.alignment == "right") bgrX = this.T.x + (this.L.w - this.T.textContainer._width * this.T.textContainer.scale.x) - this.L.scalable_bgr.xspacing; else if (this.L.scalable_bgr.alignment == "center") bgrX = this.T.x + this.T.w / 2 - bgrWantedWidth / 2; else bgrX = this.T.x - this.L.scalable_bgr.xspacing; if (this.T.multiline) { bgrY = this.T.y + (this.T.h - this.T.textContainer._height) / 2 - this.L.scalable_bgr.yspacing; bgrWantedHeight = this.T.textContainer._height + this.L.scalable_bgr.yspacing * 2; this.cg.yscale = bgrWantedHeight / this.cg._height } else { bgrY = this.T.y + (this.T.h - this.T.textContainer._height) / 2 - this.L.scalable_bgr.yspacing; bgrWantedHeight = this.T.textContainer._height + this.L.scalable_bgr.yspacing * 2; this.cg.yscale = bgrWantedHeight / this.cg._height } this.cg.xscale = bgrWantedWidth / this.cg._width; this.cg.setBounds({ x: bgrX, y: bgrY }) } }; Textfield.prototype.SetText = function (text) { this.T.text = text; this.T.update(); this.SetCaptionBgrPos() }; Textfield.prototype.SetTextColor = function (color) { this.T.textColor = color; this.T.update() }; Textfield.prototype.Show = function (b) { this.T.Visible(b, true); if (this.cg != null) this.cg.Visible(b, true) }; Textfield.prototype.ListenForTouch = function (f) { }; Textfield.prototype.RemoveShadowCss = function (style) { }; Object.defineProperty(Textfield.prototype, "x", { get: function () { return this.T.x }, set: function (value) { if (value == undefined) return; this.T.x = value; if (this.cg) this.SetCaptionBgrPos() } }); KeyBoard = {}; KeyBoard.Showing = false; function MiniLoader() { if (this.constructor !== arguments.callee) return new MiniLoader; this.K = sjs.layers["miniLoaderLayer"] ? sjs.layers["miniLoaderLayer"] : new sjs.Layer("miniLoaderLayer", undefined, undefined); this.bz = new sjs.Sprite(image_path_menu + "ui.png", this.K); this.bz.w = mini_loader.w; this.bz.h = mini_loader.w; this.bz.x = mini_loader.margin; this.bz.y = mini_loader.margin; this.bz.xoffset = mini_loader.xoffset; this.bz.yoffset = mini_loader.yoffset; this.bz.update(); this.Show(false) } MiniLoader.prototype.constructor = MiniLoader; MiniLoader.prototype.Show = function (b) { this.nZ = b; this.K.Show(b) }; USE_SCALE = true; USE_CANVAS_REELS = false; var sjs; (function (global, undefined) { var sjs = { Sprite: Sprite, Solid: Solid, Cycle: Cycle, tproperty: false, Ticker: Ticker, Layer: Layer, OriginFacade: OriginFacade, FormArea: FormArea, useCanvas: false, autoClear: false, layers: {}, dom: null, isPixi: true }; sjs.init = function () { var game_base = document.getElementById("game_base"); this._w = this._w ? this._w : 640; this._h = this._h ? this._h : 320; if (!DEVICE.desktop && !UAGENT_IE) { PIXI.InteractionManager.prototype.onMouseMove = function (event) { }; PIXI.InteractionManager.prototype.onMouseDown = function (event) { }; PIXI.InteractionManager.prototype.onMouseUp = function (event) { } } this.renderer = new PIXI.CanvasRenderer(640, 834); game_base.appendChild(this.renderer.view); var div = this.renderer.view; div.style.overflow = "hidden"; div.style.position = "relative"; div.style.top = "0px"; div.style.left = "0px"; div.style.margin = "auto"; div.id = "sjs"; this.view = new PIXI.Stage(0, true); this.view.interactive = true; this.view.click = this.view.touch = function () { if (DEVICE.desktop) return; launchFullscreen(document.documentElement) }; this.name = "Stage"; this.children = []; this.invalidSprites = []; this.debug = false; this.tick() }; sjs.tick = function () { var l = this.invalidSprites.length; for (var i = 0; i < l; i++) this.invalidSprites[i].__render(); this.invalidSprites = []; this.renderer.render(this.view) }; sjs.setW = function (value) { value = Math.ceil(value); this._w = value; if (this.renderer) this.renderer.resize(this._w, this._h) }; sjs.getW = function () { return this._w }; sjs.getH = function () { return this._h }; sjs.setH = function (value) { value = Math.ceil(value); this._h = value; if (this.renderer) this.renderer.resize(this._w, this._h) }; sjs.spritesLoaded = function () { return ResourceManager.isReady() }; sjs.SetScale = function (scale) { this.view.scale = new PIXI.Point(scale, scale) }; function error(msg) { } function Sprite(src, layer, input, bounds, style, tiling) { if (this.constructor !== arguments.callee) return new Sprite(src, layer, input, bounds, style); if (src) { var texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(src)); if (tiling) { this._tilingFrame = new PIXI.Point(bounds.w || 100, bounds.h || 100); this.view = new PIXI.TilingSprite(texture, this._tilingFrame.x, this._tilingFrame.y) } else this.view = new PIXI.Sprite(texture) } else { this.view = new PIXI.DisplayObjectContainer; this.view.hitArea = new PIXI.Rectangle(0, 0, 0, 0) } this.view.interactive = true; this.view.click = this.view.tap = function () { }; if (!layer) layer = sjs; layer.view.addChild(this.view); this.layer = layer; this.layer.children.push(this); this.useCanvas = true; this._yoffset = 0; this._xoffset = 0; this._x = 0; this._y = 0; this._width = 0; this._height = 0; this._rotation = 0; this.parentStyle = undefined; this.style = undefined; this._text = ""; this._multiline = true; this.autoscale = true; this._align = "left"; this._verticalAlign = false; this._scale = new PIXI.Point(1, 1); this._textColor = undefined; this.origin = new OriginFacade("center", "center"); if (sjs.debug === true) setupDebug(this); if (bounds) this.setBounds(bounds); if (style != undefined) this.setStyle(style); return this } Sprite.prototype = Object.create(Sprite); Sprite.prototype.constructor = Sprite; Object.defineProperty(Sprite.prototype, "w", { get: function () { return this._width }, set: function (value) { this._width = value < 0 ? 0 : value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "h", { get: function () { return this._height }, set: function (value) { this._height = value < 0 ? 0 : value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "yoffset", { get: function () { return this._yoffset }, set: function (value) { this._yoffset = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "xoffset", { get: function () { return this._xoffset }, set: function (value) { this._xoffset = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "x", { get: function () { return this._x }, set: function (value) { this._x = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "y", { get: function () { return this._y }, set: function (value) { this._y = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "xscale", { get: function () { return this._scale.x }, set: function (value) { this.scale(value, this._scale.y) } }); Object.defineProperty(Sprite.prototype, "yscale", { get: function () { return this._scale.y }, set: function (value) { this.scale(this._scale.x, value) } }); Object.defineProperty(Sprite.prototype, "angle", { get: function () { return this._rotation }, set: function (value) { this._rotation = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "opacity", { get: function () { return this.view.alpha }, set: function (value) { this.view.alpha = value } }); Object.defineProperty(Sprite.prototype, "alpha", { get: function () { return this.view.alpha }, set: function (value) { this.view.alpha = value } }); Object.defineProperty(Sprite.prototype, "multiline", { get: function () { return this._multiline }, set: function (value) { this._multiline = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "text", { get: function () { return this._text }, set: function (value) { value = value || ""; value = value.toString(); if (value == this._text) return; if (value != "" && !this.textContainer) { var pixiStyle = CSSLibrary.getStyle(this.style); pixiStyle.wordWrapWidth = this._width; pixiStyle.wordWrap = this._multiline; if (this._textColor != undefined) pixiStyle.fill = this._textColor; this.textContainer = new PNG.Text("", pixiStyle); this.view.addChild(this.textContainer) } this._text = value; this.textContainer.setText(Utils.NormalizeString(value)); this.invalidate() } }); Object.defineProperty(Sprite.prototype, "textColor", { get: function () { if (this._textColor != undefined) return this._textColor; else if (this.style) return CSSLibrary.getStyle(this.style).fill; else if (this.textContainer) return this.textContainer; else return "#000000" }, set: function (value) { this._textColor = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "textAlign", { get: function () { return this._align }, set: function (value) { this.textContainer.align = value } }); Object.defineProperty(Sprite.prototype, "verticalAlign", { get: function () { return this._verticalAlign }, set: function (value) { this._verticalAlign = value; this.invalidate() } }); Object.defineProperty(Sprite.prototype, "visible", { get: function () { return this.view.visible }, set: function (value) { this.view.visible = value } }); setupDebug = function (that) { that.view.mouseover = function (data) { PNGDebugView.install(that); Debug._target = that }; that.view.mouseout = function (data) { if (!that.debugView) return; PNGDebugView.uninstall(); if (Debug._target == that) Debug._target = undefined }; that.view.mousedown = function (data) { event = data.originalEvent; if (event.which === 3 || event.button === 2) console.log(that) } }; Sprite.prototype.getVisible = function () { return this.view.visible }; Sprite.prototype.Visible = function (b, handleAsTable) { this.view.visible = b }; Sprite.prototype.Origin = function (x, y) { this.origin = new OriginFacade(x, y); this.invalidate() }; Sprite.prototype.AddAnimationHandler = function (cb) { this.aR = new AnimationHandler(this, cb) }; Sprite.prototype.rotate = function (value) { this._rotation = value; this.invalidate(); return this }; Sprite.prototype.Fade = function (flag, fadeseq) { if (this.aR == undefined) this.AddAnimationHandler(); this.aR.J = [fadeseq]; this.aR.RunSequence() }; Sprite.prototype.scale = function (x, y) { this._scale = new PIXI.Point(x, y); this.invalidate(); return this }; Sprite.prototype.setAutoScale = function (autoscale) { this.autoscale = autoscale; this.invalidate(); return this }; Sprite.prototype.setResetScale = function (reset) { this.resetscale = reset; return this }; Sprite.prototype.setBounds = function (obj) { if (obj.x != undefined) this._x = obj.x; if (obj.y != undefined) this._y = obj.y; if (obj.w != undefined) this._width = obj.w < 0 ? 0 : obj.w; if (obj.h != undefined) this._height = obj.h < 0 ? 0 : obj.h; this.invalidate(); return this }; Sprite.prototype.setTilingFrame = function (obj) { if (!(obj instanceof PIXI.Point)) throw "setTilingFrame expects a PIXI.Point"; this._tilingFrame = obj; this.invalidate(); return this }; Sprite.prototype.getBounds = function () { var obj = new Object; obj.x = this._x; obj.y = this._y; obj.w = this._width; obj.h = this._height; return obj }; Sprite.prototype.move = function (x, y) { this._x = x; this._y = y; this.invalidate(); return this }; Sprite.prototype.offset = function (x, y) { if (x === undefined) x = this._xoffset; if (y === undefined) y = this._yoffset; this._xoffset = x; this._yoffset = y; this.invalidate() }; Sprite.prototype.invalidate = function () { if (this.invalid === true) return; this.invalid = true; sjs.invalidSprites.push(this) }; Sprite.prototype.__render = function () { if (this.view instanceof PIXI.Sprite) { if (this.view.texture) { if (!this.view.texture.baseTexture.hasLoaded) alert("Resource not loaded: " + this.view.texture.baseTexture.imageUrl); if (this.view instanceof PIXI.TilingSprite) { var text = this.view.texture; var bt = text.baseTexture; text.setFrame({ x: this._xoffset % bt.width, y: this._yoffset % bt.height, height: this._tilingFrame.y > bt.height ? bt.height : this._tilingFrame.y, width: this._tilingFrame.x > bt.width ? bt.width : this._tilingFrame.x }); this.view.width = this._width; this.view.height = this._height } else { var text = this.view.texture; var bt = text.baseTexture; text.setFrame({ x: this._xoffset % bt.width, y: this._yoffset % bt.height, height: this._height > bt.height ? bt.height : this._height, width: this._width > bt.width ? bt.width : this._width }) } } } else { var rect = new PIXI.Rectangle(0, 0, this._width, this._height); this.view.hitArea = rect } if (this.textContainer) { this.textContainer.style.wordWrapWidth = this._width; this.textContainer.scale = new PIXI.Point(1, 1); if (this.style) { var pixiStyle = CSSLibrary.getStyle(this.style); pixiStyle.wordWrapWidth = this._width; pixiStyle.wordWrap = this._multiline; if (this._textColor != undefined) pixiStyle.fill = this._textColor; this.textContainer.setStyle(pixiStyle); this.textContainer.align = pixiStyle.align } else { var style = this.textContainer.style; style.wordWrap = this._multiline; style.wordWrapWidth = this._width; this.textContainer.align = this._align; if (this._textColor != undefined) pixiStyle.fill = this._textColor; this.textContainer.setStyle(style) } if (typeof this._verticalAlign == "string") this.textContainer.verticalAlign = this._verticalAlign; else this.textContainer.verticalAlign = this._verticalAlign === true ? "middle" : "top"; this.textContainer.width = this._width; this.textContainer.height = this._height } this.view.scale = this._scale; if (this.origin) { var op = this.origin.getPoint(this); this.view.pivot = op } this.view.x = this._x; this.view.y = this._y; this.view.rotation = this._rotation; this.invalid = false }; Sprite.prototype.setStyle = function (style) { var t = this; while (t = t.layer) if (t.style) style = t.style + " " + style; this.style = style; this.invalidate() }; Sprite.prototype.setZIndex = function (idx) { if (idx > this.layer.view.children.length - 1) idx = this.layer.view.children.length - 1; this.layer.view.removeChild(this.view); this.layer.view.addChildAt(this.view, idx) }; Sprite.prototype.getZIndex = function () { return this.layer.view.children.indexOf(this.view) }; Sprite.prototype.size = function (w, h) { this._dirty.w = w; this._dirty.h = h; this.invalidate(); return this }; Sprite.prototype.remove = function remove() { this.view.parent.removeChild(this.view) }; Sprite.prototype.validateTextDom = function () { }; Sprite.prototype.attachOn = function (attachPoint) { }; Sprite.prototype.update = function () { return this }; Sprite.prototype.toString = function () { return String(this.x) + "," + String(this.y) }; Sprite.prototype.isPointIn = function pointIn(x, y) { return x >= this.x && x <= this.x + this.w && y >= this.y && y <= this.y + this.h }; Sprite.prototype.areVerticesIn = function areVerticesIn(sprite) { return this.isPointIn(sprite.x, sprite.y) || this.isPointIn(sprite.x + sprite.w, sprite.y) || this.isPointIn(sprite.x + sprite.w, sprite.y) || this.isPointIn(sprite.x, sprite.y + sprite.h) }; Sprite.prototype.collidesWith = function hasCollision(sprites) { if (sprites.length !== undefined) { for (var i = 0, sprite; sprite = sprites[i]; i++) if (this.areVerticesIn(sprite) || sprite.areVerticesIn(this)) return true; return false } return this.areVerticesIn(sprites) || sprites.areVerticesIn(this) }; function Cycle(triplets) { this.triplets = triplets; this.cycleDuration = 0; this.changingTicks = [0]; for (var i = 0, triplet; triplet = triplets[i]; i++) { this.cycleDuration = this.cycleDuration + Math.floor(triplet[2] * (60 / 14)); this.changingTicks.push(this.cycleDuration) } this.changingTicks.pop(); this.sprites = []; this.repeat = true; this.tick = 0 } Cycle.prototype.finished = function () { return this.tick >= this.cycleDuration }; Cycle.prototype.next = function (ticks) { if (ticks === undefined) ticks = 1; this.tick = this.tick + ticks; if (this.tick >= this.cycleDuration) { if (!this.repeat) return this; this.tick = this.tick % this.cycleDuration } for (var i = 0; i < this.changingTicks.length; i++) if (this.tick == this.changingTicks[i]) for (var j = 0, sprite; sprite = this.sprites[j]; j++) { sprite.xoffset = this.triplets[i][0]; sprite.yoffset = this.triplets[i][1] } return this }; Cycle.prototype.reset = function resetCycle() { this.tick = 0; for (var j = 0, sprite; sprite = this.sprites[j]; j++) { sprite.xoffset = this.triplets[0][0]; sprite.yoffset = this.triplets[0][1] } return this }; function Ticker(tickDuration, paint) { if (this.constructor !== arguments.callee) return new Ticker(tickDuration, paint); this.paint = paint; this.tickDuration = tickDuration || 1E3 / 30; this.start = this.lastTick = getTimer(); this.ticksElapsed = 0; this.currentTick = 0; this.lastTicksElapsed = 0; this.frameRate = 0; this.ticks = 0; this.frameRateTime = getTimer() } Ticker.prototype.tick = function () { var that = this; requestAnimFrame(function () { that.tick() }); if (typeof PAUSE != "undefined" && PAUSE == true) return; this.now = getTimer(); if (this.now - this.lastTick <= this.tickDuration) return; if (this.now - this.lastTick > 6E4) this.lastTick = this.now - 6E4; this.lastTicksElapsed = Math.round((this.now - this.lastTick) / this.tickDuration); this.lastTicksElapsed = 1; this.lastTick = this.lastTick + this.tickDuration; if (sjs.debug && this.paint == renderLoop) stats.begin(); this.paint(this); if (sjs.debug && this.paint == renderLoop) stats.end(); this.ticks++ }; Ticker.prototype.getActualFrameRate = function () { var now = getTimer(); var timeDiff = now - this.frameRateTime; if (timeDiff > 1E3 || this.frameRate == 0) { this.frameRate = this.ticks / (timeDiff / 1E3); this.ticks = 0; this.frameRateTime = now } return this.frameRate }; Ticker.prototype.run = function () { var that = this; requestAnimFrame(function () { that.tick() }) }; function Layer(name, options, attachPoint, absolute, pos) { absolute = true; this.useCanvas = true; var pos = pos; if (pos == undefined) pos = { x: 0, y: 0, w: 0, h: 0 }; this._x = 0; this._y = 0; this._width = undefined; this._height = undefined; this._rotation = 0; this._originXDiff = 0; this._originYDiff = 0; this._origin = new OriginFacade("center", "center"); this.invalid = false; this._scale = new PIXI.Point(1, 1); this.children = []; if (this.constructor !== arguments.callee) return new Layer(name, options, attachPoint, absolute, pos); if (attachPoint == undefined) attachPoint = sjs; this._name = name; if (sjs.layers[name] === undefined) sjs.layers[name] = this; else error("Layer " + name + " already exist."); this.view = new PIXI.DisplayObjectContainer; this.aP = true; attachPoint.view.addChild(this.view); this.layer = attachPoint; this.layer.children.push(this); if (pos != undefined) this.setBounds(pos) } Layer.prototype = Object.create(Layer); Layer.prototype.constructor = Layer; Object.defineProperty(Layer.prototype, "xscale", { get: function () { return this.view.scale.x }, set: function (value) { this._scale = this._scale || new PIXI.Point(1, 1); this._scale.x = value; this.invalidate() } }); Object.defineProperty(Layer.prototype, "yscale", { get: function () { return this.view.scale.y }, set: function (value) { this._scale = this._scale || new PIXI.Point(1, 1); this._scale.y = value; this.invalidate() } }); Object.defineProperty(Layer.prototype, "x", { get: function () { return this._x }, set: function (value) { if (value == undefined) return; this._x = value; this.invalidate() } }); Object.defineProperty(Layer.prototype, "angle", { get: function () { return this._rotation }, set: function (value) { this._rotation = value; this.invalidate() } }); Object.defineProperty(Layer.prototype, "opacity", { get: function () { return this.view.alpha }, set: function (value) { this.view.alpha = value } }); Object.defineProperty(Layer.prototype, "y", { get: function () { return this._y }, set: function (value) { if (value == undefined) return; this._y = value; this.invalidate() } }); Object.defineProperty(Layer.prototype, "w", { get: function () { return this._width != undefined ? this._width : this.view.getLocalBounds().width }, set: function (value) { this._width = value } }); Object.defineProperty(Layer.prototype, "h", { get: function () { return this._height != undefined ? this._height : this.view.getLocalBounds().height }, set: function (value) { this._height = value } }); Layer.prototype.setZIndex = function (idx) { if (idx > this.layer.view.children.length - 1) idx = this.layer.view.children.length - 1; this.layer.view.removeChild(this.view); this.layer.view.addChildAt(this.view, idx) }; Layer.prototype.getZIndex = function () { return this.layer.view.children.indexOf(this.view) }; Layer.prototype.setOverflowHidden = function () { }; Layer.prototype.setBounds = function (obj) { obj = obj || {}; if (obj.x === undefined) obj.x = 0; if (obj.y === undefined) obj.y = 0; this._x = obj.x; this._y = obj.y; if (obj.h) this._height = obj.h; if (obj.w) this._width = obj.w; this.invalidate() }; Layer.prototype.rotate = function (v) { this._rotation = v; this.invalidate(); return this }; Layer.prototype.clear = function () { }; Layer.prototype.UpdateOpacity = function () { }; Layer.prototype.Show = function (b) { this.aP = b; this.view.visible = b }; Layer.prototype.Display = function (b) { this.Show(b) }; Layer.prototype.Move = function (posX, posY) { if (posX === undefined) posX = this._x; if (posY === undefined) posY = this._y; this._x = posX; this._y = posY; this.invalidate() }; Layer.prototype.GetPos = function () { var obj = { x: this._x, y: this._y }; return obj }; Layer.prototype.SetScale = function (scale) { this.Scale(scale, scale) }; Layer.prototype.Scale = function (x, y) { this._scale = new PIXI.Point(x, y); this.invalidate() }; Layer.prototype.remove = function () { if (this.view.parent) this.view.parent.removeChild(this.view); this.view = ""; this.layer.children.splice(this.layer.children.indexOf(this), 1); sjs.layers[this.name] = null }; Layer.prototype.Origin = function (x, y) { this.origin = new OriginFacade(x, y); this.invalidate() }; Layer.prototype.__render = function () { if (this.origin) { var o = this.origin.getPoint(this); this.view.pivot = o } else this.view.pivot = new PIXI.Point; this.view.scale = this._scale; this.view.x = this._x; this.view.y = this._y; this.view.rotation = this._rotation; this.invalid = false }; Layer.prototype.invalidate = function () { if (this.invalid === true) return; this.invalid = true; sjs.invalidSprites.push(this) }; function Solid(color, layer, bounds, style) { if (this.constructor !== arguments.callee) return new Solid(color, layer); if (color === undefined) this.color = 0; else { color = color.indexOf("#") >= 0 ? Str.Replace(color, "#", "0x") : color; this.color = eval(color) } this._w = 0; this._h = 0; this.view = new PIXI.Graphics; this.view.interactive = true; this.view.click = this.view.tap = function () { }; if (bounds != undefined) this.setBounds(bounds); this.update(); this.layer = layer || sjs; this.layer.view.addChild(this.view); this.layer.children.push(this); this.alpha = 1; if (sjs.debug) setupDebug(this); return this } Solid.prototype.constructor = Solid; Object.defineProperty(Solid.prototype, "x", { get: function () { return this.view.x }, set: function (value) { this.view.x = value } }); Object.defineProperty(Solid.prototype, "y", { get: function () { return this.view.y }, set: function (value) { this.view.y = value } }); Object.defineProperty(Solid.prototype, "w", { get: function () { return this._w }, set: function (value) { this._w = value; this.update() } }); Object.defineProperty(Solid.prototype, "h", { get: function () { return this._h }, set: function (value) { this._h = value; this.update() } }); Object.defineProperty(Solid.prototype, "opacity", { get: function () { return this.alpha }, set: function (value) { this.alpha = value; this.update() } }); Object.defineProperty(Solid.prototype, "visible", { get: function () { return this.view.visible }, set: function (value) { this.view.visible = value } }); Solid.prototype.Visible = function (b, actAsTable) { this.view.visible = b }; Solid.prototype.setStyle = function (style) { }; Solid.prototype.setBounds = function (obj) { if (obj.x != undefined) this.x = obj.x; if (obj.y != undefined) this.y = obj.y; if (obj.w != undefined) this._w = obj.w; if (obj.h != undefined) this._h = obj.h; this.update(); return this }; Solid.prototype.getBounds = function () { var obj = new Object; if (this.x) obj.x = this.x; if (this.y) obj.y = this.y; obj.w = this._w; obj.h = this._h; return obj }; Solid.prototype.move = function (x, y) { this.x = x; this.y = y; return this }; Solid.prototype.size = function (w, h) { this._w = w; this._h = h; this.update(); return this }; Solid.prototype.scale = function (x, y) { this.view.scale = new PIXI.Point(x, y); return this }; Solid.prototype.remove = function remove() { this.view.parent.removeChild(this.view) }; Solid.prototype.SetColor = function (c) { this.color = c; this.update() }; Solid.prototype.update = function () { this.view.clear(); this.view.beginFill(this.color, this.alpha); this.view.drawRect(0, 0, this._w, this._h); this.view.endFill(); this.view.hitArea = new PIXI.Rectangle(0, 0, this._w, this._h); return this }; function FormArea(layer) { if (this.constructor !== arguments.callee) return new FormArea(layer); if (layer === undefined) { if (sjs.layers["default"] === undefined) sjs.layers["default"] = new Layer("default"); layer = sjs.layers["default"] } this.layer = layer; return this } FormArea.prototype.constructor = FormArea; function OriginFacade(x, y) { this._x = x; this._y = y; this._cache = undefined; this._cachedX = undefined; this._cachedY = undefined } OriginFacade.prototype.constructor = OriginFacade; Object.defineProperty(OriginFacade.prototype, "x", { get: function () { return this._x }, set: function (value) { this._x = value; this._cache = undefined } }); Object.defineProperty(OriginFacade.prototype, "y", { get: function () { return this._y }, set: function (value) { this._y = value; this._cache = undefined } }); OriginFacade.prototype.getPoint = function (target) { if (this._cache && this._cachedX === target.w && this._cachedY === target.h) return this._cache; var p = new PIXI.Point; if (!isNaN(this._x)) p.x = this._x; else if (this._x.indexOf("px") > 0) p.x = Number(this._x.split("px")[0]); else if (this._x.indexOf("%") > 0) p.x = target.w * (Number(this._x.split("%")[0]) / 100); else switch (this._x) { case "left": p.x = 0; break; case "center": p.x = target.w * 0.5; break; case "right": p.x = target.w; break } if (!isNaN(this._y)) p.y = this._y; else if (this._y.indexOf("px") > 0) p.y = Number(this._y.split("px")[0]); else if (this._y.indexOf("%") > 0) p.y = target.h * (Number(this._y.split("%")[0]) / 100); else switch (this._y) { case "top": p.y = 0; break; case "center": p.y = target.h * 0.5; break; case "bottom": p.y = target.h; break } this._cachedX = target.w; this._cachedY = target.h; this._cache = p; return p }; CSSLibrary = { cache: {} }; CSSLibrary.getStyle = function (id) { var obj = CSSLibrary.cache[id]; if (!obj) { var div = document.createElement("div"); document.body.appendChild(div); div.className = id; var obj = {}; var style = window.getComputedStyle(div); var font = style.fontFamily; var weight = style.fontWeight == "bold" ? "bold" : "normal"; var size = style.fontSize; var family = style.fontFamily; obj.font = weight + " " + size + " " + family; obj.wordWrap = true; obj.align = style.textAlign && style.textAlign != "" ? style.textAlign : "left"; if (style.textShadow && style.textShadow != "" && style.textShadow != "none") { obj.dropShadow = true; CSSLibrary.AddShadow(style, obj) } else obj.dropShadow = false; if (style.color) obj.fill = CSSLibrary.RGBToHEX(style.color); else obj.fill = "#000000"; CSSLibrary.cache[id] = obj; document.body.removeChild(div); div = null } var copy = {}; copy.font = obj.font; copy.fill = obj.fill; copy.size = obj.size; copy.wordWrap = obj.wordWrap; copy.align = obj.align; copy.dropShadow = obj.dropShadow; copy.dropShadowColor = obj.dropShadowColor; copy.dropShadowBlur = obj.dropShadowBlur; copy.dropShadowAngle = obj.dropShadowAngle; copy.dropShadowDistance = obj.dropShadowDistance; return copy }; CSSLibrary.AddShadow = function (style, obj) { var s = style.textShadow; if (!s || s == "") return; s = s.toLowerCase(); var x, y, i, i2, r; obj.dropShadowColor = CSSLibrary.RGBToHEX(s); if (s.indexOf("#") >= 0) { i = s.indexOf("#"); s = s.substr(0, i != 0 ? i : Number.MAX_VALUE) } else { i = s.indexOf("rgb("); i2 = s.indexOf(")", i2); s = s.substr(i == 0 ? i2 + 2 : 0, i != 0 ? i : Number.MAX_VALUE) } var a = s.split(" "); x = a[0].split("px")[0]; y = a[1].split("px")[0]; blurValue = a[2].split("px")[0]; obj.dropShadowBlur = Number(blurValue || 0); obj.dropShadowAngle = Math.atan2(y, x); obj.dropShadowDistance = Math.sqrt(x * x + y * y) }; CSSLibrary.RGBToHEX = function (RGB) { RGB = RGB.toLowerCase(); if (RGB.indexOf("#") >= 0) { RGB = RGB.split("#")[1]; RGB = RGB.substring(0, 6); return "#" + RGB } else if (RGB.indexOf("rgb") >= 0) { var a = RGB.split("rgb(")[1]; a = a.split(")")[0]; a = a.split(", "); var r = Number(a[0]).toString(16); r = r.length == 1 ? "0" + r : r; var g = Number(a[1]).toString(16); g = g.length == 1 ? "0" + g : g; var b = Number(a[2]).toString(16); b = b.length == 1 ? "0" + b : b; return "#" + r + g + b } }; global.sjs = sjs })(this); Swipe.DIRECTION_LEFT = 0; Swipe.DIRECTION_RIGHT = 1; Swipe.DIRECTION_UP = 2; Swipe.DIRECTION_DOWN = 3; function Swipe(displayObject, callback, minDistance, maxDuration) { this.callback = callback; this.displayObject = displayObject; this.displayObject.interactive = true; this.displayObject.mousedown = this.displayObject.touchstart = Utils.delegate(this, this.start); this.displayObject.mouseup = this.displayObject.touchend = Utils.delegate(this, this.end); this.displayObject.mouseupoutside = this.displayObject.touchendoutside = Utils.delegate(this, this.end); this.maxDuration = maxDuration; this.minDistance = minDistance || 30; this.startPoint; this.startTime } Swipe.prototype.isValid = function (distance, duration) { var validDistance = this.minDistance <= distance; var validDuration = this.maxDuration == undefined || this.maxDuration >= duration; return validDistance && validDuration }; Swipe.prototype.start = function (interactionData) { this.startTime = getTimer(); this.startPoint = interactionData.global.clone() }; Swipe.prototype.move = function (interactionData) { }; Swipe.prototype.end = function (interactionData) { var duration = getTimer() - this.startTime; var endPoint = interactionData.global; var deltaX = endPoint.x - this.startPoint.x; var deltaY = endPoint.y - this.startPoint.y; var distanceX = Math.abs(deltaX); var distanceY = Math.abs(deltaY); var distance = Math.max(distanceX, distanceY); var direction; if (this.isValid(distance, duration)) { if (distanceX > distanceY) if (deltaX < 0) direction = Swipe.DIRECTION_LEFT; else direction = Swipe.DIRECTION_RIGHT; else if (deltaY < 0) direction = Swipe.DIRECTION_UP; else direction = Swipe.DIRECTION_DOWN; this.callback(direction, distance, duration) } }; CoinShower.MODE_NONE = "mode_none"; CoinShower.MODE_NOSPAWN = "mode_nospawn"; CoinShower.MODE_SPAWN = "mode_spawn"; function CoinShower(pos) { PIXI.DisplayObjectContainer.call(this); var coinShowerAnim = []; this.rN = []; this.ok = []; this.L = pos; this.rK = 10; this.kb; this.rI = false; this._targetValue = 0; this._targetTime = 0; this._startTime = 0; this._currentValue = 0; this._startLimit = pos.start_limit; this._highLimit = 300; this._highMax = 1E3; this._limits = [100, 500, 1E3, 5E3]; this._limitFactor = 1; this._currentMode = CoinShower.MODE_LOW; this._densityValues = [6, 4, 3, 2, 1]; this.mj = new Snd("winCoinTick"); this.CoinTickVolume = 1; var coinsPool = CoinShowerEmitter.createPool(100, this); this.kC = new CoinShowerEmitter(this, coinsPool) } CoinShower.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); CoinShower.prototype.constructor = CoinShower; CoinShower.prototype.setDensityValues = function (densityValues) { this._densityValues = densityValues }; CoinShower.prototype.Animate = function () { for (var i = 0; i < this.ok.length; i++) this.ok[i].Animate(i) }; CoinShower.prototype.HideCoins = function () { this.kC.stop() }; CoinShower.prototype.HandleOrientationChange = function (portait) { }; CoinShower.prototype.StopSound = function () { this.mj.FadeOut(0.1) }; CoinShower.prototype.StartSound = function () { if (!this.mj.isPlaying()) this.mj.PlayForever(this.CoinTickVolume) }; CoinShower.prototype._setDensityValue = function () { if (this._currentValue >= this._targetValue) this._currentMode = CoinShower.MODE_NOSPAWN; else if (this._currentValue < this._limits[0] * this._limitFactor) this._currentMode = CoinShower.MODE_NONE; else this._currentMode = CoinShower.MODE_SPAWN; var density = 0; switch (this._currentMode) { case CoinShower.MODE_NONE: density = 0; break; case CoinShower.MODE_NOSPAWN: density = 0; break; case CoinShower.MODE_SPAWN: var index = 0; for (var i = 0; i < this._limits.length; i++) if (this._currentValue > this._limits[i] * this._limitFactor) index++; density = this._densityValues[index]; break } this.kC.setParameter("density", Math.floor(density)) }; CoinShower.prototype.Tick = function (currentValue) { this._updateValues(currentValue); this._setDensityValue(); this.kC.Tick() }; CoinShower.prototype.start = function (targetValue, targetTime, currentValue) { this._targetValue = targetValue; this._targetTime = targetTime; this._currentValue = currentValue; this._currentMode = CoinShower.MODE_NONE; this._startTime = getTimer(); this._setDensityValue(); this.kC.start() }; CoinShower.prototype._updateValues = function (currentValue) { this._currentValue = currentValue }; CoinShower.prototype.setLimitFactor = function (factorValue) { this._limitFactor = factorValue }; function ExpandingWinCounter(pos, coinShower) { this.L = pos; this.jA = 0; this.wincounter_layer; this.ds; this.he; this.ga; this.gA; this.cO = 0; this.m_loop = 0; this.hq = false; this.sR = this.L.start_limit; this.lX = 1E3; this.bi; this.dr; this.aa; this.cv; this.fV; this.hH; this.bQ = false; this.m_BetSettings; this.m_WinCounterLayerTween = false; this.m_WinCounterLow = false; this.m_WinCounterNormal = false; this.m_WinCounterHigh = false; this.m_WinCounterHigher = false; this.m_WinCounterIsDown = false; this.m_ValueLength = 1; this.m_LastValueLength = 0; this.m_LastTargetValue = 0; this.m_midPoint = 0; this.m_WinCounterStartPosition = 0; this.m_WinCounterCurrentPosition = 0; this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.start; this.m_WinCounterTextRealY = 0; this.m_WinCounterHolderY = this.L.win_counter_holder_upscale_y.start; this.m_WinCounterShadowWidth = 600; this.m_CoinShowerY = -10; this.m_LastWinCounterWidth = 0; this.m_LastShownValue = false; this.m_CurrentScale = 0.75; this.wincounter_layer = sjs.layers["wincounter"] ? sjs.layers["wincounter"] : new sjs.Layer("wincounter", undefined, undefined); this.wincounter_layer.Show(false); this.m_WinCounterTween = false; this.m_WinCounterTextTween = false; this.m_WinCounterRightTextTween = false; this.m_WinCounterLeftTextTween = false; this.m_WinCounterShadowTween = false; this.m_WinCounterHolder = new PIXI.DisplayObjectContainer; this.m_LeftTextHolder = new PIXI.DisplayObjectContainer; this.m_CounterTextHolder = new PIXI.DisplayObjectContainer; this.m_RightTextHolder = new PIXI.DisplayObjectContainer; this.m_WinCounterShadow = PIXI.Sprite.fromImage(image_path_htmlui + "bg_win_counter.png"); this.m_WinCounterShadow.anchor.x = this.m_WinCounterShadow.anchor.y = 0.5; this.m_WinCounterShadow.position.x = this.L.win_counter_shadow_offset[DEVICE.orientation].x; this.m_WinCounterShadow.position.y = this.L.win_counter_shadow_offset[DEVICE.orientation].y; this.ga = new PIXI.Text(Locale.IDS_MENU_WIN, { font: this.L.captions_font_size + "px Oswald, arial", align: "right", fill: "white", dropShadow: true, dropShadowColor: "#000", dropShadowDistance: 0, dropShadowBlur: 1 }); this.gA = new PIXI.Text(CreditFormatter.GetCreditString(Locale.IDS_SLOT_COINS, " "), { font: this.L.captions_font_size + "px Oswald, arial", align: "right", fill: "white", dropShadow: true, dropShadowColor: "#000", dropShadowDistance: 0, dropShadowBlur: 1 }); this.ds = new PNG.BitmapText("0", { font: this.L.counter_font_size + "px oswald", align: "center", monospace: { width: 38 } }); this.m_CounterTextHolder.pivot.set(0, 60); this.m_LeftTextHolder.addChild(this.ga); this.m_CounterTextHolder.addChild(this.ds); this.m_RightTextHolder.addChild(this.gA); this.m_WinCounterHolder.addChild(this.m_WinCounterShadow); this.m_WinCounterHolder.addChild(this.m_LeftTextHolder); this.m_WinCounterHolder.addChild(this.m_CounterTextHolder); this.m_WinCounterHolder.addChild(this.m_RightTextHolder); this.wincounter_layer.view.addChild(this.m_WinCounterHolder); if (coinShower == undefined) this.dj = new CoinShower(pos); else this.dj = coinShower; sjs.layers["coinshower"].view.addChildAt(this.dj, 0); this.dj.x = particles_pos.coinshower.x; this.dj.y = particles_pos.coinshower.y - 80; this.reset(); this.jJ = 0; this.oa = 0 } ExpandingWinCounter.prototype.constructor = ExpandingWinCounter; ExpandingWinCounter.prototype.setBetSettings = function (betSettings) { this.m_BetSettings = betSettings }; ExpandingWinCounter.prototype.setMaxAmountCap = function (val) { this.cO = val }; ExpandingWinCounter.prototype.getMaxAmountCap = function () { return this.cO }; ExpandingWinCounter.prototype.getvalue = function () { return this.aa }; ExpandingWinCounter.prototype.Show = function (b) { this.wincounter_layer.Show(b) }; ExpandingWinCounter.prototype.addWinAmount = function (amount, duration, noSound, hideCoins) { var that = this; this.sb = amount; if (this.cO != 0) if (this.aa + amount > this.cO) amount = this.cO - this.aa; if (amount > 0) { this.wincounter_layer.Show(true); this.m_LeftTextHolder.visible = true; this.m_RightTextHolder.visible = true; this.m_CounterTextHolder.visible = true; if (duration > amount * 150) duration = amount * 150; this.bi += amount; this.dr = getTimer() + duration; this.cv = (this.bi - this.aa) / duration; this.Start(undefined, noSound); if (!UAGENT_SLOW_DEVICE && !hideCoins) { this.hq = true; this.kb = 2E3 } } }; ExpandingWinCounter.prototype.setWinAmount = function (amount, duration) { if (duration == undefined) duration = 0; if (this.cO != 0) if (this.aa + amount > this.cO) amount = this.cO - this.aa; if (amount > 0) { this.wincounter_layer.Show(true); this.m_LeftTextHolder.visible = true; this.m_RightTextHolder.visible = true; this.m_CounterTextHolder.visible = true; this.bi = amount; this.dr = getTimer() + duration; if (duration > 0) this.cv = (this.bi - this.aa) / duration; else this.cv = 0; this.Start(undefined, true); if (!UAGENT_SLOW_DEVICE) { this.hq = true; this.kb = 5500 } } }; ExpandingWinCounter.prototype.adjustDuration = function (duration) { this.dr = getTimer() + duration; if (duration > 0) this.cv = (this.bi - this.aa) / duration; else this.cv = 0 }; ExpandingWinCounter.prototype.SetInfoText = function (text) { if (this.hH && getTimer() > this.dr + this.lX) this.Start(undefined, true); this.m = true; this.wincounter_layer.visible = true; this.m_LeftTextHolder.visible = false; this.m_RightTextHolder.visible = false; this.m_CounterTextHolder.visible = false }; ExpandingWinCounter.prototype.SetSilenceDelay = function (delay) { this.jA = delay + getTimer() }; ExpandingWinCounter.prototype.Start = function (force, noSound) { if (this.bi > this.m_BetSettings.GetBetCoins()) this.dj.start(this.bi, this.dr, this.aa); if (!noSound) this.dj.StartSound(); if (!this.bQ) this.bQ = true; if (this.cv > 0) this.fV = getTimer() }; ExpandingWinCounter.prototype.showSummary = function () { this.hH = true }; ExpandingWinCounter.prototype.reset = function () { this.bi = 0; this.aa = 0; this.m_LastShownValue = false; this.cv = 0; this.Show(false); this.hH = false; this.hq = false; this.dj.StopSound(); this.ds.setText(" "); this.m_WinCounterLow = false; this.m_WinCounterNormal = false; this.m_WinCounterHigh = false; this.m_WinCounterHigher = false; this.m_CurrentScale = 0.6; this.m_CounterTextHolder.scale.set(this.m_CurrentScale); this.m_scaledWidth = this.NewScaleWidth(this.m_CounterTextHolder, this.m_CurrentScale); this.m_scaledHeight = this.NewScaleHeight(this.m_CounterTextHolder, this.m_CurrentScale); this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.start; this.m_WinCounterHolder.y = this.m_WinCounterHolderY; this.m_WinCounterShadowWidth = this.L.win_counter_shadow_width.low; this.m_WinCounterShadow.width = this.m_WinCounterShadowWidth; this.m_WinCounterShadow.height = this.m_scaledHeight * 4; this.m_CounterTextHolder.position.x = this.m_midPoint - this.m_scaledWidth / 2; this.m_CounterTextHolder.position.y = this.m_WinCounterTextY; this.m_LeftTextHolder.position.x = this.m_midPoint - this.m_scaledWidth / 2 - this.m_LeftTextHolder.width - this.L.win_counter_text_offset / 2; this.m_RightTextHolder.position.x = this.m_midPoint + this.m_scaledWidth / 2 + this.L.win_counter_text_offset; this.MoveWinCounterUp() }; ExpandingWinCounter.prototype.showInfo = function () { this.Start(undefined, true); this.hH = false }; ExpandingWinCounter.prototype.flush = function () { this.aa = this.bi; this.dr = getTimer(); this.showValue(this.bi) }; ExpandingWinCounter.prototype.Ticker = function (e) { if (this.aa != this.bi) { var time = getTimer(); if (time < this.dr) this.aa = this.bi - this.cv * (this.dr - time); else { this.aa = this.bi; this.dj.StopSound(); if (this.hH) if (this.fu) this.hH = false } this.showValue(this.aa); if (this.hq && !UAGENT_SLOW_DEVICE); } else { if (this.hq) { this.hq = false; this.jJ = getTimer() + this.kb } if (this.jJ != 0 && this.jJ < getTimer()) { this.jJ = 0; this.dj.HideCoins() } } this.dj.Tick(this.aa) }; ExpandingWinCounter.prototype.Ticking = function (e) { return this.aa != this.bi }; ExpandingWinCounter.prototype.showValue = function (value) { if (value > 0) { this.ds.setText(CreditFormatter.FormatCoinValue(this.aa)); this.m_ValueLength = CreditFormatter.FormatCoinValue(this.aa).replace(/ /g, "").length; this.DefineTweens(); var tweening = false; if (this.aa < this.m_LastShownValue || !this.m_LastShownValue) { this.m_CurrentScale = 0.5; this.m_CounterTextHolder.scale.set(this.m_CurrentScale); this.m_scaledWidth = this.NewScaleWidth(this.m_CounterTextHolder, this.m_CurrentScale); this.m_scaledHeight = this.NewScaleHeight(this.m_CounterTextHolder, this.m_CurrentScale); this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.start; this.m_WinCounterHolder.y = this.m_WinCounterHolderY; this.m_WinCounterShadowWidth = this.L.win_counter_shadow_width.low; this.m_WinCounterShadow.width = this.m_WinCounterShadowWidth; this.m_WinCounterShadow.height = this.m_scaledHeight * 4; this.m_CounterTextHolder.position.x = this.m_midPoint - this.m_scaledWidth / 2; this.m_CounterTextHolder.position.y = this.m_WinCounterTextY; this.m_LeftTextHolder.position.x = this.m_midPoint - this.m_scaledWidth / 2 - this.m_LeftTextHolder.width - this.L.win_counter_text_offset / 2; this.m_RightTextHolder.position.x = this.m_midPoint + this.m_scaledWidth / 2 + this.L.win_counter_text_offset; this.m_LastWinCounterWidth = this.m_CounterTextHolder.width; this.m_LastValueLength = this.m_ValueLength } else if (this.m_LastValueLength < this.m_ValueLength) { tweening = true; this.m_LastValueLength = this.m_ValueLength } if (this.m_ValueLength > 6 && this.m_CurrentScale > 0.75 && !(this.m_LastValueLength === this.m_ValueLength)) { this.m_WinCounterShadowWidth = this.L.win_counter_shadow_width.high; tweening = true } if (this.aa >= 25 * this.m_BetSettings.GetBetCoins() && !this.m_WinCounterHigher) { this.m_CurrentScale = 0.85; this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.higher; this.m_WinCounterHigher = true; tweening = true } else if (this.aa >= 10 * this.m_BetSettings.GetBetCoins() && !this.m_WinCounterHigh && !this.m_WinCounterHigher || this.m_LeftTextHolder.width + this.m_CounterTextHolder.width + this.m_RightTextHolder.width > 800) { this.m_CurrentScale = 0.7; this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.high; this.m_WinCounterHigh = true; tweening = true } else if (this.aa >= 5 * this.m_BetSettings.GetBetCoins() && !this.m_WinCounterNormal && !this.m_WinCounterHigher && !this.m_WinCounterHigh) { this.m_CurrentScale = 0.6; this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.normal; this.m_WinCounterNormal = true; tweening = true } else if (this.aa >= this.m_BetSettings.GetBetCoins() && !this.m_WinCounterLow && !this.m_WinCounterNormal && !this.m_WinCounterHigher && !this.m_WinCounterHigh) { this.m_CurrentScale = 0.55; this.m_WinCounterTextY = this.L.win_counter_text_upscale_y.low; this.m_WinCounterLow = true; tweening = true } if (tweening) { this.m_scaledWidth = this.NewScaleWidth(this.m_CounterTextHolder, this.m_CurrentScale); this.m_scaledHeight = this.NewScaleHeight(this.m_CounterTextHolder, this.m_CurrentScale); this.m_WinCounterTextRealY = gameRes != "320" ? this.L.win_counter_text_upscale_y.start : this.m_WinCounterTextY; this.m_WinCounterTextTween.QueueTween({ x: this.m_midPoint - this.m_scaledWidth / 2, y: this.m_WinCounterTextRealY, scaleX: this.m_CurrentScale, scaleY: this.m_CurrentScale }, 0.1, undefined); this.m_WinCounterRightTextTween.QueueTween({ x: this.m_midPoint + this.m_scaledWidth / 2 + this.L.win_counter_text_offset }, 0.1); this.m_WinCounterLeftTextTween.QueueTween({ x: this.m_midPoint - this.m_scaledWidth / 2 - this.m_LeftTextHolder.width - this.L.win_counter_text_offset / 2 }, 0.1); this.m_WinCounterShadowTween.QueueTween({ width: this.m_WinCounterShadowWidth, height: this.m_scaledHeight * 4 }, 0.1); this.m_WinCounterLeftTextTween.PlayChain(); this.m_WinCounterRightTextTween.PlayChain(); this.m_WinCounterTextTween.PlayChain(); this.m_WinCounterShadowTween.PlayChain() } this.m_LastShownValue = this.aa; this.m_LastWinCounterWidth = this.m_CounterTextHolder.width; value = 0 } }; ExpandingWinCounter.prototype.onTimer = function (e) { }; ExpandingWinCounter.prototype.OnQuickWinView = function (e) { this.cv *= 5; if (this.cv > 0) this.dr = getTimer() + (this.bi - this.aa) / this.cv }; ExpandingWinCounter.prototype.SetLayerYAdj = function (value) { this.oa = value }; ExpandingWinCounter.prototype.HandleOrientationChange = function (portrait) { if (portrait) { this.m_midPoint = 0.83 * this.L.win_counter_text_pos[DEVICE.orientation].pos; this.m_WinCounterHolder.x = 0; this.m_WinCounterHolderY = this.L.win_counter_holder_y.pt; this.m_WinCounterStartPosition = 0.95 * this.L.win_counter_layer_pos.pt.y; this.m_WinCounterUpPosition = 0.95 * this.m_WinCounterStartPosition; this.m_WinCounterDownPosition = 1.04 * this.m_WinCounterStartPosition; this.m_WinCounterCurrentPosition = this.m_WinCounterIsDown ? this.m_WinCounterDownPosition : this.m_WinCounterStartPosition; this.wincounter_layer.Move(this.L.win_counter_layer_pos.pt.x, this.m_WinCounterCurrentPosition); this.dj.y = particles_pos.coinshower.y } else { this.m_midPoint = this.L.win_counter_text_pos[DEVICE.orientation].pos; this.m_WinCounterHolder.x = 0; this.m_WinCounterHolderY = this.L.win_counter_holder_y.ls; this.m_WinCounterStartPosition = 1.015 * this.L.win_counter_layer_pos.ls.y; this.m_WinCounterUpPosition = 0.95 * this.m_WinCounterStartPosition; this.m_WinCounterDownPosition = 1.04 * 0.95 * this.L.win_counter_layer_pos.pt.y; this.m_WinCounterCurrentPosition = this.m_WinCounterStartPosition; this.wincounter_layer.Move(this.L.win_counter_layer_pos.ls.x, this.m_WinCounterCurrentPosition); this.dj.y = particles_pos.coinshower.y - 50 } if (this.m_ValueLength > 6 && this.m_CurrentScale > 0.75) this.m_WinCounterShadowWidth = this.L.win_counter_shadow_width.high; this.m_WinCounterShadow.width = this.m_WinCounterShadowWidth; this.m_CounterTextHolder.position.x = this.m_midPoint - this.m_scaledWidth / 2; this.m_LeftTextHolder.position.x = this.m_midPoint - this.m_scaledWidth / 2 - this.m_LeftTextHolder.width - this.L.win_counter_text_offset / 2; this.m_RightTextHolder.position.x = this.m_midPoint + this.m_scaledWidth / 2 + this.L.win_counter_text_offset; this.m_WinCounterHolder.y = this.m_WinCounterHolderY; this.m_WinCounterShadow.position.x = this.L.win_counter_shadow_offset[DEVICE.orientation].x; this.m_WinCounterShadow.position.y = this.L.win_counter_shadow_offset[DEVICE.orientation].y }; ExpandingWinCounter.prototype.MoveWinCounterUp = function () { if (this.m_WinCounterIsDown) { this.m_WinCounterLayerTween = new TweenChain(this.wincounter_layer, Tweener.SECONDS); this.m_WinCounterLayerTween.QueueTween({ y: this.m_WinCounterStartPosition }, 0, undefined); this.m_WinCounterLayerTween.PlayChain(); this.m_WinCounterIsDown = false; return true } return false }; ExpandingWinCounter.prototype.MoveWinCounterDown = function () { if (!this.m_WinCounterIsDown) { this.m_WinCounterLayerTween = new TweenChain(this.wincounter_layer, Tweener.SECONDS); this.m_WinCounterLayerTween.QueueTween({ y: this.m_WinCounterDownPosition }, 0.2, undefined); this.m_WinCounterLayerTween.PlayChain(); this.m_WinCounterIsDown = true; return true } }; ExpandingWinCounter.prototype.DefineTweens = function () { this.m_WinCounterTween = new TweenChain(this.m_WinCounterHolder, Tweener.SECONDS); this.m_WinCounterTextTween = new TweenChain(this.m_CounterTextHolder, Tweener.SECONDS); this.m_WinCounterRightTextTween = new TweenChain(this.m_RightTextHolder, Tweener.SECONDS); this.m_WinCounterLeftTextTween = new TweenChain(this.m_LeftTextHolder, Tweener.SECONDS); this.m_WinCounterShadowTween = new TweenChain(this.m_WinCounterShadow, Tweener.SECONDS) }; ExpandingWinCounter.prototype.UndefineTweens = function () { this.m_WinCounterTextTween = false; this.m_WinCounterRightTextTween = false; this.m_WinCounterLeftTextTween = false; this.m_WinCounterShadowTween = false }; ExpandingWinCounter.prototype.NewScaleWidth = function (holder, scale) { var currentScale = holder.scaleX * 100; var newScale = scale * 100; var newWidth = holder.width / currentScale * newScale; return newWidth }; ExpandingWinCounter.prototype.NewScaleHeight = function (holder, scale) { var currentScale = holder.scaleX * 100; var newScale = scale * 100; var newHeight = holder.height / currentScale * newScale; return newHeight }; SJSTweener = window.SJSTweener || {}; SJSTweener.TYPE_GENERIC = 0; SJSTweener.TYPE_SPRITE = 1; SJSTweener.TYPE_LAYER = 2; Tweener.SECONDS = "sec"; Tweener.MS = "ms"; Tweener.FRAMES = "frames"; Tweener.T_EASEOUTQUAD = "transition_easeoutquad"; Tweener.T_EASEINQUAD = "transition_easeinquad"; Tweener.T_EASEINOUTQUAD = "transition_easeinoutquad"; Tweener.T_EASEINCUBIC = "transition_easeinquad"; Tweener.T_EASEOUTCUBIC = "transition_easeoutcubic"; Tweener.T_EASEINOUTCUBIC = "transition_easeinoutcubic"; function Tweener() { if (this.constructor !== arguments.callee) return new Tweener; if (!Tweener.Instance) Tweener.Instance = this; this.cR = {} } Tweener.prototype.constructor = Tweener; Tweener.objectIDCounter = 0; Tweener.tweenIDCounter = 0; Tweener.Instance = new Tweener; Tweener.Tick = function () { if (Tweener.Instance) Tweener.Instance.Tick() }; Tweener.AddTween = function (tweenObject) { return Tweener.Instance.AddTween(tweenObject) }; Tweener.StopAndFinishAll = function () { if (Tweener.Instance) { var repeat = true; while (repeat) { for (var k in Tweener.Instance.cR) { var tween = Tweener.Instance.cR[k]; tween.Finish() } repeat = false; for (var k in Tweener.Instance.cR) repeat = repeat && Tweener.Instance.cR[k].IsFinished() } } Tweener.StopAll() }; Tweener.StopAll = function () { if (Tweener.Instance) Tweener.Instance.cR = {} }; Tweener.prototype.AddTween = function (tweenObj) { var tweenObj2 = TweenObject.From(tweenObj); var obj = tweenObj2.obj; var prop; if (tweenObj2.parameter) { prop = {}; prop[tweenObj2.parameter] = tweenObj2.endValue } else prop = tweenObj2.properties; if (!obj.UID) obj.UID = Tweener.objectIDCounter++; for (var k in prop) prop[k] = { startValue: tweenObj2.obj[k], endValue: prop[k] }; tweenObj2.properties = prop; var id = Tweener.tweenIDCounter++; var t = new Tween(tweenObj2); t.id = id; this.cR[obj.UID + ":" + id] = t; return t }; Tweener.prototype.Tick = function () { var tweenCounter = 0; for (var key in this.cR) { tweenCounter++; var currentTween = this.cR[key]; currentTween.Tick(); if (currentTween.IsFinished()) { currentTween.Finish(); delete this.cR[key] } } }; function Tween(tweenObject) { if (this.constructor !== arguments.callee) return new Tween(tweenObj); this.ku = tweenObject.obj; this.ea = tweenObject.properties; this.lc = 1; if (tweenObject.loops) this.lc = tweenObject.loops; this.oK = tweenObject.onComplete; this.os = tweenObject.onStart; this.oO = tweenObject.onTick; this.ov = tweenObject.onLoop; this.fP; this.fE; this.UpdateDuration(tweenObject); if (tweenObject.transitionObject) this.fC = tweenObject.transitionObject; else this.CreateTransition(tweenObject); this.tweenObject = tweenObject; this.bQ = false; this.hC = -1 } Tween.prototype.constructor = Tween; Tween.prototype.UpdateDuration = function (tweenObject) { if (!tweenObject.delay) tweenObject.delay = 0; switch (tweenObject.durationType) { case Tweener.SECONDS: this.fP = tweenObject.duration * 1E3; this.iu = tweenObject.delay * 1E3; this.fE = this.ba = getTimer(); this.aS = Tweener.MS; break; case Tweener.MS: this.fP = tweenObject.duration; this.iu = tweenObject.delay; this.fE = this.ba = getTimer(); this.aS = Tweener.MS; break; case Tweener.FRAMES: default: this.fE = 0; this.fP = tweenObject.duration; this.iu = tweenObject.delay; this.ba = 0; this.aS = Tweener.FRAMES; break } }; Tween.prototype.CreateTransition = function (tweenObject) { switch (tweenObject.transition) { case Tweener.T_EASEOUTQUAD: this.fC = new EaseOutQuad; break; case Tweener.T_EASEINQUAD: this.fC = new EaseInQuad; break; case Tweener.T_EASEINOUTQUAD: this.fC = new EaseInOutQuad; break; case Tweener.T_EASEINCUBIC: this.fC = new EaseInCubic; break; case Tweener.T_EASEOUTCUBIC: this.fC = new EaseOutCubic; break; case Tweener.T_EASEINOUTCUBIC: this.fC = new EaseInOutCubic; break; default: this.fC = new Linear } }; Tween.prototype.Stop = function () { for (var k in Tweener.Instance.cR) if (Tweener.Instance.cR[k] == this) delete Tweener.Instance.cR[k]; return this }; Tween.prototype.IsFinished = function () { if (this.hC != -1) return false; if (this.fP <= this.fE - this.ba - this.iu) { this.lc--; if (this.lc > 0) this.Restart(); else return true } return false }; Tween.prototype.Pause = function () { this.hC = getTimer(); return this }; Tween.prototype.Resume = function () { if (this.aS == Tweener.MS) this.ba += getTimer() - this.hC; this.hC = -1; return this }; Tween.prototype.Restart = function () { this.fE = 0; for (var k in this.ea) this.ku[k] = this.ea[k].startValue; this.UpdateDuration(this.tweenObject); this.CallLoop(); return this }; Tween.prototype.CallStart = function () { if (this.bQ) return; this.bQ = true; if (this.os) this.os() }; Tween.prototype.CallTick = function () { if (this.oO) this.oO() }; Tween.prototype.CallLoop = function () { if (this.ov) this.ov() }; Tween.prototype.Tick = function () { if (this.hC != -1) return; if (this.aS == Tweener.FRAMES) this.fE++; else this.fE = getTimer(); if (this.fE - this.ba > this.iu) { this.CallStart(); var deltaTime = Math.min(this.fE - this.ba - this.iu, this.fP); for (var k in this.ea) this.ku[k] = this.fC.Tick(deltaTime, this.ea[k].startValue, this.ea[k].endValue, this.fP); this.CallTick() } }; Tween.prototype.Finish = function () { for (var k in this.ea) this.ku[k] = this.ea[k].endValue; if (this.oK) this.oK(this.ku); return this }; function TweenObject() { if (this.constructor !== arguments.callee) return new TweenObject; this.obj = undefined; this.properties = undefined; this.duration = undefined; this.delay = 0; this.loops = 1; this.transition = undefined; this.durationType = Tweener.FRAMES; this.onComplete = undefined; this.onStart = undefined; this.onTick = undefined; this.onLoop = undefined; this.transitionObj = undefined; this.parameter = undefined; this.endValue = undefined } TweenObject.prototype.constructor = TweenObject; TweenObject.From = function (sourceObject) { var newObject = new TweenObject; newObject.obj = sourceObject.obj; newObject.properties = {}; for (var key in sourceObject.properties) newObject.properties[key] = sourceObject.properties[key]; newObject.duration = sourceObject.duration; newObject.delay = sourceObject.delay; newObject.loops = sourceObject.loops; newObject.transition = sourceObject.transition; newObject.durationType = sourceObject.durationType; newObject.onComplete = sourceObject.onComplete; newObject.onStart = sourceObject.onStart; newObject.onTick = sourceObject.onTick; newObject.onLoop = sourceObject.onLoop; newObject.transitionObject = sourceObject.transitionObject; newObject.parameter = sourceObject.parameter; newObject.endValue = sourceObject.endValue; return newObject }; TweenObject.Copy = function (sourceObject) { return TweenObject.From(sourceObject) }; function Linear() { if (this.constructor !== arguments.callee) return new Linear } Linear.prototype.constructor = Linear; Linear.prototype.Tick = function (position, startValue, endValue, duration) { return Utils.Lerp(startValue, endValue, position / duration) }; function EaseInQuad() { if (this.constructor !== arguments.callee) return new EaseInQuad } EaseInQuad.prototype.constructor = EaseInQuad; EaseInQuad.prototype.Tick = function (position, startValue, endValue, duration) { var diffValue = endValue - startValue; var time = position / duration; return diffValue * time * time + startValue }; function EaseInOutQuad() { if (this.constructor !== arguments.callee) return new EaseInOutQuad } EaseInOutQuad.prototype.constructor = EaseInOutQuad; EaseInOutQuad.prototype.Tick = function (position, startValue, endValue, duration) { var diffValue = endValue - startValue; var time = position / duration / 2; if (time < 1) return diffValue * 2 * time * time + startValue; time--; return -diffValue / 2 * (time * (time - 2) - 1) + startValue }; function EaseOutQuad() { if (this.constructor !== arguments.callee) return new EaseOutQuad }; EaseOutQuad.prototype.constructor = EaseOutQuad; EaseOutQuad.prototype.Tick = function (position, startValue, endValue, duration) { var diffValue = endValue - startValue; var time = position / duration; return -diffValue * time * (time - 2) + startValue }; function EaseOutCubic() { if (this.constructor !== arguments.callee) return new EaseOutCubic } EaseOutCubic.prototype.constructor = EaseOutCubic; EaseOutCubic.prototype.Tick = function (position, startValue, endValue, duration) { var diffValue = endValue - startValue; var time = position / duration; time--; return diffValue * (time * time * time + 1) + startValue }; function EaseInOutCubic() { if (this.constructor !== arguments.callee) return new EaseInOutCubic } EaseInOutCubic.prototype.constructor = EaseInOutCubic; EaseInOutCubic.prototype.Tick = function (position, startValue, endValue, duration) { var diffValue = endValue - startValue; var time = position / duration / 2; if (time < 1) return diffValue / 2 * time * time * time + startValue; time -= 2; return diffValue / 2 * (time * time * time + 2) + startValue }; function EaseInCubic() { if (this.constructor !== arguments.callee) return new EaseInCubic } EaseInCubic.prototype.constructor = EaseInCubic; EaseInCubic.prototype.Tick = function (position, startValue, endValue, duration) { var diffValue = endValue - startValue; var time = position / duration; return diffValue * time * time * time + b }; function EaseBezier(points) { if (this.constructor !== arguments.callee) return new EaseBezier(points); this.dq = points } EaseBezier.prototype.constructor = EaseBezier; EaseBezier.prototype.Ease = function (points, time) { if (points.length < 1) return { x: 0, y: 0 }; var newPoints = []; for (var i = 1; i < points.length; i++) newPoints.push(this.FindPoint(points[i - 1], points[i], time)); if (newPoints.length == 1) return newPoints[0]; return this.Ease(newPoints, time) }; EaseBezier.prototype.FindPoint = function (startPoint, endPoint, time) { var p = { x: startPoint.x + (endPoint.x - startPoint.x) * time, y: startPoint.y + (endPoint.y - startPoint.y) * time }; return p }; EaseBezier.prototype.Tick = function (position, startValue, endValue, duration) { var time = position / duration; var p = this.Ease(this.dq, time); var length = this.dq[this.dq.length - 1].y - this.dq[0].y; var mod = (p.y - this.dq[0].y) / length; var ret = Math.round((startValue + (endValue - startValue) * mod) * 1E4) * 1.0E-4; return ret }; function TweenChain(targetObject, durationType) { if (this.constructor !== arguments.callee) return new TweenChain(targetObject); this.ge = []; this.lL = targetObject; this.mD = durationType; this.iQ = undefined } TweenChain.prototype.constructor = TweenChain; TweenChain.prototype.QueueTween = function (properties, duration, transitionObject, onComplete, onStart, onLoop, onTick) { var tweenObject = new TweenObject; tweenObject.obj = this.lL; tweenObject.durationType = this.mD; tweenObject.duration = duration; tweenObject.properties = properties; tweenObject.transitionObject = transitionObject; tweenObject.onComplete = onComplete; tweenObject.onStart = onStart; tweenObject.onLoop = onLoop; tweenObject.onTick = onTick; this.QueueTweenObject(tweenObject) }; TweenChain.prototype.QueueTweenObject = function (tweenObject) { tweenObject.ChainIndex = this.ge.length; tweenObject.obj = this.lL; if (this.mD) tweenObject.durationType = this.mD; if (tweenObject.ChainIndex > 0) { var oldOnComplete = this.ge[tweenObject.ChainIndex - 1].onComplete; this.ge[tweenObject.ChainIndex - 1].onComplete = Utils.delegate(this, function () { if (oldOnComplete) oldOnComplete(); this.iQ = Tweener.AddTween(this.ge[tweenObject.ChainIndex]) }) } this.ge.push(tweenObject) }; TweenChain.prototype.PlayChain = function (startIndex) { if (startIndex === undefined) startIndex = 0; if (this.ge.length > 0) this.iQ = Tweener.AddTween(this.ge[startIndex]) }; TweenChain.prototype.StopChain = function () { if (this.iQ != undefined) this.iQ.Stop() }; CrossFadeTransition.EVENT_SHOW_HALF = "event_show_half"; CrossFadeTransition.EVENT_SHOW_FULL = "event_show_full"; CrossFadeTransition.EVENT_HIDE_HALF = "event_hide_half"; CrossFadeTransition.EVENT_HIDE_FULL = "event_hide_full"; function CrossFadeTransition(targetLayer, color, customPos) { this._color = Number(color); if (isNaN(this._color)) this._color = 0; this._layer = targetLayer; var solidSize = { x: 0, y: 0, w: this._layer.w, h: this._layer.h }; if (customPos !== undefined) solidSize = customPos; this._solid = new PIXI.Graphics; this._solid.beginFill(color); this._solid.drawRect(solidSize.x, solidSize.y, solidSize.w, solidSize.h); this._solid.endFill(); this.events = new Signal; this.events.add(Utils.delegate(this, this._onEvent)) } Classify.constr(CrossFadeTransition); CrossFadeTransition.prototype.showLayer = function (time) { var halfTime = time * 0.5; this._solid.alpha = 0; this._layer.view.parent.addChild(this._solid); Tweener.AddTween({ obj: this._solid, properties: { alpha: 1 }, duration: halfTime, durationType: Tweener.SECONDS, onComplete: Utils.delegate(this, function () { this.events.fire({ type: CrossFadeTransition.EVENT_SHOW_HALF, halfTime: halfTime }) }) }) }; CrossFadeTransition.prototype.hideLayer = function (time) { var halfTime = time * 0.5; this._solid.alpha = 0; this._layer.view.parent.addChild(this._solid); Tweener.AddTween({ obj: this._solid, properties: { alpha: 1 }, duration: halfTime, durationType: Tweener.SECONDS, onComplete: Utils.delegate(this, function () { this.events.fire({ type: CrossFadeTransition.EVENT_HIDE_HALF, halfTime: halfTime }) }) }) }; CrossFadeTransition.prototype._onEvent = function (event) { switch (event.type) { case CrossFadeTransition.EVENT_SHOW_HALF: this._layer.Show(true); Tweener.AddTween({ obj: this._solid, properties: { alpha: 0 }, duration: event.halfTime, durationType: Tweener.SECONDS, onComplete: Utils.delegate(this, function () { this.events.fire({ type: CrossFadeTransition.EVENT_SHOW_FULL, halfTime: event.halfTime }) }) }); break; case CrossFadeTransition.EVENT_SHOW_FULL: if (this._solid.parent) this._solid.parent.removeChild(this._solid); break; case CrossFadeTransition.EVENT_HIDE_HALF: this._layer.Show(false); Tweener.AddTween({ obj: this._solid, properties: { alpha: 0 }, duration: event.halfTime, durationType: Tweener.SECONDS, onComplete: Utils.delegate(this, function () { this.events.fire({ type: CrossFadeTransition.EVENT_HIDE_FULL, halfTime: event.halfTime }) }) }); break; case CrossFadeTransition.EVENT_HIDE_FULL: if (this._solid.parent) this._solid.parent.removeChild(this._solid); break } }; PNG = {}; PNG.JsonLoader = function (url, crossorigin) { PIXI.EventTarget.call(this); this.url = url; this.crossorigin = crossorigin; this.baseUrl = url.replace(/[^\/]*$/, ""); this.loaded = false; this.parsers = []; this.retries = 0; this.maxRetries = 3; this.addParser(new PNG.TexturePackerParser); this.addParser(new PNG.SpineParser); this.addParser(new PNG.ZoeParser); this.addParser(new PNG.DragonbonesParser); this.addParser(new PNG.SoundManagerParser); this.addParser(new PNG.WebfontParser); this.addParser(new PNG.JSONResourceParser) }; PNG.JsonLoader.prototype.constructor = PNG.JsonLoader; PNG.JsonLoader.prototype.addParser = function (parser) { this.parsers.push(parser) }; PNG.JsonLoader.prototype.load = function () { if (window.XDomainRequest) this.ajaxRequest = new window.XDomainRequest; else if (window.XMLHttpRequest) this.ajaxRequest = new window.XMLHttpRequest; else this.ajaxRequest = new window.ActiveXObject("Microsoft.XMLHTTP"); var scope = this; this.ajaxRequest.onload = function () { scope.onJSONLoaded() }; this.ajaxRequest.open("GET", this.url, true); this.ajaxRequest.send() }; PNG.JsonLoader.prototype.onJSONLoaded = function () { if (!this.ajaxRequest.readyState || this.ajaxRequest.readyState === 4) if (!this.ajaxRequest.status || this.ajaxRequest.status === 200 || window.location.protocol.indexOf("http") === -1) { var re = /\/\*.*\*\//g; this.parseJSON(this.ajaxRequest.responseText.replace(re, "")) } else if (this.ajaxRequest.status !== 404 && ++this.retries < this.maxRetries) { var scope = this; setTimeout(function () { scope.load() }, 500) } else if (typeof onLoaderError !== "undefined") onLoaderError() }; PNG.JsonLoader.prototype.parseJSON = function (json) { this.json = JSON.parse(json); var l = this.parsers.length; for (var i = 0; i < l; i++) if (this.parsers[i].canHandle(this.json)) { this.parsers[i].handle(this.json, this); return } this.onLoaded() }; PNG.JsonLoader.prototype.cleanUp = function () { delete this.json; delete this.ajaxRequest; delete this.parsers }; PNG.JsonLoader.prototype.onLoaded = function () { this.loaded = true; this.dispatchEvent({ type: "loaded", content: this }) }; PNG.JsonLoader.prototype.onError = function () { this.dispatchEvent({ type: "error", content: this }) }; PNG.JsonLoaderParser = function () { }; PNG.JsonLoaderParser.prototype.constructor = PNG.JsonLoaderParser; PNG.JsonLoaderParser.prototype.constructor.canHandle = function (json) { return false }; PNG.JsonLoaderParser.prototype.constructor.handle = function (json) { }; PNG.TexturePackerParser = function () { }; PNG.TexturePackerParser.prototype = Object.create(PNG.JsonLoaderParser.prototype); PNG.TexturePackerParser.prototype.constructor = PNG.TexturePackerParser; PNG.TexturePackerParser.prototype.canHandle = function (json) { return json.frames != undefined && json.meta != undefined }; PNG.TexturePackerParser.prototype.handle = function (json, loader) { var textureUrl = loader.baseUrl + json.meta.image; var image = new PIXI.ImageLoader(textureUrl, loader.crossorigin); var frameData = json.frames; loader.texture = image.texture.baseTexture; image.addEventListener("loaded", function () { loader.onLoaded() }); for (var i in frameData) { var rect = frameData[i].frame; if (rect) { PIXI.TextureCache[i] = new PIXI.Texture(loader.texture, { x: rect.x, y: rect.y, width: rect.w, height: rect.h }); if (frameData[i].trimmed) { var texture = PIXI.TextureCache[i]; var actualSize = frameData[i].sourceSize; var realSize = frameData[i].spriteSourceSize; texture.trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h) } } } image.load() }; PNG.SpineParser = function () { }; PNG.SpineParser.prototype = Object.create(PNG.JsonLoaderParser.prototype); PNG.SpineParser.prototype.constructor = PNG.SpineParser; PNG.SpineParser.prototype.canHandle = function (json) { return json.bones != undefined }; PNG.SpineParser.prototype.handle = function (json, loader) { var spineJsonParser = new spine.SkeletonJson; var skeletonData = spineJsonParser.readSkeletonData(json); PIXI.AnimCache[this.url] = skeletonData; loader.onLoaded() }; PNG.ZoeParser = function () { }; PNG.ZoeParser.prototype = Object.create(PNG.JsonLoaderParser.prototype); PNG.ZoeParser.prototype.constructor = PNG.ZoeParser; PNG.ZoeParser.prototype.canHandle = function (json) { return json.frames != undefined && json.animations != undefined }; PNG.ZoeParser.prototype.handle = function (json, loader) { var movieClipName = loader.url.substring(loader.url.lastIndexOf("/") + 1, loader.url.length - 5); PNG.MovieClip.addToParseQueue({ json: json, name: movieClipName }); loader.onLoaded() }; PNG.DragonbonesParser = function () { }; PNG.DragonbonesParser.prototype = Object.create(PNG.JsonLoaderParser.prototype); PNG.DragonbonesParser.prototype.constructor = PNG.DragonbonesParser; PNG.DragonbonesParser.prototype.canHandle = function (json) { return json.armature != undefined && json.name != undefined && json.version != undefined }; PNG.DragonbonesParser.prototype.handle = function (json, loader) { var name = loader.url.substring(loader.url.lastIndexOf("/") + 1, loader.url.length - 5); PixiSkeleton.register(json, name); loader.onLoaded() }; PNG.WebfontParser = function () { }; PNG.WebfontParser.prototype = Object.create(PNG.JsonLoaderParser.prototype); PNG.WebfontParser.prototype.constructor = PNG.WebfontParser; PNG.WebfontParser.prototype.canHandle = function (json) { return json.WebFontConfig != undefined }; PNG.WebfontParser.prototype.handle = function (json, loader) { config = JSON.parse(JSON.stringify(json.WebFontConfig)); if (config.custom && config.custom.urls) for (var k in config.custom.urls) config.custom.urls[k] = loader.baseUrl + config.custom.urls; config.active = function () { loader.onLoaded() }; config.fontinactive = function (familyName, fvd) { console.error("Error loading font", familyName, fvd) }; config.inactive = function () { console.error("Some font wasn't loaded properly"); loader.onLoaded() }; config.events = true; WebFont.load(config) }; PNG.SoundManagerParser = function () { }; PNG.SoundManagerParser.prototype = Object.create(PNG.JsonLoaderParser.prototype); PNG.SoundManagerParser.prototype.constructor = PNG.SoundManagerParser; PNG.SoundManagerParser.prototype.canHandle = function (json) { return json.soundBufferId != undefined && json.sounds != undefined }; PNG.SoundManagerParser.prototype.handle = function (json, loader) { if (json.url != undefined && json.url.substr(0, 4) != "http") json.url = loader.baseUrl + json.url; SoundManager.ParseObject(json); loader.onLoaded() }; PNG.JSONResourceParser = function () { }; PNG.JSONResourceParser.prototype = Object.create(PNG.JSONResourceParser.prototype); PNG.JSONResourceParser.prototype.constructor = PNG.JSONResourceParser; PNG.JSONResourceParser.prototype.canHandle = function (json) { return json.resourceJSON === true }; PNG.JSONResourceParser.prototype.handle = function (json, loader) { var prefix = ""; if (window.resRoot) prefix = resRoot; for (var k in json.images) PIXI.BaseTexture.fromBase64(prefix + k.replace(/\\/g, "/"), json.images[k]); var k; var subloaders = 0; var completed = 0; var subloader; var startedAll = false; var callback = function (evt) { evt.content.removeEventListener("loaded", callback); if (++completed === subloaders && startedAll === true) loader.onLoaded() }; for (k in json.json) { subloader = new PNG.JsonLoader(prefix + k, loader.crossorigin); subloader.addEventListener("loaded", callback); subloaders++; var content = json.json[k]; if (content.indexOf('"') === -1) content = content.replace(/'/g, '"'); subloader.parseJSON(content) } for (k in json.xml) { subloader = new PIXI.BitmapFontLoader(prefix + k, loader.crossOrigin); subloader.addEventListener("loaded", callback); subloaders++; var xml = json.xml[k]; if (window.DOMParser) { parser = new DOMParser; xmlDoc = parser.parseFromString(xml, "text/xml") } else { xmlDoc = new ActiveXObject("Microsoft.XMLDOM"); xmlDoc.async = false; xmlDoc.loadXML(xml) } subloader.parseXML(xmlDoc) } if (completed === subloaders) loader.onLoaded(); startedAll = true }; PNG.AssetLoader = function (assetURLs, crossorigin) { PIXI.EventTarget.call(this); this.assetURLs = assetURLs; this.crossorigin = crossorigin; this.loaders = []; this.loadersByType = { "jpg": PIXI.ImageLoader, "jpeg": PIXI.ImageLoader, "png": PIXI.ImageLoader, "gif": PIXI.ImageLoader, "json": PNG.JsonLoader, "atlas": PIXI.AtlasLoader, "anim": PIXI.SpineLoader, "xml": PIXI.BitmapFontLoader, "fnt": PIXI.BitmapFontLoader } }; PNG.AssetLoader.prototype.constructor = PNG.AssetLoader; PNG.AssetLoader.prototype._getDataType = function (str) { var test = "data:"; var start = str.slice(0, test.length).toLowerCase(); if (start === test) { var data = str.slice(test.length); var sepIdx = data.indexOf(","); if (sepIdx === -1) return null; var info = data.slice(0, sepIdx).split(";")[0]; if (!info || info.toLowerCase() === "text/plain") return "txt"; return info.split("/").pop().toLowerCase() } return null }; PNG.AssetLoader.prototype.load = function () { var scope = this; function onLoad(evt) { scope.onAssetLoaded(evt.content) } this.loadCount = this.assetURLs.length; for (var i = 0; i < this.assetURLs.length; i++) { var fileName = this.assetURLs[i]; var fileType = this._getDataType(fileName); if (!fileType) fileType = fileName.split("?").shift().split(".").pop().toLowerCase(); var Constructor = this.loadersByType[fileType]; if (!Constructor) throw new Error(fileType + " is an unsupported file type"); var loader = new Constructor(fileName, this.crossorigin); loader.addEventListener("loaded", onLoad); loader.load(); this.loaders.push(loader) } }; PNG.AssetLoader.prototype.onAssetLoaded = function (loader) { this.loadCount--; this.loaders.splice(this.loaders.indexOf(loader), 1); this.dispatchEvent({ type: "onProgress", content: this, loader: loader }); if (this.onProgress) this.onProgress(loader); if (!this.loadCount) { PNG.MovieClip.parseAll(); this.dispatchEvent({ type: "onComplete", content: this }); if (this.onComplete) this.onComplete() } }; PNG.BitmapText = function (text, style) { PIXI.DisplayObjectContainer.call(this); this._wantedWidth = 0; this._wantedHeight = 0; this._compensate = new PIXI.Point; this._align = style.align || "left"; this._verticalAlign = "top"; this._pool = []; this.setText(text); this.setStyle(style); this.updateText(); this.dirty = false }; PNG.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PNG.BitmapText.prototype.constructor = PNG.BitmapText; PNG.BitmapText.prototype.setText = function (text) { this.text = text || " "; this.text = this.text.toString(); this.dirty = true }; Object.defineProperty(PNG.BitmapText.prototype, "fontSize", { get: function () { return this._fontSize }, set: function (value) { this._fontSize = value; this.dirty = true } }); PNG.BitmapText.prototype.setStyle = function (style) { style = style || {}; if (typeof style == "string") style = CSSLibrary.getStyle(style); style.align = style.align || "left"; this.style = style; var font = style.font.split(" "); this.fontName = font[font.length - 1]; if (!PIXI.BitmapText.fonts[this.fontName]) throw Error("Bitmapfont " + this.fontName + " doesn't exist!"); this._fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size; this.dirty = true; this.tint = style.tint; var copy = function (target) { var n = {}; for (var k in target) if (typeof target[k] != "object") n[k] = target[k]; return n }; var original, data; if (style.fill && style.fill.toLowerCase() !== "#ffffff") { var originalName = this.fontName; this.fontName += "_" + style.fill.replace("#", ""); if (!PIXI.BitmapText.fonts[this.fontName]) { original = PIXI.BitmapText.fonts[originalName]; data = copy(original); data.chars = {}; for (var k in original.chars) { data.chars[k] = copy(original.chars[k]); data.chars[k].kerning = original.chars[k].kerning; data.chars[k].texture = (new PIXI.Sprite(original.chars[k].texture)).generateGrayTexture() } PIXI.BitmapText.fonts[this.fontName] = data } } if (style.monospace) { var monospace = style.monospace.width; var exempt = style.monospace.exempt || [32, 44, 46]; original = PIXI.BitmapText.fonts[this.fontName]; data = copy(original); data.chars = {}; this.fontData = data; for (var k in original.chars) { data.chars[k] = copy(original.chars[k]); data.chars[k].kerning = original.chars[k].kerning; data.chars[k].texture = original.chars[k].texture; if (exempt.indexOf(Number(k)) == -1) data.chars[k].xAdvance = monospace; else data.chars[k].xAdvance = monospace / 2 } } else this.fontData = PIXI.BitmapText.fonts[this.fontName] }; PNG.BitmapText.prototype.updateText = function () { var data = this.fontData; var pos = new PIXI.Point; var prevCharCode = null; var chars = []; var maxLineWidth = 0; var lineWidths = []; var line = 0; var scale = this._fontSize / data.size; for (var i = 0; i < this.text.length; i++) { var charCode = this.text.charCodeAt(i); if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) { lineWidths.push(pos.x); maxLineWidth = Math.max(maxLineWidth, pos.x); line++; pos.x = 0; pos.y += data.lineHeight; prevCharCode = null; continue } var charData = data.chars[charCode]; if (!charData) continue; if (prevCharCode && charData[prevCharCode]) pos.x += charData.kerning[prevCharCode]; var space = charData.xAdvance / 2 - charData.texture.width / 2; chars.push({ texture: charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset + space, pos.y + charData.yOffset) }); pos.x += charData.xAdvance; prevCharCode = charCode } lineWidths.push(pos.x); maxLineWidth = Math.max(maxLineWidth, pos.x); var lineAlignOffsets = []; for (i = 0; i <= line; i++) { var alignOffset = 0; if (this.style.align === "right") alignOffset = maxLineWidth - lineWidths[i]; else if (this.style.align === "center") alignOffset = (maxLineWidth - lineWidths[i]) / 2; lineAlignOffsets.push(alignOffset) } var lenChildren = this.children.length; var lenChars = chars.length; var tint = this.tint || 16777215; for (i = 0; i < lenChars; i++) { var c = i < lenChildren ? this.children[i] : this._pool.pop(); if (c) c.setTexture(chars[i].texture); else c = new PIXI.Sprite(chars[i].texture); c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale; c.position.y = chars[i].position.y * scale; c.scale.x = c.scale.y = scale; c.tint = tint; if (!c.parent) this.addChild(c) } while (this.children.length > lenChars) { var child = this.getChildAt(this.children.length - 1); this._pool.push(child); this.removeChild(child) } this.textWidth = maxLineWidth * scale; this.textHeight = (pos.y + data.lineHeight) * scale; if (this._wantedWidth != 0 || this._wantedHeight != 0) this.updateOffsets() }; PNG.BitmapText.prototype.updateOffsets = function () { if (this._originalScaleX) { this.scale.x = this._originalScaleX; this._originalScaleX = undefined } if (this._originalScaleY) { this.scale.y = this._originalScaleY; this._originalScaleY = undefined } var x = this.x; var y = this.y; this._compensate = new PIXI.Point; if (this._wantedWidth != 0 && this._wantedWidth * this.scale.x < this.textWidth) { this._originalScaleX = this.scale.x; this.scale.x = this._wantedWidth / (this.textWidth / this.scale.x) } else if (this._wantedWidth != 0 && this._align != "left") { switch (this._align) { case "center": this._compensate.x = this._wantedWidth / 2 - this.textWidth / 2; break; case "right": this._compensate.x = this._wantedWidth - this.textWidth; break } this._compensate.x *= this.scale.x } else this._compensate.x = 0; if (this._wantedHeight != 0 && this._wantedHeight * scale.y < this.textHeight) { this._originalScaleY = this.scale.y; this.scale.y = this._wantedHeight / (this.textHeight / this.scale.y) } else if (this._wantedHeight != 0 && this._verticalAlign != "top") { switch (this._verticalAlign) { case "middle": this._compensate.y = this._wantedHeight / 2 - this.textHeight / 2; break; case "bottom": this._compensate.y = this._wantedHeight - this.textHeight; break } this._compensate.y *= this.scale.y } else this._compensate.y = 0; this.x = x; this.y = y }; Object.defineProperty(PNG.BitmapText.prototype, "width", { get: function () { return this._wantedWidth != 0 ? this._wantedWidth : this.textWidth }, set: function (value) { this._wantedWidth = value; this.dirty = true } }); Object.defineProperty(PNG.BitmapText.prototype, "height", { get: function () { return this._wantedHeight != 0 ? this._wantedHeight : this._height }, set: function (value) { this._wantedHeight = value; this.dirty = true } }); Object.defineProperty(PNG.BitmapText.prototype, "x", { get: function () { return this.position.x - this._compensate.x }, set: function (value) { this.position.x = value + this._compensate.x } }); Object.defineProperty(PNG.BitmapText.prototype, "y", { get: function () { return this.position.y - this._compensate.y }, set: function (value) { this.position.y = value + this._compensate.y } }); Object.defineProperty(PNG.BitmapText.prototype, "align", { get: function () { return this._align }, set: function (value) { this._align = value; this.style.align = value || "left"; this.setStyle(this.style) } }); Object.defineProperty(PNG.BitmapText.prototype, "verticalAlign", { get: function () { return this._verticalAlign }, set: function (value) { this._verticalAlign = value } }); PNG.BitmapText.prototype.updateTransform = function () { if (this.dirty) { this.updateText(); this.dirty = false } PIXI.DisplayObjectContainer.prototype.updateTransform.call(this) }; PNG.Text = function (text, style) { if (typeof style == "string") style = CSSLibrary.getStyle(style); this._wantedWidth = 0; this._wantedHeight = 0; this._compensate = new PIXI.Point; this._doOffset = true; this._autoScale = true; this._verticalAlign = "top"; PIXI.Text.call(this, text, style); if (!style || !style.wordWrap) this.style.wordWrap = false }; PNG.Text.prototype = Object.create(PIXI.Text.prototype); PNG.Text.prototype.constructor = PNG.Text; PNG.Text.prototype.setStyle = function (style) { if (typeof style == "string") { style = CSSLibrary.getStyle(style); style.wordWrapWidth = this.width } this._align = style ? style.align || "left" : "left"; PIXI.Text.prototype.setStyle.call(this, style) }; PNG.Text.prototype.updateText = function () { this.scale.x = 1; this.scale.y = 1; PIXI.Text.prototype.updateText.call(this); this.updateOffsets() }; PNG.Text.prototype.updateOffsets = function () { var x = this.x; var y = this.y; this._compensate = new PIXI.Point; if (this._autoScale && this._wantedWidth != 0 && this.width < this._width) this.scale.x = this.width / this._width; else if (this._wantedWidth != 0 && this._align != "left") { switch (this._align) { case "center": this._compensate.x = this._wantedWidth / 2 - this._width / 2; break; case "right": this._compensate.x = this._wantedWidth - this._width; break } this._compensate.x *= this.scale.x } if (this._autoScale && this._wantedHeight != 0 && this._wantedHeight < this._height) this.scale.y = this._wantedHeight / this._height; else if (this._wantedHeight != 0 && this._verticalAlign != "top") { switch (this._verticalAlign) { case "middle": this._compensate.y = this._wantedHeight / 2 - this._height / 2; break; case "bottom": this._compensate.y = this._wantedHeight - this._height; break } this._compensate.y *= this.scale.y } this.x = x; this.y = y }; Object.defineProperty(PNG.Text.prototype, "width", { get: function () { return this._wantedWidth != 0 ? this._wantedWidth : this.scale.x * this.texture.frame.width }, set: function (value) { this._wantedWidth = value; this.style.wordWrapWidth = value; this.dirty = true } }); Object.defineProperty(PNG.Text.prototype, "height", { get: function () { return this._wantedHeight != 0 ? this._wantedHeight : this.scale.x * this.texture.frame.height }, set: function (value) { this._wantedHeight = value; this.dirty = true } }); Object.defineProperty(PNG.Text.prototype, "actualWidth", { get: function () { if (this.dirty) this.updateText(); return this.scale.x * this.texture.frame.width } }); Object.defineProperty(PNG.Text.prototype, "actualHeight", { get: function () { return this.scale.x * this.texture.frame.height } }); Object.defineProperty(PNG.Text.prototype, "x", { get: function () { return this.position.x - this._compensate.x }, set: function (value) { this.position.x = Math.round(value + this._compensate.x) } }); Object.defineProperty(PNG.Text.prototype, "y", { get: function () { return this.position.y - this._compensate.y }, set: function (value) { this.position.y = Math.round(value + this._compensate.y) } }); Object.defineProperty(PNG.Text.prototype, "align", { get: function () { return this._align }, set: function (value) { this._align = value; this.style.align = value || "left"; this.setStyle(this.style); this.dirty = true } }); Object.defineProperty(PNG.Text.prototype, "verticalAlign", { get: function () { return this._verticalAlign }, set: function (value) { this._verticalAlign = value; this.dirty = true } }); Object.defineProperty(PNG.Text.prototype, "autoScale", { get: function () { return this._autoScale }, set: function (value) { this._autoScale = value; this.dirty = true } }); PNG.MovieClip = function (textures) { if (!(textures instanceof Array)) { this._frameLabels = textures; for (var k in textures) { textures = textures[k].textures; break } PIXI.MovieClip.call(this, textures); this.animationSpeed = this._frameLabels[k].animationSpeed } else PIXI.MovieClip.call(this, textures) }; PNG.MovieClip.prototype = Object.create(PIXI.MovieClip.prototype); PNG.MovieClip.prototype.constructor = PNG.MovieClip; PNG.MovieClip.prototype.clone = function () { var mc = new PNG.MovieClip(this._frameLabels ? this._frameLabels : this.textures); mc.x = this.x; mc.y = this.y; mc.scale = this.scale; mc.rotation = this.rotation; mc.alpha = this.alpha; mc.anchor = this.anchor; mc.visible = this.visible; mc.animationSpeed = this.animationSpeed; return mc }; PNG.MovieClip.prototype.gotoAndPlay = function (frame, customAnimationSpeed) { if (typeof frame == "string") { if (this._frameLabels) { this.textures = this._frameLabels[frame].textures; this.animationSpeed = customAnimationSpeed || this._frameLabels[frame].animationSpeed } else throw "This movieclip hasn't got any framelabels"; frame = 0 } PIXI.MovieClip.prototype.gotoAndPlay.call(this, frame) }; PNG.MovieClip.prototype.gotoAndStop = function (frame, customAnimationSpeed) { if (typeof frame == "string") { if (this._frameLabels) { this.textures = this._frameLabels[frame].textures; this.animationSpeed = customAnimationSpeed || this._frameLabels[frame].animationSpeed } else throw "This movieclip hasn't got any framelabels"; frame = 0 } PIXI.MovieClip.prototype.gotoAndStop.call(this, frame) }; PNG.MovieClip.__cache = {}; PNG.MovieClip.__parseQueue = []; PNG.MovieClip.addToParseQueue = function (valueObject) { PNG.MovieClip.__parseQueue.push(valueObject) }; PNG.MovieClip.store = function (name, labels) { PNG.MovieClip.__cache[name] = labels; PNG.MovieClip.__textureCache = undefined }; PNG.MovieClip.parseAll = function () { while (PNG.MovieClip.__parseQueue.length > 0) { var vo = PNG.MovieClip.__parseQueue.pop(); var json = vo.json; var labels = {}; for (var name in json.animations) { var current = json.animations[name]; var textures = []; var frames = current.frames; for (var i = 0; i < frames.length; i++) { var texture = PIXI.Texture.fromFrame(json.images[frames[i]]); textures.push(texture) } labels[name] = { textures: textures, animationSpeed: current.speed } } PNG.MovieClip.store(vo.name, labels) } }; PNG.MovieClip.get = function (mcName) { if (PNG.MovieClip.__cache[mcName]) return new PNG.MovieClip(PNG.MovieClip.__cache[mcName]); else return null }; function Particle() { PIXI.DisplayObjectContainer.call(this) } Particle.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); Particle.prototype.constructor = Particle; Particle.prototype.init = function (emitter) { var point = emitter.getPos(parent); this.x = point.x; this.y = point.y }; Particle.prototype.tick = function (part) { }; Particle.prototype.tickCompleted = function () { return false }; Emitter.TICK_TIME = 42; function Emitter(mc, pool, parent) { if (pool == undefined) pool = null; this.bS; this.ee = mc; this.ko = pool; this.hk = false; this.lv = false } Emitter.prototype.constructor = Emitter; Emitter.prototype.attachTo = function (mc) { if (this.ee && this.hk) this.stop(); this.ee = mc }; Emitter.prototype.setEmitterPos = function (pos) { this.sj = pos }; Emitter.prototype.start = function () { this.bS = getTimer(); this.hk = true }; Emitter.prototype.stop = function () { this.hk = false }; Emitter.prototype.onEnterFrame = function () { var aTime = getTimer(); var prevTickPos = this.bS % Emitter.TICK_TIME; var eTime = this.bS + Emitter.TICK_TIME - prevTickPos; if (eTime > aTime) eTime = aTime; if (prevTickPos > 0) { this.tick((eTime - this.bS) / Emitter.TICK_TIME); if (eTime <= aTime) this.tickCompleted(); this.bS = eTime } while (this.bS + Emitter.TICK_TIME <= aTime && this.hk) { this.tick(1); this.tickCompleted(); this.bS += Emitter.TICK_TIME } if (aTime > this.bS && this.hk) { this.tick((aTime - this.bS) / Emitter.TICK_TIME); this.bS = aTime } }; Emitter.prototype.tick = function (part) { }; Emitter.prototype.tickCompleted = function () { }; Emitter.prototype.getPos = function (o) { return { x: 0, y: 0 } }; Emitter.prototype.setParameter = function (name, value) { }; Emitter.prototype.getMC = function () { return this.ee }; function ListItem(o) { this.fl = null; this.cZ = null; this.pA = o } ListItem.prototype.constructor = ListItem; ListItem.prototype.getNext = function () { return this.cZ }; ListItem.prototype.getObj = function () { return this.pA }; ListItem.prototype.link = function (prev, next) { this.fl = prev; this.cZ = next }; ListItem.prototype.unLink = function () { if (this.fl) this.fl.cZ = this.cZ; if (this.cZ) this.cZ.fl = this.fl }; ListItem.prototype.linkTo = function (source) { this.cZ = source.cZ; if (this.cZ) this.cZ.fl = this; source.cZ = this; this.fl = source }; function Pool(size, particleClass, mc) { if (mc == undefined) mc = null; this.attachMC(mc); this.kQ = new ListItem(null); this.cJ = new ListItem(null); this.TICK_TIME = 42; var i; this.fR = []; for (i = 0; i < size; i++) this.fR[i] = new ListItem(new particleClass); this.kQ.link(null, this.fR[0]); for (i = 0; i < size; i++) this.fR[i].link(i < 1 ? this.kQ : this.fR[i - 1], i < size ? this.fR[i + 1] : null) } Pool.prototype.constructor = Pool; Pool.prototype.attachMC = function (mc) { this.detach(); this.ee = mc; this.bS = getTimer() }; Pool.prototype.detach = function () { this.ee = null }; Pool.prototype.add = function () { var ret = this.kQ.getNext(); if (ret) { ret.unLink(); ret.linkTo(this.cJ); if (this.ee) this.ee.addChild(ret.getObj()); return ret.getObj() } return null }; Pool.prototype.free = function (particle) { particle.unLink(); particle.linkTo(this.kQ) }; Pool.prototype.onEnterFrame = function (e) { var aTime = getTimer(); var prevTickPos = this.bS % this.TICK_TIME; var eTime = this.bS + this.TICK_TIME - prevTickPos; if (eTime > aTime) { this.tick((aTime - this.bS) / this.TICK_TIME); this.bS = aTime } else { this.tick((eTime - this.bS) / this.TICK_TIME); this.tickCompleted(); this.bS = eTime } while (this.bS + this.TICK_TIME <= aTime) { this.tick(1); this.tickCompleted(); this.bS += this.TICK_TIME } if (aTime > this.bS) { this.tick((aTime - this.bS) / this.TICK_TIME); this.bS = aTime } }; Pool.prototype.tick = function (part) { var a = this.cJ.getNext(); while (a) { var next = a.getNext(); var p = a.getObj(); p.tick(part); a = next } }; Pool.prototype.tickCompleted = function () { var a = this.cJ.getNext(); while (a) { var next = a.getNext(); var p = a.getObj(); if (!p.tickCompleted()) { if (p.parent) p.parent.removeChild(p); this.free(a) } a = next } }; function CoinShowerEmitter(mc, pool) { if (pool == undefined) pool = null; Emitter.call(this, mc, pool); this.hD = 0; this.pR = 0 } CoinShowerEmitter.prototype = Object.create(Emitter.prototype); CoinShowerEmitter.prototype.constructor = CoinShowerEmitter; CoinShowerEmitter.prototype.Tick = function () { this.onEnterFrame(); this.ko.onEnterFrame() }; CoinShowerEmitter.prototype.setDensity = function (density) { this.pR = density }; CoinShowerEmitter.start = function () { Emitter.prototype.start.call(this); this.hD = 0 }; CoinShowerEmitter.prototype.stop = function () { var items = this.ko.fR; for (var i = 0; i < items.length; i++); Emitter.prototype.stop.call(this) }; CoinShowerEmitter.prototype.tickCompleted = function () { if (this.hD++ % this.pR == 0) { var item1 = this.ko.add(); if (item1) item1.init(this) } }; CoinShowerEmitter.createPool = function (size, mc) { return new Pool(size, CoinShowerEmitterItem, mc) }; CoinShowerEmitter.prototype.setParameter = function (name, value) { if (name == "density") this.setDensity(value) }; var DEBUG_ITEM = undefined; CoinShowerEmitterItem.frames = []; for (var i = 0; i < 16; i++) CoinShowerEmitterItem.frames.push("bitmap-" + (10001 + i).toString() + ".png.png"); function CoinShowerEmitterItem() { Particle.call(this); this.hD = 0; this.nU = 0; this.nq = 0; this._currentScale = this.hY = 0.5; this.sX; this.ee; this.L = particles_pos.coinshower; this.H = new PIXI.MovieClip.fromFrames(CoinShowerEmitterItem.frames); this.H.loop = true; this.H.animationSpeed = 0.33; this.H.currentFrame = Utils.RandRange(0, 15); this.H.pivot.x = this.H.pivot.y = this.H.width * 0.5; this.addChild(this.H); DEBUG_ITEM = this }; CoinShowerEmitterItem.prototype = Object.create(Particle.prototype); CoinShowerEmitterItem.prototype.constructor = CoinShowerEmitterItem; CoinShowerEmitterItem.prototype.init = function (emitter) { Particle.prototype.init.call(this, emitter); this.reset(); this.x = 0; this.y = 0; this.scaleX = this.scaleY = this.hY; this.H.rotation = Math.PI * 2 * Math.random(); this.H.currentFrame = Utils.RandRange(0, 15); this.H.play() }; CoinShowerEmitterItem.prototype.reset = function () { var a = this.L.angle(); var r = this.L.radius(); this.nU = Math.sin(a) * r; this.nq = -Math.cos(a) * r; this.hD = this.L.cntstart; this.hY = this.L.scalestart; this.x = 0; this.y = 0; this.scaleX = this.scaleY = this.hY; this.H.stop() }; CoinShowerEmitterItem.prototype.tick = function (part) { this.x += this.nU * part; this.y += this.nq * part; this.scaleX = this.scaleY = this.hY; this.H.rotation += 0.3 * Math.random() }; CoinShowerEmitterItem.prototype.tickCompleted = function () { this.nq += this.L.ymoverate; this.hY += this.L.scalerate; this.hD--; var isAlive = this.hD > 0; isAlive = this.y < this.L.y_kill_level; if (!isAlive) this.reset(); return isAlive }; var __extends = this.__extends || function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() { this.constructor = d } __.prototype = b.prototype; d.prototype = new __ }; var dragonBones; (function (dragonBones) { (function (display) { var PixiDisplayBridge = function () { var blendModeMap = { "add": PIXI.blendModes.ADD, "alpha": PIXI.blendModes.NORMAL, "darken": PIXI.blendModes.DARKEN, "difference": PIXI.blendModes.DIFFERENCE, "erase": PIXI.blendModes.NORMAL, "hardlight": PIXI.blendModes.HARD_LIGHT, "invert": PIXI.blendModes.NORMAL, "layer": PIXI.blendModes.NORMAL, "lighten": PIXI.blendModes.LIGHTEN, "multiply": PIXI.blendModes.MULTIPLY, "normal": PIXI.blendModes.NORMAL, "overlay": PIXI.blendModes.OVERLAY, "screen": PIXI.blendModes.NORMAL, "shader": PIXI.blendModes.NORMAL, "subtract": PIXI.blendModes.NORMAL }; function PixiDisplayBridge() { } PixiDisplayBridge.prototype.getVisible = function () { return this._display ? this._display.visible : false }; PixiDisplayBridge.prototype.setVisible = function (value) { if (this._display) this._display.visible = value }; PixiDisplayBridge.prototype.getDisplay = function () { return this._display }; PixiDisplayBridge.prototype.setDisplay = function (value) { if (this._display == value) return; var index = -1; if (this._display) { var parent = this._display.parent; if (parent) index = this._display.parent.children.indexOf(this._display); this.removeDisplay() } this._display = value; this.addDisplay(parent, index) }; PixiDisplayBridge.prototype.dispose = function () { this._display = null }; PixiDisplayBridge.prototype.updateTransform = function (matrix, transform) { this._display.x = matrix.tx; this._display.y = matrix.ty; this._display.skewX = transform.skewX; this._display.skewY = transform.skewY; this._display.scale.x = transform.scaleX; this._display.scale.y = transform.scaleY }; PixiDisplayBridge.prototype.updateBlendMode = function (blendMode) { if (this._display) this._display.blendMode = blendModeMap[blendMode] }; PixiDisplayBridge.prototype.updateColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier) { if (this._display) this._display.alpha = aMultiplier }; PixiDisplayBridge.prototype.addDisplay = function (container, index) { var parent = container; if (parent && this._display) if (index < 0) parent.addChild(this._display); else parent.addChildAt(this._display, Math.min(index, parent.children.length)) }; PixiDisplayBridge.prototype.removeDisplay = function () { if (this._display && this._display.parent) this._display.parent.removeChild(this._display) }; PixiDisplayBridge.RADIAN_TO_ANGLE = 180 / Math.PI; return PixiDisplayBridge }(); display.PixiDisplayBridge = PixiDisplayBridge })(dragonBones.display || (dragonBones.display = {})); var display = dragonBones.display; (function (textures) { var PixiTextureAtlas = function () { function PixiTextureAtlas(image, textureAtlasRawData, scale) { if (typeof scale === "undefined") scale = 1; this._regions = {}; this.image = image; this.scale = scale; this.parseData(textureAtlasRawData) }; PixiTextureAtlas.prototype.dispose = function () { this.image = null; this._regions = null }; PixiTextureAtlas.prototype.getRegion = function (subTextureName) { return this._regions[subTextureName] }; PixiTextureAtlas.prototype.parseData = function (textureAtlasRawData) { var textureAtlasData = dragonBones.objects.DataParser.parseTextureAtlasData(textureAtlasRawData, this.scale); this.name = textureAtlasData.__name; delete textureAtlasData.__name; for (var subTextureName in textureAtlasData) this._regions[subTextureName] = textureAtlasData[subTextureName] }; return PixiTextureAtlas }(); textures.PixiTextureAtlas = PixiTextureAtlas })(dragonBones.textures || (dragonBones.textures = {})); var textures = dragonBones.textures; (function (factorys) { var PixiFactory = function (_super) { __extends(PixiFactory, _super); function PixiFactory() { _super.call(this) } PixiFactory.prototype._generateArmature = function () { var view = new PIXI.Dragonbones.Armature; var armature = new dragonBones.Armature(view); view.armature = armature; return armature }; PixiFactory.prototype._generateSlot = function () { var slot = new dragonBones.Slot(new display.PixiDisplayBridge); return slot }; PixiFactory.prototype._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) { var texture = PIXI.Texture.fromFrame(fullName + ".png"); var image = new PIXI.Dragonbones.Slot(texture); image.pivot.x = pivotX; image.pivot.y = pivotY; return image }; return PixiFactory }(factorys.BaseFactory); factorys.PixiFactory = PixiFactory })(dragonBones.factorys || (dragonBones.factorys = {})); var factorys = dragonBones.factorys })(dragonBones || (dragonBones = {})); dragonBones.parseJSONAtlas = function (atlasJson, name, partsList) { var bonesAtlas = {}; bonesAtlas.name = name; bonesAtlas.SubTexture = []; var n = partsList.length; var subTextures = atlasJson.frames; var isArray = Array.isArray(subTextures); var k = 0; if (isArray) k = subTextures.length; var partName; var txData; var filename; var hasExtension; function createFrame(txData, p_partName) { var frame = txData.frame; var subTexture = { name: p_partName }; subTexture.x = frame.x; subTexture.y = frame.y; subTexture.width = frame.w; subTexture.height = frame.h; bonesAtlas.SubTexture[i] = subTexture } for (var i = 0; i < n; i++) { partName = partsList[i]; hasExtension = partName.match(/.png/i) !== null; if (hasExtension) { filename = partName; partName = filename.substr(-4) } else filename = partName + ".png"; if (isArray) for (var j = 0; j < k; j++) { txData = subTextures[j]; if (txData.filename == filename) { createFrame(txData, partName); break } } else for (var s in subTextures) if (s == filename) { createFrame(subTextures[s], partName); break } } return bonesAtlas }; PIXI.Dragonbones = {}; function PixiSkeleton(json, name) { this.name = name || json.name; if (PixiSkeleton.nK != PIXI.TextureCache.length) { PixiSkeleton.nB = Object.keys(PIXI.TextureCache); PixiSkeleton.nK = PIXI.TextureCache.length } PixiSkeleton.nl.addSkeletonData(dragonBones.objects.DataParser.parseSkeletonData(json), this.name); var textureData = dragonBones.parseJSONAtlas(PIXI.TextureCache, this.name, PixiSkeleton.nB); new dragonBones.textures.PixiTextureAtlas(undefined, textureData); PixiSkeleton.ki[this.name] = this } PixiSkeleton.prototype.constructor = PixiSkeleton; PixiSkeleton.prototype.create = function (armatureName) { return PixiSkeleton.nl.buildArmature(armatureName, "", this.name) }; PixiSkeleton.ki = {}; PixiSkeleton.register = function (json, name) { return new PixiSkeleton(json, name) }; PixiSkeleton.create = function (skeletonName, armatureName) { PixiSkeleton.get(skeletonName).create(armatureName) }; PixiSkeleton.exists = function (name) { return PixiSkeleton.ki[name] !== undefined }; PixiSkeleton.get = function (name) { return PixiSkeleton.ki[name] }; PixiSkeleton.nl = new dragonBones.factorys.PixiFactory; PixiSkeleton.nB = null; PixiSkeleton.nK = -1; function PixiArmature(name, skeleton) { return PixiSkeleton.nl.buildArmature(name, "", skeleton) } PixiArmature.prototype.constructor = PixiArmature; function ArmaturePool() { this._pools = {} } ArmaturePool.prototype.getArmature = function (id) { var pool = this._getPool(id); var armature; return armature = new PixiArmature(id); if (pool.length === 0) armature = new PixiArmature(id); else armature = pool.pop(); return armature }; ArmaturePool.prototype.recycle = function (armature) { var pool = this._getPool(armature.name); var displayObject = armature.getDisplay(); if (displayObject.parent) displayObject.parent.removeChild(displayObject); armature.dispose() }; ArmaturePool.prototype._getPool = function (id) { if (!this._pools[id]) this._pools[id] = new Array; return this._pools[id] }; PIXI.Dragonbones.Armature = function () { PIXI.DisplayObjectContainer.call(this) }; PIXI.Dragonbones.Armature.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Dragonbones.Armature.prototype.constructor = PIXI.Dragonbones.Armature; Object.defineProperty(PIXI.Dragonbones.Armature.prototype, "blendMode", { get: function () { return this._blendMode }, set: function (value) { this._blendMode = value; if (value == PIXI.blendModes.ADD) for (var i = 0; i < this.children.length; i++) this.children[i].blendMode = value } }); PIXI.Dragonbones.Armature.prototype.setStageReference = function () { dragonBones.animation.WorldClock.clock.add(this.armature); PIXI.DisplayObjectContainer.prototype.setStageReference.apply(this, arguments) }; PIXI.Dragonbones.Armature.prototype.removeStageReference = function () { dragonBones.animation.WorldClock.clock.remove(this.armature); PIXI.DisplayObjectContainer.prototype.removeStageReference.apply(this, arguments) }; PIXI.Dragonbones.Armature.prototype.updateTransform = function () { if (!this.visible) return; this._updateTransform(); if (this._cacheAsBitmap) return; for (var i = 0, j = this.children.length; i < j; i++) this.children[i].updateTransform() }; PIXI.Dragonbones.Armature.prototype.gotoAndPlay = function () { return this.armature.animation.gotoAndPlay.apply(this.armature.animation, arguments) }; PIXI.Dragonbones.Armature.prototype.getSlot = function () { return this.armature.getSlot.apply(this.armature, arguments) }; PIXI.Dragonbones.Armature.prototype._updateTransform = function () { if (this.skewX !== this._skewXCache) { this._skewXCache = this.skewX; this._cx = Math.cos(this.skewX); this._sx = Math.sin(this.skewX) } if (this.skewY !== this._skewYCache) { this._skewYCache = this.skewY; if (this.skewY === this.skewX) { this._cy = this._cx; this._sy = this._sx } else { this._cy = Math.cos(this.skewY); this._sy = Math.sin(this.skewY) } } var parentTransform = this.parent.worldTransform; var worldTransform = this.worldTransform; var px = this.pivot.x; var py = this.pivot.y; var a00 = this._cy * this.scale.x, a01 = -this._sx * this.scale.y, a10 = this._sy * this.scale.x, a11 = this._cx * this.scale.y, a02 = this.position.x - a00 * px - py * a01, a12 = this.position.y - a11 * py - px * a10, b00 = parentTransform.a, b01 = parentTransform.b, b10 = parentTransform.c, b11 = parentTransform.d; worldTransform.a = b00 * a00 + b01 * a10; worldTransform.b = b00 * a01 + b01 * a11; worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx; worldTransform.c = b10 * a00 + b11 * a10; worldTransform.d = b10 * a01 + b11 * a11; worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty; this.worldAlpha = this.alpha * this.parent.worldAlpha }; PIXI.Dragonbones.Slot = function (texture) { PIXI.Sprite.call(this, texture) }; PIXI.Dragonbones.Slot.prototype = Object.create(PIXI.Sprite.prototype); PIXI.Dragonbones.Slot.prototype.constructor = PIXI.Dragonbones.Slot; PIXI.Dragonbones.Slot.prototype.updateTransform = function () { if (!this.visible) return; this._updateTransform(); if (this._cacheAsBitmap) return; for (var i = 0, j = this.children.length; i < j; i++) this.children[i].updateTransform() }; PIXI.Dragonbones.Slot.prototype._updateTransform = function () { if (this.skewX !== this._skewXCache) { this._skewXCache = this.skewX; this._cx = Math.cos(this.skewX); this._sx = Math.sin(this.skewX) } if (this.skewY !== this._skewYCache) { this._skewYCache = this.skewY; if (this.skewY === this.skewX) { this._cy = this._cx; this._sy = this._sx } else { this._cy = Math.cos(this.skewY); this._sy = Math.sin(this.skewY) } } var parentTransform = this.parent.worldTransform; var worldTransform = this.worldTransform; var px = this.pivot.x; var py = this.pivot.y; var a00 = this._cy * this.scale.x, a01 = -this._sx * this.scale.y, a10 = this._sy * this.scale.x, a11 = this._cx * this.scale.y, a02 = this.position.x - a00 * px - py * a01, a12 = this.position.y - a11 * py - px * a10, b00 = parentTransform.a, b01 = parentTransform.b, b10 = parentTransform.c, b11 = parentTransform.d; worldTransform.a = b00 * a00 + b01 * a10; worldTransform.b = b00 * a01 + b01 * a11; worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx; worldTransform.c = b10 * a00 + b11 * a10; worldTransform.d = b10 * a01 + b11 * a11; worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty; this.worldAlpha = this.alpha * this.parent.worldAlpha }; function ReelManager(cb) { this.pg = 100; this.lQ = 2E3; this.ao = cb; this.kf; this.or; this.ab; this.bj = 0; this.kk; this.cl; this.fg; this.bv; this.eC; this.jB; this.az; this.bh; this.du; this.eA; this.ni = false; this.fA = 0; this.aU = 0; this.le; this.jI; this.iz; this.bo; this.nC = [2, 1, 3, 0, 4]; this.mC = [0, 0, 0, 0]; this.C; this.ez; this.eL; this.dE; this.bQ; this.bQ = false; this.C = true; this.eC = false; this.eA = false; this.jB = false; this.kk = [0, 2 * 83, 4 * 83, 6 * 83, 8 * 83]; this.le = 1500; this.jI = 1E3; this.az = 0; this.cl = false; this.iz = false; this.bh = false; this.ab = []; this.ez = 0; this.eL = 2 } ReelManager.prototype.constructor = ReelManager; ReelManager.prototype.getMinFullSpinningTime = function () { return this.lQ }; ReelManager.prototype.setMinFullSpinningTime = function (value) { this.lQ = value }; ReelManager.prototype.getFreeSpinLength = function () { return this.jI }; ReelManager.prototype.setFreeSpinLength = function (value) { this.jI = value }; ReelManager.prototype.getSpinLength = function () { return this.le }; ReelManager.prototype.getReelPos = function () { return this.bv }; ReelManager.prototype.setSpinLength = function (value) { this.le = value }; ReelManager.prototype.getStartDelayed = function () { return this.jB }; ReelManager.prototype.setStartDelayed = function (value) { this.jB = value }; ReelManager.prototype.setReelSpinStartDelay = function (value) { this.kk = value }; ReelManager.prototype.getAllReelsStop = function () { return this.eC }; ReelManager.prototype.setAllReelsStop = function (value) { this.eC = value }; ReelManager.prototype.getNumReels = function () { return this.az }; ReelManager.prototype.SetScatterRows = function (start, end) { this.ez = start; this.eL = end }; ReelManager.prototype.destroy = function () { if (this.ab != null) for (var i = 0; i < this.ab.length; i++) { var reel = this.ab[i]; reel.destroy() } this.ab = [] }; ReelManager.prototype.GetReel = function (reel) { return this.ab[reel] }; ReelManager.prototype.AddReel = function (reel) { this.ab.push(reel); this.az++ }; ReelManager.prototype.SetLayout = function (paylineLayouts) { this.bo = paylineLayouts }; ReelManager.prototype.SetReelMaps = function (reelMaps) { this.kf = reelMaps; this.or = true }; ReelManager.prototype.ReconnectEnd = function () { this.C = false; for (var i = 0; i < this.ab.length; i++) this.ab[i].ReconnectEnd() }; ReelManager.prototype.GetPaylineSymbolIndex = function (reel, payline) { var symbols = this.ab[0].getNumSymbols(); return this.bv[reel * symbols + this.bo[payline][reel]] }; ReelManager.prototype.GetLayout243 = function (payline, layout) { if (layout == undefined) layout = null; var reels = this.ab.length; if (layout == null) layout = []; var symbols = this.ab[0].getNumSymbols(); var divider = 1; for (var i = 0; i < reels; i++) { layout[i] = payline % symbols; payline /= symbols } return layout }; ReelManager.prototype.GetSymbolIndex = function (reel, row) { var symbols = this.ab[0].getNumSymbols(); return this.bv[row + reel * symbols] }; ReelManager.prototype.GetPaylineSymbol = function (reel, payline) { return this.ab[reel].GetSymbol(this.bo[payline][reel]) }; ReelManager.prototype.GetSymbol = function (reel, row) { return this.ab[reel].GetSymbol(row) }; ReelManager.prototype.GetSymbolIndexArray = function (symbol) { var grid = []; for (var i = 0; i < this.az; i++) { var numSymbols = this.ab[i].getNumSymbols(); var range = this.eL - this.ez + 1; for (var j = this.ez; j < numSymbols && j <= this.eL; j++) { var tmp = this.bv[j + i * numSymbols]; if (tmp == symbol) grid.push(j + i * range - this.ez) } } return grid }; ReelManager.prototype.AnimateLine = function (num, line, firstFlag, startPos) { if (startPos == undefined) startPos = 0; for (var i = 0; i < num; i++) { var loopCycle = undefined; var skipAnim = false; var reel = this.ab[i]; index = this.bo[line][i]; currentSymbol = this.bv[i * 3 + index]; if (!this.C) this.GetPaylineSymbol(startPos + i, line).Animate(firstFlag, currentSymbol, index, false, loopCycle) } }; ReelManager.prototype.AnimateScatter = function (symbol, firstFlag, data) { for (var i = 0; i < this.az; i++) { var numSymbols = this.ab[i].getNumSymbols(); for (var j = this.ez; j < numSymbols && j <= this.eL; j++) { var tmp = this.bv[j + i * numSymbols]; if (tmp == symbol) this.GetSymbol(i, j).Animate(firstFlag, data) } } }; ReelManager.prototype.AnimateSymbols = function (symbols, firstFlag) { var rowNum = this.ab[0].getNumSymbols(); for (var i = 0; i < symbols.length; i++) { var row = symbols[i] % rowNum; var reel = Math.floor(symbols[i] / rowNum); this.GetSymbol(reel, row).Animate(firstFlag) } }; ReelManager.prototype.StopAllAnimations = function () { for (var i = 0; i < this.ab.length; i++) this.ab[i].StopAllAnimations() }; ReelManager.prototype.StopReel = function (reel, delay) { this.ao("reelstopping", reel); this.ao("reelstop", reel); this.ab[reel].StopSpin(false, this.ni && this.bh, delay) }; ReelManager.prototype.ReelStopped = function (reel) { }; ReelManager.prototype.OnReelStop = function (eEvent) { if (!this.bQ) return }; ReelManager.prototype.Tick = function (diff) { var anyActive = false; for (var i = 0; i < this.az; i++) if (this.ab[i].Ticker(diff)) anyActive = true; var time = getTimer(); if (this.iz) if (this.aU < time || this.C) if (this.InternalStopReels(time - this.aU)) { if (!anyActive) { this.bQ = false; this.ao("allstopped", -1); this.iz = false } } else if (this.dE != null) this.aU = this.dE[this.bj - 1]; if (this.jB && this.fg) { for (i = 0; i < this.az; i++) if (time > this.mC[i] && !this.ab[i].getStarted()) this.ab[i].StartSpin(time - this.mC[i]); var done = true; for (i = 0; i < this.az; i++) if (!this.ab[i].getStarted()) { done = false; break } if (done) { this.cl = false; this.fg = false } } }; ReelManager.prototype.StopReels = function (freeSpinMode, spinStopTimes) { var i; for (i = 0; i < this.ab.length; i++) this.ab[i].SetFreeSpinMode(freeSpinMode); this.bh = freeSpinMode; if (this.C) { this.fg = false; while (!this.InternalStopReels(0)); this.bQ = false; this.ao("allstopped", -1) } else { this.iz = true; if (this.du) { if (this.aU < getTimer()) { var diff = getTimer() - this.aU; this.aU = getTimer(); for (i = 0; i < this.dE.length; i++) this.dE[i] += diff } } else { if (!this.bh) this.aU = this.fA + this.le; else this.aU = this.fA + this.jI; this.dE = spinStopTimes; if (this.dE) { if (this.aU < getTimer()) this.aU = getTimer(); for (i = 0; i < this.dE.length; i++) this.dE[i] += this.aU } } } }; ReelManager.prototype.NextStop = function (time) { this.aU = getTimer() + time }; ReelManager.prototype.setReelStopOrder = function (array) { this.nC = array }; ReelManager.prototype.InternalStopReels = function (delay) { if (delay == undefined) delay = 0; if (!this.cl) { this.SetReels(); this.cl = true } if (this.bj < this.az) if (this.eC) { var reel = this.nC[this.bj]; this.StopReel(reel, delay); this.bj++ } else if (this.du && this.eA) { for (var i = this.bj; i < this.az; i++) this.StopReel(i, delay); this.bj = this.az } else { this.StopReel(this.bj, delay); this.bj++ } else return true; return false }; ReelManager.prototype.NextReels = function (reels) { this.bv = reels }; ReelManager.prototype.SetReels = function (reel) { if (reel == undefined) reel = -1; if (this.or) return this.SetMappedReels(reel); var reels = this.bv; for (var reelNr = 0; reelNr < this.az; reelNr++) if (reel == -1 || reel == reelNr) { var numSymbols = this.ab[reelNr].getNumSymbols(); for (var i = 0; i < numSymbols; i++) { var symbol = reels[i + reelNr * numSymbols]; this.ab[reelNr].GetSymbol(i).SetSymbol(symbol); if (this.ab[reelNr].SetSpinnerSymbols) this.ab[reelNr].SetSpinnerSymbols(i, symbol) } } }; ReelManager.prototype.SetReelSymbol = function (reel, symbolIndex) { var reels = this.bv; var numSymbols = this.ab[reel].getNumSymbols(); var symbol = reels[symbolIndex + reel * numSymbols]; this.ab[reel].GetSymbol(symbolIndex).SetSymbol(symbol) }; ReelManager.prototype.SetMappedReels = function (reel) { if (reel == undefined) reel = -1; var reels = this.bv; for (var reelNr = 0; reelNr < this.az; reelNr++) if (reel == -1 || reel == reelNr) for (var i = 0; i < 5; i++) { var reelMap = this.kf[reelNr]; if (reelMap == null) reelMap = this.kf[0]; if (reelMap != null) { var stop = reels[reelNr] + (reelMap.length - 3); var symbol = reelMap[(stop + i) % reelMap.length]; this.ab[reelNr].GetSymbol(i).SetSymbol(symbol) } } }; ReelManager.prototype.StartReels = function () { this.fA = getTimer(); this.du = false; this.bQ = true; for (i = 0; i < this.az; i++) if (this.ab[i].prepareStart) this.ab[i].prepareStart(); if (this.jB && !this.C) { var time = getTimer(); for (var i = 0; i < this.az; i++) this.mC[i] = time + this.kk[i]; this.fg = true } else { var tmpRnd = -1; var rnd = -1; for (var i = 0; i < this.az; i++) { tmpRnd = Math.floor(Math.random() * this.ab[i].iW.length); if (i > 0) while (tmpRnd == rnd || this.GetFirstAndLastYoffsetSame(tmpRnd, rnd)) tmpRnd = Math.floor(Math.random() * this.ab[i].iW.length); rnd = tmpRnd; this.ab[i].StartSpin(rnd) } this.cl = false } this.bj = 0 }; ReelManager.prototype.GetFirstAndLastYoffsetSame = function (tmpRnd, rnd) { var firstAndLastSame = false; firstAndLastSame = tmpRnd == this.ab[0].iW.length - 1 && rnd == 0; firstAndLastSame = firstAndLastSame || rnd == this.ab[0].iW.length - 1 && tmpRnd == 0; return firstAndLastSame }; ReelManager.prototype.StopAll = function () { this.fg = false; this.du = false; this.bQ = false; for (var i = 0; i < this.ab.length; i++) this.ab[i].StopSpin(true) }; ReelManager.prototype.OnQuickStop = function (e) { var currentTime = getTimer(); var minFullStopTime = Number(this.fA) + Number(this.lQ); var estimatedFullStopTime = currentTime + this.pg; if (this.az > this.bj && minFullStopTime > estimatedFullStopTime) currentTime += minFullStopTime - estimatedFullStopTime; this.du = true; currentTime += this.pg; this.dE = []; this.aU = currentTime; for (var i = this.bj; i < this.az; i++) this.dE[i] = currentTime }; ReelManager.prototype.OnQuickWinView = function (e) { }; function ReelSymbol(reelIndex, rowIndex, parent, sprite, symbolCycleHandler) { if (this.constructor !== arguments.callee) return new ReelSymbol(reelIndex, rowIndex, parent, sprite, symbolCycleHandler); this.hd = new CycleHandler(symbolCycleHandler, sprite, false); this.H = sprite; this.bn = parent; this.da; this.aN; this.dJ; this.iC; this.ve; this.ja; this.ep; this.bh; this.fk; this.MAXSYMBOLS = 15; this.da = reelIndex; this.iC = rowIndex; this.aN = false; this.dJ = 0; this.ja = new Array; this.bh = false; this.ep = null } ReelSymbol.prototype.constructor = ReelSymbol; ReelSymbol.prototype.SetFreeSpinMode = function (b) { this.bh = b }; ReelSymbol.prototype.getFreeSpinMode = function () { return this.bh }; ReelSymbol.prototype.destroy = function () { this.ClearAttached(); this.ee = null; this.ja = null }; ReelSymbol.prototype.SetSymbol = function (symbolIndex) { this.hd.Stop(true); this.hd.dY[0].reset(); this.hd.ClearAnimationData(); if (symbolIndex != this.dJ) this.dJ = symbolIndex; if (!isNaN(symbolIndex)) this.H.offset(symbol_size.w * symbol_map[symbolIndex][0], symbol_size.h * symbol_map[symbolIndex][1]) }; ReelSymbol.prototype.Animate = function (firstTime) { if (firstTime == undefined) firstTime = true; this.aN = firstTime }; ReelSymbol.prototype.StopAnimation = function () { this.Clear() }; ReelSymbol.prototype.GetSymbol = function () { return this.dJ }; ReelSymbol.prototype.PlayAttached = function (movieToAttach, attachTo, symbol) { }; ReelSymbol.prototype.Clear = function () { this.ClearAttached(); this.aN = false; this.fk = false }; ReelSymbol.prototype.ClearAttached = function () { if (this.ep) this.ep = null }; ReelSymbol.prototype.GetDisplayId = function (symbolIndex) { return String(symbolIndex) }; ReelSymbol.prototype.OnQuickView = function (e) { this.fk = true }; ReelSymbol.prototype.Ticker = function () { }; Feature.FEATURE_IDLE = -1; Feature.FEATURE_STARTED = 0; Feature.FEATURE_RUNNING = 1; Feature.FEATURE_COLLECTED = 2; Feature.FEATURE_START = 0; Feature.FEATURE_PROCESS = 1; Feature.FEATURE_SELECT = 2; Feature.FEATURE_DONE = 3; Feature.EVENT_TYPE_STATE = 0; Feature.EVENT_TYPE_MISC = 1; function Feature(featureEventHandler, implementation) { this.hJ = []; this.dc = new Object; this.qp = featureEventHandler; this.kZ = false; this.nX; this.C; this.aS; this.jC; this.ag; this.bV; this.hV; this.fM; this.m_State; this.bH = implementation; this.aS; this.aZ; this.bG; this.dw; var that = this; this.Clean(true) } Feature.prototype.constructor = Feature; Feature.prototype.NeedsCollect = function () { return this.nX }; Feature.prototype.GetAward = function (index) { return this.hJ[index] }; Feature.prototype.NumAwards = function () { return this.hJ.length }; Feature.prototype.Symbol = function () { return this.jC }; Feature.prototype.Line = function () { return this.bV }; Feature.prototype.NumSymbols = function () { return this.ag }; Feature.prototype.Reconnecting = function () { return this.C }; Feature.prototype.TotalCoins = function () { return this.dc.Coins }; Feature.prototype.TotalFreeSpins = function () { return this.dc.FreeSpins }; Feature.prototype.TotalMoney = function () { return this.dc.Money }; Feature.prototype.Type = function () { return this.aS }; Feature.prototype.State = function () { return this.m_State }; Feature.prototype.Waiting = function () { return this.hV != Feature.FEATURE_DONE }; Feature.prototype.CanProcess = function () { return this.hV == Feature.FEATURE_PROCESS }; Feature.prototype.CanSelect = function () { return this.hV == Feature.FEATURE_SELECT }; Feature.prototype.GetAcceptInput = function () { return this.fM }; Feature.prototype.SetAcceptInput = function (b) { this.fM = b }; Feature.prototype.getAutoPlay = function () { return this.dw.getAutoPlay() }; Feature.prototype.setAutoPlay = function (b) { this.dw.setAutoPlay(b) }; Feature.prototype.ChangeWaitState = function (state) { this.hV = state }; Feature.prototype.SendEvent = function (event) { this.qp(event, this) }; Feature.prototype.Clean = function (reconnecting, comm, settings, autoplay) { this.Reset(); this.hJ.length = 0; this.m_State = Feature.FEATURE_IDLE; this.hV = Feature.FEATURE_START; this.dc.Coins = 0; this.dc.FreeSpins = 0; this.dc.Money = 0; this.aZ = comm; this.bG = settings; this.dw = autoplay; this.fM = true; if (reconnecting) this.C = true; else { this.C = false; this.ReconnectEnd() } if (this.bH && this.bH.Clean) this.bH.Clean(reconnecting, comm, settings, autoplay) }; Feature.prototype.HandleCommand = function (cmd) { if (this.bH && this.bH.HandleCommand) this.bH.HandleCommand(cmd); switch (cmd.GetInt(0)) { case CmdType.FEATURE_START: this.aS = cmd.GetInt(1); this.jC = cmd.GetInt(2); this.ag = cmd.GetInt(3); this.bV = cmd.GetInt(4); this.kZ = true; break; case CmdType.FEATURE_AWARD: this.hJ.push(new FeatureAward(cmd)); break; case CmdType.FEATURE_SELECT: if (this.bH && this.bH.OnSelect) this.bH.OnSelect(cmd); this.OnSelect(cmd); break; case CmdType.FEATURE_INPUT: this.ChangeWaitState(Feature.FEATURE_SELECT); if (this.bH && this.bH.RequestInput) this.bH.RequestInput(cmd); this.RequestInput(cmd); break; case CmdType.FEATURE_DATA: if (this.bH && this.Reconnecting() && this.bH.OnData) this.bH.OnData(cmd); if (this.Reconnecting()) this.OnData(cmd); break; case CmdType.FEATURE_END: this.nX = cmd.GetInt(1) == 1; this.TotalWin(); if (this.bH && this.bH.FeatureProcessed) this.bH.FeatureProcessed(); this.FeatureProcessed(); this.ChangeWaitState(Feature.FEATURE_PROCESS); break; case CmdType.FEATURE_COLLECT: if (this.Reconnecting()) this.Collect(); this.ChangeWaitState(Feature.FEATURE_DONE); break } }; Feature.prototype.Collect = function () { if (this.bH && this.bH.OnCollect) this.bH.OnCollect(); this.OnCollect(); this.ChangeState(Feature.FEATURE_COLLECTED) }; Feature.prototype.OnCollect = function () { }; Feature.prototype.ReconnectEnd = function () { this.C = false; if (this.bH && this.bH.OnReconnectEnd) this.bH.OnReconnectEnd(); else if (this.bH && this.bH.ReconnectEnd) this.bH.ReconnectEnd() }; Feature.prototype.Tick = function (time) { if (this.m_State == Feature.FEATURE_COLLECTED) return true; if (this.bH && this.bH.OnTick) return this.bH.OnTick(time); return false }; Feature.prototype.Process = function (time) { if (this.m_State == Feature.FEATURE_COLLECTED) return true; if (this.bH && this.bH.OnTick) return this.bH.OnTick(time); return false }; Feature.prototype.ChangeState = function (state) { if (!this.C && state == Feature.FEATURE_COLLECTED && this.NeedsCollect() && this.kZ) { this.kZ = false; this.aZ.Send(CmdType.FEATURE, CmdType.FEATURE_COLLECT) } this.m_State = state; var obj = new Object; obj.Type = Feature.EVENT_TYPE_STATE; obj.State = this.m_State; this.SendEvent(obj) }; Feature.prototype.TotalWin = function () { var coinsmultiplier = 1; var freespinsmultiplier = 1; for (var i = 0; i < this.hJ.length; i++) { var award = this.hJ[i]; switch (award.Type()) { case FeatureAward.COINSMULTIPLIER: coinsmultiplier *= award.Value(); break; case FeatureAward.FREESPINSMULTIPLIER: freespinsmultiplier *= award.Value(); break; case FeatureAward.COINS: this.dc.Coins += award.Value(); break; case FeatureAward.FREESPINS: this.dc.FreeSpins += award.Value(); break; case FeatureAward.AMOUNT: case FeatureAward.JACKPOT: this.dc.Money += award.Amount(); break } } this.dc.Coins *= coinsmultiplier; this.dc.FreeSpins *= freespinsmultiplier }; Feature.prototype.FeatureProcessed = function () { }; Feature.prototype.OnData = function (cmd) { }; Feature.prototype.RequestInput = function (cmd) { }; Feature.prototype.OnSelect = function (cmd) { }; Feature.prototype.Reset = function () { }; FeatureManager.FEATURE_WAITCOLLECT = "feature_waitcollect"; FeatureManager.FEATURE_COLLECTED = "feature_collect"; function FeatureManager(cb) { if (this.constructor !== arguments.callee) return new FeatureManager; this.ao = cb; this.bQ = false; this.jj = false; this.cT = 0; this.bs = 0; this.bw = []; this.C = true; this.lf = 0 } FeatureManager.prototype.constructor = FeatureManager; FeatureManager.prototype.getFeatureIndex = function () { return this.bs }; FeatureManager.prototype.ReconnectEnd = function () { this.C = false; for (var i = 0; i < this.bw.length; i++) this.bw[i].ReconnectEnd() }; FeatureManager.prototype.GetFeatures = function () { return this.bw }; FeatureManager.prototype.getAcceptInput = function () { if (this.bs < this.bw.length) return this.bw[this.bs].GetAcceptInput(); return true }; FeatureManager.prototype.AddFeature = function (feature, comm, settings, autoplay) { this.bw.push(feature); this.bw[this.bw.length - 1].Clean(this.C, comm, settings, autoplay) }; FeatureManager.prototype.HandleCommand = function (cmd) { this.bw[this.bw.length - 1].HandleCommand(cmd) }; FeatureManager.prototype.SetDelay = function (delay) { this.lf = getTimer() + delay }; FeatureManager.prototype.Clear = function () { this.bw.length = 0; this.bs = 0; this.jj = false; this.bQ = false }; FeatureManager.prototype.Start = function () { this.bQ = true; this.jj = false; this.cT = 0; this.bs = 0; this.lf = 0 }; FeatureManager.prototype.Complete = function () { this.jj = true }; FeatureManager.prototype.Tick = function () { var time = getTimer(); if (this.bQ) if (this.lf < time || this.C) { if (this.bs < this.bw.length) { var feature = this.bw[this.bs]; if (feature.Process()) { var freeSpins = feature.TotalFreeSpins(); this.cT += freeSpins; this.bs++; this.ao({ type: "nextfeature", FreeSpins: freeSpins }) } } if (this.bs >= this.bw.length && this.jj) { this.bQ = false; this.jj = false; this.ao({ type: "allstopped", FreeSpins: this.cT }) } } }; FeatureManager.prototype.onWaitCollect = function (e) { dispatchEvent(e) }; FeatureManager.prototype.onCollected = function (e) { dispatchEvent(e) }; FeatureAward.COINS = 0; FeatureAward.FREESPINS = 1; FeatureAward.AMOUNT = 2; FeatureAward.JACKPOT = 3; FeatureAward.COINSMULTIPLIER = 4; FeatureAward.FREESPINSMULTIPLIER = 5; FeatureAward.FEATURE = 6; FeatureAward.JACKPOT_LAYOUT = 15; function FeatureAward(cmd) { var aS = cmd.GetInt(1); var jx; var oZ; if (aS != FeatureAward.AMOUNT) oZ = cmd.GetInt(2); else jx = cmd.GetInt(2); if (aS == FeatureAward.JACKPOT) jx = cmd.GetInt(3); this.Type = function () { return aS }; this.Value = function () { return oZ }; this.Amount = function () { return jx } } FeatureAward.prototype.constructor = FeatureAward; function Scatter(eventHandler) { if (this.constructor !== arguments.callee) return new Scatter; var aW = new Feature(eventHandler, this); this.Feature = aW; var that = this; this.OnFeatureProcessed = function () { aW.SetAcceptInput(false) }; this.OnTick = function (time) { if (!aW.CanProcess()) return false; switch (aW.State()) { case Feature.FEATURE_IDLE: aW.ChangeState(Feature.FEATURE_STARTED); break; case Feature.FEATURE_STARTED: aW.SetAcceptInput(true); aW.ChangeState(Feature.FEATURE_RUNNING); break; case Feature.FEATURE_RUNNING: aW.ChangeState(Feature.FEATURE_COLLECTED); break } return aW.State() == Feature.FEATURE_COLLECTED } } Scatter.prototype.constructor = Scatter; FreeGameHandler.START = "freegamestart"; FreeGameHandler.END = "freegameend"; FreeGameHandler.CONSUMED = "freegame_consumed"; FreeGameHandler.TOTALWIN = "freegame_totalwin"; FreeGameHandler.ADDITIONAL_FREEGAMES = "freegame_additional"; function FreeGameHandler(game) { this.START = "freegamestart"; this.END = "freegameend"; this.CONSUMED = "freegame_consumed"; this.TOTALWIN = "freegame_totalwin"; this.ADDITIONAL_FREEGAMES = "freegame_additional"; var fa = game; var cJ = false; var hf = false; var fq = 0; this.nF = 0; var eH = {}; this.Active = function () { return cJ }; this.FreeGames = function () { return fq }; this.OnIncomingPacket = function (cmd) { SetFreeGameData(cmd); switch (cmd.ae) { case Command.SSFREEGAME: fq = eH.FreeGames; if (!cJ) fa.OnFreeGameEvent(this.START, eH); else fa.OnFreeGameEvent(this.TOTALWIN, eH); cJ = fq > 0; if (hf && fq > 0) fq--; break; case Command.SSFREEGAMEEND: this.nF = cmd.GetInt(0); cJ = fq > 0; fa.OnFreeGameEvent(this.TOTALWIN, eH, true); if (cmd.GetInt(1) == 1) fa.OnFreeGameEvent(this.ADDITIONAL_FREEGAMES, eH); else fa.OnFreeGameEvent(this.END, eH); break } if (fa.ToggleButtonState) fa.ToggleButtonState(true) }; this.OnAdditionalFgDeclined = function () { fa.OnFreeGameEvent(this.END, eH) }; this.GameStart = function () { if (!hf && fq > 0) { hf = true; fq-- } }; this.GameEnd = function () { var end = hf && fq == 0; hf = false; return end }; var SetFreeGameData = function (cmd) { eH = {}; var type = cmd.ae; var freeGames = cmd.GetInt(0); var bet = cmd.GetInt(1); var lines = cmd.GetInt(2); var denomination = cmd.GetMoney(3); var freeGamesWin = cmd.GetMoney(4); var resumed = cmd.GetInt(5) == 0; eH = { Type: type, Bet: bet, Lines: lines, FreeGames: freeGames, Denomination: denomination, FreeGamesWin: freeGamesWin, Resumed: resumed } } }; function RoundEvent() { } RoundEvent.BET = "bet"; RoundEvent.WIN = "win"; RoundEvent.BALANCE = "balance"; RoundEvent.ROUNDSTART = "roundstart"; RoundEvent.ROUNDEND = "roundend"; RoundEvent.ROUNDABORT = "roundabort"; RoundEvent.CURRENCY = "currency"; VideoSlot.NONE = 0; VideoSlot.LOGIN = 1; VideoSlot.WAITINGSPIN = 2; VideoSlot.WAITINGRESPONSE = 3; VideoSlot.STOPREELS = 4; VideoSlot.HANDLEFEATURES = 5; VideoSlot.HANDLEWIN = 6; VideoSlot.WAITINGBONUS = 7; VideoSlot.FREESPINANIM = 8; VideoSlot.GAMBLE = 9; VideoSlot.GAMBLEANIM = 10; function CmdType() { }; CmdType.NONE = 0; CmdType.SPINEND = 3; CmdType.GAMBLECMD = 4; CmdType.NOGAMBLECMD = 5; CmdType.PAYOUT = 6; CmdType.CFREESPINCMD = 7; CmdType.SFREESPINCMD = 83; CmdType.JACKPOT_NOTIFICATION = 58; CmdType.SPIN = 1; CmdType.FEATURE = 2; CmdType.FEATURE_START = 0; CmdType.FEATURE_INPUT = 1; CmdType.FEATURE_AWARD = 2; CmdType.FEATURE_SELECT = 3; CmdType.FEATURE_DATA = 4; CmdType.FEATURE_END = 5; CmdType.FEATURE_COLLECT = 6; FEATURE_MYSTERYJACKPOT = 10; var SND_START = 0; var SND_SPIN = 1; var SND_BUTTON = 2; var SND_REELSTOP = 3; function VideoSlot(gameName, gameVersion, game) { this.bJ; this.ab = []; this.oe; this.bv; this.aV; this.bj = 0; this.cw = new Array; this.ac = new Array; var aK = -1; this.eK = 0; this.G = game; this.qi = 0; this.fA = 0; this.rD = 0; this.aU; this.fL = 0; this.sP = 23; this.cT = 0; this.iU = true; this.bG; this.bf; this.lW = 0; this.so; this.sa; this.bK; this.nu = false; this.aN; this.du; this.eA; this.ni = false; this.ji = false; this.ke = false; this.ft; this.bw = []; this.bs = 0; this.eQ; this.eC; this.ra; this.oT = false; this.cl = false; this.fg; this.eP = 0; this.rQ; this.ru; this.tA = []; this.au = []; this.hy; this.O = new GameBase(gameName, gameVersion, this); this.oC = new LimitsBase; this.m_State = VideoSlot.LOGIN; this.bb = new FreeGameHandler(this); this.hy = false; this.gZ = 0; this.O.LoadConfigURL(); if (this.O.aB.limits != undefined) this.oV = this.O.aB.limits; else this.oV = " "; this.eC = false; this.eA = false; this.ra = false; this.az = 5; this.qS = true; this.jS = []; this.jP = undefined; this.hy = false; this.bu; this.randomReels = [2, 1, 3, 0, 4]; this.rA = 0; this.oldTime = 0; this.diffs = new Array; this.spinTimer = [0, 0, 0, 0]; this.spinning = [0, 0, 0, 0]; this.qD; this.lY = false; this.sV = false; this.pU; this.aJ; this.aO; this.qq = false; this.dg = undefined; this.qX = true; this.aD = "pt"; this.mK = null; this.bA; this.InitWinDisplay(); this.av = null; this.m_MysteryJackpotFeature = undefined; this.og = 0; this.oY = 0; this.jn = 0; this.ib = false; this.la = -1; this.qU = true; this.C = true; this.aQ; this.rZ; this.uE; this.sQ; this.ie = false; this._state; HostInterface.addCallback(HostInterface.CALLBACK_STOP_AUTOPLAY, this.StopAutoPlay.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_GET_SELECTED_COIN, this.GetSelectedCoin.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_GET_SELECTED_LINES, this.GetSelectedLines.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_AVAILABLE_COINS, this.GetAvailableCoins.bind(this)); HostInterface.addCallback(HostInterface.CALLBACK_GET_SELECTED_COIN_VALUE, this.GetSelectedCoinValue.bind(this)) } VideoSlot.prototype.constructor = VideoSlot; Object.defineProperty(VideoSlot.prototype, "m_State", { configurable: true, get: function () { return this._state }, set: function (value) { this._state = value; HostInterface.processVideoslotState({ type: value }) } }); VideoSlot.prototype.InitWinDisplay = function () { this.bA = new WinDisplay(Utils.delegate(this, this.WinDisplayCallback)) }; VideoSlot.prototype.getStateChangeDelayed = function () { return this.qU }; VideoSlot.prototype.WinDisplayCallback = function (e, windisplaywin) { switch (e) { case "done": this.OnWinDisplayDone(); break; case "stop": this.OnWinDisplayStop(); break; case "start": this.OnWinDisplayStart(); break; case "linesstart": this.OnWinDisplayLinesStart(); break; case "allticked": this.AllWinsTicked(); break; case "win": this.OnWinDisplayWin(windisplaywin); break; case "firstwin": this.OnWinDisplayFirstWin(); break } }; VideoSlot.prototype.NextState = function () { if (this.aO.getRestartFreeSpin()) this.m_State = VideoSlot.FREESPINANIM; if (!this.aO.getFreeSpinMode() && this.m_State != VideoSlot.FREESPINANIM) this.DisplayWinEnableUI(); else this.m_State = VideoSlot.FREESPINANIM }; VideoSlot.prototype.OnWinDisplayFirstWin = function (e) { this.ti = false; HostInterface.processVideoslotState({ type: HostInterface.CALL_PAYLINE_WIN }) }; VideoSlot.prototype.OnWinDisplayStart = function (e) { if (!this.aO.getFreeSpinMode() && this.m_State != VideoSlot.FREESPINANIM && !this.ib) this.DisplayWinEnableUI(); if (this.av) WinLine.SetFeatures(this.av.GetFeatures()); else WinLine.SetFeatures(this.bw); if (!this.getStateChangeDelayed()) this.NextState() }; VideoSlot.prototype.OnWinDisplayLinesStart = function (e) { }; VideoSlot.prototype.OnWinDisplayStop = function (e) { }; VideoSlot.prototype.ShowMenu = function (b) { if (b) { this.UpdateAutoPlayDlgStates(); this.SetBetDlgValues(0); if (typeof this.m_MysteryJackpotFeature != "undefined") if (this.m_MysteryJackpotFeature.m_AnimState == MysteryJackpotFeature.ANIMSTATE_STARTCOINS || this.m_MysteryJackpotFeature.m_AnimState == MysteryJackpotFeature.ANIMSTATE_STOPCOINS) { this.m_MysteryJackpotFeature.m_Popup.Show(false); this.m_MysteryJackpotFeature.m_FireworksEmitter.stop(); this.m_MysteryJackpotFeature.m_Popup.kC.stop() } } else if (typeof this.m_MysteryJackpotFeature != "undefined") if (this.m_MysteryJackpotFeature.m_AnimState == MysteryJackpotFeature.ANIMSTATE_STARTCOINS || this.m_MysteryJackpotFeature.m_AnimState == MysteryJackpotFeature.ANIMSTATE_STOPCOINS) { this.m_MysteryJackpotFeature.m_Popup.Show(true); this.m_MysteryJackpotFeature.m_FireworksEmitter.start(); this.m_MysteryJackpotFeature.m_Popup.kC.start() } sjs.layers["coinshower"].Show(!b); this.bu.aq.Show(b); sjs.layers["scalelayer"].Show(!b) }; VideoSlot.prototype.DelayedInit = function (gameUI) { this.bu = gameUI; this.bG = gameUI.bG; this.bJ = gameUI.bJ; this.m_GamePanelHandler = this.bu.m_GamePanelHandler; this.bA.setWinCounter(this.bJ); var payLines = this.InitPaylines(); var scatter = this.InitWinScatter(); var payboxAmountHandler = undefined; if (this.qX) payboxAmountHandler = new PayboxAmountHandler(this.bA); this.bA.Init(payLines, scatter, payboxAmountHandler, this.m_GamePanelHandler, this.G.bo); this.aT = gameUI.aT; this.bK = gameUI.dw ? gameUI.dw : undefined; this.SetAutoPlayLimitSettings(); this.SetAutoPlaySpinnerData(); this.aJ = new RedOrBlack(this.bG, gamble, Utils.delegate(this, this.onGambleEvent)); this.aJ.Show(false); if (this.bG.getNeverGamble() === true) this.aJ.setEnableGambleFeature(false); this.O.aZ.SetMinKeepAliveTime(3E4); this.StopWinAnim(); this.m_State = VideoSlot.WAITINGSPIN; var defaultLimit = this.O.mv; if (defaultLimit > 0 && defaultLimit <= this.bG.getMaxCoins()) this.bG.setCoins(defaultLimit); var defaultLines = this.O.mo; if (defaultLines > 0 && defaultLines <= this.bG.getMaxLines()) this.bG.setLines(defaultLines); this.O.DelayedInit(); this.ShowNewGame(); SoundPlayer.ToggleOnOff(false); if (!SoundPlayer.CheckSoundSupport()) { SoundPlayer.Pause(); this.UpdateSettingsDlgStates(0, "disabled") } else this.UpdateSettingsDlgStates(0, SoundPlayer.GetEnabled()); if (this.O.ReadLeftHandModeCookie()) this.SetGameSettings(2); this.InitQuickstopLayer(); if (this.aQ) this.aQ.setMinFullSpinningTime(this.O.fW); this.SetGameSettings(1); if (this.aQ && this.G.ReelHandlerCallback) { this.m_SuperReelHandlerCallback = this.G.ReelHandlerCallback.bind(this.G); this.G.ReelHandlerCallback = this.ReelHandlerCallback; this.aQ.ao = this.ReelHandlerCallback.bind(this) } }; VideoSlot.prototype.ReelHandlerCallback = function (type, reel) { this.m_SuperReelHandlerCallback(type, reel); switch (type) { case "allstopped": HostInterface.processVideoslotState({ type: HostInterface.CALL_SPIN_ENDED }); break } }; VideoSlot.prototype.InitMysteryJackpotFeature = function (jackpots) { if (typeof MysteryJackpotFeature !== "undefined") { MysteryJackpotFeature.Active = true; this.m_MysteryJackpotFeature = new MysteryJackpotFeature(function () { }, this.bG); this.m_MysteryJackpotFeature.createJackpots(jackpots); this.bK.SetJackpotEnabled(true); if (this.bu.aq.m_BetView) this.bu.aq.m_BetView.showJackpot(); else this.bu.aq.cN.ShowJackpot() } }; VideoSlot.prototype.InitQuickstopLayer = function () { this.jW = new sjs.Layer("quickstop", undefined, sjs.layers["scalelayer"]); this.sN = new Button(this.jW, { x: 0, y: 0, w: 1260, h: 1180 }, Utils.delegate(this, this.OnQuickStop)); this.QuickstopAvailable(false) }; VideoSlot.prototype.InitPaylines = function () { this.aV = new Array; if (special_paylines != undefined) var s_paylines_layer = sjs.layers["specialpaylines"]; var s_line; var s_line_getValueFromIndex; var paylines_layer = sjs.layers["paylines"]; for (var i = 0; i < this.bG.getMaxLines() ; i++) { s_line = undefined; s_line_getValueFromIndex = undefined; if (special_paylines != undefined) for (var j = 0; j < special_paylines.length; j++) if (special_paylines[j] == i + 1) { s_line = new sjs.Sprite(this.G.pJ || image_path_paylines + "paylines_lines_" + this.bG.getMaxLines() + ".png", s_paylines_layer, undefined, paylines_pos); s_line_getValueFromIndex = j; break } this.hu = new Array; var line = new sjs.Sprite(this.G.pJ || image_path_paylines + "paylines_lines_" + this.bG.getMaxLines() + ".png", paylines_layer, undefined, paylines_pos); if (this.jS.length > 0) { line.yoffset = this.jS[i]; line.h = payline_heights[i]; line.y = paylines_y_positions[i] } else line.yoffset = paylines_pos.h * i; if (this.qS) for (var j = 0; j < this.az; j++) { this.hu[j] = new sjs.Sprite(this.G.qA || image_path_paylines + "paylines_boxes_" + this.bG.getMaxLines() + ".png", paylines_layer, undefined, paylines_box_pos); this.hu[j].x = paylines_box_pos.x + (paylines_box_pos.w - paylines_adjust.box_horizontal_adj) * j; this.hu[j].xscale = paylines_adjust.box_scale; this.hu[j].yscale = paylines_adjust.box_scale; this.hu[j].yoffset = paylines_box_pos.h * i; this.hu[j].Visible(false) } this.CreateWinLine(line, i, s_line, s_line_getValueFromIndex) } return this.aV }; VideoSlot.prototype.CreateWinLine = function (line, i, s_line, s_line_getValueFromIndex) { this.aV[i] = new WinLine(line, i, this.hu, this.G.bo, s_line, s_line_getValueFromIndex) }; VideoSlot.prototype.CreateWinScatter = function () { this.dp = new WinScatter(this.ij, this.ab) }; VideoSlot.prototype.InitWinScatter = function () { var paylines_layer = sjs.layers["paylines"]; this.sy = new Array; this.qf = this.ab[0].bc.length; this.ij = []; for (var j = 0; j < this.az; j++) { if (this.jP != undefined) { this.ij[j] = new sjs.Sprite(this.G.qA || image_path_paylines + "paylines_boxes_" + this.bG.getMaxLines() + ".png", paylines_layer, undefined, scatter_frame_pos); this.ij[j].yoffset = this.jP; this.ij[j].Visible(false) } else; this.ij[j].x += j * scatter_frame_gap.w } this.CreateWinScatter(); return this.dp }; VideoSlot.prototype.HandleReelStop = function (reel) { if (!this.aQ) { this.ab[reel].Stop(); this.spinning[0] = 0; this.spinning[1] = 0; this.spinning[2] = 0; this.spinning[3] = 0; this.fg = false; this.aU = getTimer() + 60; if (this.G.OnHandleReelStop) this.G.OnHandleReelStop(reel) } }; VideoSlot.prototype.UpdateBetValue = function (spinner, n) { switch (spinner) { case 0: this.bG.setDenom(n - 1); break; case 1: this.bG.setCoins(n); break; case 2: this.bG.setLines(n); break } this.OnSettingsNotify({ type: "CHANGE" }); this.SetBetDlgValues(spinner); this.UpdateGamePanel(this.O.getBalance()) }; VideoSlot.prototype.SetBetDlgValues = function (spinner) { if (this.bu.aq) { var data = { totBet: this.bG.GetBetAmount(), totCoinBet: this.bG.GetBetCoins(), denominationsIndex: this.bG.getCurrentDenominationIndex() + 1, coinsIndex: this.bG.getCoins(), linesIndex: this.bG.getLines() }; this.bu.aq.SetBetDlgBetData(data, spinner) } }; VideoSlot.prototype.SetInitialSound = function (b) { this.UpdateSettingsDlgStates(0, b); if (b && this.G.ToggleBGM) this.G.ToggleBGM() }; VideoSlot.prototype.UpdateSettingsDlgStates = function (id, state) { if (this.bu.aq.SetSettingsStates) this.bu.aq.SetSettingsStates(id, state) }; VideoSlot.prototype.SetGameSettings = function (button) { switch (button) { case 0: SoundPlayer.ToggleOnOff(!SoundPlayer.GetEnabled()); if (!SoundPlayer.GetEnabled()) SoundPlayer.Pause(); this.O.SaveSoundCookie(); if (!SoundPlayer.CheckSoundSupport()) { SoundPlayer.Pause(); this.UpdateSettingsDlgStates(button, "disabled") } else this.UpdateSettingsDlgStates(button, SoundPlayer.GetEnabled()); break; case 1: this.bG.toggleAutoAdjustBet(); this.UpdateSettingsDlgStates(button, this.bG.getAutoAdjustBet()); break; case 2: this.m_GamePanelHandler.setLeftHandMode(); this.aT.setLeftHandMode(); this.O.SaveLeftHandModeCookie(this.m_GamePanelHandler.getLeftHandMode()); break } }; VideoSlot.prototype.SetAutoPlaySpinnerData = function () { if (this.bK == undefined) return; if (this.bu.aq) { var spinsArray = this.O.getAutoSpins() != undefined ? this.O.getAutoSpins() : this.bK.GetSpinsArray(); var initSpins = this.O.getDefaultAutoSpins() != undefined ? this.O.getDefaultAutoSpins() : 1; this.bK.SetSpinsArray(spinsArray); var autoplayDlg_SpinnerValues = { spinsArray: spinsArray, initSpins: initSpins }; this.bu.aq.SetAutoPlayDlgSpinnerData(autoplayDlg_SpinnerValues) } }; VideoSlot.prototype.SetAutoPlayLimitSettings = function () { if (this.bK == undefined) return; if (this.bu.aq) { var settings = { autoplayreset: this.O.m_AutoplayReset, autoplaylimits: this.O.m_AutoplayLimits }; this.bu.aq.SetAutoPlayLimitSettings(settings) } }; VideoSlot.prototype.UpdateAutoPlayDlgStates = function () { if (this.bK == undefined) return; if (this.bu.aq.SetAutoPlayStates) { var autoplayStates = { anyWin: this.bK.GetStopAtAnyWin(), freeSpinWin: this.bK.GetStopAtFsWin(), bonusGameWin: this.bK.GetStopAtBonusWin(), jackpotWin: this.bK.GetStopAtJackpotWin() }; this.bu.aq.SetAutoPlayStates(autoplayStates) } }; VideoSlot.prototype.SetAutoPlaySettings = function (button, n) { if (this.bK == undefined) return; switch (button) { case -1: this.bK.SetSpinsUsingIndex(n - 1); break; case 0: this.bK.SetStopAtAnyWin(!this.bK.GetStopAtAnyWin()); break; case 1: this.bK.SetStopAtFsWin(!this.bK.GetStopAtFsWin()); break; case 2: this.bK.SetStopAtBonusWin(!this.bK.GetStopAtBonusWin()); break; case 3: this.bK.SetStopAtJackpotWin(!this.bK.GetStopAtJackpotWin()); break; case 4: this.bK.SetStopAtWinValue(n); break; case 5: this.bK.SetStopAtBalanceIncValue(n); break; case 6: this.bK.SetStopAtBalanceDecValue(n); break; case 7: this.bK.SetStopAtTotalLossValue(n); break } if (button < 4 || button == 5) this.UpdateAutoPlayDlgStates() }; VideoSlot.prototype.StartAutoPlay = function () { if (this.bK.GetSpins() > 0) { if (this.bu.aq.GetIsShowing()) { this.ShowMenu(false); this.m_GamePanelHandler.ShowMenuButton(true); this.m_GamePanelHandler.ShowBackButton(false); this.bK.Start(this.O.getBalance()); this.bK.setAutoPlay(true) } this.bf = true; if (!this.ji) this.aT.ShowAutoPlayPanel(true); else if (this.ji) this.ke = true } }; VideoSlot.prototype.GetMenuIsShowing = function () { return this.bu.aq.GetIsShowing() }; VideoSlot.prototype.OnAutoPlaySettingsNotify = function () { if (this.bK == undefined) return; if (this.aT.setAutoPlay) this.aT.setAutoPlay(this.bK.getAutoPlay()); this.aT.UpdateAutoPlayText(this.bK.GetSpins()); if (this.bK.GetSpins() <= 0) this.bf = false; this.bu.aq.EnableAutoPlayDlg(!this.bK.getAutoPlay()); if (this.aT.et.getShowing() && this.aT.et.getShowing() != this.bK.getAutoPlay()) this.aT.ShowAutoPlayPanel(this.bK.getAutoPlay()) }; VideoSlot.prototype.CheckAutoPlay = function (win, balance) { if (this.bK && this.bf) { this.bK.OnWin(win); this.bK.OnBalance(balance + win) } }; VideoSlot.prototype.MainLoop = function () { var time = getTimer(); if (!this.O.Ticker()) return; if (this.m_State == VideoSlot.WAITINGSPIN && !this.aJ.CanGamble() && !this.O.C) { var cmd = this.O.aZ.GetPostponedServerMessageCommand(); if (cmd != null) if (cmd.GetInt(3) == ServerMessage.ACTION_NEWFREEGAME && !this.bb.Active()) this.O.m_InSessionFreegamesModalWin.Show() } if (this.av) this.av.Tick(); this.bu.aq.Ticker(time); this.bu.aT.Ticker(); this.aJ.Ticker(); for (var i = 0; i < this.ab.length; i++) if (!this.aQ) this.ab[i].Ticker(); if (this.oT && this.fg) { if (time > spinTimer[0] && spinning[0] == 0) { this.ab[1].Start(); spinning[0] = 1 } if (time > spinTimer[1] && spinning[1] == 0) { this.ab[2].Start(); spinning[1] = 1 } if (time > spinTimer[2] && spinning[2] == 0) { this.ab[3].Start(); spinning[2] = 1 } if (time > spinTimer[3] && spinning[3] == 0) { this.ab[4].Start(); spinning[3] = 1; this.cl = false } } if (this.eP > 0 && (this.O.C || this.eP < time) && !this.bf) { if (this.m_State == VideoSlot.WAITINGSPIN) { this.bu.aT.ShowSpinPanel(!this.ie); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Show(true); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.setGambleMode(this.aJ.CanGamble()); if (this.bu.aT.eN.m_QuickMenu) this.bu.aT.eN.showQuickMenu(false); this.bu.aT.ShowGamblePanel(this.aJ.CanGamble()); if (this.aJ.CanGamble()) if (!this.bG.getLock()) { this.bu.aq.DisableAllBetSpinners(true, true); this.bu.aq.EnableAutoPlayDlg(true) } this.bu.aT.DisableGamble(false) } this.eP = 0 } this.bA.Tick(); this.aO.Tick(); if (this.av) { var readCommand = true; while (readCommand) { readCommand = this.av.getAcceptInput() && this.aJ.getAcceptInput(); readCommand = readCommand && this.m_State != VideoSlot.STOPREELS && this.m_State != VideoSlot.FREESPINANIM && this.m_State != VideoSlot.HANDLEWIN && this.m_State != VideoSlot.GAMBLEANIM; readCommand = readCommand && !(this.aO.getFreeSpinMode() && this.eQ); if (this.O.aZ.IsDataAvailable() && readCommand && !this.O.jz) { var nextcmd = this.O.aZ.GetNextCmd(); this.ProcessCommand(nextcmd); readCommand = this.O.aZ.PeekNext() == CmdType.FEATURE; if (nextcmd.ae == Command.SSPJACKPOTPROJECTION) readCommand = true } else readCommand = false } } else { var readCommand = true; var currentFeature = null; while (readCommand) { if (this.bs < this.bw.length) readCommand = this.bw[this.bs].GetAcceptInput(); readCommand = readCommand && this.aJ.getAcceptInput(); readCommand = readCommand && this.m_State != VideoSlot.STOPREELS && this.m_State != VideoSlot.FREESPINANIM && this.m_State != VideoSlot.HANDLEWIN && this.m_State != VideoSlot.GAMBLEANIM; readCommand = readCommand && !(this.aO.getFreeSpinMode() && this.eQ); if (this.O.aZ.IsDataAvailable() && readCommand && !this.O.jz) { this.ProcessCommand(this.O.aZ.GetNextCmd()); readCommand = this.O.aZ.PeekNext() == CmdType.FEATURE } else readCommand = false } } var tickUp = 0; switch (this.m_State) { case VideoSlot.STOPREELS: if (!this.aQ) if (this.aU < time || this.O.C) if (this.bj < this.az) if (this.eC) { var reel = randomReels[this.bj]; this.SetReels(this.bv, reel); this.HandleReelStop(reel); this.bj++ } else if (this.du && this.eA) { for (var i = this.bj; i < this.az; i++) { this.SetReels(this.bv, i); this.HandleReelStop(i) } this.bj = this.az } else { this.SetReels(this.bv, this.bj); this.HandleReelStop(this.bj); this.bj++ } else this.m_State = VideoSlot.HANDLEFEATURES; break; case VideoSlot.HANDLEFEATURES: if (!this.av) if (this.aU < time || this.O.C) { if (this.bs < this.bw.length) if (this.bw[this.bs].Tick(time)) { var freeSpins = this.bw[this.bs].TotalFreeSpins(); if (freeSpins > 0) this.cT += freeSpins; this.bs++ } if (this.bs >= this.bw.length && this.eQ) { this.m_State = VideoSlot.HANDLEWIN; this.G.OnFeaturesStopped({ FreeSpins: this.cT }); if (this.G.PreWin) this.G.PreWin(time) } } break; case VideoSlot.HANDLEWIN: break; case VideoSlot.GAMBLE: } if (!this.aQ) if (this.m_State == VideoSlot.STOPREELS && !this.cl) { this.SetReels(this.bv); this.cl = true } this.QuickstopAvailable(this.m_State == VideoSlot.STOPREELS || this.m_State == VideoSlot.WAITINGRESPONSE); if (this.bf && this.m_State == VideoSlot.WAITINGSPIN && this.lW < getTimer() && !this.bA.IsActive()) if (!this.bJ.Ticking()) { this.OnSpin(); if (this.bK) this.bK.OnSpin(this.GetBetAmount()) } this.bJ.Ticker(); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Tick() }; VideoSlot.prototype.OnChangeState = function (e) { switch (e) { case VideoSlot.STOPREELS: this.m_State = VideoSlot.STOPREELS; if (this.aQ) this.aQ.StopReels(this.aO.getFreeSpinMode()); break; case VideoSlot.HANDLEFEATURES: this.m_State = VideoSlot.HANDLEFEATURES; if (this.av) this.av.Start(); break; case VideoSlot.HANDLEWIN: this.m_State = VideoSlot.HANDLEWIN; this.bA.Start(this.aO.getFreeSpinMode()); break; case VideoSlot.GAMBLE: this.m_State = VideoSlot.GAMBLE; this.bA.Stop(); this.bu.aT.ShowSpinPanel(false); this.bu.aT.ShowGamblePanel(true); this.bu.aT.SetBlinkButtons(false); this.bu.aT.DisableGamble(true); break } }; VideoSlot.prototype.DisplayWinEnableUI = function () { if (this.bA.HasWins()) this.eP = getTimer() + 500; else this.eP = getTimer() + 100; if (this.ft > 0) this.SetWin(this.ft); this.aJ.setWonCoins(this.oe); this.m_State = VideoSlot.WAITINGSPIN; if (!this.aJ.CanGamble() || this.bf) this.OnCollect(null, true); if (this.bb.GameEnd()) { this.eP = getTimer() + 1500; this.ie = true; this.StopAutoPlay() } this.lW = getTimer() + 500 }; VideoSlot.prototype.AllWinsTicked = function () { }; VideoSlot.prototype.GetSymbolIndexArray = function (symbol) { var scatterPos = []; var currentRow = 0; var currentReel = 0; var scattersCount = 0; if (this.lY) { ez = 1; eL = 3; var grid = new Array; var reelIndex; var symbolCount = 0; for (var i = 0; i < this.az; i++) { var numSymbols = 5; var range = eL - ez + 1; for (var j = ez; j < numSymbols && j <= eL; j++) { var tmp = this.bv[j + i * numSymbols]; if (tmp == symbol) { reelIndex = (symbolCount - symbolCount % 3) / 3; grid.push([reelIndex, j]) } symbolCount++ } } return grid } else { for (var j = 0; j < this.bv.length; j++) { if (this.bv[j] == symbol) { scatterPos[scattersCount] = [currentReel, currentRow]; scattersCount++ } currentRow++; if (currentRow > this.qf - 1) { currentRow = 0; currentReel++ } } return scatterPos } }; VideoSlot.prototype.AddScatterWin = function (symbol, coins, num, grid) { }; VideoSlot.prototype.OnWinDisplayDone = function () { if (this.G.OnWinDisplayDone) this.G.OnWinDisplayDone(); if (this.m_State == VideoSlot.HANDLEWIN) this.NextState(); if (this.aO.getFreeSpinMode() || this.m_State == VideoSlot.FREESPINANIM) { this.bA.Stop(); this.aO.NextSpin(); return } }; VideoSlot.prototype.setFreeSpinStartWait = function (b) { if (!b && this.nu) { this.OnFreeSpinStart(); this.nu = false } this.aT.ShowSpinPanel(b); this.nu = b }; VideoSlot.prototype.displayWinLine = function (payline, amount) { var that = this; if (this.bJ != undefined) { var winCounterDurationAmount = amount / this.bG.getCoins(); var duration = this.C ? 0 : this.G.GetWinCounterTickDuration(winCounterDurationAmount); if (this.cw.length == 0) this.mK = setTimeout(function () { if (that.iU) that.bJ.addWinAmount(amount, duration, true) }, this.C ? 1 : 500) } }; VideoSlot.prototype.displayWinScatter = function (amount, scatterObj, onlyScatter) { if (this.bJ && onlyScatter) { this.PlayWinSound(undefined, undefined, undefined, amount, true, false, true); var winCounterDurationAmount = amount / this.bG.getCoins(); var duration = this.G.GetWinCounterTickDuration(winCounterDurationAmount); if (this.iU) this.bJ.addWinAmount(amount, this.O.C ? 1 : duration, true) } }; VideoSlot.prototype.OnWinDisplayWin = function (obj) { this.displayWinInfo(obj); if (obj.aS == "line") { var payline = obj.od; if (payline.GetJackpotWonAmount() > 0) this.GamePanelHandler.setInfoBarText(Str.Replace(Str.Replace(Locale.IDS_MENU_WONJACKPOT_LINE, "%d", Utils.MoneyToString(payline.GetJackpotWonAmount())), "%l", String(payline.GetIndex())), 2); else if (payline.GetWonAmount() > 0) this.m_GamePanelHandler.setInfoBarText(Str.Replace(Str.Replace(CreditFormatter.GetCreditString(Locale.IDS_MENU_WONCOINS_LINE, Locale.IDS_MENU_WONMONEY_LINE), "%d", CreditFormatter.FormatCoinValue(payline.GetWonAmount())), "%l", String(payline.GetIndex())), 2) } else if (obj.aS == "scatter") if (obj.fQ > 0) this.m_GamePanelHandler.setInfoBarText(Str.Replace(Str.Replace(CreditFormatter.GetCreditString(Locale.IDS_MENU_WONCOINS_SCATTER, Locale.IDS_MENU_WONMONEY_SCATTER), "%d", CreditFormatter.FormatCoinValue(obj.fQ)), "%s", String(obj.nb)), 2); var amount = this.jn; if (this.G.AdjustWonAmount) amount = this.G.AdjustWonAmount(amount); if (obj.aS == "scatter") { var o = obj; this.PlayWinSound(o.aA, o.jC, o.nb, amount, o.aN); if (o.aN) { amount = o.fQ; if (this.aO.getFreeSpinMode()) this.aO.AddAmount(amount); this.displayWinScatter(amount, o, this.bA.ac.length == 0); if (this.G.PlayWinSound) this.G.PlayWinSound(o.aA, o.jC, o.nb, o.fQ, o.aN) } } else { var payline = obj.od; this.PlayWinSound(obj.aA, payline.GetWinSymbol(), payline.GetNumSymbols(), amount, obj.aN, payline.GetNumWilds()); if (obj.aN) { if (this.aO.getFreeSpinMode()) this.aO.AddAmount(payline.GetWonAmount()); if (this.bA.aK == 0) this.displayWinLine(payline, amount); if (this.G.PlayWinSound) this.G.PlayWinSound(obj.aA, payline.GetWinSymbol(), payline.GetNumSymbols(), payline.GetWonAmount(), obj.aN, payline.GetNumWilds()) } } }; VideoSlot.prototype.displayWinInfo = function (e) { if (e == undefined) e = null }; VideoSlot.prototype.PlayWinSound = function (line, symbol, num, coins, firstFlag, wilds, extraScatterSnd) { if (this.cw.length > 0 && this.qq || coins == 0) return; if (firstFlag && (line == this.bA.ac[0] || extraScatterSnd)); else return; var that = this; var hg = undefined; hg = this.GetWinSnd(line, symbol, num, coins, firstFlag, wilds); if (hg != undefined) { if (this.aO.getFreeSpinMode()) { this.G.bN.SetCurrentBGMTime(SoundPlayer.getCurrentTime()); setTimeout(function () { if (that.G.bN.intro_box_layer != undefined) { if (!that.G.bN.intro_box_layer.aP) that.G.bN.StartBackgroundMusic() } else that.G.bN.StartBackgroundMusic() }, stime_ticker_delay[hg - 3]) } setTimeout(function () { SoundPlayer.Play(hg) }, UAGENT_ANDROID_23 ? 400 : 100); this.bJ.SetSilenceDelay(stime_ticker_delay[hg - 3]); setTimeout(function () { if (that.bJ.Ticking()) that.bJ.Start(true, true) }, stime_ticker_delay[hg - 3]) } }; VideoSlot.prototype.SetCurrency = function (currency) { this.bu.aq.cN.SetCurrency(currency) }; VideoSlot.prototype.GetSymbolWinSound = function (symbol, num, coins) { if (this.G.GetSymbolWinSound) return this.G.GetSymbolWinSound(symbol, num, coins); else return undefined }; VideoSlot.prototype.GetAmountWinSound = function (coins) { if (this.G.GetAmountWinSound) return this.G.GetAmountWinSound(coins); var idx = 2; if (coins >= 5) idx++; if (coins >= 11) idx++; if (coins >= 25) idx++; if (coins >= 50) idx++; if (coins >= 75) idx++; if (coins >= 100) idx++; if (coins >= 150) idx++; return idx }; VideoSlot.prototype.GetWinSnd = function (line, symbol, num, coins, firstFlag, wilds) { coins /= this.bG.getCoins(); var ret = this.GetSymbolWinSound(symbol, num, coins); if (ret == undefined) ret = this.GetAmountWinSound(coins); return ret }; VideoSlot.prototype.HandleOrientationChange = function (orientation) { this.aD = this.O.ai.bF ? "pt" : "ls"; sjs.layers["scalelayer"].Scale(scale_layer_pos[this.aD].scale, scale_layer_pos[this.aD].scale); sjs.layers["scalelayer"].setBounds(scale_layer_pos[this.aD]); if (DEVICE.orientation == "ls") sjs.layers["scalelayer"].Origin("center", "78.813559322033898305084745762712%"); else sjs.layers["scalelayer"].Origin("center", "bottom"); if (this.G.HandleOrientationChange) this.G.HandleOrientationChange(orientation); this.bu.m_GamePanelHandler.HandleOrientationChange(this.O.ai.bF); this.bu.aT.HandleOrientationChange(this.O.ai.bF); this.bu.aq.HandleOrientationChange(this.O.ai.bF); this.aJ.HandleOrientationChange(this.O.ai.bF); this.bJ.HandleOrientationChange(this.O.ai.bF); if (this.bb.Active()) this.m_GamePanelHandler.FreeGameOrientationChange(); if (this.bX) this.bX.HandleOrientationChange(); if (JackpotHandler) if (JackpotHandler.HandleOrientationChange) JackpotHandler.HandleOrientationChange(DEVICE.orientation === "pt"); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.HandleOrientationChange() }; VideoSlot.prototype.UpdateBetMenuSpinnerData = function () { if (this.bu.aq) { var betDlg_SpinnerValues = { denominations: this.bG.getDenominationData(), initDenomination: this.bG.GetCoinDenomination(this.bG.getCoins()), coins: this.bG.getMaxCoins(), initCoin: this.bG.getCoins(), lines: this.bG.getMaxLines(), initLine: this.bG.getLines() }; this.bu.aq.SetBetDlgSpinnerData(betDlg_SpinnerValues); this.bu.aq.SetDenominationMultiplier(this.bG.getDenominationMultiplier()); this.SetBetDlgValues() } }; VideoSlot.prototype.ProcessDenominationsCommand = function (cmd) { this.bG.SetEnabledDenominations(cmd); this.bG.ResolveDenominations(this.oV); var defaultDenomination = this.O.lJ; this.bG.setDenomination(defaultDenomination * this.bG.getDenominationMultiplier()); this.UpdateBetMenuSpinnerData(); this.UpdateGamePanel(this.O.getBalance()) }; VideoSlot.prototype.ProcessCommand = function (cmd) { if (cmd.ae == Command.SRECONNECTEND && !this.O.C) return; this.O.ProcessCommand(cmd); if (this.qW) { var packet = this.qW.FromServer(cmd); if (packet) this.aJ.OnIncomingPacket(cmd) } else this.aJ.OnIncomingPacket(cmd); switch (cmd.ae) { case Command.SLOGINANSWER: if (this.bu.aq.m_GameRulesView != undefined && this.O.ha != "") this.bu.aq.m_GameRulesView.loadPage(decodeURIComponent(this.O.ha) + "&method=open&currency=" + this.O.cW); break; case Command.SRECONNECTEND: if (this.G.ReconnectEnd) this.G.ReconnectEnd(); if (this.bu.aT) this.bu.aT.ReconnectEnd(); if (this.aJ) this.aJ.ReconnectEnd(); if (this.aO) this.aO.ReconnectEnd(); if (this.bu.aq) this.bu.aq.ReconnectEnd(); if (this.aQ) this.aQ.ReconnectEnd(); this.bJ.flush(); this.bA.ReconnectEnd(); this.SetBet(this.GetBetAmount(), true); if (this.av) this.av.ReconnectEnd(); else for (var i = 0; i < this.bw.length; i++) this.bw[i].ReconnectEnd(); this.OnSettingsNotify({ type: "SoundEnabled" }); if (this.O.aM) this.O.ai.initOrientationCheck(); this.initGamePanelValues(); if (this.m_State == VideoSlot.WAITINGSPIN && this.bX) this.bu.aT.ShowSpinPanel(false); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.onBetChange(this.GetBetAmount()); this.C = false; break; case Command.SSPDENOMINATIONS: this.ProcessDenominationsCommand(cmd); this.SetWin(0); break } switch (cmd.ae) { case CmdType.SFREESPINCMD: if (this.O.C) { this.la = cmd.GetInt(0); this.aJ.setConfirmCollect(true) } break; case CmdType.SPIN: if (this.O.C && this.aO.getFreeSpinMode()) { if (this.O.aZ.PeekNext() != CmdType.FEATURE) if (this.aO.GetPlayedFreeSpins() == this.la) { var reconnectCmd = new Command; reconnectCmd.ae = Command.SRECONNECTEND; this.ProcessCommand(reconnectCmd) } this.bu.aT.ShowSpinPanel(false) } if (!this.hy && !this.aO.getFreeSpinMode()) this.StartAnimSpin(); this.hy = false; this.eQ = false; this.cw.length = 0; this.cT = 0; if (this.av) this.av.Clear(); else { this.bw.length = 0; this.bs = 0 } this.bG.setCoins(cmd.GetInt(0)); this.bG.setLines(cmd.GetInt(1)); if (this.O.C && !this.aO.getFreeSpinMode()) this.bb.GameStart(); var denom = cmd.GetMoney(2); if (this.O.C || this.aO.getNumFreeSpins() > 0) { if (this.O.C) { this.cl = false; this.bu.aT.ShowSpinPanel(false) } this.m_State = VideoSlot.WAITINGRESPONSE } this.bG.setDenomination(denom); this.SetBet(this.GetBetAmount()); this.RoundStart(); this.og = 0; this.oY = 0; this.jn = 0; this.ProcessSpinCommand(cmd); if (!this.aO.getFreeSpinMode()) this.aU = this.fA + this.O.fW; else this.aU = getTimer() + 700; this.m_State = VideoSlot.STOPREELS; if (this.G.OnChangeState) this.G.OnChangeState(VideoSlot.STOPREELS); break; case CmdType.SPINEND: var canContinueGamble = cmd.GetInt(0) > 0; this.oe = cmd.GetInt(1); this.ft = cmd.GetInt(2); if (this.ft <= 0) canContinueGamble = false; if (this.av) this.av.Complete(); if (this.CheckAutoPlay) this.CheckAutoPlay(this.ft, this.O.getCurrentFunds()); this.aO.setWonCoins(cmd.GetInt(1)); this.eQ = true; this.aJ.SetGambleFinished(!canContinueGamble); if (this.aO.getFreeSpinMode()) if (cmd.GetInt(3) == 0) this.aO.ForceEnd(); if (this.O.C && this.aO.getFreeSpinMode()) if (this.aO.GetPlayedFreeSpins() == this.la) { reconnectCmd = new Command; reconnectCmd.ae = Command.SRECONNECTEND; this.ProcessCommand(reconnectCmd) } break; case CmdType.FEATURE: switch (cmd.GetInt(0)) { case CmdType.FEATURE_START: if (this.av) this.av.AddFeature(this.FeatureFactoryInternal(cmd), this.O.aZ, this.bu.bG, this.bK); else { var feature = this.FeatureFactoryInternal(cmd); this.bw.push(feature); feature.Clean(this.O.C, this.O.aZ, this.bu.bG) } default: if (this.av) this.av.HandleCommand(cmd); else { this.bw[this.bw.length - 1].HandleCommand(cmd); if (cmd.GetInt(0) == CmdType.FEATURE_AWARD && cmd.GetInt(1) == FeatureAward.COINS) { this.oY += cmd.GetInt(2); this.jn += cmd.GetInt(2) } } break } break; case Command.SSFREEGAME: this.bb.OnIncomingPacket(cmd); break; case Command.SSFREEGAMEEND: this.bb.OnIncomingPacket(cmd); break; case CmdType.PAYOUT: this.aJ.SetGambleFinished(true); break; case Command.SSPCUSTOMDATA: this.ProcessCustomData(cmd); break } }; VideoSlot.prototype.FeatureFactoryInternal = function (cmd) { if (cmd.GetInt(1) == FEATURE_MYSTERYJACKPOT) if (this.av) { this.GotJackpotFeature(); return this.m_MysteryJackpotFeature } else { this.GotJackpotFeature(); return this.m_MysteryJackpotFeature.aW } return this.G.FeatureFactory(cmd) }; VideoSlot.prototype.ProcessCustomData = function (cmd) { if (typeof JackpotHandler !== "undefined") if (JackpotHandler.ProcessCustomData) { var jackpots = JackpotHandler.ProcessCustomData(cmd); if (cmd.dM[0].indexOf('MysteryJackpot Enabled="1"') > -1) { this.InitMysteryJackpotFeature(jackpots); this.HandleOrientationChange() } } }; VideoSlot.prototype.initGamePanelValues = function () { var balanceAdjust = 0; if (this.ft > 0 || this.av != null && this.av.bw.length > 0) balanceAdjust = this.bG.GetBetCoins(); var coinBalance = this.bG.AmountToCoins(this.O.getBalance()) - balanceAdjust; this.m_GamePanelHandler.setInfoBarText(Locale.IDS_LBL_COINS + ": " + coinBalance, 1); this.m_GamePanelHandler.setInfoBarText(Locale.IDS_MENU_BET_VSLOT + ": " + this.bG.GetBetCoins(), 3) }; VideoSlot.prototype.ProcessSpinCommand = function (cmd) { var data = 3 + this.az * 3; this.qi = cmd.GetInt(data++); var winLines = cmd.GetInt(data++); for (var i = 0; i < winLines; i++) { var lineIndex, wonAmount, symbols, symbol, flags; lineIndex = cmd.GetInt(data); wonAmount = cmd.GetInt(data + 4); symbols = cmd.GetInt(data + 2); symbol = cmd.GetInt(data + 1); flags = cmd.GetInt(data + 3); this.bA.AddLineWin(i, lineIndex, wonAmount, symbols, symbol, flags, this.bG.getCoins()); data += 5; this.og += wonAmount; this.jn += wonAmount } var symbolArray; if (this.lY) { data = 5 + 3 * 3 + winLines * 5; symbolArray = new Array(cmd.GetInt(data), cmd.GetInt(3), cmd.GetInt(4), cmd.GetInt(5), cmd.GetInt(data + 1), cmd.GetInt(data + 2), cmd.GetInt(6), cmd.GetInt(7), cmd.GetInt(8), cmd.GetInt(data + 3), cmd.GetInt(data + 4), cmd.GetInt(9), cmd.GetInt(10), cmd.GetInt(11), cmd.GetInt(data + 5)) } else symbolArray = new Array(cmd.GetInt(3), cmd.GetInt(4), cmd.GetInt(5), cmd.GetInt(6), cmd.GetInt(7), cmd.GetInt(8), cmd.GetInt(9), cmd.GetInt(10), cmd.GetInt(11), cmd.GetInt(12), cmd.GetInt(13), cmd.GetInt(14), cmd.GetInt(15), cmd.GetInt(16), cmd.GetInt(17)); this.bv = symbolArray; if (this.aQ) this.aQ.NextReels(symbolArray) }; VideoSlot.prototype.SetReels = function (reels, reelNo) { this.bv = reels; this.G.SetReels(reels, reelNo) }; VideoSlot.prototype.OnSettingsNotify = function (e) { if (e.type == "CHANGE" || e.type == "CLICKED") { this.OnCollect(); this.StopWinAnim(); this.SetBet(this.GetBetAmount()); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.onBetChange(this.GetBetAmount()); for (var i = 0; i < this.bG.eV; i++) this.aV[i].Enable(true); for (var i = this.bG.eV; i < this.bG.getMaxLines() ; i++) this.aV[i].Enable(false) } }; VideoSlot.prototype.OnSettingsNotifyLock = function (lock) { this.bu.aq.DisableAllBetSpinners(lock) }; VideoSlot.prototype.StopWinAnim = function (gambleStart) { this.bA.Stop(); this.m_GamePanelHandler.setInfoBarText("", 2) }; VideoSlot.prototype.OnGameEvent = function (type) { switch (type) { case "startspinsound": break } }; VideoSlot.prototype.DoSpin = function () { var that = this; setTimeout(function () { that.OnGameEvent("startspinsound") }, 200); if (this.aQ) this.aQ.StartReels(); if (this.G.aO) { if (!this.G.aO.getFreeSpinMode()) SoundPlayer.Play(0) } else SoundPlayer.Play(0); this.eQ = false; if (!this.aQ) { if (this.oT && !this.O.C) { var time = getTimer(); spinTimer[0] = time + 2 * 83 * 1; spinTimer[1] = time + 2 * 83 * 2; spinTimer[2] = time + 2 * 83 * 3; spinTimer[3] = time + 2 * 83 * 4; this.fg = true; this.ab[0].Start() } else { var randReel1 = Utils.RandRange(1, 4); var randReel2 = Utils.RandRange(1, 4); var randReel3 = Utils.RandRange(1, 4); if (randReel1 == randReel2) randReel2 = (randReel2 + 1) % 4 + 1; if (randReel2 == randReel3) randReel3 = (randReel3 + 1) % 4 + 1; this.ab[0].Start(randReel1); this.ab[1].Start(randReel2); this.ab[2].Start(randReel3); if (this.az == 5) { this.ab[3].Start(randReel2); this.ab[4].Start(randReel1) } this.cl = false } this.bj = 0 } if (this.aO.getFreeSpinMode()) { if (!this.O.C && this.aJ.getConfirmCollect()) this.O.aZ.Send(CmdType.CFREESPINCMD, this.aO.GetPlayedFreeSpins()); this.m_State = VideoSlot.WAITINGRESPONSE } this.fA = getTimer(); this.bA.HidePayBoxAmount() }; GameBase.prototype.onCurrency = VideoSlot.prototype.UpdateBetDisplay; VideoSlot.prototype.UpdateBetDisplay = function () { }; VideoSlot.prototype.GetBetAmount = function () { return this.bG.getCoins() * this.bG.getDenomination() * this.bG.getLines() }; VideoSlot.prototype.ShowNewGame = function () { if (this.m_State == VideoSlot.WAITINGSPIN) this.eP = 0; this.O.ShowNewGame() }; VideoSlot.prototype.OnFundsError = function () { this.O.AbortRound(); this.StopAutoPlay(); this.m_State = VideoSlot.WAITINGSPIN; if (this.aQ) this.aQ.StopAll(); else for (var i = 0; i < this.az; i++) this.ab[i].Stop(true); this.bu.aT.ShowSpinPanel(true); this.ShowNewGame(); if (!this.bG.getLock()) this.bu.aq.DisableAllBetSpinners(false) }; VideoSlot.prototype.ButtonClicked = function () { }; VideoSlot.prototype.BetAdjustDown = function () { var adjusted = false; if (this.bG.getCoins() > 1) { this.bG.setCoins(this.bG.getCoins() - 1); adjusted = true } else if (this.bG.getLines() > 1) { this.bG.setLines(this.bG.getLines() - 1); adjusted = true } return adjusted }; VideoSlot.prototype.QuickstopAvailable = function (enabled) { if (!enabled || !this.O.m_QuickStopEnabled) this.jW.Show(false); else { var autoPlay = this.bf !== undefined ? this.bf : this.bK && this.bK.bf; var freespins = this.aO && this.aO.getFreeSpinMode(); this.jW.Show(!autoPlay && !freespins) } }; VideoSlot.prototype.OnSpin = function (auto) { if (ModalWin.GetVisibleState()) { this.StopAutoPlay(); return } this.du = false; this.eA = false; this.qY = false; SpinStart = getTimer(); if (this.G.OnSpin) this.G.OnSpin(); this.bu.aT.ShowSpinPanel(false); this.bu.aq.DisableAllBetSpinners(true); this.bA.HidePayBoxAmount(); if (this.m_State == VideoSlot.WAITINGRESPONSE || this.m_State == VideoSlot.STOPREELS) return; if (this.m_State != VideoSlot.WAITINGSPIN) return; this.ib = false; this.StopWinAnim(); this.bA.Stop(); this.OnCollect(null, false, true); var needMoney = false; if (!this.bb.Active()) needMoney = !this.bG.AdjustBet(this.O.getBalance()); this.m_State = VideoSlot.WAITINGRESPONSE; this.bb.GameStart(); this.hy = false; this.SetBet(this.GetBetAmount()); HostInterface.processVideoslotState({ type: HostInterface.CALL_SPIN_STARTED }); if (this.aJ.getConfirmCollect()) this.O.aZ.Send(CmdType.SPIN, this.bG.getCoins(), this.bG.getLines(), this.bG.getDenomination(), 1); else this.O.aZ.Send(CmdType.SPIN, this.bG.getCoins(), this.bG.getLines(), this.bG.getDenomination()); this.RoundStart(); if (!needMoney) this.StartAnimSpin() }; VideoSlot.prototype.StartAnimSpin = function () { this.bu.aq.DisableAllBetSpinners(true); this.hy = true; this.fA = getTimer(); this.eP = 0; this.eQ = false; this.qD = getTimer() + 165; this.DoSpin() }; VideoSlot.prototype.UpdateFreeSpin = function () { if (this.G.UpdateFreeSpin) this.G.UpdateFreeSpin() }; VideoSlot.prototype.UpdateFreeSpinWin = function (totFreeSpinWin) { if (this.G.UpdateFreeSpinWin) this.G.UpdateFreeSpinWin(totFreeSpinWin) }; VideoSlot.prototype.DoFreeSpinModeEnd = function () { if (this.G.DoFreeSpinModeEnd) this.G.DoFreeSpinModeEnd(); this.m_GamePanelHandler.setInfoBarText(Str.Replace(CreditFormatter.GetCreditString(Locale.IDS_MENU_WONCOINS_FREESPINS, Locale.IDS_MENU_WONMONEY_FREESPINS), "%d", CreditFormatter.FormatCoinValue(this.aO.getTotalFreeSpinWin())), 2) }; VideoSlot.prototype.FreeSpinModeInit = function () { this.ji = true; if (this.G.FreeSpinModeInit) this.G.FreeSpinModeInit() }; VideoSlot.prototype.FreeSpinModeStart = function () { if (this.ke) { this.aT.ShowAutoPlayPanel(true); this.ke = false } this.ji = false; if (this.G.FreeSpinModeStart) this.G.FreeSpinModeStart() }; VideoSlot.prototype.OnCollect = function (e, force, spin) { if (this.aJ.CanGamble() || force) { this.RoundEnd(this.ft); this.ft = 0; this.aJ.End(); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.setGambleMode(false); if (!force) { this.eP = 0; if (!this.bG.getLock() && !spin) this.bu.aq.DisableAllBetSpinners(false); this.UpdateAutoPlayDlgStates() } else if (!this.bf) { this.bu.aT.ShowSpinPanel(true); if (!this.bG.getLock()) this.bu.aq.DisableAllBetSpinners(false); this.UpdateAutoPlayDlgStates() } this.bu.aT.ShowGamblePanel(false); clearTimeout(this.mK); this.bJ.Show(false); this.m_State = VideoSlot.WAITINGSPIN; if (typeof this.m_GamePanelHandler.enableMenuButton === "function") this.m_GamePanelHandler.enableMenuButton(true) } if (this.bf && !this.aT.et.getShowing()) { this.aT.ShowAutoPlayPanel(true); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Show(true) } this.bA.HidePayBoxAmount() }; VideoSlot.prototype.SetBet = function (bet, keepWin) { this.O.SetBet(bet); if (bet != 0 && !keepWin) this.m_GamePanelHandler.setWin(Utils.MoneyToString(0)); if (!keepWin) this.StopWinAnim(); for (var i = 0; i < this.ab.length; i++) this.ab[i].ClearAnimationData() }; VideoSlot.prototype.SetWin = function (win) { this.m_GamePanelHandler.setWin(Utils.MoneyToString(win)) }; VideoSlot.prototype.UpdateGamePanel = function (balance) { if (balance != undefined) { if (!this.bb.Active()) this.m_GamePanelHandler.setBalance(Utils.MoneyToString(balance)); if (balance > 0) this.m_GamePanelHandler.setInfoBarText(Locale.IDS_LBL_COINS + ": " + this.bG.AmountToCoins(balance), 1); else this.m_GamePanelHandler.setInfoBarText(Locale.IDS_LBL_COINS + ": " + "0", 1) } if (!this.bb.Active()) this.m_GamePanelHandler.setBet(this.bG.GetBetAmount()); this.m_GamePanelHandler.setInfoBarText(Locale.IDS_MENU_BET_VSLOT + ": " + this.bG.GetBetCoins(), 3) }; VideoSlot.prototype.CoinsToMoneyString = function (coins) { return Utils.MoneyToString(coins * this.bG.getDenomination()) }; VideoSlot.prototype.RoundStart = function (inGame) { clearTimeout(this.mK); this.bJ.Show(false); if (!this.aO.getFreeSpinMode()) this.bJ.reset(); this.bu.m_GamePanelHandler.setInfoBarText(Locale.IDS_MSG_GOODLUCK, 2); this.O.RoundStart(inGame); if (inGame) this.m_GamePanelHandler.setWin(Utils.MoneyToString(0)); if (this.G.OnRoundStart) this.G.OnRoundStart() }; VideoSlot.prototype.RoundEnd = function (win, stayInGame) { this.m_GamePanelHandler.setInfoBarText(" ", 2); this.O.RoundEnd(win, stayInGame); this.m_GamePanelHandler.setWin(Utils.MoneyToString(win)); if (this.G.OnRoundEnd) this.G.OnRoundEnd(); if (this.bK && this.bf) this.bK.OnRoundEnd(win) }; VideoSlot.prototype.OnFreeGameEvent = function (state, data, lastRound) { this.m_GamePanelHandler.OnFreeGameEvent(state, data, lastRound, this.bb); if (state == this.bb.START) { this.pU = this.bb.START; if (this.bG.addTemporaryFreegameDenomIfMissing(data.Denomination)) this.bu.aq.AddTemporaryDenomination(data.Denomination, data.Bet, data.Lines); this.bG.setCoins(data.Bet); this.bG.setLines(data.Lines); this.bG.setDenomination(data.Denomination); this.bG.setLock(true); this.SetBetDlgValues(); if (!data.Resumed) { var message = ""; if (data.FreeGames > 1) message = Str.Replace(Locale.IDS_WONFREEGAMES, "%d", "" + data.FreeGames); else message = Str.Replace(Locale.IDS_WONFREEGAME, "%d", "" + data.FreeGames); var msg = new ServerMessage(this.O, Locale.IDS_FREEGAMESTITLE, message, 0, undefined, true) } else { var message = ""; if (data.FreeGames > 1) message = Str.Replace(Locale.IDS_FREEGAMES_RECONNECT, "%d", "" + data.FreeGames); else message = Str.Replace(Locale.IDS_FREEGAME_RECONNECT, "%d", "" + data.FreeGames); var msg = new ServerMessage(this.O, Locale.IDS_FREEGAMESTITLE, message, 0, undefined, true) } this.OnFreeGameEvent(this.bb.TOTALWIN, data); this.bu.aq.LockBetSpinners(true) } if (state == this.bb.END) { var denom = this.bG.removeTemporaryFreegameDenom(); if (denom != -1) this.bu.aq.RemoveTemporaryDenominations(); var msg = new ServerMessage(this.O, Locale.IDS_FREEGAMESTITLE, Locale.IDS_FREEGAMESCOMPLETED, 0, undefined, true), coins = this.O.mv, lines = this.O.mo, denomination = this.O.lJ * this.bG.getDenominationMultiplier(); this.bG.setLock(false); this.bG.setCoins(coins > 0 && coins <= this.bG.getMaxCoins() ? coins : this.bG.getMaxCoins()); this.bG.setLines(lines > 0 && lines <= this.bG.getMaxLines() ? lines : this.bG.getMaxLines()); this.bG.setDenomination(denomination); this.SetBet(this.GetBetAmount(), true); this.O.SetBalanceText(); this.StopAutoPlay(); this.ie = false; this.bu.aq.LockBetSpinners(false); this.bu.aq.EnableAutoPlayDlg(true); this.bu.aq.cN.ik.Enable2(true) } if (state == this.bb.TOTALWIN); if (state == this.bb.ADDITIONAL_FREEGAMES) this.O.qF.Show(true) }; VideoSlot.prototype.GotBonusFeature = function () { if (this.bK) this.bK.OnBonusWin(); else this.StopAutoPlay(); this.aT.ShowAutoPlayPanel(false); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Show(false) }; VideoSlot.prototype.GotFreespinFeature = function () { this.ji = true; if (this.bK) this.bK.OnFsWin(); else this.StopAutoPlay(); this.aT.ShowAutoPlayPanel(false); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Show(false) }; VideoSlot.prototype.GotJackpotFeature = function () { if (this.bK && this.bK.bf === false) return; else if (this.bK) this.bK.OnJackpotWin(); else this.StopAutoPlay() }; VideoSlot.prototype.StopAutoPlay = function () { if (this.bK && this.bK.bf === false) return; if (this.m_Autoplay === false) return; if (this.bK) this.bK.Stop(); if (this.m_State == VideoSlot.WAITINGSPIN && !this.ie) this.bu.aq.DisableAllBetSpinners(false); this.bf = false; if (this.bK) this.bK.setAutoPlay(false); var timerAdjust = 100; if (this.ie) { this.bu.aq.EnableAutoPlayDlg(false, true); timerAdjust = 1E3 } this.eP = getTimer() + timerAdjust }; VideoSlot.prototype.OnAutoPlayToggle = function () { this.bf = !this.bf; this.aT.ShowAutoPlayPanel(this.bf); if (this.bK && this.aT.getAutoPlay()) this.bK.bf = this.aT.getAutoPlay(); else if (this.bK) this.bK.bf = this.bf }; VideoSlot.prototype.HasFeatures = function (bonus, freespin, jackpot, autoplayhandler) { if (autoplayhandler != undefined) this.bK = autoplayhandler; var tmpBonus = bonus != undefined ? bonus : false; var tmpFreespin = freespin != undefined ? freespin : false; var tmpJackpot = jackpot != undefined ? jackpot : false; if (this.bK) { this.bK.SetBonusEnabled(tmpBonus); this.bK.SetFreeSpinEnabled(tmpFreespin); this.bK.SetJackpotEnabled(tmpJackpot) } }; VideoSlot.prototype.SetTickerText = function (text, id) { id -= 1; if (this.bJ && id == GameBase.MSG_INFORMATION) this.bJ.SetInfoText(text); else this.bJ.SetInfoText(text, id) }; VideoSlot.prototype.onGambleEvent = function (e) { switch (e.n) { case RedOrBlack.WINAMOUNTCHANGED: if (this.bJ) if (this.aJ.getWonCoins() > 0 && this.iU) this.bJ.setWinAmount(this.aJ.getWonCoins(), 700); else this.bJ.reset(); this.ft = this.bG.CoinsToAmount(this.aJ.getWonCoins()); this.m_GamePanelHandler.setWin(Utils.MoneyToString(this.ft)); if (this.aJ.getWonCoins()) HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_WON, winamount: this.aJ.getWonCoins() }); break; case RedOrBlack.INIT: if (this.bJ) { if (this.iU) this.bJ.setWinAmount(this.aJ.getWonCoins()); this.bJ.showInfo(); var str = Str.Replace(Str.Replace(CreditFormatter.GetCreditString(Locale.IDS_GAMBLELIMIT, Locale.IDS_GAMBLELIMIT_MONEY), "%d", this.aJ.getMaxGambles()), "%c", CreditFormatter.FormatCoinValue(this.aJ.getGambleLimit())); this.m_GamePanelHandler.setInfoBarText(str, 2); this.StopWinAnim(true); this.bu.aq.EnableAutoPlayDlg(false, true) } HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_STARTED }); break; case RedOrBlack.COMPLETE: this.SetTickerText(" ", GameBase.MSG_INFORMATION); this.OnCollect(null, true); this.bu.aq.EnableAutoPlayDlg(true, true); HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_ENDED }); if (this.G.R.aJ.iR == 0) HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_LOST }); break; case RedOrBlack.PICK: this.DisableCollectButton(true); this.O.aZ.Send(CmdType.GAMBLECMD, e.rb_choice); if (e.n == 4 && e.rb_choice == 0) HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_ENDED }); break; case RedOrBlack.DISABLECOLLECT: this.DisableCollectButton(e.b); break; case RedOrBlack.RUNNING: this.m_State = VideoSlot.GAMBLE; this.OnChangeState(VideoSlot.GAMBLE); this.bu.aT.gC = false; this.bu.aT.BlinkSequenceEnd(); this.bu.aT.DisableGamble(true); break } }; VideoSlot.prototype.DisableCollectButton = function (b) { this.bu.aT.DisableCollect(b) }; VideoSlot.prototype.FreeSpinModeEnd = function (e) { if (this.bJ) this.bJ.reset(e); if (!this.O.C && this.aJ.getConfirmCollect()) this.O.aZ.Send(CmdType.CFREESPINCMD, this.aO.getTotalFreeSpins()); this.aO.Reset(); this.la = 0; this.DisplayWinEnableUI() }; VideoSlot.prototype.OnQuickWinView = function () { if (this.bJ) this.bJ.OnQuickWinView() }; VideoSlot.prototype.FreeSpinCallBack = function (e, reel) { var FreeSpin = this.G.FreeSpinCallBack(e, reel); switch (e) { case FreeSpinHandler.INIT: HostInterface.processVideoslotState({ type: HostInterface.CALL_FREESPIN_STARTED }); break; case FreeSpinHandler.END: HostInterface.processVideoslotState({ type: HostInterface.CALL_FREESPIN_ENDED }); break; case FreeSpinHandler.NEXTSPIN: HostInterface.processVideoslotState({ type: HostInterface.CALL_SPIN_STARTED }); break } return FreeSpin }; VideoSlot.prototype.OnFreeSpinStart = function () { this.aO.NextSpin(); this.aT.ShowSpinPanel(false); this.bA.HidePayBoxAmount() }; VideoSlot.prototype.OnFeaturesStopped = function (e) { if (e.FreeSpins > 0) this.aO.AddFreeSpins(e.FreeSpins); this.OnChangeState(VideoSlot.HANDLEWIN) }; VideoSlot.prototype.HTMLUISidePanelCallback = function (e) { switch (e.type) { case 0: case 1: case 2: case 3: this.SidePanelCallback(e.type); break; case SpinButton.EVENT_START_AUTOPLAY: this.StartAutoPlay(); break; case QuickMenuVS.EVENT_AUTOPLAY_ENABLED: break; case QuickMenuVS.EVENT_AUTOPLAY_DISABLED: break; case QuickMenuVS.EVENT_FASTPLAY_ENABLED: this.bG.setFastPlay(true); break; case QuickMenuVS.EVENT_FASTPLAY_DISABLED: this.bG.setFastPlay(false); break; case QuickMenuVS.EVENT_LINES_CHANGED: if (this.bG) this.UpdateBetValue(2, e.data.value); break; case QuickMenuVS.EVENT_COINS_CHANGED: if (this.bG) this.UpdateBetValue(1, e.data.value); break; case QuickMenuVS.EVENT_DENOM_CHANGED: if (this.bG) this.UpdateBetValue(0, e.data.index + 1); break; case QuickMenuVS.EVENT_BET_CHANGED: break } }; VideoSlot.prototype.SidePanelCallback = function (num) { switch (num) { case 0: if (this.aO.getFreeSpinMode()) this.OnFreeSpinStart(); else this.OnSpin(); break; case 1: this.StopAutoPlay(); break; case 2: this.OnChangeState(VideoSlot.GAMBLE); this.bu.aT.ShowSpinPanel(false); this.bu.aT.DisableGamble(true); this.aJ.Start(); break; case 3: this.bu.aT.ShowSpinPanel(true); this.OnCollect(); this.bu.aq.EnableAutoPlayDlg(true, true); break } }; VideoSlot.prototype.OnInterRoundData = function (cmd) { }; GameBase.prototype.GoToLobby = function (b) { if (!b) { this.kD.Show(); return } if (this.bn.aJ.iE && this.bn.aJ.cF) this.bn.aJ.End(); this.OnLogout(); InvalidatePage(undefined, true) }; VideoSlot.prototype.OnQuickStop = function (e) { if (this.du === true) return; if (this.aQ) this.aQ.OnQuickStop(e); this.du = true; this.eA = true; this.qY = true }; VideoSlot.prototype.OnSplashContinue = function () { if (this.m_State == VideoSlot.WAITINGSPIN) this.bu.aT.ShowSpinPanel(true); this.bX = null }; VideoSlot.prototype.GetSelectedCoin = function () { return this.bG.getCoins() }; VideoSlot.prototype.GetSelectedCoinValue = function () { return Utils.MoneyToString(this.bG.getDenomination()) }; VideoSlot.prototype.GetSelectedLines = function () { return this.bG.getLines() }; VideoSlot.prototype.GetAvailableCoins = function () { return this.bG.getMaxCoins() }; GameBase.prototype.GetBet = function () { var o = {}; o.BetInCoins = this.bn.bG.GetBetCoins(); o.BetInMoney = Utils.MoneyToString(this.dh); o.Currency = Utils.cW; return o }; GameBase.prototype.GetBalance = function () { var o = {}; o.BalanceInCoins = Math.floor(this.getBalance() / this.bn.bG.getDenomination()); o.BalanceInMoney = Utils.MoneyToString(this.getBalance()); o.Currency = Utils.cW; return o }; GameBase.prototype.GetWin = function () { var o = {}; o.WinInCoins = this.dI / this.bn.bG.getDenomination(); o.WinInMoney = Utils.MoneyToString(this.dI); o.Currency = Utils.cW; return o }; function VideoSlotSettings(maxLines, maxCoins, notify, notifyLock) { if (this.constructor !== arguments.callee) return new VideoSlotSettings; var that = this; this.dU; this.eV; this.pQ; this.ej; this.jL; this.eb; this.fe = []; this.aE = []; this.dB; this.nz = 0; this.m_NeverGamble = false; var gameVars = getUrlVars(); var propName = Utils.hasOwnPropertyCaseInsensitive(gameVars, "autoadjustbet"); var propValue; if (propName) { propValue = gameVars[propName].toString().toLowerCase(); this.jt = !JSON.parse(propValue) } else this.jt = false; propName = Utils.hasOwnPropertyCaseInsensitive(gameVars, "nevergamble"); if (propName) { propValue = gameVars[propName].toString().toLowerCase(); this.m_NeverGamble = Boolean(JSON.parse(propValue)) } this.hB = notify; this.ot = notifyLock; this.jL = maxLines; this.eb = maxCoins; this.eV = this.jL; this.dU = this.eb; this.pI; this.ej = 0; this.hh = 1; this.m_TemporaryAddedFreegameDenom = -1; this.fe = [1, 2, 5, 10, 20, 25, 50, 100]; this.hh; this.AUTOADJUSTBET = "AutoAdjustBet"; this.EVENT_LOCK = "LockEvent"; this.EVENT_UNLOCK = "UnlockEvent"; this.nQ } VideoSlotSettings.prototype.constructor = VideoSlotSettings; VideoSlotSettings.prototype.getFastPlay = function () { return this.nQ }; VideoSlotSettings.prototype.setFastPlay = function (value) { this.nQ = value }; VideoSlotSettings.prototype.getLock = function () { return this.dB }; VideoSlotSettings.prototype.setLock = function (b) { this.dB = b; if (this.ot != undefined) this.ot(this.dB) }; VideoSlotSettings.prototype.setMaxWinAmount = function (val) { this.nz = val }; VideoSlotSettings.prototype.getMaxWinAmount = function () { return this.nz }; VideoSlotSettings.prototype.getAutoAdjustBet = function () { return this.jt }; VideoSlotSettings.prototype.setAutoAdjustBet = function (b) { this.jt = b }; VideoSlotSettings.prototype.toggleAutoAdjustBet = function () { this.jt = !this.jt }; VideoSlotSettings.prototype.setLines = function (l) { if (this.dB) return; this.eV = l; this.pQ = this.eV }; VideoSlotSettings.prototype.getLines = function () { return this.eV }; VideoSlotSettings.prototype.setCoins = function (c) { if (this.dB) return; this.dU = c; this.pI = this.dU }; VideoSlotSettings.prototype.getCoins = function () { return this.dU }; VideoSlotSettings.prototype.setDenom = function (c) { if (this.dB) return; this.ej = c; CreditFormatter.Denomination = this.getDenomination() }; VideoSlotSettings.prototype.getDenom = function () { return this.ej }; VideoSlotSettings.prototype.getDenomination = function () { if (this.ej < 0) return this.GetCoinDenomination(this.dU); return this.fe[this.ej] }; VideoSlotSettings.prototype.getCurrentDenominationIndex = function () { var denom = this.getDenomination(); return Utils.GetClosestValueIndex(denom, this.fe) }; VideoSlotSettings.prototype.getDenominationData = function () { return this.fe }; VideoSlotSettings.prototype.getCoinDenominationData = function () { return this.aE }; VideoSlotSettings.prototype.GetCoinDenomination = function (coins) { if (this.aE && this.aE.length >= coins - 1) return this.aE[coins - 1]; return 0 }; VideoSlotSettings.prototype.getDenominationMultiplier = function () { return this.hh }; VideoSlotSettings.prototype.setDenomination = function (denomination) { if (this.dB) return; this.setDenom(Utils.GetClosestValueIndex(denomination, this.fe)) }; VideoSlotSettings.prototype.GetBetAmount = function () { return Utils.MoneyToString(this.getCoins() * this.getDenomination() * this.getLines()) }; VideoSlotSettings.prototype.GetBetAmountRaw = function () { return this.getCoins() * this.getDenomination() * this.getLines() }; VideoSlotSettings.prototype.GetBetCoins = function () { return this.getCoins() * this.getLines() }; VideoSlotSettings.prototype.AmountToCoins = function (amount) { return Math.floor(amount / this.getDenomination()) }; VideoSlotSettings.prototype.CoinsToAmount = function (coins) { return coins * this.getDenomination() }; VideoSlotSettings.prototype.getMaxLines = function () { return this.jL }; VideoSlotSettings.prototype.getMaxCoins = function () { return this.eb }; VideoSlotSettings.prototype.getHasMultipleDenominations = function () { return this.fe.length > 1 }; VideoSlotSettings.prototype.getNeverGamble = function () { return this.m_NeverGamble }; VideoSlotSettings.prototype.SetEnabledDenominations = function (cmd) { var len = cmd.GetInt(0); this.fe.length = 0; for (var i = 1; i < len + 1; i++) { var denom = Number(cmd.GetInt(i)); this.fe.push(denom) } this.hh = cmd.GetInt(len + 1); if (isNaN(this.hh)) this.hh = 1; CreditFormatter.Denomination = this.getDenomination(); CreditFormatter.DenominationMultiplier = this.hh }; VideoSlotSettings.prototype.ResolveDenominations = function (limits) { this.aE = limits.split(","); if (this.aE.length > this.eb) this.aE.length = this.eb; if (this.aE.length < 1) this.aE.push(1); if (isNaN(this.aE[0])) this.aE[0] = 1; var i; for (i = 1; i < this.eb; i++) { if (this.aE.length < i + 1) this.aE.push(this.aE[i - 1]); if (isNaN(this.aE[i])) this.aE[i] = this.aE[i - 1] } for (i = 0; i < this.eb; i++) this.aE[i] = this.fe[Utils.GetClosestValueIndex(this.aE[i] * this.hh, this.fe)]; this.aE.sort(sortNumber) }; VideoSlotSettings.prototype.AdjustBet = function (balance) { if (this.dB) return false; if (!this.getAutoAdjustBet()) return true; if (balance >= this.GetBetAmountRaw()) return true; var oldDenomination = this.getDenom(); var oldCoins = this.getCoins(); var oldLines = this.getLines(); while (balance < this.GetBetAmountRaw()) if (!this.BetAdjustDown()) { this.setDenom(oldDenomination); this.setCoins(oldCoins); this.setLines(oldLines); return false } if (this.hB != undefined) this.hB({ type: "CHANGE" }); return true }; VideoSlotSettings.prototype.BetAdjustDown = function () { var oldDenom = this.getDenom(); var adjusted = false; if (this.ej > 0) this.ej--; if (oldDenom == this.getDenom()) if (this.dU > 1) { this.dU--; adjusted = true } else { if (this.eV > 1) { this.eV--; adjusted = true } } else adjusted = true; return adjusted }; VideoSlotSettings.prototype.BetMax = function () { if (this.dB) return; this.eV = this.jL; this.dU = this.eb; if (this.hB != undefined) this.hB({ type: "CHANGE" }) }; VideoSlotSettings.prototype.DispatchChangeEvent = function () { if (this.hB != undefined) this.hB({ type: "CHANGE" }) }; VideoSlotSettings.prototype.addTemporaryFreegameDenomIfMissing = function (denom) { var index = this.fe.indexOf(denom); if (index == -1) { this.m_TemporaryAddedFreegameDenom = denom; this.fe.push(denom); this.fe.sort(sortNumber); return true } return false }; VideoSlotSettings.prototype.removeTemporaryFreegameDenom = function () { if (this.m_TemporaryAddedFreegameDenom != -1) { var denom = this.m_TemporaryAddedFreegameDenom; this.fe.splice(this.fe.indexOf(this.m_TemporaryAddedFreegameDenom), 1); this.m_TemporaryAddedFreegameDenom = -1; return denom } return -1 }; function AutoPlaySettings(updateCallBack) { if (this.constructor !== arguments.callee) return new AutoPlaySettings; this.iZ = updateCallBack; this.mZ = false; this.nv = false; this.mf = false; this.lT = false; this.mR = false; this.nj = false; this.mN = false; this.ia = 0; this.it = 0; this.ig = 0; this.mb; this.mr = [10, 20, 30, 40, 50]; this.fw = 0; this.nR = false; this.nV = false; this.rj = false; this.bf = false; this.m_StopAtTotalLoss = false; this.m_StopAtTotalLossValue = 0; this.m_StopAtTotalLossPool = 0; this.m_CurrentBet = 0; Context.blur.add(Utils.delegate(this, this.Stop)) } AutoPlaySettings.prototype.constructor = AutoPlaySettings; AutoPlaySettings.prototype.HandleRoundEvent = function (e) { switch (e.type) { case RoundEvent.BALANCE: break; case RoundEvent.WIN: this.OnWin(e.jx); break } }; AutoPlaySettings.prototype.Start = function (balance) { this.mb = balance; HostInterface.processVideoslotState({ type: HostInterface.CALL_AUTOPLAY_STARTED, numautoplays: this.GetSpins() }); this.bf = true; this.m_StopAtTotalLossPool = this.m_StopAtTotalLossValue; StatsHandler.HandleEvent("autoplay", { numautoplays: this.GetSpins() }) }; AutoPlaySettings.prototype.Stop = function () { if (this.bf == true) HostInterface.processVideoslotState({ type: HostInterface.CALL_AUTOPLAY_ENDED }); this.fw = 0; this.bf = false; this.iZ() }; AutoPlaySettings.prototype.GetSpinsArray = function () { return this.mr }; AutoPlaySettings.prototype.SetSpinsArray = function (spinsArray) { this.mr = spinsArray }; AutoPlaySettings.prototype.GetSpins = function () { return this.fw }; AutoPlaySettings.prototype.SetSpinsUsingIndex = function (index) { this.fw = this.mr[index]; this.iZ() }; AutoPlaySettings.prototype.SetSpins = function (spins) { this.fw = spins; if (this.fw == 0) this.bf = false; this.iZ() }; AutoPlaySettings.prototype.OnSpin = function (bet) { this.m_CurrentBet = bet; if (this.m_StopAtTotalLoss) this.m_StopAtTotalLossPool -= bet; if (this.fw > 0) { this.fw--; HostInterface.processVideoslotState({ type: HostInterface.CALL_AUTOPLAY_NEXTROUND, numautoplays: this.GetSpins() }) } if (this.fw == 0) { this.bf = false; HostInterface.processVideoslotState({ type: HostInterface.CALL_AUTOPLAY_ENDED }) } this.iZ() }; AutoPlaySettings.prototype.OnWin = function (win) { if (this.mZ && win > 0) this.Stop(); else if (this.mR && win > this.ia) this.Stop() }; AutoPlaySettings.prototype.OnRoundEnd = function (win) { if (this.m_StopAtTotalLoss) { this.m_StopAtTotalLossPool += win; if (this.m_StopAtTotalLossPool < this.m_CurrentBet) this.Stop() } this.m_CurrentBet = 0 }; AutoPlaySettings.prototype.OnFsWin = function () { if (this.nv) this.Stop() }; AutoPlaySettings.prototype.OnBonusWin = function () { if (this.mf) this.Stop() }; AutoPlaySettings.prototype.OnJackpotWin = function () { if (this.lT) this.Stop() }; AutoPlaySettings.prototype.OnBalance = function (balance) { if (this.nj && balance >= this.mb + this.it) this.Stop(); else if (this.mN && balance <= this.mb - this.ig) this.Stop() }; AutoPlaySettings.prototype.GetStopAtAnyWin = function () { return this.mZ }; AutoPlaySettings.prototype.SetStopAtAnyWin = function (b) { this.mZ = b }; AutoPlaySettings.prototype.GetStopAtFsWin = function () { return this.nv }; AutoPlaySettings.prototype.SetStopAtFsWin = function (b) { this.nv = b }; AutoPlaySettings.prototype.GetStopAtBonusWin = function () { return this.mf }; AutoPlaySettings.prototype.SetStopAtBonusWin = function (b) { this.mf = b }; AutoPlaySettings.prototype.GetStopAtJackpotWin = function () { return this.lT }; AutoPlaySettings.prototype.SetStopAtJackpotWin = function (b) { this.lT = b }; AutoPlaySettings.prototype.GetStopAtWin = function () { return this.mR }; AutoPlaySettings.prototype.SetStopAtWin = function (b) { this.mR = b }; AutoPlaySettings.prototype.GetStopAtBalanceInc = function () { return this.nj }; AutoPlaySettings.prototype.SetStopAtBalanceInc = function (b) { this.nj = b }; AutoPlaySettings.prototype.GetStopAtBalanceDec = function () { return this.mN }; AutoPlaySettings.prototype.SetStopAtBalanceDec = function (b) { this.mN = b }; AutoPlaySettings.prototype.SetStopAtTotalLoss = function (b) { this.m_StopAtTotalLoss = b }; AutoPlaySettings.prototype.GetStopAtWinValue = function () { return this.ia }; AutoPlaySettings.prototype.SetStopAtWinValue = function (n) { this.ia = n != "" || n != " " ? Math.floor(n * 100) : 0; this.SetStopAtWin(this.ia != 0) }; AutoPlaySettings.prototype.GetStopAtBalanceIncValue = function () { return this.it }; AutoPlaySettings.prototype.SetStopAtBalanceIncValue = function (n) { this.it = n != "" || n != " " ? Math.floor(n * 100) : 0; this.SetStopAtBalanceInc(this.it != 0) }; AutoPlaySettings.prototype.GetStopAtBalanceDecValue = function () { return this.ig }; AutoPlaySettings.prototype.SetStopAtBalanceDecValue = function (n) { this.ig = n != "" || n != " " ? Math.floor(n * 100) : 0; this.SetStopAtBalanceDec(this.ig != 0) }; AutoPlaySettings.prototype.GetStopAtTotalLossValue = function () { return this.m_StopAtTotalLossValue }; AutoPlaySettings.prototype.SetStopAtTotalLossValue = function (n) { this.m_StopAtTotalLossValue = n != "" || n != " " ? Math.floor(n * 100) : 0; this.SetStopAtTotalLoss(this.m_StopAtTotalLossValue != 0) }; AutoPlaySettings.prototype.GetFreeSpinEnabled = function () { return this.nR }; AutoPlaySettings.prototype.SetFreeSpinEnabled = function (b) { this.nR = b }; AutoPlaySettings.prototype.GetBonusEnabled = function () { return this.nV }; AutoPlaySettings.prototype.SetBonusEnabled = function (b) { this.nV = b }; AutoPlaySettings.prototype.GetJackpotEnabled = function () { return this.rj }; AutoPlaySettings.prototype.SetJackpotEnabled = function (b) { this.rj = b }; AutoPlaySettings.prototype.setAutoPlay = function (b) { if (b == false && this.bf != b) HostInterface.processVideoslotState({ type: HostInterface.CALL_AUTOPLAY_ENDED }); this.bf = b; this.iZ() }; AutoPlaySettings.prototype.getAutoPlay = function () { return this.bf }; FreeSpinHandler.INIT = 0; FreeSpinHandler.END = 1; FreeSpinHandler.START = 2; FreeSpinHandler.NEXTSPIN = 3; FreeSpinHandler.UPDATE = 4; FreeSpinHandler.COMPLETE = 5; function FreeSpinHandler(eventcallback) { var that = this; this.ao = eventcallback; this.fL = 0; this.cT = 0; this.lG = 0; this.bh = false; this.hI = 0; this.fS = false; this.gZ = 0; this.gF = 1; this.C = true; this.jD = false; this.cO = 0; this.qT } FreeSpinHandler.prototype.constructor = FreeSpinHandler; FreeSpinHandler.prototype.DoFreeSpin = function () { var that = this; if (!this.bh || this.fS) { if (!this.bh) { this.fL = getTimer() + 80 * 5; this.hI = this.gZ; this.bh = true; this.ao(FreeSpinHandler.INIT); return } this.ao(FreeSpinHandler.START); this.fS = false } this.hI = this.gZ; if (this.cT > 0) this.cT--; this.UpdateFreeSpin(); setTimeout(function () { that.OnNextSpinTimer() }, this.gF) }; FreeSpinHandler.prototype.ForceEnd = function () { this.jD = true }; FreeSpinHandler.prototype.getFreeSpinStartTimer = function () { return this.fL }; FreeSpinHandler.prototype.setMaxAmountCap = function (val) { this.cO = val }; FreeSpinHandler.prototype.getMaxAmountCap = function () { return this.cO }; FreeSpinHandler.prototype.getTotalFreeSpinWin = function () { return this.hI }; FreeSpinHandler.prototype.getRestartFreeSpin = function () { return this.fS }; FreeSpinHandler.prototype.setWonCoins = function (value) { this.gZ = value }; FreeSpinHandler.prototype.getFreeSpinMode = function () { return this.bh }; FreeSpinHandler.prototype.setFreeSpinMode = function () { return this.bh }; FreeSpinHandler.prototype.getNumFreeSpins = function () { return this.cT }; FreeSpinHandler.prototype.getTotalFreeSpins = function () { return this.lG }; FreeSpinHandler.prototype.ReconnectEnd = function () { this.C = false }; FreeSpinHandler.prototype.Reset = function () { this.fS = false; this.hI = 0; this.lG = 0; this.cT = 0; this.bh = false; this.fL = 0; this.gZ = 0; this.jD = false }; FreeSpinHandler.prototype.Tick = function () { if (this.fL > 0 && (getTimer() > this.fL || this.C)) { this.fL = 0; this.DoFreeSpin() } }; FreeSpinHandler.prototype.NextSpin = function () { if (this.cT == 0 || this.jD) { if (this.jD) this.rE -= this.cT; this.hI = this.gZ; this.bh = false; this.ao(FreeSpinHandler.END) } else this.DoFreeSpin() }; FreeSpinHandler.prototype.OnNextSpinTimer = function (e) { this.gF = 1; this.ao(FreeSpinHandler.NEXTSPIN) }; FreeSpinHandler.prototype.AddFreeSpins = function (num) { if (this.jD) return; this.cT += num; this.lG += num; this.UpdateFreeSpin(); this.fS = true; this.qT = num }; FreeSpinHandler.prototype.AddAmount = function (num) { this.hI += num; this.UpdateFreeSpin() }; FreeSpinHandler.prototype.UpdateFreeSpin = function () { this.ao(FreeSpinHandler.UPDATE) }; FreeSpinHandler.prototype.GetPlayedFreeSpins = function () { return this.getTotalFreeSpins() - this.getNumFreeSpins() - 1 }; function FreeSpinBonus(eventHandler) { if (this.constructor !== arguments.callee) return new FreeSpinBonus; var aW = new Feature(eventHandler, this); this.Feature = aW; this.aW = aW; var ReconnectEnd = function () { C = false }; this.OnFeatureProcessed = function () { this.aW.SetAcceptInput(false) } }; FreeSpinBonus.prototype.OnTick = function (time) { if (!this.aW.CanProcess()) return false; switch (this.aW.State()) { case Feature.FEATURE_IDLE: this.aW.SetAcceptInput(true); this.aW.ChangeState(Feature.FEATURE_STARTED); break; case Feature.FEATURE_STARTED: this.aW.ChangeState(Feature.FEATURE_RUNNING); break; case Feature.FEATURE_RUNNING: this.aW.ChangeState(Feature.FEATURE_COLLECTED); break } var state = this.aW.State(); return state == Feature.FEATURE_COLLECTED }; FreeSpinBonus.prototype.contructor = FreeSpinBonus; function WinDisplay(cb) { this.ao = cb; this.bJ; this.aN; this.bh; this.cw = new Array; this.ac = new Array; this.aV = new Array; this.dg; this.dp; this.m_GamePanelHandler; this.bo; this.mP; this.ta; this.rm = 0; this.C = true; this.aK = -1; this.eK = 0; this.mg = 0; this.bQ = false; this.iL = false }; WinDisplay.prototype.constructor = WinDisplay; WinDisplay.prototype.setWinCounter = function (winCounter) { this.bJ = winCounter }; WinDisplay.prototype.Init = function (payLines, scatterAnimator, payboxAmountHandler, gph, pll, scatterTickDelay) { if (scatterTickDelay == undefined) scatterTickDelay = 23; this.aV = payLines; this.dp = scatterAnimator; this.dg = payboxAmountHandler; this.m_GamePanelHandler = gph; this.bo = pll; this.Stop() }; WinDisplay.prototype.OnWinLineClicked = function (eEvent) { }; WinDisplay.prototype.OnWinLineOver = function (eEvent) { }; WinDisplay.prototype.OnWinLineOut = function (eEvent) { }; WinDisplay.prototype.ReconnectEnd = function () { this.C = false; for (var i = 0; i < this.aV.length; i++) if (this.aV[i] && this.aV[i].ReconnectEnd) this.aV[i].ReconnectEnd(); if (this.dp != null && this.dp.ReconnectEnd) this.dp.ReconnectEnd() }; WinDisplay.prototype.HideAllLines = function () { for (var i = 0; i < this.aV.length; i++) this.aV[i].Show(false) }; WinDisplay.prototype.ShowLines = function (end) { if (this.rm != end) { this.rm = end; var i; for (i = 0; i < end; i++) this.aV[i].Enable(true); for (i = end; i < this.aV.length; i++) this.aV[i].Enable(false); this.KillHideLinesTimer() } }; WinDisplay.prototype.KillHideLinesTimer = function () { }; WinDisplay.prototype.onHideTimer = function (e) { }; WinDisplay.prototype.EnableLineUI = function (b) { for (var i = 0; i < this.aV.length; i++) this.aV[i].EnableUI(b) }; WinDisplay.prototype.AddLineWin = function (winIndex, lineIndex, wonAmount, symbols, symbol, flags, betCoinsPerLine) { this.ac[winIndex] = lineIndex; this.aV[lineIndex].SetWin(wonAmount, symbols, symbol, flags, betCoinsPerLine); if (winIndex > 0) this.aV[this.ac[winIndex - 1]].SetNext(this.aV[lineIndex]) }; WinDisplay.prototype.AddScatterWin = function (symbol, coins, num, grid) { var o = new Object; o.qP = symbol; o.jT = coins; o.ma = num; o.bI = grid; this.cw.push(o) }; WinDisplay.prototype.IsActive = function () { return this.aK >= 0 && this.aN }; WinDisplay.prototype.HasWins = function () { if (this.ac.length > 0 || this.cw.length > 0) return true; return false }; WinDisplay.prototype.HasLineWins = function () { if (this.ac.length > 0) return true; return false }; WinDisplay.prototype.GetWinLineOnSymbol = function (symbolIndex) { for (var i = 0; i < this.ac.length; i++) if (this.aV[this.ac[i]].GetWinSymbol() == symbolIndex) return this.aV[this.ac[i]]; return null }; WinDisplay.prototype.Start = function (freeSpinMode, delay, skipFirstRound) { if (freeSpinMode == undefined) freeSpinMode = false; if (delay == undefined) delay = 0; if (skipFirstRound == undefined) skipFirstRound = false; this.bh = freeSpinMode; this.bQ = true; this.mP = true; this.aN = !skipFirstRound; this.mg = getTimer() + delay }; WinDisplay.prototype.SetStartDelay = function (delay) { if (delay == undefined) delay = 0; this.mg = getTimer() + delay }; WinDisplay.prototype.LinesStart = function (firstTime) { if (firstTime == undefined) firstTime = false; if (this.bQ) { this.aN = firstTime; this.ao("linesstart"); for (var i = 0; i < this.ac.length; i++) { this.aV[this.ac[i]].Show(true); this.aV[this.ac[i]].Stop() } if (this.ac.length > 0 || this.cw.length > 0) { this.m_GamePanelHandler.setInfoBarText(Locale.IDS_MENU_CONGRATULATIONS, 2); this.HidePayBoxAmount(); this.aK = 0; if (this.ac.length == 0) this.eK = 6 * 83 + getTimer(); else this.eK = 6 * 83 + getTimer() } else { if (this.aN && !this.bh) this.ao("allticked"); this.aK = -1; this.ao("done") } } }; WinDisplay.prototype.ShowPayBoxAmount = function (amount, symbolindex, numsymbols, scatter) { if (this.dg) this.dg.ShowPayBoxAmount(amount, symbolindex, numsymbols, scatter) }; WinDisplay.prototype.HidePayBoxAmount = function () { if (this.dg) this.dg.Show(false) }; WinDisplay.prototype.Stop = function () { this.bQ = false; this.aN = false; this.aK = -1; this.eK = 0; this.cw.length = 0; while (this.ac.length != 0) this.ac.pop(); for (var i = 0; i < this.aV.length; i++) { this.aV[i].Show(false); this.aV[i].Stop(); this.aV[i].Clear() } this.dp.Stop(); this.KillHideLinesTimer(); this.ao("stop") }; WinDisplay.prototype.Pause = function () { this.bQ = false; this.aK = -1 }; WinDisplay.prototype.SetNextWinDelay = function (delay, scatter) { if (scatter) this.dp.SetNextWinDelay(delay); else { var payline = this.aV[this.ac[this.aK]]; payline.SetNextWinDelay(delay) } }; WinDisplay.prototype.Tick = function () { this.WaitForWinCounter(); if (this.dg) this.dg.Ticker(); if (this.bQ && this.mP) { if (this.mg < getTimer() || this.C) { this.ao("start"); if (!this.aN) { if (!this.bh) this.ao("allticked"); this.ao("done") } this.LinesStart(this.aN); this.mP = false } return } var payline; if (this.aK >= 0) if (this.eK > 0) { if (this.eK > getTimer() && !this.C) return; if (!this.dp.Tick()) { this.eK = 0; for (var i = 0; i < this.ac.length; i++) this.aV[this.ac[i]].Show(false); if (this.cw.length > 0) if (this.aK == 1E3 + this.cw.length) { this.aK = 0; if (this.ac.length == 0) { this.restart(); return } } else { if (this.aK < 1E3) { this.aK = 1E3; if (this.aN) this.ao("firstwin") } var o = this.cw[this.aK - 1E3]; if (this.dg) this.ShowPayBoxAmount(o.jT, o.bI[1][1], 4, true); this.dp.Stop(); this.dp.AnimateWithWinValue(o.bI, this.bh, this.aN, o.jT); this.ao("win", this.WinDisplayScatter(this.aK, this.aN, o.qP, o.ma, o.jT)); this.eK = 1; this.aK++; return } if (this.cw.length == 0) if (this.aN) this.ao("firstwin"); payline = this.aV[this.ac[this.aK]]; payline.Animate(this.bh, this.aN); if (this.dg) this.ShowPayBoxAmount(payline.GetWonAmount(), this.bo[this.ac[this.aK]], payline.ag); this.ao("win", this.WinDisplayLine(this.ac[this.aK], this.aN, payline)) } } else if (!this.iL && !this.aV[this.ac[this.aK]].Tick()) { this.aK++; if (this.aK >= this.ac.length) if (this.bJ.Ticking()) this.iL = true; else this.restart(); else { payline = this.aV[this.ac[this.aK]]; payline.Animate(this.bh, this.aN); if (this.dg) this.ShowPayBoxAmount(payline.GetWonAmount(), this.bo[this.ac[this.aK]], payline.ag); this.ao("win", this.WinDisplayLine(this.ac[this.aK], this.aN, payline)) } } }; WinDisplay.prototype.restart = function (force) { if (force == undefined) force = false; if (this.aN && !this.bh) this.ao("allticked"); this.aN = false; this.ao("done"); if (force) this.bQ = true; if (this.bQ) this.LinesStart() }; WinDisplay.prototype.WaitForWinCounter = function () { if (this.bJ.Ticking()) return; if (this.iL) { if (this.aN && !this.bh) this.ao("allticked"); this.aN = false; this.ao("done"); if (this.bQ) this.LinesStart(); this.iL = false } }; WinDisplay.prototype.WinDisplayLine = function (index, firstTime, payline) { var tmpObj = {}; tmpObj.od = payline; tmpObj.aS = "line"; tmpObj.aA = index; tmpObj.aN = firstTime; return tmpObj }; WinDisplay.prototype.WinDisplayScatter = function (index, firstTime, symbol, numberOfSymbols, winAmount) { var tmpObj = {}; tmpObj.jC = symbol; tmpObj.nb = numberOfSymbols; tmpObj.fQ = winAmount; tmpObj.aS = "scatter"; tmpObj.aA = index; tmpObj.aN = firstTime; return tmpObj }; WinDisplay.prototype.getActiveLine = function () { if (this.aK >= 0 && this.aK < 1E3) return this.aV[this.ac[this.aK]]; return null }; WinDisplay.prototype.GetWinLine = function (idx) { return this.aV[this.ac[idx]] }; WinDisplay.prototype.GetPayLine = function (idx) { return this.aV[idx] }; WinDisplay.prototype.getWinningLines = function () { return this.ac }; WinDisplay.prototype.getScatterAnimator = function () { return this.dp }; WinDisplay.prototype.OnQuickWinView = function (e) { }; WinScatter.BlinkLength = 24; WinScatter.BlinkSpeed = 4; function WinScatter(frames, reels) { this.dn = frames; this.ab = reels; this.bL = 0; this.cs = 0; this.aP = true; this.C = true }; WinScatter.prototype.Tick = function () { if (this.bL <= 0) return false; if (this.cs > getTimer()) return true; this.cs += 83; if (this.bL % WinScatter.BlinkSpeed == 0) if (this.aP) this.InternalSetVisible(!this.gD); if (--this.bL == 0) { this.Stop(); return false } return true }; WinScatter.prototype.AnimateWithWinValue = function (grid, freeSpinMode) { this.Animate(grid, freeSpinMode) }; WinScatter.prototype.Animate = function (grid, freeSpinMode) { this.bI = grid; this.cs = getTimer() + 83; if (freeSpinMode) this.bL = 15; else this.bL = WinScatter.BlinkLength - 1; this.InternalSetVisible(this.aP) }; WinScatter.prototype.Stop = function () { this.bL = 0; for (var i = 0; i < this.dn.length; i++) this.dn[i].Visible(false) }; WinScatter.prototype.InternalSetVisible = function (b) { if (b) for (var i = 0; i < this.bI.length; i++) { var reel = this.ab[this.bI[i][0]]; var customModifier = 0; if (scatter_frame_modifier == 1 && this.bI[i][1] == 1) customModifier = 1; else customModifier = 0; this.dn[this.bI[i][0]].Visible(b); this.dn[this.bI[i][0]].y = reel.bc[this.bI[i][1] - scatter_frame_modifier + customModifier].y + scatter_frame_adjust.y; this.dn[this.bI[i][0]].update() } else for (var j = 0; j < this.bI.length; j++) this.dn[this.bI[j][0]].Visible(b); this.gD = b }; WinScatter.prototype.ReconnectEnd = function () { this.C = false }; function MultiplierOverlayHandler(layer, imgName, posObj) { if (this.constructor !== arguments.callee) return new MultiplierOverlayHandler; this.K = layer; this.L = posObj; this.dA = []; for (var i = 0; i < 5; i++) { this.dA[i] = new sjs.Sprite(imgName, layer, undefined, posObj.pos); var padding = posObj.padding ? posObj.padding : 0; this.dA[i].x = posObj.pos.x + i * posObj.spacing.w + padding; this.dA[i].update() } this.Show(false) } MultiplierOverlayHandler.prototype.constructor = MultiplierOverlayHandler; MultiplierOverlayHandler.prototype.Show = function (b, numSymbols, offsetInd, paylineLayout) { if (numSymbols == undefined) numSymbols = this.dA.length; if (offsetInd != undefined) { this.SetOffset(offsetInd, numSymbols); if (paylineLayout) this.PlaceMultipliers(paylineLayout, numSymbols) } for (var i = 0; i < this.dA.length; i++) this.dA[i].Visible(false); if (b) for (var i = 0; i < numSymbols; i++) this.dA[i].Visible(true) }; MultiplierOverlayHandler.prototype.PlaceMultipliers = function (paylineLayout, numSymbols) { var padding = this.L.padding ? this.L.padding : 0; for (var i = 0; i < numSymbols; i++) { this.dA[i].y = this.L.pos.y + this.L.spacing.h * paylineLayout[i] + padding; this.dA[i].update() } }; MultiplierOverlayHandler.prototype.SetOffset = function (offsetInd, numSymbols) { for (var i = 0; i < numSymbols; i++) { this.dA[i].offset(this.L.pos.w * offsetInd, 0); this.dA[i].update() } }; function WinLine(pl, index, paylineBehind) { this.m_Numbers; this.kM; this.ag; this.jw; this.kU; this.ow; this.aA; this.qG; this.iq; this.aP; this.fk; this.pM; this.ad; this.C; this.m_UIEnabled; WinLine.Features; this.aP = true; this.ad = true; this.aA = index + 1; this.m_Numbers = pl; var i; if (paylineBehind); this.ag = 1; this.m_UIEnabled = false; this.C = true; this.kU = 0 } WinLine.prototype.constructor = WinLine; WinLine.prototype.getFeatureLink = function () { return this.iq }; WinLine.prototype.getWildWin = function () { return this.jw > 0 }; WinLine.SetFeatures = function (features) { WinLine.Features = features }; WinLine.prototype.SetWin = function (wonAmount, symbols, symbol, flags, coinsBet) { this.kM = symbol; this.ag = symbols; this.kU = wonAmount; this.ow = coinsBet; this.jw = flags & 7; this.qG = (flags & 8) != 0; this.iq = flags >> 4; this.pM = null }; WinLine.prototype.SetNext = function (nextLine) { this.pM = nextLine }; WinLine.prototype.ReconnectEnd = function () { this.C = false }; WinLine.prototype.GetIndex = function () { return this.aA }; WinLine.prototype.GetWonAmount = function () { if (this.iq > 0) return WinLine.Features[this.iq - 1].TotalCoins(); return this.kU }; WinLine.prototype.GetJackpotWonAmount = function () { if (this.iq > 0) return WinLine.Features[this.iq - 1].TotalMoney(); return 0 }; WinLine.prototype.GetWinSymbol = function () { return this.kM }; WinLine.prototype.GetNumSymbols = function () { return this.ag }; WinLine.prototype.GetNumWilds = function () { return this.jw }; WinLine.prototype.GetCoinsBet = function () { return this.ow }; WinLine.prototype.Tick = function () { return true }; WinLine.prototype.Animate = function (freeSpinMode, firstTime) { }; WinLine.prototype.Stop = function () { }; WinLine.prototype.SetNextWinDelay = function (delay) { }; WinLine.prototype.Show = function (b) { }; WinLine.prototype.SetVisible = function (b) { this.aP = b }; WinLine.prototype.getEnabled = function () { return this.ad }; WinLine.prototype.Enable = function (b) { this.ad = b; this.Show(b) }; WinLine.prototype.EnableUI = function (b) { if (b == this.m_UIEnabled) return; this.m_UIEnabled = b }; WinLine.prototype.Clear = function () { this.fk = false; this.kU = 0 }; WinLine.prototype.onClick = function () { }; WinLine.prototype.OnQuickView = function (e) { this.fk = true }; WinLine.prototype.getnextLine = function () { return this.pM }; WinLine.prototype.getEndTime = function () { return 0 }; function GamePanel(lobbybtncb, menubtncb, showclock, freegamehandler, soundToggleCB) { this.bb = freegamehandler; this.m_LobbyCallBack = lobbybtncb; this.m_MenuCallBack = menubtncb; this.eU = showclock; this.m_SoundToggleCallback = soundToggleCB; this.m_infoBarShowing = new Signal; this.m_LeftHandMode = false; this.m_StartEvent = "mousedown"; this.m_EndEvent = "mouseup"; this.m_MoveEvent = "mousemove"; this.m_TouchInside = false; this.m_TouchInsideSoundButton = false; if ("ontouchstart" in window) { this.m_StartEvent = "touchstart"; this.m_EndEvent = "touchend"; this.m_MoveEvent = "touchmove" } this.m_MenuButtonStartDelegate = Utils.delegate(this, this.menuButtonPressed); this.m_MenuButtonEndDelegate = Utils.delegate(this, this.displayMenuPressed); this.m_MenuButtonMoveDelegate = Utils.delegate(this, this.checkMenuHitArea); this.m_LobbyButtonStartDelegate = Utils.delegate(this, this.lobbyButtonPressed); this.m_LobbyButtonEndDelegate = Utils.delegate(this, this.lobbyButtonReleased); this.m_LobbyButtonMoveDelegate = Utils.delegate(this, this.checkLobbyHitArea); this.m_SoundButtonStartDelegate = Utils.delegate(this, this.soundButtonPressed); this.m_SoundButtonEndDelegate = Utils.delegate(this, this.soundButtonReleased); this.m_SoundButtonMoveDelegate = Utils.delegate(this, this.checkSoundHitArea); this.m_Canvas = document.getElementById("sjs"); this.m_GamePanel = document.getElementById("gamepanel") || DOMHelper.createAndAppendDiv(document.body, "game_panel", undefined); this.m_GamePanel.style.display = ""; this.m_BackgroundImg = DOMHelper.createImage(this.m_GamePanel, "backgroundImg", undefined, image_path_htmlui + "bottomBg.png"); this.m_infoBar = DOMHelper.createAndAppendDiv(this.m_GamePanel, "informationBar", undefined); this.m_BottomPanelWrapper = DOMHelper.createAndAppendDiv(this.m_GamePanel, "bottomPanelWrapper", undefined); this.m_LobbyButtonWrapper = DOMHelper.createAndAppendDiv(this.m_GamePanel, "lobbyButtonWrapper", undefined); this.m_SoundButtonWrapper = DOMHelper.createAndAppendDiv(this.m_GamePanel, "soundButtonWrapper", undefined); this.m_MenuButtonWrapper = DOMHelper.createAndAppendDiv(this.m_GamePanel, "menuButtonWrapper", undefined); this.m_PortraitPanelWrapper = DOMHelper.createAndAppendDiv(this.m_GamePanel, "portraitPanelWrapper", undefined); this.m_MenuWrapper1 = DOMHelper.createAndAppendDiv(this.m_PortraitPanelWrapper, "menuWrapper1", undefined); this.m_MenuWrapper2 = DOMHelper.createAndAppendDiv(this.m_BottomPanelWrapper, "menuWrapper2", undefined); this.m_MenuWrapper3 = DOMHelper.createAndAppendDiv(this.m_PortraitPanelWrapper, "menuWrapper3", undefined); DOMHelper.setWidth(this.m_GamePanel, DEVICE[DEVICE.orientation].w); DOMHelper.setStyle(this.m_GamePanel, DEVICE.orientation); this.m_BackgroundImg.style.width = this.m_GamePanel.offsetWidth + "px"; this.m_BackgroundImg.style.height = "100%"; this.createChildDivs(); this.setWrapperValues(); this.enableMenuButton(true); this.enableLobbyButton(true); this.enableSoundButton(true); if (this.eU == true) { this.createClock(); this.jo.StartTime() } this.buttonAdjFactor = UAGENT_IPHONE ? 1.1 : 1; this.freeGameMode = false } Classify.constr(GamePanel); GamePanel.prototype.createChildDivs = function () { this.m_DisplayCoins = CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS); this.m_LobbyButtonImage = DOMHelper.createImageFromSpriteSheet(this.m_LobbyButtonWrapper, "lobbyImg", undefined, image_path_htmlui + "uiElements.png", uiElements.lobbyBtn); this.m_MenuButtonImage = DOMHelper.createImageFromSpriteSheet(this.m_MenuButtonWrapper, "menuImg", undefined, image_path_htmlui + "uiElements.png", uiElements.settingsBtn); this.m_SoundButtonImage = DOMHelper.createImageFromSpriteSheet(this.m_SoundButtonWrapper, "soundImg", undefined, image_path_htmlui + "uiElements.png", uiElements.soundOffBtn); this.m_ClockWrapper = DOMHelper.createDiv("clockWrapper", undefined); this.m_ClockImage = DOMHelper.createImage(this.m_ClockWrapper, "clockImg", undefined, image_path_htmlui + "clockIcon.png"); this.m_LocalTime = DOMHelper.createTextfield(this.m_ClockWrapper, "time", undefined, " "); this.m_MoneyBalanceWrapper = DOMHelper.createDiv("moneyBalanceWrapper", undefined); this.m_BalanceCaption = DOMHelper.createTextfield(this.m_MoneyBalanceWrapper, "balanceText", undefined, Localizer.getInstance().getString("IDS_BALANCE_CAPTION")); this.m_MoneyBalance = DOMHelper.createTextfield(this.m_MoneyBalanceWrapper, "moneyBalance", undefined, " "); this.m_CoinsBalanceWrapper = DOMHelper.createDiv("coinsBalanceWrapper", undefined); this.m_CoinsCaption = DOMHelper.createTextfield(this.m_CoinsBalanceWrapper, "coinsText", undefined, Localizer.getInstance().getString("IDS_COINS_CAPTION")); this.coinsBalance = DOMHelper.createTextfield(this.m_CoinsBalanceWrapper, "coinsBalance", undefined, " "); this.m_CoinsBetWrapper = DOMHelper.createDiv("coinsBetWrapper", undefined); this.m_CoinBetCaption = DOMHelper.createTextfield(this.m_CoinsBetWrapper, "betCoinsText", undefined, Localizer.getInstance().getString("IDS_BET_CAPTION")); this.coinsBet = DOMHelper.createTextfield(this.m_CoinsBetWrapper, "coinsBet", undefined, " "); this.m_MoneyWinWrapper = DOMHelper.createDiv("moneyWinWrapper", undefined); this.m_WinCaption = DOMHelper.createTextfield(this.m_MoneyWinWrapper, "winText", undefined, Localizer.getInstance().getString("IDS_WIN_CAPTION")); this.m_MoneyWin = DOMHelper.createTextfield(this.m_MoneyWinWrapper, "moneyWin", undefined, " "); this.m_MoneyBetWrapper = DOMHelper.createDiv("moneyBetWrapper", undefined); this.m_MoneyBetCaption = DOMHelper.createTextfield(this.m_MoneyBetWrapper, "betMoneyText", undefined, Localizer.getInstance().getString("IDS_BET_CAPTION")); this.m_MoneyBet = DOMHelper.createTextfield(this.m_MoneyBetWrapper, "moneyBet", undefined, " "); this.m_MoneyWin.style.visibility = "hidden"; if (this.m_DisplayCoins) { DOMHelper.appendChild(this.m_MenuWrapper1, this.m_ClockWrapper); DOMHelper.appendChild(this.m_MenuWrapper1, this.m_MoneyBalanceWrapper); DOMHelper.appendChild(this.m_MenuWrapper2, this.m_CoinsBalanceWrapper); DOMHelper.appendChild(this.m_MenuWrapper2, this.m_CoinsBetWrapper); DOMHelper.appendChild(this.m_MenuWrapper3, this.m_MoneyWinWrapper); DOMHelper.appendChild(this.m_MenuWrapper3, this.m_MoneyBetWrapper); if (!this.eU) this.m_MenuWrapper1.classList.add("noclock") } else { DOMHelper.appendChild(this.m_MenuWrapper1, this.m_MoneyBalanceWrapper); DOMHelper.appendChild(this.m_MenuWrapper2, this.m_MoneyBetWrapper); DOMHelper.appendChild(this.m_MenuWrapper2, this.m_MoneyWinWrapper); DOMHelper.appendChild(this.m_MenuWrapper3, this.m_ClockWrapper) } this.HandleOrientationChange(); if (!this.eU) this.m_ClockWrapper.style.display = "none" }; GamePanel.prototype.displayMenuPressed = function (e) { this.m_MenuButtonImage.classList.remove("scaleup"); this.m_MenuButtonWrapper.buttonPressed = false; if (!this.m_TouchInside) return; this.displayMenu() }; GamePanel.prototype.checkMenuHitArea = function (e) { if (!this.m_MenuButtonWrapper.buttonPressed) return; if (!DOMHelper.touchUpEventInTarget(e)) { this.m_MenuButtonImage.classList.remove("scaleup"); this.m_TouchInside = false } else this.m_MenuButtonImage.classList.add("scaleup") }; GamePanel.prototype.checkLobbyHitArea = function (e) { if (!this.m_LobbyButtonWrapper.buttonPressed) return; if (!DOMHelper.touchUpEventInTarget(e)) { this.m_LobbyButtonImage.classList.remove("scaleup"); this.m_TouchInside = false } else this.m_LobbyButtonImage.classList.add("scaleup") }; GamePanel.prototype.checkSoundHitArea = function (e) { if (!this.m_SoundButtonWrapper.buttonPressed) return; if (!DOMHelper.touchUpEventInTarget(e)) { this.m_SoundButtonImage.classList.remove("scaleup"); this.m_TouchInsideSoundButton = false } else this.m_SoundButtonImage.classList.add("scaleup") }; GamePanel.prototype.displayMenu = function (b) { b = b !== undefined ? b : !this.m_MenuButtonWrapper.bMenuVisible; if (b) { this.m_MenuCallBack(true); this.m_MenuButtonWrapper.bMenuVisible = true; this.m_Canvas.style.display = "none"; this.changeMenuImage() } else { this.m_MenuCallBack(false); this.m_MenuButtonWrapper.bMenuVisible = false; this.m_Canvas.style.display = ""; this.changeMenuImage() } }; GamePanel.prototype.changeMenuImage = function () { if (this.m_MenuButtonWrapper.bMenuVisible) DOMHelper.setImageFromSpriteSheet(this.m_MenuButtonImage, image_path_htmlui + "uiElements.png", uiElements.backBtn); else DOMHelper.setImageFromSpriteSheet(this.m_MenuButtonImage, image_path_htmlui + "uiElements.png", uiElements.settingsBtn) }; GamePanel.prototype.enableMenuButton = function (bEnable) { this.m_bMenuButtonEnabled = bEnable; if (bEnable) { this.m_MenuButtonImage.style.opacity = 1; this.m_MenuButtonWrapper.addEventListener(this.m_StartEvent, this.m_MenuButtonStartDelegate, false); this.m_MenuButtonWrapper.addEventListener(this.m_MoveEvent, this.m_MenuButtonMoveDelegate, false); this.m_MenuButtonWrapper.addEventListener(this.m_EndEvent, this.m_MenuButtonEndDelegate, false); this.m_MenuButtonWrapper.bHasListener = true; this.m_MenuButtonWrapper.bMenuVisible = false } else if (this.m_MenuButtonWrapper.bHasListener) { this.m_MenuButtonImage.style.opacity = 0.3; this.m_MenuButtonWrapper.removeEventListener(this.m_StartEvent, this.m_MenuButtonStartDelegate, false); this.m_MenuButtonWrapper.removeEventListener(this.m_MoveEvent, this.m_MenuButtonMoveDelegate, false); this.m_MenuButtonWrapper.removeEventListener(this.m_EndEvent, this.m_MenuButtonEndDelegate, false); this.m_MenuButtonWrapper.bHasListener = false } }; GamePanel.prototype.enableSoundButton = function (bEnable) { this.m_bSoundButtonEnabled = bEnable; if (bEnable) { this.m_SoundButtonImage.style.opacity = 1; this.m_SoundButtonImage.style.display = "inline-block"; this.m_SoundButtonWrapper.addEventListener(this.m_StartEvent, this.m_SoundButtonStartDelegate, false); this.m_SoundButtonWrapper.addEventListener(this.m_MoveEvent, this.m_SoundButtonMoveDelegate, false); this.m_SoundButtonWrapper.addEventListener(this.m_EndEvent, this.m_SoundButtonEndDelegate, false); this.m_SoundButtonWrapper.bHasListener = true; this.m_SoundButtonWrapper.bMenuVisible = false } else if (this.m_SoundButtonWrapper.bHasListener) { this.m_SoundButtonImage.style.opacity = 0; this.m_SoundButtonImage.style.display = "none"; this.m_SoundButtonWrapper.removeEventListener(this.m_StartEvent, this.m_SoundButtonStartDelegate, false); this.m_SoundButtonWrapper.removeEventListener(this.m_MoveEvent, this.m_SoundButtonMoveDelegate, false); this.m_SoundButtonWrapper.removeEventListener(this.m_EndEvent, this.m_SoundButtonEndDelegate, false); this.m_SoundButtonWrapper.bHasListener = false } }; GamePanel.prototype.enableLobbyButton = function (bEnable) { this.m_bLobbyButtonEnabled = bEnable; if (bEnable) { this.m_LobbyButtonWrapper.addEventListener(this.m_StartEvent, this.m_LobbyButtonStartDelegate, false); this.m_LobbyButtonWrapper.addEventListener(this.m_MoveEvent, this.m_LobbyButtonMoveDelegate, false); this.m_LobbyButtonWrapper.addEventListener(this.m_EndEvent, this.m_LobbyButtonEndDelegate, false); this.m_LobbyButtonWrapper.bHasListener = true } else if (this.m_LobbyButtonWrapper.bHasListener) { this.m_LobbyButtonWrapper.removeEventListener(this.m_StartEvent, this.m_LobbyButtonStartDelegate, false); this.m_LobbyButtonWrapper.removeEventListener(this.m_MoveEvent, this.m_LobbyButtonMoveDelegate, false); this.m_LobbyButtonWrapper.removeEventListener(this.m_EndEvent, this.m_LobbyButtonEndDelegate, false); this.m_LobbyButtonWrapper.bHasListener = false } }; GamePanel.prototype.menuButtonPressed = function () { this.m_MenuButtonImage.classList.add("scaleup"); this.m_MenuButtonWrapper.buttonPressed = true; this.m_TouchInside = true }; GamePanel.prototype.lobbyButtonPressed = function () { this.m_LobbyButtonImage.classList.add("scaleup"); this.m_LobbyButtonWrapper.buttonPressed = true; this.m_TouchInside = true }; GamePanel.prototype.soundButtonPressed = function () { this.m_SoundButtonImage.classList.add("scaleup"); this.m_SoundButtonWrapper.buttonPressed = true; this.m_TouchInsideSoundButton = true }; GamePanel.prototype.lobbyButtonReleased = function (e) { this.m_LobbyButtonImage.classList.remove("scaleup"); this.m_LobbyButtonWrapper.buttonPressed = false; if (!this.m_TouchInside) return; e.preventDefault(); this.m_LobbyCallBack() }; GamePanel.prototype.soundButtonReleased = function (e) { this.m_SoundButtonImage.classList.remove("scaleup"); this.m_SoundButtonWrapper.buttonPressed = false; if (!this.m_TouchInsideSoundButton) return; this.m_SoundToggleCallback(); this.updateSoundButton() }; GamePanel.prototype.updateSoundButton = function () { if (SoundManager.IsEnabled()) DOMHelper.setImageFromSpriteSheet(this.m_SoundButtonImage, image_path_htmlui + "uiElements.png", uiElements.soundOnBtn); else DOMHelper.setImageFromSpriteSheet(this.m_SoundButtonImage, image_path_htmlui + "uiElements.png", uiElements.soundOffBtn) }; GamePanel.prototype.HandleOrientationChange = function () { var scaleValue = scale_layer_pos[DEVICE.orientation].scale; var originalButtonOffset = this.m_MenuButtonWrapper.getBoundingClientRect(); this.m_GamePanel.style.top = DEVICE[DEVICE.orientation].h - this.m_GamePanel.clientHeight + 1 + "px"; DOMHelper.setWidth(this.m_GamePanel, DEVICE[DEVICE.orientation].w); DOMHelper.setWidth(this.m_BottomPanelWrapper, this.m_GamePanel.offsetWidth); DOMHelper.setHeight(this.m_BottomPanelWrapper, this.m_GamePanel.offsetHeight); DOMHelper.setStyle(this.m_GamePanel, DEVICE.orientation); this.m_BackgroundImg.style.width = this.m_GamePanel.offsetWidth + "px"; DOMHelper.setStyle(this.m_ClockWrapper, DEVICE.orientation); DOMHelper.setStyle(this.m_MoneyBalanceWrapper, DEVICE.orientation); DOMHelper.setStyle(this.m_CoinsBalanceWrapper, DEVICE.orientation); DOMHelper.setStyle(this.m_CoinsBetWrapper, DEVICE.orientation); DOMHelper.setStyle(this.m_MoneyWinWrapper, DEVICE.orientation); DOMHelper.setStyle(this.m_MoneyBetWrapper, DEVICE.orientation); if (DEVICE.orientation === "ls") { var buttonPos = parseInt(this.m_GamePanel.style.height) * scaleValue * this.buttonAdjFactor + "px"; this.m_MenuButtonWrapper.style.bottom = buttonPos; this.m_LobbyButtonWrapper.style.bottom = buttonPos; this.m_SoundButtonWrapper.style.bottom = buttonPos; if (this.m_DisplayCoins) { DOMHelper.appendChild(this.m_MenuWrapper1, this.m_MoneyBalanceWrapper); DOMHelper.appendChild(this.m_MenuWrapper3, this.m_MoneyBetWrapper); while (this.m_PortraitPanelWrapper.childNodes.length > 0) this.m_BottomPanelWrapper.appendChild(this.m_PortraitPanelWrapper.childNodes[0]); this.m_ClockWrapper.classList.add("coin"); this.m_MoneyBet.classList.add("coin") } else { DOMHelper.appendChild(this.m_MenuWrapper1, this.m_MoneyBetWrapper); DOMHelper.appendChild(this.m_MenuWrapper3, this.m_MoneyWinWrapper); DOMHelper.appendChild(this.m_MenuWrapper3, this.m_ClockWrapper); this.m_MoneyBetWrapper.classList.add("nocoin"); this.m_MoneyWinWrapper.classList.add("nocoin"); this.m_BalanceCaption.classList.add("nocoin"); DOMHelper.setStyle(this.m_MenuWrapper2, "nocoin"); DOMHelper.setStyle(this.m_MoneyBet, "nocoin"); DOMHelper.setStyle(this.m_MoneyWin, "nocoin") } this.m_MenuButtonWrapper.style.transformOrigin = "right 0"; this.m_MenuButtonWrapper.style.webkitTransformOrigin = "right 0"; this.m_LobbyButtonWrapper.style.transformOrigin = "left 0"; this.m_LobbyButtonWrapper.style.webkitTransformOrigin = "left 0"; this.m_SoundButtonWrapper.style.transformOrigin = "right 0"; this.m_SoundButtonWrapper.style.webkitTransformOrigin = "right 0"; DOMHelper.reorderChildrenInDiv(this.m_BottomPanelWrapper, ["menuWrapper1", "menuWrapper2", "menuWrapper3"]); DOMHelper.setStyle(this.m_PortraitPanelWrapper, "nodisplay") } else { if (this.m_DisplayCoins) { DOMHelper.appendChild(this.m_MenuWrapper1, this.m_ClockWrapper); DOMHelper.setStyle(this.m_MoneyBetWrapper, ""); DOMHelper.reorderChildrenInDiv(this.m_MenuWrapper3, ["moneyBetWrapper", "moneyWinWrapper"]) } else { DOMHelper.appendChild(this.m_MenuWrapper2, this.m_MoneyBetWrapper); DOMHelper.appendChild(this.m_MenuWrapper2, this.m_MoneyWinWrapper); DOMHelper.setStyle(this.m_MoneyBetWrapper, "pt nocoin"); DOMHelper.setStyle(this.m_MoneyWinWrapper, "pt nocoin"); DOMHelper.setStyle(this.m_MoneyBet, "nocoin"); DOMHelper.setStyle(this.m_MoneyWin, "nocoin"); DOMHelper.setStyle(this.m_MoneyBalanceWrapper, "pt nocoin"); DOMHelper.setStyle(this.m_ClockWrapper, "pt nocoin") } this.m_MenuButtonWrapper.style.transformOrigin = "center 0"; this.m_MenuButtonWrapper.style.webkitTransformOrigin = "center 0"; this.m_MenuButtonWrapper.style.msTransformOrigin = "center 0"; this.m_LobbyButtonWrapper.style.transformOrigin = "center 0"; this.m_LobbyButtonWrapper.style.webkitTransformOrigin = "center 0"; this.m_LobbyButtonWrapper.style.msTransformOrigin = "center 0"; this.m_SoundButtonWrapper.style.transformOrigin = "center 0"; this.m_SoundButtonWrapper.style.webkitTransformOrigin = "center 0"; this.m_SoundButtonWrapper.style.msTransformOrigin = "center 0"; DOMHelper.appendChild(this.m_PortraitPanelWrapper, this.m_MenuWrapper1); DOMHelper.appendChild(this.m_PortraitPanelWrapper, this.m_MenuWrapper3); DOMHelper.setStyle(this.m_PortraitPanelWrapper, " "); DOMHelper.reorderChildrenInDiv(this.m_BottomPanelWrapper, ["menuWrapper2", "portraitPanelWrapper"]) } this.m_MenuButtonWrapper.style.transform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_MenuButtonWrapper.style.webkitTransform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_MenuButtonWrapper.style.msTransform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_LobbyButtonWrapper.style.transform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_LobbyButtonWrapper.style.webkitTransform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_LobbyButtonWrapper.style.msTransform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_SoundButtonWrapper.style.transform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_SoundButtonWrapper.style.webkitTransform = "scale( " + scaleValue + ", " + scaleValue + ")"; this.m_SoundButtonWrapper.style.msTransform = "scale( " + scaleValue + ", " + scaleValue + ")"; DOMHelper.setWidth(this.m_ClockImage, uiElements.clockIcon.w * scaleValue); DOMHelper.setHeight(this.m_ClockImage, uiElements.clockIcon.h * scaleValue); this.resetDivs(); this.setWrapperValues(); this.setLeftHandModeValues() }; GamePanel.prototype.resetDivs = function () { var scaleFactor = scale_layer_pos[DEVICE.orientation].scale; if (DEVICE.orientation == "ls") this.m_GamePanel.style.height = htmlui_gamepanel.ls.gpheight * scaleFactor + "px"; else this.m_GamePanel.style.height = htmlui_gamepanel.pt.gpheight * scaleFactor + "px"; this.m_GamePanel.style.fontSize = parseInt(gamepanel.max_font_size * scaleFactor) + "px"; this.setWrapperValues() }; GamePanel.prototype.setWrapperValues = function () { var scaleValue = scale_layer_pos[DEVICE.orientation].scale; if (DEVICE.orientation == "ls") { var sideDivWidth = (this.m_GamePanel.offsetWidth - this.m_MenuWrapper2.offsetWidth) / 2 - 1; this.m_MenuWrapper1.style.width = parseInt(sideDivWidth) + "px"; this.m_MenuWrapper3.style.width = parseInt(sideDivWidth) + "px" } this.checkDivSizes() }; GamePanel.prototype.checkDivSizes = function () { var scaleFactor = 1; if (DEVICE.orientation == "ls") { if (DOMHelper.divHasExceededMaxWidth(this.m_MenuWrapper1, scaleFactor, false, 10) || DOMHelper.divHasExceededMaxWidth(this.m_MenuWrapper3, scaleFactor, false, 10)) { var fontSize = parseInt(window.getComputedStyle(this.m_GamePanel, null).getPropertyValue("font-size")); this.m_GamePanel.style.fontSize = fontSize - 1 + "px"; this.setWrapperValues() } } else if (DOMHelper.divHasExceededMaxWidth(this.m_MenuWrapper2, scaleFactor) || DOMHelper.divHasExceededMaxWidth(this.m_MoneyBalanceWrapper, scaleFactor) || DOMHelper.divHasExceededMaxWidth(this.m_MoneyBetWrapper, scaleFactor) || DOMHelper.divHasExceededMaxWidth(this.m_MoneyWinWrapper, scaleFactor, true)) { var fontSize = parseInt(window.getComputedStyle(this.m_GamePanel, null).getPropertyValue("font-size")); this.m_GamePanel.style.fontSize = fontSize - 1 + "px"; this.setWrapperValues() } }; GamePanel.prototype.setBalance = function (balance) { this.m_MoneyBalance.innerHTML = balance; this.resetDivs(); this.setWrapperValues() }; GamePanel.prototype.setBet = function (moneyBet) { this.m_MoneyBet.innerHTML = moneyBet; this.resetDivs(); this.setWrapperValues() }; GamePanel.prototype.setWin = function (moneyWin) { var val = parseFloat(moneyWin.match(/\d+/g).join(".")); if (val === 0) { this.m_MoneyWin.style.visibility = "hidden"; this.m_MoneyWin.innerHTML = this.m_MoneyBet.innerHTML } else { this.m_MoneyWin.style.visibility = "visible"; this.m_MoneyWin.innerHTML = moneyWin; this.resetDivs(); this.setWrapperValues() } }; GamePanel.prototype.setInfoBarText = function (message, id) { if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_CURRENCY) && id != 2 && id != 4) return; this.kS = false; switch (id) { case 1: this.setCoinsBalance(message); break; case 2: break; case 3: this.setCoinsBet(message); break; case 4: } }; GamePanel.prototype.setTime = function (localTime) { this.m_LocalTime.innerHTML = localTime }; GamePanel.prototype.setInfoText = function (message) { if (message == " ") DOMHelper.setStyle(this.m_infoBar, "fadeOut"); else DOMHelper.setStyle(this.m_infoBar, "fadeIn"); this.m_infoBar.innerHTML = message }; GamePanel.prototype.setCoinsBalance = function (coinBalance, freegames) { if (!this.freeGameMode || this.freeGameMode && freegames) { this.coinsBalance.innerHTML = coinBalance; this.resetDivs(); this.setWrapperValues() } }; GamePanel.prototype.setCoinsBet = function (coinBet) { this.coinsBet.innerHTML = coinBet; this.resetDivs(); this.setWrapperValues() }; VideoSlot.prototype.UpdateGamePanel = function (balance) { if (balance != undefined) { if (!this.bb.Active()) this.m_GamePanelHandler.setBalance(Utils.MoneyToString(balance)); if (balance > 0) this.m_GamePanelHandler.setInfoBarText(this.bG.AmountToCoins(balance), 1); else this.m_GamePanelHandler.setInfoBarText("0", 1) } if (!this.bb.Active()) this.m_GamePanelHandler.setBet(this.bG.GetBetAmount()); this.m_GamePanelHandler.setInfoBarText(this.bG.GetBetCoins(), 3) }; VideoSlot.prototype.initGamePanelValues = function () { var balanceAdjust = 0; if (this.ft > 0 || this.av != null && this.av.bw.length > 0) balanceAdjust = this.bG.GetBetCoins(); var coinBalance = this.bG.AmountToCoins(this.O.getBalance()) - balanceAdjust; if (!this.bb.Active()) this.m_GamePanelHandler.setInfoBarText(coinBalance, 1); this.m_GamePanelHandler.setInfoBarText(this.bG.GetBetCoins(), 3) }; GamePanel.prototype.createClock = function () { this.jo = new Clock(undefined, undefined, this.m_LocalTime, function (value) { this.m_LocalTime.innerHTML = value }.bind(this)) }; GamePanel.prototype.ShowMenuButton = function (b) { if (this.bM) this.cB.SetVisible(b); else this.cr.SetVisible(b) }; GamePanel.prototype.ShowBackButton = function (b) { }; GamePanel.prototype.FreeGameOrientationChange = function () { if (DEVICE.orientation === "pt") { this.m_MenuWrapper3.style.height = "100%"; this.m_MoneyWinWrapper.style.transform = "translateY(-50%)"; this.m_MoneyWinWrapper.style.webkitTransform = "translateY(-50%)" } else { this.m_MenuWrapper3.style.height = ""; this.m_MoneyWinWrapper.style.transform = ""; this.m_MoneyWinWrapper.style.webkitTransform = "" } if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) this.m_MoneyBetWrapper.style.display = "none"; else this.m_MoneyBetWrapper.style.display = "" }; GamePanel.prototype.OnFreeGameEvent = function (state, data, lastRound, fgHandler) { switch (state) { case FreeGameHandler.START: this.m_CoinsCaption.innerHTML = Localizer.getInstance().getString("IDS_FREEGAMES_CAPTION"); this.m_MoneyBetCaption.innerHTML = Localizer.getInstance().getString("IDS_FREEGAMES_CAPTION"); this.m_BalanceCaption.innerHTML = Localizer.getInstance().getString("IDS_TOTALWIN_FG_CAPTION"); if (DEVICE.orientation === "pt") { this.m_MenuWrapper3.style.height = "100%"; this.m_MoneyWinWrapper.style.transform = "translateY(-50%)"; this.m_MoneyWinWrapper.style.webkitTransform = "translateY(-50%)" } else { this.m_MenuWrapper3.style.height = ""; this.m_MoneyWinWrapper.style.transform = ""; this.m_MoneyWinWrapper.style.webkitTransform = "" } if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) this.m_MoneyBetWrapper.style.display = "none"; else this.m_MoneyBetWrapper.style.display = ""; this.freeGameMode = true; break; case FreeGameHandler.END: this.freeGameMode = false; this.m_CoinsCaption.innerHTML = Localizer.getInstance().getString("IDS_COINS_CAPTION"); this.m_MoneyBetCaption.innerHTML = Localizer.getInstance().getString("IDS_BET_CAPTION"); this.m_BalanceCaption.innerHTML = Localizer.getInstance().getString("IDS_BALANCE_CAPTION"); this.m_MoneyWinWrapper.style.transform = ""; this.m_MoneyWinWrapper.style.webkitTransform = ""; this.m_MoneyBetWrapper.style.display = ""; this.m_MenuWrapper3.style.height = ""; break; case FreeGameHandler.TOTALWIN: if (lastRound) { this.setBalance(Utils.MoneyToString(fgHandler.nF)); this.setNumFreeGames(0) } else { this.setBalance(Utils.MoneyToString(data.FreeGamesWin)); this.setNumFreeGames(data.FreeGames) } break; case FreeGameHandler.ADDITIONAL_FREEGAMES: break } }; GamePanel.prototype.setNumFreeGames = function (numFreeGames) { if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) this.setCoinsBalance(numFreeGames, true); else this.setBet(numFreeGames, true) }; GamePanel.prototype.setLeftHandMode = function () { this.m_LeftHandMode = !this.m_LeftHandMode; this.setLeftHandModeValues() }; GamePanel.prototype.getLeftHandMode = function () { return this.m_LeftHandMode }; GamePanel.prototype.setLeftHandModeValues = function () { if (this.m_LeftHandMode) if (DEVICE.orientation === "ls") { this.m_MenuButtonWrapper.style.right = ""; this.m_MenuButtonWrapper.style.left = "2%"; this.m_LobbyButtonWrapper.style.left = ""; this.m_LobbyButtonWrapper.style.right = "2%"; this.m_SoundButtonWrapper.style.right = ""; this.m_SoundButtonWrapper.style.left = "2%"; this.m_MenuButtonWrapper.style.transformOrigin = "left 0"; this.m_MenuButtonWrapper.style.webkitTransformOrigin = "left 0"; this.m_MenuButtonWrapper.style.msTransformOrigin = "left 0"; this.m_LobbyButtonWrapper.style.transformOrigin = "right 0"; this.m_LobbyButtonWrapper.style.webkitTransformOrigin = "right 0"; this.m_LobbyButtonWrapper.style.msTransformOrigin = "right 0"; this.m_SoundButtonWrapper.style.transformOrigin = "left 0"; this.m_SoundButtonWrapper.style.webkitTransformOrigin = "left 0"; this.m_SoundButtonWrapper.style.msTransformOrigin = "left 0" } else { this.m_MenuButtonWrapper.style.right = ""; this.m_MenuButtonWrapper.style.left = "4%"; this.m_LobbyButtonWrapper.style.left = ""; this.m_LobbyButtonWrapper.style.right = "4%"; this.m_SoundButtonWrapper.style.right = ""; this.m_SoundButtonWrapper.style.left = "4%"; this.m_MenuButtonImage.style.right = ""; this.m_MenuButtonImage.style.left = "-25%"; this.m_LobbyButtonImage.style.left = ""; this.m_LobbyButtonImage.style.right = "-25%"; this.m_SoundButtonImage.style.right = ""; this.m_SoundButtonImage.style.left = "-25%" } else if (DEVICE.orientation === "ls") { this.m_MenuButtonWrapper.style.left = ""; this.m_MenuButtonWrapper.style.right = "2%"; this.m_LobbyButtonWrapper.style.right = ""; this.m_LobbyButtonWrapper.style.left = "2%"; this.m_SoundButtonWrapper.style.left = ""; this.m_SoundButtonWrapper.style.right = "2%"; this.m_MenuButtonWrapper.style.transformOrigin = "right 0"; this.m_MenuButtonWrapper.style.webkitTransformOrigin = "right 0"; this.m_MenuButtonWrapper.style.msTransformOrigin = "right 0"; this.m_LobbyButtonWrapper.style.transformOrigin = "left 0"; this.m_LobbyButtonWrapper.style.webkitTransformOrigin = "left 0"; this.m_LobbyButtonWrapper.style.msTransformOrigin = "left 0"; this.m_SoundButtonWrapper.style.transformOrigin = "right 0"; this.m_SoundButtonWrapper.style.webkitTransformOrigin = "right 0"; this.m_SoundButtonWrapper.style.msTransformOrigin = "right 0" } else { this.m_MenuButtonWrapper.style.left = ""; this.m_MenuButtonWrapper.style.right = "4%"; this.m_LobbyButtonWrapper.style.right = ""; this.m_LobbyButtonWrapper.style.left = "4%"; this.m_SoundButtonWrapper.style.left = ""; this.m_SoundButtonWrapper.style.right = "4%"; this.m_MenuButtonImage.style.left = ""; this.m_MenuButtonImage.style.right = "-25%"; this.m_LobbyButtonImage.style.right = ""; this.m_LobbyButtonImage.style.left = "-25%"; this.m_SoundButtonImage.style.left = ""; this.m_SoundButtonImage.style.right = "-25%" } }; GamePanel.prototype.SetServerTime = function (serverTime) { if (this.jo) this.jo.SetServerTime(serverTime) }; GamePanel.prototype.SetUseServerTime = function (b) { if (this.jo) this.jo.SetUseServerTime(b) }; symbol_startpos = { x: 124, y: 146, w: 150, h: 150 }; symbol_spacing = { w: 160, h: 150 }; symbol_size = { w: 150, h: 150 }; VALUES.MAX_LOGO_SCALE_PT = 1.3; OLDUI = false; function setVSValues() { if (DEVICE.orientation == "pt") { var bgr_gamepanel_pos = 930; var bgr_top = bgr_gamepanel_pos - game_panel_layer_pos.pt.y / scale_layer_pos.pt.scale; var logoheight = game_bgr_pos.logo.layer.pt.y + game_bgr_pos.logo.layer.pt.h - bgr_top; var logoscale = logoheight / game_bgr_pos.logo.layer.pt.h; if (logoscale < 0.25) logoscale = 0.25; if (logoscale > 1.3) logoscale = VALUES.MAX_LOGO_SCALE_PT; game_bgr_pos.logo.layer.pt.scale = logoscale; side_panels.spin_panel_layer.pt.scale = scale_layer_pos.pt.scale + 0.2; side_panels.autoplay_panel_layer.pt.scale = scale_layer_pos.pt.scale + 0.2; side_panels.gamble_panel_layer.pt.scale = scale_layer_pos.pt.scale + 0.2; side_panels.spin_panel_layer.pt.x = DEVICE[DEVICE.orientation].w - side_panels.right.pt.size.w; var spinpanel_adjust = 2; var gamblepanel_adjust = 0; side_panels.spin_panel_layer.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y + VALUES.GAMEPANELDIFF - side_panels.spin_panel_layer.pt.h + spinpanel_adjust; side_panels.autoplay_panel_layer.pt.x = DEVICE[DEVICE.orientation].w - side_panels.right_ap.pt.size.w - 24; side_panels.autoplay_panel_layer.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y - (side_panels.autoplay_panel_layer.pt.h - VALUES.GAMEPANELDIFF) + spinpanel_adjust; side_panels.gamble_panel_layer.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y + VALUES.GAMEPANELDIFF - side_panels.gamble_panel_layer.pt.h + gamblepanel_adjust; side_panels.side_panel_layer_pos.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y - side_panels.right.pt.size.h - (gamepanel_pos.game_panel_layer_pos.pt.h - side_panels.right.pt.size.h + 4) * 0.8 } else { var bgr_gamepanel_pos = 930; var bgr_top = bgr_gamepanel_pos - game_panel_layer_pos.ls.y / scale_layer_pos.ls.scale; var logoheight = game_bgr_pos.logo.layer.ls.y + game_bgr_pos.logo.layer.ls.h - bgr_top; var logoscale = logoheight / game_bgr_pos.logo.layer.ls.h; if (logoscale < 0.25) logoscale = 0.25; if (logoscale > 1) logoscale = 1; game_bgr_pos.logo.layer.ls.scale = logoscale; side_panels.spin_panel_layer.ls.x = DEVICE[DEVICE.orientation].w - side_panels.right.ls.size.w; side_panels.spin_panel_layer.ls.y = DEVICE[DEVICE.orientation].h / 2 - side_panels.right.ls.size.h / 2; side_panels.autoplay_panel_layer.ls.y = DEVICE[DEVICE.orientation].h / 2 - side_panels.right_ap.ls.size.h / 2; side_panels.autoplay_panel_layer.ls.x = DEVICE[DEVICE.orientation].w - side_panels.right_ap.ls.size.w; side_panels.gamble_panel_layer.ls.y = DEVICE[DEVICE.orientation].h / 2 - side_panels.left.ls.size.h / 2 } } history_button_index = 3; cashier_button_index = 4; MENU_BTN_ID_BET = 0; MENU_BTN_ID_SETTINGS = 1; MENU_BTN_ID_AUTOPLAY = 2; MENU_BTN_ID_PAYTABLE = 3; MENU_BTN_ID_HISTORY = 4; MENU_BTN_ID_CASHIER = 5; ICON_BET = { x: menu_pos.catpanel.btn.icon_offsets.xbet, y: menu_pos.catpanel.btn.icon_offsets.y }; ICON_SETTINGS = { x: menu_pos.catpanel.btn.icon_offsets.xsettings, y: menu_pos.catpanel.btn.icon_offsets.y }, ICON_AUTOPLAY = { x: menu_pos.catpanel.btn.icon_offsets.xautoplay, y: menu_pos.catpanel.btn.icon_offsets.y }, ICON_PAYTABLE = { x: menu_pos.catpanel.btn.icon_offsets.xpaytable, y: menu_pos.catpanel.btn.icon_offsets.y }, ICON_GAMEHISTORY = { x: menu_pos.catpanel.btn.icon_offsets.xhistory, y: menu_pos.catpanel.btn.icon_offsets.y }, ICON_CASHIER = { x: menu_pos.catpanel.btn.icon_offsets.xcashier, y: menu_pos.catpanel.btn.icon_offsets.y }; ICON_GAMERULES = { x: menu_pos.catpanel.btn.icon_offsets.xgamerules, y: menu_pos.catpanel.btn.icon_offsets.y }; categorypanel = [button = { caption: Locale.IDS_MENU_BET_VSLOT, callback: 0, type: MENU_BTN_ID_BET, icon: ICON_BET }, button = { caption: Locale.IDS_BTN_SETTINGS, callback: 1, type: MENU_BTN_ID_SETTINGS, icon: ICON_SETTINGS }, button = { caption: Locale.IDS_BTN_AUTOPLAY, callback: 2, type: MENU_BTN_ID_AUTOPLAY, icon: ICON_AUTOPLAY }, button = { caption: Locale.IDS_BTN_PAYTABLE, callback: 3, type: MENU_BTN_ID_PAYTABLE, icon: ICON_PAYTABLE }]; historybutton = { caption: Locale.IDS_BTN_GAMEHISTORY, callback: null, type: MENU_BTN_ID_HISTORY, icon: ICON_GAMEHISTORY }; cashierbutton = { caption: Locale.IDS_BTN_CASHIER, callback: null, type: MENU_BTN_ID_CASHIER, icon: ICON_CASHIER }; side_panels = { side_panel_layer_pos: side_panel_layer_pos = { pt: pt = { x: 0, y: 0, w: 640, h: 834, scale: 1 }, ls: ls = { x: 0, y: 0, w: 640, h: 834, scale: 1 } }, spin_panel_layer: spin_panel_layer = { pt: pt = { x: 0, y: 0, w: 200, h: 144, scale: 1 }, ls: ls = { x: 0, y: 0, w: 145, h: 200, scale: 1 } }, autoplay_panel_layer: autoplay_panel_layer = { pt: pt = { x: 0, y: 0, w: 200, h: 144, scale: 1 }, ls: ls = { x: 0, y: 0, w: 154, h: 200, scale: 1 } }, gamble_panel_layer: gamble_panel_layer = { pt: pt = { x: 0, y: 50, w: 360, h: 104, scale: 1 }, ls: ls = { x: 0, y: 0, w: 140, h: 200, scale: 1 } }, right: right = { layer: spin_panel_layer, operator: o = "+", pt: pt = { size: size = { w: 200, h: 144 }, pos: pos = { x: 30, y: 0, w: size.w, h: size.h }, offset: offset = { x: 294, y: 198 } }, ls: ls = { size: size = { w: 154, h: 200 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h }, offset: offset = { x: 140, y: 198 } }, start_pt: start_pt = { p: 140 }, start_ls: start_ls = { p: 140 }, end: end = { p: 0 } }, right_ap: right_ap = { layer: autoplay_panel_layer, operator: o = "+", pt: pt = { size: size = { w: 200, h: 144 }, pos: pos = { x: 35, y: 0, w: size.w, h: size.h }, offset: offset = { x: 294, y: 198 }, cap_pos: cap_pos = { x: 85, y: 5, w: 100, h: 28 }, counter_pos: counter_pos = { x: 60, y: 60, w: 50, h: 34 } }, ls: ls = { size: size = { w: 116, h: 220 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h }, offset: offset = { x: 494, y: 198 }, cap_pos: cap_pos = { x: 12, y: 10, w: 100, h: 26 }, counter_pos: counter_pos = { x: 32, y: 40, w: 50, h: 34 } }, start_pt: start_pt = { p: 140 }, start_ls: start_ls = { p: 140 }, end: end = { p: 0 } }, right_narrow: right_narrow = { pt: pt = {}, ls: ls = {} }, left: left = { layer: gamble_panel_layer, operator: o = "-", pt: pt = { size: size = { w: 360, h: 104 }, pos: pos = { x: -30, y: 0, w: size.w, h: size.h }, offset: offst = { x: 0, y: 398 } }, ls: ls = { size: size = { w: 140, h: 200 }, pos: pos = { x: 0, y: 0, w: size.w, h: size.h }, offset: offst = { x: 0, y: 198 } }, start_pt: start_pt = { p: 0 }, start_ls: start_ls = { p: 0 }, end: end = { p: layer.y } }, buttons: buttons = { spin: spin = { pt: pt = { size: size = { w: 140, h: 140 }, offset: offset = { xon: 0, yon: 140, xoff: 0, yoff: 0, glow: glow = { xglow: 0, yglow: 280 } }, pos: pos = { x: 54, y: 0, w: size.w, h: size.h, offsets: offset }, textpos: textpos = { x: pos.x + 20, w: size.w - 40 } }, ls: ls = { size: size = { w: 140, h: 140 }, offset: offset = { xon: 0, yon: 140, xoff: 0, yoff: 0, glow: glow = { xglow: 0, yglow: 280 } }, pos: pos = { x: 20, y: 20, w: size.w, h: size.h, offsets: offset }, textpos: textpos = { x: pos.x + 20, w: size.w - 40 } }, caption: Locale.IDS_BTN_SPIN }, stop: stop = { pt: pt = { size: size = { w: 100, h: 100 }, offset: offset = { xon: 0, yon: 100, xoff: 0, yoff: 0 }, pos: pos = { x: 115, y: 35, w: size.w, h: size.h, offsets: offset } }, ls: ls = { size: size = { w: 100, h: 100 }, offset: offset = { xon: 0, yon: 100, xoff: 0, yoff: 0 }, pos: pos = { x: 14, y: 96, w: size.w, h: size.h, offsets: offset } } }, gamble: gamble = { pt: pt = { size: size = { w: 122, h: 72 }, offset: offset = { xon: 0, yon: 72, xoff: 0, yoff: 0, xenabled: 0, yenabled: 0, xdisabled: 0, ydisabled: 144, xblink: 0, yblink: 216 }, pos: pos = { x: 16, y: 16, w: size.w, h: size.h, offsets: offset }, textpos: textpos = { x: pos.x + 10, w: size.w - 20 } }, ls: ls = { size: size = { w: 122, h: 72 }, offset: offset = { xon: 0, yon: 72, xoff: 0, yoff: 0, xenabled: 0, yenabled: 0, xdisabled: 0, ydisabled: 144, xblink: 0, yblink: 216 }, pos: pos = { x: 2, y: 8, w: size.w, h: size.h, offsets: offset }, textpos: textpos = { x: pos.x + 10, w: size.w - 20 } } }, collect: collect = { pt: pt = { size: size = { w: 122, h: 72 }, offset: offset = { xon: 0, yon: 72, xoff: 0, yoff: 0, xenabled: 0, yenabled: 0, xdisabled: 0, ydisabled: 144, xblink: 0, yblink: 216 }, pos: pos = { x: 176, y: 16, w: size.w, h: size.h, offsets: offset }, textpos: textpos = { x: pos.x + 10, w: size.w - 20 } }, ls: ls = { size: size = { w: 122, h: 72 }, offset: offset = { xon: 0, yon: 72, xoff: 0, yoff: 0, xenabled: 0, yenabled: 0, xdisabled: 0, ydisabled: 144, xblink: 0, yblink: 216 }, pos: pos = { x: 2, y: 102, w: size.w, h: size.h, offsets: offset }, textpos: textpos = { x: pos.x + 10, w: size.w - 20 } } } } }; content_window_pos = { betdlg: betdlg = { layer: layer = { pt: pt = { x: -20, y: 0 }, ls: ls = { x: 0, y: 0 } }, currency_pos_adj: currency_pos_adj = { up: -40, down: 40 }, spinners: spinners = { value: value = { cap: cap = { x: 50, y: 290, w: 200, h: 35 }, pos: pos = { x: cap.x + 42, y: cap.y + cap.h, w: 116, h: 44 }, overlay_pos: overlay_pos = { x: pos.x - 2, y: pos.y - 4, w: pos.w + 2, h: 134 }, control_pos: control_pos = { x: cap.x, y: cap.y, w: 200, h: 162 } }, coins: coins = { cap: cap = { x: value.cap.x + 170, y: 290, w: 200, h: 35 }, pos: pos = { x: cap.x + 42, y: cap.y + cap.h, w: 116, h: 44 }, overlay_pos: overlay_pos = { x: pos.x - 2, y: pos.y - 4, w: pos.w + 2, h: 134 }, control_pos: control_pos = { x: cap.x, y: cap.y, w: 200, h: 162 } }, lines: lines = { cap: cap = { x: value.cap.x + 170 * 2, y: 290, w: 200, h: 35 }, pos: pos = { x: cap.x + 42, y: cap.y + cap.h, w: 116, h: 44 }, overlay_pos: overlay_pos = { x: pos.x - 2, y: pos.y - 4, w: pos.w + 2, h: 134 }, control_pos: control_pos = { x: cap.x, y: cap.y, w: 200, h: 162 } } }, betinfo: betinfo = { tot_bet_cap: tot_bet_cap = { x: 80, y: 100, w: 200, h: 68 }, tot_coinbet_cap: tot_coinbet_cap = { x: 80, y: 185, w: 200, h: 68 }, value_frame_offset: value_frame_offset = { x: 0, y: 522 }, value_frame_bet: value_frame_bet = { x: tot_bet_cap.x + tot_bet_cap.w + 14, y: tot_bet_cap.y, w: 274, h: 68 }, value_frame_cbet: value_frame_cbet = { x: tot_coinbet_cap.x + tot_coinbet_cap.w + 14, y: tot_coinbet_cap.y, w: 274, h: 68 }, tot_bet: tot_bet = { x: value_frame_bet.x + 10, y: value_frame_bet.y, w: value_frame_bet.w - 20, h: value_frame_bet.h }, tot_coinbet: tot_coinbet = { x: value_frame_cbet.x + 10, y: value_frame_cbet.y, w: value_frame_cbet.w - 20, h: value_frame_cbet.h } } }, settingsdlg: settingsdlg = { layer: layer = { pt: pt = { x: -20, y: 0 }, ls: ls = { x: 0, y: 0 } }, line: line = { x: 60, y: 170, w: 520, h: 2, yadj: 3 } }, autoplaydlg: autoplaydlg = { layer: layer = { pt: pt = { x: -20, y: 0 }, ls: ls = { x: 0, y: 0 } }, checkbox: checkbox = { offsets: offsets = { x: x = 254, xoff: x, yoff: 32, xon: x, yon: 98, xenabled: x, yenabled: 32, xdisabled: x, ydisabled: 164, yenabled_unchecked: 32, ydisabled_unchecked: 164, ydisabled_checked: 230, ydisabled_cross: 296 }, pos: pos = { x: 490, y: 300, w: 66, h: 66, offsets: offsets }, btn_pos: btn_pos = { x: 60, y: pos.y, w: 310, h: pos.h, offsets: offsets }, currency_sign_pos: currency_sign_pos = { x: 40 + 320, y: pos.y, w: 60, h: pos.h }, pos_adj: pos_adj = { x: 0, y: 20 } }, spinners: spinners = { spins: spins = { cap: cap = { x: 50, y: 70, w: 200, h: 35, string: Locale.IDS_LBL_SPINS }, pos: pos = { x: cap.x + 42, y: cap.y + cap.h, w: 116, h: 44 }, overlay_pos: overlay_pos = { x: pos.x - 2, y: pos.y - 4, w: pos.w + 2, h: 134 }, control_pos: control_pos = { x: cap.x, y: cap.y, w: 200, h: 162 } }, totalloss: totalloss = { cap: cap = { x: 50, y: 320, w: 200, h: 35, string: Locale.IDS_AP_LOSSREACHES }, pos: pos = { x: cap.x + 42, y: cap.y + cap.h, w: 116, h: 44 }, overlay_pos: overlay_pos = { x: pos.x - 2, y: pos.y - 4, w: pos.w + 2, h: 134 }, control_pos: control_pos = { x: cap.x, y: cap.y, w: 200, h: 162 } }, win: win = { cap: cap = { x: 300, y: 320, w: 200, h: 35, string: Locale.IDS_AP_WINEXCEEDS }, pos: pos = { x: cap.x + 42, y: cap.y + cap.h, w: 116, h: 44 }, overlay_pos: overlay_pos = { x: pos.x - 2, y: pos.y - 4, w: pos.w + 2, h: 134 }, control_pos: control_pos = { x: cap.x, y: cap.y, w: 200, h: 162 } }, LimitsOffset: 180 }, start_btn: start_btn = { size: size = { w: 200, h: 108 }, offset: offset = { xon: 0, yon: 108, xoff: 0, yoff: 0, xenabled: 0, yenabled: 0, xdisabled: 0, ydisabled: 216 }, pos: pos = { x: 300, y: 116, w: size.w, h: size.h, offsets: offset } }, stop_btn: stop_btn = { size: size = { w: 100, h: 100 }, offset: offset = { xon: 0, yon: 100, xoff: 0, yoff: 0 }, pos: pos = { x: 350, y: 116, w: size.w, h: size.h, offsets: offset } }, info: info = { stop_on: stop_on = { x: 60, y: 260, w: 400, h: 68 } }, line: line = { x: 60, y: 376, w: 520, h: 2 }, sections: sections = [0, 460] }, paytabledlg: paytabledlg = { layer: layer = { pt: pt = { x: -20, y: 0 }, ls: ls = { x: 0, y: 0 } }, button_size: button_size = { w: 218, h: 80 }, button_offset: button_offset = { xon: 0, yon: 322, xoff: 0, yoff: 242, xenabled: 0, yenabled: 242, xdisabled: 0, ydisabled: 402 }, icon_adjust: icon_adjust = { x: 14, y: 20 }, icon_size: icon_size = { w: 40, h: 40 }, caption_size: caption_size = { w: 140, h: 80, adjustx: 58 }, rules_button: rules_button = { size: size = { w: button_size.w, h: button_size.h }, offset: offset = button_offset, pos: pos = { x: 350, y: 66, w: size.w, h: size.h, offsets: offset }, icon_state_offsets: icon_state_offsets = { enabled: 482, disabled: 482 }, icon_symbol_offsets: icon_symbol_offsets = { question: 280 }, icon: icon = { x: icon_adjust.x + pos.x, y: icon_adjust.y + pos.y, w: icon_size.w, h: icon_size.h, offsets: offsets = { x: icon_symbol_offsets.question, y: icon_state_offsets.enabled } }, caption: caption = { x: pos.x + caption_size.adjustx, y: pos.y, w: caption_size.w, h: caption_size.h } }, rules_info: rules_info = { size: size = { w: 280, h: 80 }, pos: pos = { x: 56, y: 66, w: size.w, h: size.h } }, no_rules_adj: no_rules_adj = { x: 0, y: -80 } }, externalwin: externalwin = { size: size = { w: 566, h: 50 }, pos: pos = { pt: pt = { x: 36, y: 30, w: size.w, h: size.h }, ls: ls = { x: 36, y: 56, w: size.w, h: size.h } } } }; var reel_values_gen = { anim_cycle_length: 8, reel_spin_img_height: 1960, reel_base_height: 460, reel_bounce_speed: 6, reel_spinner_speed: 40, reel_width_canvas: 920 }; if (UAGENT_IE) var ie_menu_cover = { x: 0, y: 0, w: 2E3, h: 2E3 }; mysteryjackpot = { img_size: { vs_small: { x: 0, y: 0, w: 302, h: 32 }, vs_large: { x: 0, y: 0, w: 336, h: 36 }, gs_small: { x: 0, y: 0, w: 220, h: 64 }, gs_large: { x: 0, y: 0, w: 230, h: 74 }, win: { x: 0, y: 0, w: 680, h: 450 } }, container: { ls: { bottomright: { x: 380, y: 45, xadj: 10 }, bottomleft: { x: 880, y: 45, xadj: -10 }, topright: { x: 400, y: 0, xadj: 10 }, topleft: { x: 860, y: 0, xadj: -10 }, single_4: { x: 395, y: 310 } }, pt: { stacked: { bottomright: { x: 0, y: 134 + 30 }, bottomleft: { x: 0, y: 96 + 20 }, topright: { x: 0, y: 48 + 10 }, topleft: { x: 0, y: 0 }, single_4: { x: 630, y: 310 } }, bottom: { bottomright: { w: 306, h: 44, x: 324, y: 50, xadj: 6 }, bottomleft: { w: 306, h: 44, x: -6, y: 50, xadj: -6 }, topright: { w: 306, h: 52, x: 324, y: 0, xadj: 6 }, topleft: { w: 306, h: 52, x: -6, y: 0, xadj: -6 } }, lstop: { bottomright: { w: 306, h: 44, x: 324, y: 54, xadj: 6 }, bottomleft: { w: 306, h: 44, x: -6, y: 54, xadj: -6 }, topright: { w: 306, h: 52, x: 324, y: 0, xadj: 6 }, topleft: { w: 306, h: 52, x: -6, y: 0, xadj: -6 } } } }, layer: { stacked: { w: 360, h: 200, x: 446, y: 140 }, ls: { w: 1260, h: 62, x: 450, y: 420 }, bottom: { w: 1260, h: 62, x: 220, y: 1050, reelbottomadj: 85 } }, text: { title: { w: 150, wadj: 30, xadj: 14, yadj: 2 }, value: { w: 120, wadj: 20, xadj: 0, yadj: 2 }, names: { 1: "Mini Jackpot", 2: "Minor Jackpot", 3: "Major Jackpot", 4: "Grand Jackpot" } }, popup: { w: 680, h: 450, x: 288, y: 465, text: { congr: { w: 600, y: 37 }, youwin: { w: 600, y: 150 }, jackpotname: { w: 600, y: 220 }, winvalue: { w: 600, y: 320, fontsize: 78 } }, coinshower: { x: 300, y: 400 } }, layout: "stacked" }; mysteryjackpot.spinbutton = { yadj: 170 }; mysteryjackpot.gamblebutton = { yadj: 20 }; mysteryjackpot_old = { img_size: { vs_small: { x: 0, y: 0, w: 302, h: 32 }, vs_large: { x: 0, y: 0, w: 336, h: 36 }, gs_small: { x: 0, y: 0, w: 220, h: 64 }, gs_large: { x: 0, y: 0, w: 230, h: 74 }, win: { x: 0, y: 0, w: 680, h: 450 } }, container: { ls: { bottomright: { x: 0, y: 46, w: 306, h: 44, xadj: 21 }, bottomleft: { x: 0, y: 46, w: 306, h: 44, xadj: -10 }, topright: { x: 0, y: 0, w: 306, h: 52, xadj: 21 }, topleft: { x: 0, y: 0, w: 306, h: 52, xadj: -10 }, single_4: { x: 395, y: 310 } }, pt: { stacked: { bottomright: { x: 0, y: 134 + 30, w: 306, h: 44 }, bottomleft: { x: 0, y: 96 + 20, w: 306, h: 44 }, topright: { x: 0, y: 48 + 10, w: 306, h: 52 }, topleft: { x: 0, y: 0, w: 306, h: 52 }, single_4: { x: 630, y: 310 } }, bottom: { bottomright: { w: 306, h: 44, x: 324, y: 52 }, bottomleft: { w: 306, h: 44, x: -6, y: 52 }, topright: { w: 306, h: 52, x: 324, y: 0 }, topleft: { w: 306, h: 52, x: -6, y: 0 } }, lstop: { bottomright: { w: 306, h: 44, x: 324, y: 56, xadj: 21 }, bottomleft: { w: 306, h: 44, x: -6, y: 56, xadj: -6 }, topright: { w: 306, h: 52, x: 324, y: 0, xadj: 21 }, topleft: { w: 306, h: 52, x: -6, y: 0, xadj: -6 } } } }, layer: { stacked: { w: 360, h: 200, x: 450, y: 140 }, bottom: { w: 1260, h: 62, x: 0, y: 1E3 }, ls: { w: 1260, h: 62, x: 450, y: 420 } }, text: { title: { wadj: 30, xadj: 16, yadj: 0 }, value: { wadj: 50, xadj: 34, yadj: 0 } }, popup: { w: 680, h: 450, x: 288, y: 465, text: { congr: { w: 600, y: 37 }, youwin: { w: 600, y: 150 }, jackpotname: { w: 600, y: 220 }, winvalue: { w: 600, y: 320 } } }, layout: "stacked" }; mysteryjackpot.winSounds = { 1: -1, 2: -1, 3: -1, 4: -1 }; function getMysteryJackpotSounds() { }; mysteryjackpot.jackpotpos_old = { layer_jackpot: layer_jackpot = { x: 0, y: 0, w: 1260, h: 1180 }, layer_particles: layer_particles = { x: 0, y: 0, w: 1260, h: 1180 }, layer_summary: layer_summary = { x: 1260 * 0.5 - 414 * 0.5, y: 1180 * 0.5, w: 414, h: 240 }, summarybox: summarybox = { x: 0, y: 0, w: 414, h: 240 }, summarytext_congratulations: summarytext_congratulations = { x: 0, y: 10, w: 414, h: 100 }, summarytext_jackpot: summarytext_jackpot = { x: 0, y: 90, w: 414, h: 80 }, summarytext_winnings: summarytext_winnings = { x: 0, y: 140, w: 414, h: 100 } }; mysteryjackpot.particles_old = { layer: layer = { w: 1040, h: 866, x: 110, y: 370 }, fireworkrocket: fireworkrocket = { start: start = { ls: ls = { x: 630, y: 910 }, pt: pt = { x: 630, y: 1180 } }, targetrect: targetrect = { x: 470, y: 470, w: 320, h: 150 }, firerockettimes: firerockettimes = [0, 0, 886, 1023, 2509, 2509, 3038, 3516, 3516], flyduration: 786, duration: 1, spawnrate: 15, vx: function () { return (Math.random() - 0.5) * 24 }, vy: function () { return (Math.random() - 11) * 3 }, ydrag: 0.2, cnt: N_ONE * N_TEN * N_THREE, scale: N_ONE, deltavx: N_ONE - 0.5 / N_TEN, deltavy: N_ONE - 0.5 / N_TEN, roof: 500, size: size = { w: 24, h: 60 }, colorOffset: colorOffset = { white: white = { x: 0, y: 0 }, red: red = { x: 0, y: 60 }, green: green = { x: 0, y: 120 }, blue: blue = { x: 0, y: 180 } }, spriteType: spriteType = { star: star = { x: 0, y: 0 }, small: small = { x: 24, y: 0 }, big: big = { x: 48, y: 0 } }, colors: colors = [this.colorOffset.white, this.colorOffset.blue, this.colorOffset.red, this.colorOffset.green] }, fireworkexplosion: fireworkexplosion = { startscale: function () { return Math.random() * 0 + 0.2 }, endscale: function () { return Math.random() * 0.6 + 1.7 }, duration: 1E3, alphastart: 300, alphaduration: 1E3, w: 156, h: 154, offsetwhite: 0, offsetred: 156 * 2, offsetgreen: 156 * 3, offsetblue: 156 * 1 }, coinshower: coinshower = { x: 640, y: 850, w: 50, h: 50, scalestart: N_ONE / N_FIVE * N_FOUR, scalerate: N_ONE / N_FOUR / N_TEN, ymoverate: 4, cntstart: N_FIVE * N_TEN, density: N_FIVE, angle: function () { return (Math.random() - 0.5) * 0.5 }, radius: function () { return 30 + Math.random() * 4 }, y_kill_level: 1180 + 50 } }; portraitlayout = { gamepanelmargin: 96 * 2, logomargin: 65 * 2, basewidth: 400 * 2, reelheight: 225 * 2 }; BrandHandler.BRANDHANDLER = undefined; function BrandHandler(gb, newui) { BrandHandler.BRANDHANDLER = this; this.O = gb; var brand = this.O.lj; this.m_NewUi = newui; var gameid = this.O.cp; this.jc = gameid; var historyUrl = this.O.en; var cashierUrl = this.O.eg; var helpUrl = this.O.ha; if (typeof setBrandValues === "function") setBrandValues(brand); if (this.constructor !== arguments.callee) return new BrandHandler; this.ri = false; this.iI = false; var oldGames = [100001, 100004, 100005, 100031, 100016, 100017, 100018, 100047, 100211, 100056, 100093, 100094, 100099, 100105, 100106, 100107, 100108, 100235]; for (var i = 0; i < oldGames.length; i++) if (gameid == oldGames[i]) this.iI = true; switch (brand) { case "bet365": pt_help_btn_cap = Locale.IDS_BTN_HELP; pt_cashier_btn_cap = Locale.IDS_BTN_BANK; if (!this.iI && !this.m_NewUi) { menu_icon_offsets = [{ x: menu_pos.catpanel.btn.icon_offsets.xbet, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xsettings, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xautoplay, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xpaytable, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xgamerules, y: menu_pos.catpanel.btn.icon_offsets.y }, { x: menu_pos.catpanel.btn.icon_offsets.xcashier, y: menu_pos.catpanel.btn.icon_offsets.y }]; if (helpUrl) { historybutton.caption = Locale.IDS_BTN_HELP; historybutton.icon = ICON_GAMERULES; categorypanel.push(historybutton) } if (cashierUrl) cashierbutton.caption = Locale.IDS_BTN_BANK; if (!this.iI) this.GamePanelOnTop(gameid) } break } if (brand != undefined) switch (gameid) { case 100002: case 100008: case 100009: case 100010: case 100034: case 100035: case 100036: case 100037: case 100038: case 100039: case 100016: case 100058: case 100019: case 100044: case 100045: case 100046: case 100020: case 100021: case 100022: case 100023: case 100048: case 100049: case 100050: case 100051: card_pos.imgpath = image_path_brands + "card_anim" + "_" + brand + ".png"; break } }; BrandHandler.prototype.constructor = BrandHandler; BrandHandler.prototype.OverrideMenuCallbacks = function (parent) { switch (parent.lj) { case "bet365": if (!this.m_NewUi) { if (parent.bn.bu.aq) var menu = parent.bn.bu.aq; else var menu = parent.bn.aq; for (var i = 0; i < categorypanel.length; i++) if (categorypanel[i].type == MENU_BTN_ID_HISTORY) { menu.qk = menu.mI; menu.aq.fz.bB[i].SetClickListener(Utils.delegate(parent, parent.OpenGameRulesPage)); menu.aq.fz.bB[i].SetClickListener(Utils.delegate(parent, parent.OpenGameRulesPage), true) } else if (categorypanel[i].type == MENU_BTN_ID_CASHIER) if (menu.aq.fz.bB[i]) { menu.aq.fz.bB[i].SetClickListener(function () { menu.ou() }); menu.aq.fz.bB[i].SetClickListener(function () { menu.ou() }, true) } } break } }; BrandHandler.prototype.HandleOrientationChange = function (o) { if (this.iI && this.O.ix) this.GamePanelOnTopOldGames(o) }; BrandHandler.prototype.GamePanelOnTopOldGames = function (o) { if (!document.getElementById("game") || !document.getElementById("controls")) return; if (Utils.eD == 320) { if (o == "pt") { document.getElementById("game").style.top = "20px"; document.getElementById("controls").style.top = "-398px" } else { document.getElementById("game").style.top = "0px"; document.getElementById("controls").style.top = "0px" } if (typeof touch_adjust != "undefined") touch_adjust.y = 20 } else { if (o == "pt") { document.getElementById("game").style.top = "40px"; document.getElementById("controls").style.top = "-796px" } else { document.getElementById("game").style.top = "0px"; document.getElementById("controls").style.top = "0px" } switch (this.jc) { case 100211: case 100031: ls_ipad_topmenu_adjust = -40; ls_ipad_topmenu_funds_adjust = -36; ls_ipad_paytable_btn_pos.y = ls_ipad_topmenu_adjust; ls_ipad_paytable_btn_bounds.y = ls_ipad_topmenu_adjust; ls_ipad_menu_btn_pos.y = ls_ipad_topmenu_adjust; ls_ipad_menu_btn_bounds.y = ls_ipad_topmenu_adjust; ls_ipad_funds_bar_pos.y = ls_ipad_topmenu_adjust; ls_ipad_balance_caption_pos.y = ls_ipad_topmenu_funds_adjust; ls_ipad_balance_text_pos.y = ls_ipad_topmenu_funds_adjust; ls_ipad_bet_caption_pos.y = ls_ipad_topmenu_funds_adjust; ls_ipad_bet_text_pos.y = ls_ipad_topmenu_funds_adjust; break } if (typeof touch_adjust != "undefined") touch_adjust.y = 40 } }; BrandHandler.prototype.TableGame = function (gameid) { var tablegame; switch (Number(gameid)) { case 100052: case 100053: case 100054: case 100055: case 100268: case 100057: case 100058: case 100056: case 100034: case 100035: case 100289: case 100011: tablegame = true; break; default: tablegame = false; break } if (tablegame == false) return false; if (Utils.eD == 320) if (DEVICE.orientation == "ls") { gamepanel_pos.game_panel_layer_pos.ls.y = 0; gamepanel_pos.funds_bar.ls.layer = { x: 0, y: -18 }; gamepanel_pos.info_bar.ls.layer = { x: 0, y: 14 }; gamepanel_pos.game_panel_shadow.ls = { x: 0, y: 33, w: DEVICE.ls.w, h: 5 }; gamepanel_pos.game_panel_shadow.ls.css = "panelshadowgadient_top"; gamepanel_pos.game_panel_shadow_top = { x: 0, y: 33, w: 960, h: 5 }; gamepanel_pos.game_panel_bg.ls.w = DEVICE[DEVICE.orientation].w; scale_layer_pos.ls.y += 33; menu_pos.layer.ls.y = 33; if (typeof side_panels != "undefined") { side_panels.deal_panel_layer.ls.y += 33; side_panels.bet_panel_layer.ls.y += 33; side_panels.feature_panel_layer.ls.y += 33; side_panels.play_panel_layer.ls.y += 33; side_panels.play_panel_big_layer.ls.y += 33 } if (typeof uipos != "undefined") uipos.sidepanel.layer.ls.y += 33; gamepanel_pos.buttons.ls.layer.y = 0 } else { scale_layer_pos.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.game_panel_layer_pos.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.buttons.pt.layer.y = 0; gamepanel_pos.buttons.pt.layer.origin = { x: "center", y: "top" }; menu_pos.layer.pt.y = gamepanel_pos.buttons.pt.layer.y + 33 - VALUES.GAMEPANELDIFF / 2; menu_pos.contwin.layer.pt.h = DEVICE[DEVICE.orientation].h; if (typeof side_panels != "undefined") { side_panels.deal_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; side_panels.bet_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; side_panels.feature_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; side_panels.play_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; side_panels.play_panel_big_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2 } if (typeof uipos != "undefined") uipos.sidepanel.layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2 } else if (DEVICE.orientation == "ls") { gamepanel_pos.game_panel_layer_pos.ls.y = 0; gamepanel_pos.funds_bar.ls.layer = { x: 0, y: -36 }; gamepanel_pos.info_bar.ls.layer = { x: 0, y: 27 }; gamepanel_pos.game_panel_shadow.ls = { x: 0, y: 66, w: DEVICE.ls.w, h: 10 }; gamepanel_pos.game_panel_shadow.ls.css = "panelshadowgadient_top"; gamepanel_pos.game_panel_shadow_top = { x: 0, y: 66, w: 960, h: 10 }; gamepanel_pos.game_panel_bg.ls.w = DEVICE[DEVICE.orientation].w; scale_layer_pos.ls.y += 66; menu_pos.layer.ls.y = 66; if (typeof side_panels != "undefined") { side_panels.deal_panel_layer.ls.y += 66; side_panels.bet_panel_layer.ls.y += 66; side_panels.feature_panel_layer.ls.y += 66; side_panels.play_panel_layer.ls.y += 66; side_panels.play_panel_big_layer.ls.y += 66 } if (typeof uipos != "undefined") uipos.sidepanel.layer.ls.y += 66; gamepanel_pos.buttons.ls.layer.y = 0 } else { scale_layer_pos.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.game_panel_layer_pos.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.buttons.pt.layer.y = 0; gamepanel_pos.buttons.pt.layer.origin = { x: "center", y: "top" }; menu_pos.layer.pt.y = gamepanel_pos.buttons.pt.layer.y + 66 - VALUES.GAMEPANELDIFF / 2; menu_pos.contwin.layer.pt.h = DEVICE[DEVICE.orientation].h; if (typeof side_panels != "undefined") { side_panels.deal_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; side_panels.bet_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; side_panels.feature_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; side_panels.play_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; side_panels.play_panel_big_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2 } if (typeof uipos != "undefined") uipos.sidepanel.layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2 } return tablegame }; BrandHandler.prototype.GamePanelOnTop = function (gameid) { if (!this.ri) return; if (this.TableGame(gameid)) return; if (Utils.eD == 320) if (DEVICE.orientation == "ls") { gamepanel_pos.game_panel_layer_pos.ls.y = 0; gamepanel_pos.funds_bar.ls.layer = { x: 0, y: -18 }; gamepanel_pos.info_bar.ls.layer = { x: 0, y: 14 }; gamepanel_pos.game_panel_shadow.ls = { x: 0, y: 33, w: DEVICE.ls.w, h: 5 }; gamepanel_pos.game_panel_shadow.ls.css = "panelshadowgadient_top"; gamepanel_pos.game_panel_shadow_top = { x: 0, y: 33, w: 960, h: 5 }; gamepanel_pos.game_panel_bg.ls.w = DEVICE[DEVICE.orientation].w; scale_layer_pos.ls.y += 33; menu_pos.layer.ls.y = 33; if (typeof side_panels != "undefined") { side_panels.spin_panel_layer.ls.y += 33; side_panels.autoplay_panel_layer.ls.y += 33; side_panels.gamble_panel_layer.ls.y += 33 } if (typeof uipos != "undefined") uipos.sidepanel.layer.ls.y += 33; gamepanel_pos.buttons.ls.layer.y = 0; if (this.jc == 100196) { bonus_game.book.ls.y = DEVICE[DEVICE.orientation].h - bonus_game.book.ls.h + 25; bonus_game.layer.ls.y = -10 } } else { scale_layer_pos.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.game_panel_layer_pos.ls.h = 66; gamepanel_pos.game_panel_layer_pos.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.buttons.pt.layer.y = 0; gamepanel_pos.buttons.pt.layer.origin = { x: "center", y: "top" }; menu_pos.layer.pt.y = gamepanel_pos.buttons.pt.layer.y + 33 - VALUES.GAMEPANELDIFF / 2; menu_pos.contwin.layer.pt.h = DEVICE[DEVICE.orientation].h; if (typeof side_panels != "undefined") { side_panels.spin_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; side_panels.autoplay_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; side_panels.gamble_panel_layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2 } if (typeof uipos != "undefined") uipos.sidepanel.layer.pt.y += 33 - VALUES.GAMEPANELDIFF / 2; if (this.jc == 100196) bonus_game.book.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y + VALUES.GAMEPANELDIFF - bonus_game.book.pt.h + 1 } else if (DEVICE.orientation == "ls") { gamepanel_pos.game_panel_layer_pos.ls.y = 0; gamepanel_pos.funds_bar.ls.layer = { x: 0, y: -36 }; gamepanel_pos.info_bar.ls.layer = { x: 0, y: 27 }; gamepanel_pos.game_panel_shadow.ls = { x: 0, y: 66, w: DEVICE.ls.w, h: 10 }; gamepanel_pos.game_panel_shadow.ls.css = "panelshadowgadient_top"; gamepanel_pos.game_panel_shadow_top = { x: 0, y: 66, w: 960, h: 10 }; gamepanel_pos.game_panel_bg.ls.w = DEVICE[DEVICE.orientation].w; scale_layer_pos.ls.y += 66; menu_pos.layer.ls.y = 66; if (typeof side_panels != "undefined") { side_panels.spin_panel_layer.ls.y += 66; side_panels.autoplay_panel_layer.ls.y += 66; side_panels.gamble_panel_layer.ls.y += 66 } if (typeof uipos != "undefined") uipos.sidepanel.layer.ls.y += 66; gamepanel_pos.buttons.ls.layer.y = 0; if (this.jc == 100196) { bonus_game.book.ls.y = DEVICE[DEVICE.orientation].h - bonus_game.book.ls.h + 50; bonus_game.layer.ls.y = -25 } } else { scale_layer_pos.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.game_panel_layer_pos.ls.h = 132; gamepanel_pos.game_panel_layer_pos.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; gamepanel_pos.buttons.pt.layer.y = 0; gamepanel_pos.buttons.pt.layer.origin = { x: "center", y: "top" }; menu_pos.layer.pt.y = gamepanel_pos.buttons.pt.layer.y + 66 - VALUES.GAMEPANELDIFF / 2; menu_pos.contwin.layer.pt.h = DEVICE[DEVICE.orientation].h; if (typeof side_panels != "undefined") { side_panels.spin_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; side_panels.autoplay_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; side_panels.gamble_panel_layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2 } if (typeof uipos != "undefined") uipos.sidepanel.layer.pt.y += 66 - VALUES.GAMEPANELDIFF / 2; if (this.jc == 100196) bonus_game.book.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y + VALUES.GAMEPANELDIFF - bonus_game.book.pt.h + 2 } }; function setBrandValues(brand) { switch (brand) { case "bet365": BrandValueFunctions.setBet365(); break; case "verajohn": BrandValueFunctions.setVeraJohn(); break; case "casinoheroes": BrandValueFunctions.setCasinoHeroes(); break; case "royalcasino": BrandValueFunctions.setRoyalCasino(); break } } BrandValueFunctions = {}; BrandValueFunctions.setBet365 = function () { mysteryjackpot.brand_img_path = { vs_jackpot1_bg: image_path_brands + "bet365/vs_jackpot1_bg.png", vs_jackpot2_bg: image_path_brands + "bet365/vs_jackpot2_bg.png", vs_jackpot3_bg: image_path_brands + "bet365/vs_jackpot3_bg.png", vs_jackpot4_bg: image_path_brands + "bet365/vs_jackpot4_bg.png", gs_jackpot1_bg: image_path_brands + "bet365/gs_jackpot1_bg.png", gs_jackpot2_bg: image_path_brands + "bet365/gs_jackpot2_bg.png", gs_jackpot3_bg: image_path_brands + "bet365/gs_jackpot3_bg.png", gs_jackpot4_bg: image_path_brands + "bet365/gs_jackpot4_bg.png", win: image_path_brands + "bet365/jp_popup_bg.png" }; mysteryjackpot_old.brand_img_path = { vs_jackpot1_bg: image_path_brands + "bet365/vs_jackpot1_bg.png", vs_jackpot2_bg: image_path_brands + "bet365/vs_jackpot2_bg.png", vs_jackpot3_bg: image_path_brands + "bet365/vs_jackpot3_bg.png", vs_jackpot4_bg: image_path_brands + "bet365/vs_jackpot4_bg.png", gs_jackpot1_bg: image_path_brands + "bet365/gs_jackpot1_bg.png", gs_jackpot2_bg: image_path_brands + "bet365/gs_jackpot2_bg.png", gs_jackpot3_bg: image_path_brands + "bet365/gs_jackpot3_bg.png", gs_jackpot4_bg: image_path_brands + "bet365/gs_jackpot4_bg.png", win: image_path_brands + "bet365/jp_popup_bg.png" } }; BrandValueFunctions.setVeraJohn = function () { mysteryjackpot.popup.text.youwin.y = 120; mysteryjackpot.popup.text.jackpotname.y = 184; mysteryjackpot.popup.text.winvalue.y = 264; mysteryjackpot.brand_img_path = { vs_jackpot1_bg: image_path_brands + "verajohn/vs_jackpot3_bg.png", vs_jackpot2_bg: image_path_brands + "verajohn/vs_jackpot4_bg.png", vs_jackpot3_bg: image_path_brands + "verajohn/vs_jackpot1_bg.png", vs_jackpot4_bg: image_path_brands + "verajohn/vs_jackpot2_bg.png", gs_jackpot1_bg: image_path_brands + "verajohn/gs_jackpot3_bg.png", gs_jackpot2_bg: image_path_brands + "verajohn/gs_jackpot4_bg.png", gs_jackpot3_bg: image_path_brands + "verajohn/gs_jackpot1_bg.png", gs_jackpot4_bg: image_path_brands + "verajohn/gs_jackpot2_bg.png", win: image_path_brands + "verajohn/jp_popup_bg.png" }; mysteryjackpot_old.brand_img_path = { vs_jackpot1_bg: image_path_brands + "verajohn/vs_jackpot3_bg.png", vs_jackpot2_bg: image_path_brands + "verajohn/vs_jackpot4_bg.png", vs_jackpot3_bg: image_path_brands + "verajohn/vs_jackpot1_bg.png", vs_jackpot4_bg: image_path_brands + "verajohn/vs_jackpot2_bg.png", gs_jackpot1_bg: image_path_brands + "verajohn/gs_jackpot3_bg.png", gs_jackpot2_bg: image_path_brands + "verajohn/gs_jackpot4_bg.png", gs_jackpot3_bg: image_path_brands + "verajohn/gs_jackpot1_bg.png", gs_jackpot4_bg: image_path_brands + "verajohn/gs_jackpot2_bg.png", win: image_path_brands + "verajohn/jp_popup_bg.png" }; MysterJackpotWinPopup.prototype.initWinValueTextFieldPixi = function () { this.m_txtWinValue = new PNG.Text("\u00c2\u00a3 10,000,000.00", "mj_old_popup_winvalue"); this.m_txtWinValue.width = mysteryjackpot.popup.text.winvalue.w; this.m_txtWinValue.x = this.m_Popup.w / 2 - this.m_txtWinValue.width / 2; this.m_txtWinValue.y = mysteryjackpot.popup.text.winvalue.y; this.m_txtWinValue.zIndex = 100 } }; BrandValueFunctions.setCasinoHeroes = function () { mysteryjackpot.popup.text.youwin.y = 120; mysteryjackpot.popup.text.jackpotname.y = 184; mysteryjackpot.popup.text.winvalue.y = 315; mysteryjackpot.brand_img_path = { vs_jackpot1_bg: image_path_brands + "casinoheroes/vs_jackpot4_bg.png", vs_jackpot2_bg: image_path_brands + "casinoheroes/vs_jackpot3_bg.png", vs_jackpot3_bg: image_path_brands + "casinoheroes/vs_jackpot2_bg.png", vs_jackpot4_bg: image_path_brands + "casinoheroes/vs_jackpot1_bg.png", gs_jackpot1_bg: image_path_brands + "casinoheroes/gs_jackpot4_bg.png", gs_jackpot2_bg: image_path_brands + "casinoheroes/gs_jackpot3_bg.png", gs_jackpot3_bg: image_path_brands + "casinoheroes/gs_jackpot2_bg.png", gs_jackpot4_bg: image_path_brands + "casinoheroes/gs_jackpot1_bg.png", win: image_path_brands + "casinoheroes/jp_popup_bg.png" }; mysteryjackpot_old.brand_img_path = { vs_jackpot1_bg: image_path_brands + "casinoheroes/vs_jackpot4_bg.png", vs_jackpot2_bg: image_path_brands + "casinoheroes/vs_jackpot3_bg.png", vs_jackpot3_bg: image_path_brands + "casinoheroes/vs_jackpot2_bg.png", vs_jackpot4_bg: image_path_brands + "casinoheroes/vs_jackpot1_bg.png", gs_jackpot1_bg: image_path_brands + "casinoheroes/gs_jackpot4_bg.png", gs_jackpot2_bg: image_path_brands + "casinoheroes/gs_jackpot3_bg.png", gs_jackpot3_bg: image_path_brands + "casinoheroes/gs_jackpot2_bg.png", gs_jackpot4_bg: image_path_brands + "casinoheroes/gs_jackpot1_bg.png", win: image_path_brands + "casinoheroes/jp_popup_bg.png" }; MysterJackpotWinPopup.prototype.initWinValueTextFieldPixi = function () { this.m_txtWinValue = new PNG.Text("\u00c2\u00a3 10,000,000.00", "mj_old_popup_winvalue"); this.m_txtWinValue.width = mysteryjackpot.popup.text.winvalue.w; this.m_txtWinValue.x = this.m_Popup.w / 2 - this.m_txtWinValue.width / 2; this.m_txtWinValue.y = mysteryjackpot.popup.text.winvalue.y }; MysteryJackpotDisplay.override("CreateUI", function (index) { return new JackpotDisplayUI(index, "", sjs.layers.mystery, this.bG, this.m_DisplayPosition) }) }; BrandValueFunctions.setRoyalCasino = function () { mysteryjackpot.brand_img_path = { vs_jackpot1_bg: image_path_brands + "royalcasino/vs_jackpot1_bg.png", vs_jackpot2_bg: image_path_brands + "royalcasino/vs_jackpot2_bg.png", vs_jackpot3_bg: image_path_brands + "royalcasino/vs_jackpot3_bg.png", vs_jackpot4_bg: image_path_brands + "royalcasino/vs_jackpot4_bg.png", win: image_path_brands + "royalcasino/jp_popup_bg.png" }; mysteryjackpot_old.brand_img_path = { vs_jackpot1_bg: image_path_brands + "royalcasino/vs_jackpot1_bg.png", vs_jackpot2_bg: image_path_brands + "royalcasino/vs_jackpot2_bg.png", vs_jackpot3_bg: image_path_brands + "royalcasino/vs_jackpot3_bg.png", vs_jackpot4_bg: image_path_brands + "royalcasino/vs_jackpot4_bg.png", win: image_path_brands + "royalcasino/jp_popup_bg.png" } }; function MJFireworks(mc, rocketPool, particlePool, particleDustPool, sounds) { if (rocketPool == undefined) rocketPool = null; if (particlePool == undefined) particlePool = null; if (particleDustPool == undefined) particleDustPool = null; if (sounds == undefined) sounds = null; this.hD; this.pR; this.m_ParticlePool; this.m_ParticleDustPool; this.m_Snds; this._super(mc, rocketPool); this.m_RocketPool = rocketPool; this.m_ParticlePool = particlePool; this.m_ParticleDustPool = particleDustPool; this.m_Snds = sounds } Classify.constr(MJFireworks).ext(Emitter); MJFireworks.override("start", function () { this._super(); this.hD = 0 }); MJFireworks.prototype.Tick = function () { this.onEnterFrame(); this.m_RocketPool.onEnterFrame(); this.m_ParticlePool.onEnterFrame(); this.m_ParticleDustPool.onEnterFrame() }; MJFireworks.override("tickCompleted", function () { if (this.ee.parent == null) return; if (this.hD++ % 40 == 0) { var item1 = this.ko.add(); if (item1) item1.initWithArgs(this, this.m_ParticlePool, this.m_ParticleDustPool, this.m_Snds) } }); MJFireworks.createRocketPool = function (size, mc) { return new Pool(size, FireworkRocket, mc) }; MJFireworks.createParticlePool = function (size, mc) { return new Pool(size, FireworkParticle, mc) }; MJFireworks.createParticleDustPool = function (size, mc) { return new Pool(size, FireworkParticleDust, mc) }; function FireworkRocket() { this._super(); this.m_ContentClass = null; this.m_Colors = ["new ColorTransform(0x1c / 255.0, 0xfe / 255.0, 0x5c / 255.0)", "new ColorTransform(0xff / 255.0, 0xf4 / 255.0, 0x24 / 255.0)", "new ColorTransform(0xff / 255.0, 0x6c / 255.0, 0x29 / 255.0)", "new ColorTransform(0x1c / 255.0, 0xd1 / 255.0, 0xff / 255.0)", "new ColorTransform(0xff / 255.0, 0x16 / 255.0, 0x9f / 255.0)", "new ColorTransform(0xff / 255.0, 0xff / 255.0, 0xff / 255.0)"]; this.m_Fac = 180 / Math.PI; this.hD; this.nU; this.nq; this.hY; this.m_ParticlePool; this.m_ParticleDustPool; this.m_Snds; this.ee; this.m_ContentClass = new PIXI.Sprite.fromImage(image_path_particles + "glint3.png"); this.m_ContentClass.w = 10; this.m_ContentClass.h = 60; this.ee = this.m_ContentClass; this.addChild(this.ee) } Classify.constr(FireworkRocket).ext(Particle); FireworkRocket.prototype.initWithArgs = function (emitter, particlePool, particleDustPool, sounds) { this.init(emitter); this.m_ParticlePool = particlePool; this.m_ParticleDustPool = particleDustPool; this.m_Snds = sounds; this.nU = (Math.random() - 0.5) * 20; this.nq = (Math.random() - 8) * 3; this.hD = 20; this.hY = 0.6; this.scaleX = this.scaleY = this.hY }; FireworkRocket.override("tick", function (part) { this.x += this.nU * part; this.y += this.nq * part }); FireworkRocket.override("tickCompleted", function () { this.rotation = Math.atan2(this.nU, -this.nq); this.nq += 0.4; this.nU *= 0.95; this.nq *= 0.95; if (--this.hD == 0) this.explode(); return this.hD > 0 }); FireworkRocket.prototype.explode = function () { var explodingForce = Math.random() * 3; var colorIdx = Math.floor(Math.random() * this.m_Colors.length); var color = this.m_Colors[colorIdx]; for (var i = 20; --i > 0;) { var item1 = this.m_ParticlePool.add(); if (item1) item1.initWithArgs(this.x, this.y, this.nU, this.nq, explodingForce, color, this.m_ParticleDustPool) } var idx = Math.floor(explodingForce) + 1 }; function FireworkParticle() { this._super(); this.m_ContentClass = null; this.m_Fac = 180 / Math.PI; this.hD; this.m_DustDelay; this.nU; this.nq; this.hY; this.m_ParticleDustPool; this.sf; this.m_ActualColor; this.ee; this.m_ContentClass = new PIXI.Sprite.fromImage(image_path_particles + "glint2.png"); this.ee = this.m_ContentClass; this.addChild(this.ee) } Classify.constr(FireworkParticle).ext(Particle); FireworkParticle.prototype.initWithArgs = function (x0, y0, vx0, vy0, force, color, particleDustPool) { this.m_ParticleDustPool = particleDustPool; this.sf = color; var a = Math.random() * 2 * Math.PI; var r = Math.random() + 3 + force; this.nU = vx0 + Math.sin(a) * r; this.nq = vy0 + Math.cos(a) * r; this.x = x0 + this.nU; this.y = y0 + this.nq; this.hD = 25 + Math.floor(Math.random() * 20); this.m_DustDelay = 6; this.hY = 0; this.alpha = 1; this.scaleX = this.scaleY = this.hY }; FireworkParticle.override("tick", function (part) { this.x += this.nU * part; this.y += this.nq * part }); FireworkParticle.override("tickCompleted", function () { this.rotation = Math.atan2(this.nU, -this.nq); this.nq += 0.4; this.nU *= 0.98; this.nq *= 0.98; this.hY = Math.sqrt(this.nU * this.nU + this.nq * this.nq) * 0.12; this.scaleX = this.scaleY = this.hY; if (this.hD < 10) this.alpha = this.hD * 0.1; if (--this.m_DustDelay < 0 && (this.hD & 6) == 0) this.emitDust(); return --this.hD > 0 }); FireworkParticle.prototype.emitDust = function () { var item1 = this.m_ParticleDustPool.add(); if (item1) item1.initWithArgs(this.x - this.nU * 3, this.y - this.nq * 3, this.nU, this.nq, this.alpha, this.sf) }; function FireworkParticleDust() { this._super(); this.contentClass = null; this.nU; this.nq; this.hY; this.hD; this.ee; this.m_ContentClass = new PIXI.Sprite.fromImage(image_path_particles + "glint.png"); this.ee = this.m_ContentClass; this.addChild(this.ee) } Classify.constr(FireworkParticleDust).ext(Particle); FireworkParticleDust.prototype.initWithArgs = function (x0, y0, vx0, vy0, a, color) { this.x = x0; this.y = y0; this.nU = vx0; this.nq = vy0; this.hY = 0.5; this.hD = 20; this.alpha = 1; this.scaleX = this.scaleY = this.hY }; FireworkParticleDust.override("tick", function (part) { this.x += this.nU * part; this.y += this.nq * part }); FireworkParticleDust.override("tickCompleted", function () { this.nq += 0.4; this.nU *= 0.8; this.nq *= 0.8; this.hY *= 0.98; if (--this.hD < 8) this.alpha -= 0.125; this.scaleX = this.scaleY = this.hY; return this.hD > 0 }); function JackpotDisplayUI(index, name, parentLayer, settings, displayPosition) { this.aA = index; this.bG = settings; this.gm = 0; this.m_DisplayPosition = displayPosition; var img_path = this.getImagePath(); this.cK = new PIXI.DisplayObjectContainer; this.cK.scaleX = 1.2; this.cK.scaleY = 1.2; this.m_GambleMode = false; this.IsCurrentDisplayingJackpot = false; this.m_Background = new PIXI.Sprite.fromImage(img_path); this.m_Background.x = 0; this.m_Background.y = 0; var halfWidth = this.m_Background.width * N_HALF; this.m_txtCaption = new PNG.Text(name, "mj_title" + this.aA); this.m_txtCaption.height = this.m_Background.height; this.m_txtCaption.width = mysteryjackpot.text.title.w; this.m_txtCaption.x = this.m_Background.x + mysteryjackpot.text.title.xadj; this.m_txtCaption.style.wordWrap = false; this.m_txtCaption.verticalAlign = "middle"; this.m_txtValue = new PNG.Text(0, "mj_value" + this.aA); this.m_txtValue.height = this.m_Background.height; this.m_txtValue.width = mysteryjackpot.text.value.w; this.m_txtValue.x = this.m_txtCaption.width - mysteryjackpot.text.value.xadj; this.m_txtValue.verticalAlign = "middle"; this.m_txtValue.style.wordWrap = false; this.cK.addChild(this.m_Background); this.cK.addChild(this.m_txtCaption); this.cK.addChild(this.m_txtValue); sjs.layers.mystery.view.addChild(this.cK); this.setValue("1000000.00"); this.HandleOrientationChange() } Classify.constr(JackpotDisplayUI); JackpotDisplayUI.prototype.Show = function (b) { if (this.cK.visible != b) this.cK.visible = b }; JackpotDisplayUI.prototype.setGambleMode = function (b) { this.m_GambleMode = b; if (mysteryjackpot.layout == "bottom") this.Show(!b && this.IsCurrentDisplayingJackpot); else; }; JackpotDisplayUI.prototype.HandleOrientationChange = function (pt) { this.UpdateBackground(); if (DEVICE.orientation == "pt") if (mysteryjackpot.layout == "stacked") { this.HandleStackedLayout(); if (this.m_GambleMode && !this.cK.visible) this.Show(true) } else if (mysteryjackpot.layout == "lstop" || mysteryjackpot.layout == "top_2") { this.HandleLSTopLayout(); if (this.m_GambleMode && !this.cK.visible) this.Show(true) } else { if (OLDUI) this.HandleBottomLayoutOLDUI(); else this.HandleBottomLayout(); if (this.m_GambleMode && this.cK.visible) this.Show(false) } else { this.HandleLandscapeLayout(); if (this.m_GambleMode && !this.cK.visible) this.Show(true) } }; JackpotDisplayUI.prototype.GetActualDisplayPosition = function (displayPosition) { if (typeof displayPosition == "undefined") displayPosition = this.m_DisplayPosition; if (mysteryjackpot.layout == "single_4") return MysteryJackpotPosition.TOPLEFT; else if (mysteryjackpot.layout == "top_2") if (displayPosition == MysteryJackpotPosition.TOPLEFT || displayPosition == MysteryJackpotPosition.BOTTOMLEFT) return MysteryJackpotPosition.TOPLEFT; else { if (displayPosition == MysteryJackpotPosition.TOPRIGHT || displayPosition == MysteryJackpotPosition.BOTTOMRIGHT) return MysteryJackpotPosition.TOPRIGHT } else return displayPosition }; JackpotDisplayUI.prototype.UpdateBackground = function () { var displayPosition = this.GetActualDisplayPosition(); var img_path = this.getImagePath(); this.cK.removeChild(this.m_Background); this.m_Background = new PIXI.Sprite.fromImage(img_path); this.cK.addChildAt(this.m_Background, 0); var titleBounds, valueBounds; if (mysteryjackpot.bg == "gs") { var halfHeight = this.m_Background.height * N_HALF; titleBounds = { h: halfHeight, w: this.m_Background.width - mysteryjackpot.text_gs.title.wadj, x: this.m_Background.x + mysteryjackpot.text_gs.title.xadj, y: this.m_Background.y + mysteryjackpot.text_gs.title.yadj }; valueBounds = { h: halfHeight, w: this.m_Background.width - mysteryjackpot.text_gs.value.wadj, x: this.m_Background.x + mysteryjackpot.text_gs.value.xadj, y: this.m_Background.y + halfHeight + mysteryjackpot.text_gs.value.yadj }; this.m_txtCaption.align = "center"; this.m_txtValue.align = "center" } else { titleBounds = { h: this.m_Background.height, w: mysteryjackpot.text.title.w, x: this.m_Background.x + mysteryjackpot.text.title.xadj, y: 0 }; valueBounds = { h: this.m_Background.height, w: mysteryjackpot.text.value.w, x: this.m_Background.x + titleBounds.w + mysteryjackpot.text.title.xadj + mysteryjackpot.text.value.xadj, y: 0 }; this.m_txtCaption.align = "left"; this.m_txtValue.align = "right" } this.m_txtCaption.x = titleBounds.x; this.m_txtCaption.y = titleBounds.y; this.m_txtCaption.width = titleBounds.w; this.m_txtCaption.height = titleBounds.h; this.m_txtValue.x = valueBounds.x; this.m_txtValue.y = valueBounds.y; this.m_txtValue.width = valueBounds.w; this.m_txtValue.height = valueBounds.h }; JackpotDisplayUI.prototype.HandleBottomLayout = function () { sjs.layers.mystery.Origin("center", "bottom"); sjs.layers.mystery.xscale = 1; sjs.layers.mystery.yscale = 1; sjs.layers.mystery.w = mysteryjackpot.layer.bottom.w; sjs.layers.mystery.h = mysteryjackpot.layer.bottom.h; sjs.layers.mystery.x = mysteryjackpot.layer.bottom.x; sjs.layers.mystery.y = mysteryjackpot.layer.bottom.y; var reelLayer = sjs.layers.reels, reelHeight = portraitlayout.reelheight, reelBottom = reelLayer.y + reelHeight; sjs.layers.mystery.y = reelBottom + mysteryjackpot.layer.bottom.reelbottomadj; var screenWidth = DEVICE.pt.w / scale_layer_pos.pt.scale; var diff = (sjs.layers.mystery.w - screenWidth) / 2; sjs.layers.mystery.x = diff; this.cK.scaleX = 1.1; this.cK.scaleY = 1.1; var displayPosition = this.GetActualDisplayPosition(); if (mysteryjackpot.layout == "single_4") { this.cK.x = mysteryjackpot.container.pt.bottom[displayPosition].x; this.cK.y = mysteryjackpot.container.pt.bottom[displayPosition].y } else if (displayPosition === MysteryJackpotPosition.BOTTOMRIGHT || displayPosition == MysteryJackpotPosition.TOPRIGHT) this.cK.x = screenWidth - this.cK.width + mysteryjackpot.container.pt.bottom[displayPosition].xadj; else this.cK.x = mysteryjackpot.container.pt.bottom[displayPosition].xadj; this.cK.y = mysteryjackpot.container.pt.bottom[displayPosition].y }; JackpotDisplayUI.prototype.HandleBottomLayoutOLDUI = function () { sjs.layers.mystery.Origin("left", "bottom"); sjs.layers.mystery.xscale = 0.91; sjs.layers.mystery.yscale = 0.91; sjs.layers.mystery.w = mysteryjackpot.layer.bottom.w; sjs.layers.mystery.h = mysteryjackpot.layer.bottom.h; sjs.layers.mystery.x = mysteryjackpot.layer.bottom.x; sjs.layers.mystery.y = mysteryjackpot.layer.bottom.y; var reelLayer = sjs.layers.reels, reelHeight = portraitlayout.reelheight, reelBottom = reelLayer.y + reelHeight; sjs.layers.mystery.y = reelBottom + mysteryjackpot.layer.bottom.reelbottomadj; var screenWidth = DEVICE.pt.w / scale_layer_pos.pt.scale; var diff = (sjs.layers.mystery.w - screenWidth) / 2; sjs.layers.mystery.x = diff; this.cK.scaleX = 1.1; this.cK.scaleY = 1.1; var displayPosition = this.GetActualDisplayPosition(); if (mysteryjackpot.layout == "single_4") { this.cK.x = mysteryjackpot.container.pt.bottom[displayPosition].x; this.cK.y = mysteryjackpot.container.pt.bottom[displayPosition].y } else if (displayPosition === MysteryJackpotPosition.BOTTOMRIGHT || displayPosition == MysteryJackpotPosition.TOPRIGHT) this.cK.x = screenWidth - this.cK.width + mysteryjackpot.container.pt.bottom[displayPosition].xadj; else this.cK.x = mysteryjackpot.container.pt.bottom[displayPosition].xadj; this.cK.y = mysteryjackpot.container.pt.bottom[displayPosition].y; this.cK.x = mysteryjackpot_old.container.pt.bottom[displayPosition].x }; JackpotDisplayUI.prototype.HandleLSTopLayout = function () { sjs.layers.mystery.Origin("center", "bottom"); sjs.layers.mystery.xscale = 1; sjs.layers.mystery.yscale = 1; sjs.layers.mystery.w = mysteryjackpot.layer.bottom.w; sjs.layers.mystery.h = mysteryjackpot.layer.bottom.h; sjs.layers.mystery.x = mysteryjackpot.layer.bottom.x; sjs.layers.mystery.y = mysteryjackpot.layer.bottom.y; var screenWidth = DEVICE.pt.w / scale_layer_pos.pt.scale; var diff = (sjs.layers.mystery.w - screenWidth) / 2; sjs.layers.mystery.x = diff; var displayPosition = this.GetActualDisplayPosition(); if (typeof mysteryjackpot.container.pt.lstop[displayPosition].scale != "undefined") { this.cK.scaleX = mysteryjackpot.container.pt.lstop[displayPosition].scale; this.cK.scaleY = mysteryjackpot.container.pt.lstop[displayPosition].scale } else { this.cK.scaleX = 1.2; this.cK.scaleY = 1.2 } if (displayPosition == MysteryJackpotPosition.BOTTOMRIGHT || displayPosition == MysteryJackpotPosition.TOPRIGHT) this.cK.x = screenWidth - this.cK.width + mysteryjackpot.container.pt.bottom[displayPosition].xadj; else this.cK.x = mysteryjackpot.container.pt.bottom[displayPosition].xadj; this.cK.y = mysteryjackpot.container.pt.lstop[displayPosition].y }; JackpotDisplayUI.prototype.HandleStackedLayout = function () { sjs.layers.mystery.Origin("center", "bottom"); sjs.layers.mystery.xscale = 1.1; sjs.layers.mystery.yscale = 1.1; this.cK.scaleX = 1.2; this.cK.scaleY = 1.2; this.cK.x = mysteryjackpot.container[DEVICE.orientation].stacked[this.m_DisplayPosition].x; this.cK.y = mysteryjackpot.container[DEVICE.orientation].stacked[this.m_DisplayPosition].y; sjs.layers.mystery.x = mysteryjackpot.layer.stacked.x; sjs.layers.mystery.y = mysteryjackpot.layer.stacked.y; sjs.layers.mystery.w = mysteryjackpot.layer.stacked.w; sjs.layers.mystery.h = mysteryjackpot.layer.stacked.h }; JackpotDisplayUI.prototype.HandleLandscapeLayout = function () { sjs.layers.mystery.xscale = 1; sjs.layers.mystery.yscale = 1; sjs.layers.mystery.w = mysteryjackpot.layer.ls.w; sjs.layers.mystery.h = mysteryjackpot.layer.ls.h; var screenWidth = DEVICE.ls.w / scale_layer_pos.ls.scale; var diff = (sjs.layers.mystery.w - screenWidth) / 2; sjs.layers.mystery.x = diff; sjs.layers.mystery.y = mysteryjackpot.layer.ls.y; sjs.layers.mystery.w = screenWidth; sjs.layers.mystery.h = mysteryjackpot.layer.ls.h; this.cK.scaleX = 1; this.cK.scaleY = 1; var displayPosition = this.GetActualDisplayPosition(); if (mysteryjackpot.layout == "single_4") { this.cK.x = mysteryjackpot.container.ls[displayPosition].x; this.cK.y = mysteryjackpot.container.ls[displayPosition].y } else { if (displayPosition === MysteryJackpotPosition.BOTTOMRIGHT || displayPosition === MysteryJackpotPosition.TOPRIGHT) this.cK.x = screenWidth - this.cK.width + mysteryjackpot.container.ls[displayPosition].xadj; else this.cK.x = mysteryjackpot.container.ls[displayPosition].xadj; this.cK.y = mysteryjackpot.container.ls[displayPosition].y } }; JackpotDisplayUI.prototype.setPosition = function (x, y) { this.cK.x = x; this.cK.y = y }; JackpotDisplayUI.prototype.setName = function (newName) { this.m_txtCaption.text = newName; this.m_txtCaption.updateText() }; JackpotDisplayUI.prototype.getName = function () { return this.m_txtCaption.text }; JackpotDisplayUI.prototype.setValue = function (newValue) { if (this.m_txtValue.text != newValue) { this.m_txtValue.text = newValue; this.m_txtValue.updateText() } }; JackpotDisplayUI.prototype.setTotalBet = function (v) { this.gm = v * 100 * this.bG.getDenominationMultiplier() }; JackpotDisplayUI.prototype.onBetChange = function (newbet) { }; JackpotDisplayUI.prototype.getImagePath = function () { var imagesToUse; var displayPosition; displayPosition = this.m_DisplayPosition; if (mysteryjackpot.bg == "gs") if (mysteryjackpot.brand_img_path) imagesToUse = { jackpot1_bg: mysteryjackpot.brand_img_path.gs_jackpot1_bg, jackpot2_bg: mysteryjackpot.brand_img_path.gs_jackpot2_bg, jackpot3_bg: mysteryjackpot.brand_img_path.gs_jackpot3_bg, jackpot4_bg: mysteryjackpot.brand_img_path.gs_jackpot4_bg }; else imagesToUse = { jackpot4_bg: image_path_jackpot + "gs_jackpot4_bg.png", jackpot3_bg: image_path_jackpot + "gs_jackpot3_bg.png", jackpot2_bg: image_path_jackpot + "gs_jackpot2_bg.png", jackpot1_bg: image_path_jackpot + "gs_jackpot1_bg.png" }; else if (mysteryjackpot.brand_img_path) imagesToUse = { jackpot1_bg: mysteryjackpot.brand_img_path.vs_jackpot1_bg, jackpot2_bg: mysteryjackpot.brand_img_path.vs_jackpot2_bg, jackpot3_bg: mysteryjackpot.brand_img_path.vs_jackpot3_bg, jackpot4_bg: mysteryjackpot.brand_img_path.vs_jackpot4_bg }; else imagesToUse = { jackpot4_bg: image_path_jackpot + "vs_jackpot4_bg.png", jackpot3_bg: image_path_jackpot + "vs_jackpot3_bg.png", jackpot2_bg: image_path_jackpot + "vs_jackpot2_bg.png", jackpot1_bg: image_path_jackpot + "vs_jackpot1_bg.png" }; var imgPath = undefined; if (mysteryjackpot.brand_img_path) switch (Number(this.aA)) { case 1: imgPath = imagesToUse.jackpot1_bg; break; case 2: imgPath = imagesToUse.jackpot2_bg; break; case 3: imgPath = imagesToUse.jackpot3_bg; break; case 4: imgPath = imagesToUse.jackpot4_bg; break } else switch (displayPosition) { case MysteryJackpotPosition.BOTTOMRIGHT: imgPath = imagesToUse.jackpot4_bg; break; case MysteryJackpotPosition.BOTTOMLEFT: imgPath = imagesToUse.jackpot3_bg; break; case MysteryJackpotPosition.TOPLEFT: imgPath = imagesToUse.jackpot2_bg; break; case MysteryJackpotPosition.TOPRIGHT: imgPath = imagesToUse.jackpot1_bg; break } return imgPath }; JackpotDisplayUI.prototype.setDisplayPosition = function (displayPosition) { this.m_DisplayPosition = displayPosition }; JackpotDisplayUI.prototype.getDisplayPosition = function () { return this.m_DisplayPosition }; JackpotDisplayUI.prototype.setCurrent = function (b) { this.IsCurrentDisplayingJackpot = b }; function MysterJackpotWinPopup() { this.m_Popup = new PIXI.DisplayObjectContainer; this.m_Popup.w = mysteryjackpot.popup.w; this.m_Popup.h = mysteryjackpot.popup.h; this.m_Popup.x = mysteryjackpot.popup.x; this.m_Popup.y = mysteryjackpot.popup.y; this.m_Popup.visible = false; this.m_PopupBG = new PIXI.Sprite.fromImage(this.getImagePath()); this.m_txtCongr; this.m_txtYouWin; this.m_txtJackpotName; this.m_txtWinValue; this.initCongratulationsTextFieldPixi(); this.initYouWinTextFieldPixi(); this.initJackpotNameTextFieldPixi(); this.initWinValueTextFieldPixi(); var emitterContainer = new PIXI.DisplayObjectContainer; emitterContainer.x = mysteryjackpot.popup.coinshower.x; emitterContainer.y = mysteryjackpot.popup.coinshower.y; emitterContainer.scaleX = 1.7; emitterContainer.scaleY = 1.7; var coinsPool = CoinShowerEmitter.createPool(100, emitterContainer); this.kC = new CoinShowerEmitter(emitterContainer, coinsPool); this.m_Popup.addChild(this.m_PopupBG); this.m_Popup.addChild(this.m_txtCongr); this.m_Popup.addChild(this.m_txtYouWin); this.m_Popup.addChild(this.m_txtJackpotName); this.m_Popup.addChild(this.m_txtWinValue); this.m_Popup.addChild(emitterContainer); sjs.layers.scalelayer.view.addChild(this.m_Popup) } Classify.constr(MysterJackpotWinPopup); MysterJackpotWinPopup.prototype.initCongratulationsTextFieldPixi = function () { this.m_txtCongr = new PNG.Text(Locale.IDS_MSG_CONGRATULATIONS, "mj_old_popup_congr"); this.m_txtCongr.width = mysteryjackpot.popup.text.congr.w; this.m_txtCongr.x = this.m_Popup.w / 2 - this.m_txtCongr.width / 2; this.m_txtCongr.y = mysteryjackpot.popup.text.congr.y }; MysterJackpotWinPopup.prototype.initYouWinTextFieldPixi = function () { this.m_txtYouWin = new PNG.Text(Locale.IDS_YOUWIN, "mj_old_popup_youwin"); this.m_txtYouWin.width = mysteryjackpot.popup.text.youwin.w; this.m_txtYouWin.x = this.m_Popup.w / 2 - this.m_txtYouWin.width / 2; this.m_txtYouWin.y = mysteryjackpot.popup.text.youwin.y }; MysterJackpotWinPopup.prototype.initJackpotNameTextFieldPixi = function () { this.m_txtJackpotName = new PNG.Text("Mega Jackpot", "mj_old_popup_jackpotname"); this.m_txtJackpotName.width = mysteryjackpot.popup.text.jackpotname.w; this.m_txtJackpotName.x = this.m_Popup.w / 2 - this.m_txtJackpotName.width / 2; this.m_txtJackpotName.y = mysteryjackpot.popup.text.jackpotname.y }; MysterJackpotWinPopup.prototype.initWinValueTextFieldPixi = function () { this.m_txtWinValue = new PNG.BitmapText("\u00c2\u00a3 10,000,000.00", { font: mysteryjackpot.popup.text.winvalue.fontsize + "px oswald", align: "center", monospace: { width: 38 } }); this.m_txtWinValue.width = mysteryjackpot.popup.text.winvalue.w; this.m_txtWinValue.x = this.m_Popup.w / 2 - this.m_txtWinValue.width / 2; this.m_txtWinValue.y = mysteryjackpot.popup.text.winvalue.y }; MysterJackpotWinPopup.prototype.setWinValue = function (value) { this.m_txtWinValue.text = value; this.m_txtWinValue.updateText(); this.m_txtWinValue.x = this.m_Popup.w / 2 - this.m_txtWinValue.width / 2 }; MysterJackpotWinPopup.prototype.setJackpotName = function (str) { this.m_txtJackpotName.text = str; this.m_txtJackpotName.updateText(); this.m_txtJackpotName.x = this.m_Popup.w / 2 - this.m_txtJackpotName.width / 2 }; MysterJackpotWinPopup.prototype.Show = function (b) { if (b !== this.m_Popup.visible) { this.m_Popup.visible = true; this.m_Popup.alpha = b ? 0 : 1; Tweener.AddTween({ obj: this.m_Popup, properties: { alpha: b ? 1 : 0 }, onComplete: Utils.delegate(this, function () { this.m_Popup.visible = b }), duration: 250, durationType: Tweener.MS }) } }; MysterJackpotWinPopup.prototype.getImagePath = function (index) { var imagesToUse = { win: image_path_jackpot + "jp_popup_bg.png" }; if (mysteryjackpot.brand_img_path) for (var k in imagesToUse) if (mysteryjackpot.brand_img_path[k] !== undefined) imagesToUse[k] = mysteryjackpot.brand_img_path[k]; return imagesToUse.win }; function JackpotBase(index) { JackpotHandler.RegisterJackpot(this); this.kz = index; this.m_BaseTime = 0; this.m_BaseAmount = 0; this.m_ShortTime = 100; this.m_ShortAmount = 0; this.m_ProjectionTime = 100; this.m_ProjectionAmount = 0; this.m_ElapsedTime = 0; this.m_RecvTime = 0; this.m_CurrentAmount = 0; this.m_JpWinAmount = 0; this.m_SavedRecvTime = 0; this.m_SavedCmd = null } Classify.constr(JackpotBase); JackpotBase.prototype.ResetJackpotWin = function () { this.setJackpotWin(0) }; JackpotBase.prototype.ProcessSavedCmd = function () { if (this.m_SavedCmd != null) JackpotHandler.ReadJackpot(this.m_SavedCmd); this.m_SavedCmd = undefined }; JackpotBase.prototype.setJackpotWin = function (amount) { this.m_JpWinAmount = amount }; JackpotBase.prototype.ReconnectEnd = function () { }; JackpotBase.prototype.Update = function () { }; JackpotBase.prototype.getCurrency = function () { return JackpotHandler.GetCurrency() }; JackpotBase.prototype.getCurrentAmount = function () { return this.m_CurrentAmount }; JackpotBase.prototype.getDemoMode = function () { return JackpotHandler.getDemoMode() }; JackpotDisplay.SHOWAMOUNT = 0; JackpotDisplay.SCROLL = 1; JackpotDisplay.BLINKAMOUNT = 2; JackpotDisplay.SCROLLJP = 3; JackpotDisplay.WAIT = 4; JackpotDisplay.SCROLLWIN = 5; JackpotDisplay.dotSize = 2.2; JackpotDisplay.m_Speed = 2; function JackpotDisplay(index) { this._super(index); this.m_WinMessage = undefined; this.m_DecimalSize = 20; this.m_UI = this.CreateUI(index); this.C = true; this.m_ScrollTicks = 0; this.m_SlowStart = 0; this.m_SlowEnd = 0; this.m_JackpotTimer = 0; this.m_ScrollMessages = []; this.m_ScrollMessage = 0; this.m_ScollSpeed = 800; this.m_JackpotWon = 0; this.m_JackpotMessages = []; this.m_JackpotMessage = 0; this.m_State = JackpotDisplay.SHOWAMOUNT } Classify.constr(JackpotDisplay).ext(JackpotBase); JackpotDisplay.prototype.Show = function (b) { this.m_UI.Show(b) }; JackpotDisplay.prototype.HandleOrientationChange = function (pt) { this.m_UI.HandleOrientationChange(pt) }; JackpotDisplay.prototype.CreateUI = function (index) { var jpName = "Mini Jackpot"; switch (index) { case 1: jpName = Locale.IDS_MJNAME1 || "Minor Jackpot"; break; case 2: jpName = Locale.IDS_MJNAME2 || "Mini Jackpot"; break; case 3: jpName = Locale.IDS_MJNAME3 || "Mega Jackpot"; break; case 4: jpName = Locale.IDS_MJNAME4 || "Grand Jackpot"; break } return new JackpotDisplayUI(index, jpName, sjs.layers.scalelayer) }; JackpotDisplay.prototype.SetColor = function (color) { }; JackpotDisplay.prototype.AddScrollMessage = function (str, color) { }; JackpotDisplay.prototype.setScrollSpeed = function (speed) { this.m_ScollSpeed = speed }; JackpotDisplay.prototype.RemoveScrollMessage = function (str) { }; JackpotDisplay.prototype.AddWinMessage = function (str, color) { }; JackpotDisplay.prototype.AddJackpotMessage = function (str, color) { }; JackpotDisplay.prototype.ReconnectEnd = function () { this.C = false }; JackpotDisplay.prototype.ShowWin = function (amount, hand) { }; JackpotDisplay.prototype.LockJackpotWin = function (amount, wait) { }; JackpotDisplay.prototype.ShowJackpotWin = function (amount) { }; JackpotDisplay.prototype.AnimHandler = function () { }; JackpotDisplay.prototype.NextAnim = function () { var newState; if (this.m_State == JackpotDisplay.SCROLLWIN) newState = JackpotDisplay.WAIT; else if (this.m_State == JackpotDisplay.SCROLLJP || this.m_JackpotMessage > 0) if (this.m_State == JackpotDisplay.BLINKAMOUNT) newState = JackpotDisplay.SCROLLJP; else { if (this.m_State == JackpotDisplay.SCROLLJP) if (this.m_JackpotMessage == 0) { newState = JackpotDisplay.WAIT; this.m_JackpotWon = 0 } else newState = JackpotDisplay.BLINKAMOUNT } else if ((this.m_State == JackpotDisplay.WAIT || this.m_State == JackpotDisplay.SHOWAMOUNT) && this.m_ScrollMessages.length > 0) newState = JackpotDisplay.SCROLL; else if (this.m_State == JackpotDisplay.SCROLL) newState = JackpotDisplay.BLINKAMOUNT; else { if (this.m_JackpotWon > 0) newState = JackpotDisplay.WAIT; else newState = JackpotDisplay.SHOWAMOUNT; this.m_JackpotWon = 0 } switch (newState) { case JackpotDisplay.WAIT: this.m_ScrollMessage = 0; break; case JackpotDisplay.BLINKAMOUNT: if (this.m_State == JackpotDisplay.SCROLL || this.m_State == JackpotDisplay.SCROLLJP); break; case JackpotDisplay.SHOWAMOUNT: if (this.m_State == JackpotDisplay.BLINKAMOUNT || this.m_State == JackpotDisplay.WAIT); if (this.m_State == JackpotDisplay.SCROLL || this.m_State == JackpotDisplay.SCROLLJP); break; case JackpotDisplay.SCROLL: this.InitScroll(this.getCurrentAmount(), this.m_ScrollMessages[this.m_ScrollMessage].color, this.m_ScrollMessages[this.m_ScrollMessage].str); this.m_ScrollMessage++; this.m_ScrollMessage %= this.m_ScrollMessages.length; break; case JackpotDisplay.SCROLLJP: this.InitScroll(this.m_JackpotWon, this.m_JackpotMessages[this.m_JackpotMessage].color, this.m_JackpotMessages[this.m_JackpotMessage].str); this.m_JackpotMessage++; this.m_JackpotMessage %= this.m_JackpotMessages.length; break } this.m_State = newState }; JackpotDisplay.prototype.InitScroll = function (amount, color, message) { }; JackpotDisplay.prototype.PaintText = function () { var s = ""; switch (m_State) { case JackpotDisplay.BLINKAMOUNT: case JackpotDisplay.SHOWAMOUNT: var align = undefined; if (this.getDemoMode()) s = "DEMO MODE"; else { if (m_JackpotWon > 0); else; var dotIndex = s.lastIndexOf("."); if (dotIndex < 0) s += ".00"; else { var size = dotIndex + 3; if (size > s.length) s += "00".substr(0, size - s.length); else if (size < s.length) s = s.substr(0, size) } } break; case JackpotDisplay.SCROLL: break } }; JackpotDisplay.prototype.Update = function () { this.AnimHandler(); this.PaintText() }; JackpotDisplay.prototype.setDecimalSize = function (decimalSize) { this.m_DecimalSize = decimalSize }; function MysteryJackpotDisplay(index, name, settings, position) { this.m_Name = name || this.findProperName(index); this.cJ = false; this.bG = settings; this.m_DisplayPosition = position || "topleft"; this._super(index) } Classify.constr(MysteryJackpotDisplay).ext(JackpotDisplay); MysteryJackpotDisplay.override("CreateUI", function (index) { return new JackpotDisplayUI(index, this.m_Name, sjs.layers.mystery, this.bG, this.m_DisplayPosition) }); MysteryJackpotDisplay.prototype.findProperName = function (index) { var name = Locale["IDS_MJNAME" + index]; name = name || mysteryjackpot.text.names[index]; return name }; MysteryJackpotDisplay.prototype.StopBlinking = function () { this.m_JackpotTimer = 0 }; MysteryJackpotDisplay.prototype.setActive = function (b) { this.cJ = b }; MysteryJackpotDisplay.prototype.getActive = function () { return this.cJ }; MysteryJackpotDisplay.prototype.setName = function (newName) { this.m_UI.setName(newName) }; MysteryJackpotDisplay.prototype.setTotalBet = function (v) { this.m_UI.setTotalBet(v) }; MysteryJackpotDisplay.prototype.onBetChange = function (newbet) { this.m_UI.onBetChange(newbet) }; MysteryJackpotDisplay.prototype.setGambleMode = function (b) { if (this.getActive()) this.m_UI.setGambleMode(b) }; MysteryJackpotDisplay.override("Show", function (b) { if (this.m_UI.m_GambleMode && mysteryjackpot.layout == "bottom") return; if (this.getActive()) this.m_UI.Show(b); else this.m_UI.Show(false) }); MysteryJackpotDisplay.prototype.setJackpotValue = function (value) { }; MysteryJackpotDisplay.override("PaintText", function () { var str; switch (this.m_State) { case JackpotDisplay.BLINKAMOUNT: break; case JackpotDisplay.SHOWAMOUNT: if (this.getDemoMode()) { str = "DEMO MODE"; this.m_UI.setValue(str) } else { if (this.m_JackpotWon > 0) str = Utils.DenominationString(this.m_JackpotWon, this.getCurrency(), THOUSAND_SEPARATED); else str = Utils.DenominationString(this.getCurrentAmount(), this.getCurrency(), THOUSAND_SEPARATED); this.m_UI.setValue(str) } break; case JackpotDisplay.SCROLL: break } }); MysteryJackpotDisplay.prototype.setDisplayPosition = function (displayPosition) { this.m_DisplayPosition = displayPosition; this.m_UI.setDisplayPosition(this.m_DisplayPosition) }; MysteryJackpotDisplay.prototype.getDisplayPosition = function () { return this.m_DisplayPosition }; MysteryJackpotDisplay.prototype.getID = function () { return this.kz }; MysteryJackpotDisplay.prototype.setCurrent = function (b) { this.m_UI.IsCurrentDisplayingJackpot = b }; MysteryJackpotPosition.TOPLEFT = "topleft"; MysteryJackpotPosition.TOPRIGHT = "topright"; MysteryJackpotPosition.BOTTOMLEFT = "bottomleft"; MysteryJackpotPosition.BOTTOMRIGHT = "bottomright"; MysteryJackpotPosition.STATE_IDLE = 0; MysteryJackpotPosition.STATE_REVOLVING = 1; function MysteryJackpotPosition(displayPosition) { this.m_DisplayPosition = displayPosition || MysteryJackpotPosition.TOPLEFT; this.m_DisplayDuration = 4E3; this.m_CurrentJackpotIndex = 0; this.m_Jackpots = []; this.m_DisplayTimer = 0; this.m_State = MysteryJackpotPosition.STATE_IDLE } MysteryJackpotPosition.prototype.tick = function () { switch (this.m_State) { case MysteryJackpotPosition.STATE_REVOLVING: if (getTimer() > this.m_DisplayTimer) { this.updateTimer(); this.showNextJackpot() } break } }; MysteryJackpotPosition.prototype.updateTimer = function () { this.m_DisplayTimer = getTimer() + this.m_DisplayDuration }; MysteryJackpotPosition.prototype.showNextJackpot = function () { this.hideJackpotIndex(this.m_CurrentJackpotIndex); this.m_CurrentJackpotIndex++; if (this.m_CurrentJackpotIndex >= this.m_Jackpots.length) this.m_CurrentJackpotIndex = 0; this.showJackpotIndex(this.m_CurrentJackpotIndex) }; MysteryJackpotPosition.prototype.updateVisibility = function () { for (var ind in this.m_Jackpots) this.m_Jackpots[ind].Show(ind == this.m_CurrentJackpotIndex) }; MysteryJackpotPosition.prototype.showJackpotIndex = function (index) { if (index >= this.m_Jackpots.length) return; this.m_Jackpots[index].Show(true); this.m_Jackpots[index].setCurrent(true) }; MysteryJackpotPosition.prototype.hideJackpotIndex = function (index) { if (index >= this.m_Jackpots.length) return; this.m_Jackpots[index].Show(false); this.m_Jackpots[index].setCurrent(false) }; MysteryJackpotPosition.prototype.showJackpot = function (jackpot) { this.hideJackpotIndex(this.m_CurrentJackpotIndex); this.m_CurrentJackpotIndex = this.m_Jackpots.indexOf(jackpot); if (this.m_CurrentJackpotIndex == -1) this.m_CurrentJackpotIndex = 0; this.showJackpotIndex(this.m_CurrentJackpotIndex) }; MysteryJackpotPosition.prototype.addJackpot = function (jackpot) { this.m_Jackpots.push(jackpot); if (this.m_Jackpots.length == 1) this.showJackpotIndex(0); else jackpot.Show(false) }; MysteryJackpotPosition.prototype.removeJackpot = function (jackpot) { var index = this.m_Jackpots.indexOf(jackpot); if (index > -1) this.m_Jackpots.splice(index, 1) }; MysteryJackpotPosition.prototype.startRevolving = function () { if (this.m_Jackpots.length <= 1) this.m_State = MysteryJackpotPosition.STATE_IDLE; else { this.m_State = MysteryJackpotPosition.STATE_REVOLVING; this.updateTimer() } }; MysteryJackpotPosition.prototype.stopRevolving = function () { this.m_State = MysteryJackpotPosition.STATE_IDLE }; function SetJackpotDisplaySizes(value) { mysteryjackpot_old.bg = value; mysteryjackpot.bg = value; var widthSmall, widthLarge, heightSmall, heightLarge; if (value == "gs") { widthSmall = mysteryjackpot_old.img_size.gs_small.w; widthLarge = mysteryjackpot_old.img_size.gs_large.w; heightSmall = mysteryjackpot_old.img_size.gs_small.h; heightLarge = mysteryjackpot_old.img_size.gs_large.h } else { widthSmall = mysteryjackpot_old.img_size.vs_small.w; widthLarge = mysteryjackpot_old.img_size.vs_large.w; heightSmall = mysteryjackpot_old.img_size.vs_small.h; heightLarge = mysteryjackpot_old.img_size.vs_large.h } mysteryjackpot_old.container.ls.topleft.w = widthLarge; mysteryjackpot_old.container.ls.topleft.h = heightLarge; mysteryjackpot_old.container.ls.topright.w = widthLarge; mysteryjackpot_old.container.ls.topright.h = heightLarge; mysteryjackpot_old.container.ls.bottomleft.w = widthSmall; mysteryjackpot_old.container.ls.bottomleft.h = heightSmall; mysteryjackpot_old.container.ls.bottomright.w = widthSmall; mysteryjackpot_old.container.ls.bottomright.h = heightSmall; for (var key in mysteryjackpot_old.container.pt) { mysteryjackpot_old.container.pt[key].topleft.w = widthLarge; mysteryjackpot_old.container.pt[key].topleft.h = heightLarge; mysteryjackpot_old.container.pt[key].topright.w = widthLarge; mysteryjackpot_old.container.pt[key].topright.h = heightLarge; mysteryjackpot_old.container.pt[key].bottomleft.w = widthSmall; mysteryjackpot_old.container.pt[key].bottomleft.h = heightSmall; mysteryjackpot_old.container.pt[key].bottomright.w = widthSmall; mysteryjackpot_old.container.pt[key].bottomright.h = heightSmall } }; JackpotHandler = {}; JackpotHandler.m_Jackpots = []; JackpotHandler.cW = ""; JackpotHandler.m_ForFun = false; JackpotHandler.m_PostponeReadProjDataCmd = false; JackpotHandler.ProcessCustomData = function (cmd) { var cmdString = cmd.GetXML(0); var i = 0; var customNode = undefined; for (i = 0; i < cmdString.childNodes.length; i++) if (cmdString.childNodes[i].nodeName === "custom") { customNode = cmdString.childNodes[i]; break } var mjNode = undefined; if (customNode !== undefined) for (i = 0; i < customNode.childNodes.length; i++) if (customNode.childNodes[i].nodeName === "MysteryJackpot") { mjNode = customNode.childNodes[i]; break } var jpNodes = []; if (mjNode !== undefined) for (i = 0; i < mjNode.childNodes.length; i++) if (mjNode.childNodes[i].nodeName === "Jackpot") jpNodes.push(mjNode.childNodes[i]); for (i = 0; i < JackpotHandler.m_Jackpots.length; i++) JackpotHandler.m_Jackpots[i].Show(false); var jackpots = []; for (i = 0; i < jpNodes.length; i++) { var jpID = jpNodes[i].getAttribute("Value"); var jpName = jpNodes[i].getAttribute("Name"); var jpTotalBet = jpNodes[i].getAttribute("TotalBet"); var jpDisplayPosition = jpNodes[i].getAttribute("Position"); var jackpot = { id: jpID, name: jpName, displayPosition: jpDisplayPosition, totalBet: jpTotalBet }; jackpots.push(jackpot) } return jackpots }; JackpotHandler.HandleOrientationChange = function (pt) { for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) JackpotHandler.m_Jackpots[i].HandleOrientationChange(pt) }; JackpotHandler.RegisterJackpot = function (jackpot) { JackpotHandler.m_Jackpots.push(jackpot) }; JackpotHandler.SetCurrency = function (currency) { JackpotHandler.cW = currency }; JackpotHandler.GetCurrency = function () { return JackpotHandler.cW }; JackpotHandler.setDemoMode = function (forFun) { JackpotHandler.m_ForFun = forFun }; JackpotHandler.getDemoMode = function () { return JackpotHandler.m_ForFun }; JackpotHandler.setPostponeReadCmd = function (b) { JackpotHandler.m_PostponeReadProjDataCmd = b }; JackpotHandler.getPostponeReadCmd = function () { return JackpotHandler.m_PostponeReadProjDataCmd }; JackpotHandler.SaveCmd = function (id, cmd) { for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) if (JackpotHandler.m_Jackpots[i].kz == id) { var jp = JackpotHandler.m_Jackpots[i]; jp.m_SavedCmd = cmd; jp.m_SavedRecvTime = getTimer() / 1E3 } }; JackpotHandler.ReadJackpot = function (cmd) { if (cmd == undefined) return; var id = cmd.GetInt(0); if (JackpotHandler.getPostponeReadCmd()) { JackpotHandler.SaveCmd(id, cmd); return } for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) if (JackpotHandler.m_Jackpots[i].kz == id) { var jp = JackpotHandler.m_Jackpots[i]; if (jp.m_BaseTime != cmd.GetInt(2)) { jp.m_BaseTime = cmd.GetInt(2); jp.m_ShortAmount = cmd.GetMoney(3); jp.m_ShortTime = cmd.GetInt(4) * 60; jp.m_ProjectionAmount = cmd.GetMoney(5); jp.m_ProjectionTime = cmd.GetInt(6) * 60; jp.m_ElapsedTime = cmd.GetInt(7); if (jp.m_SavedRecvTime != 0) jp.m_RecvTime = jp.m_SavedRecvTime; else jp.m_RecvTime = getTimer() / 1E3; jp.m_SavedRecvTime = 0; if (jp.m_CurrentAmount == 0 || jp.m_CurrentAmount > jp.m_ShortAmount || jp.m_CurrentAmount > jp.m_ProjectionAmount) jp.m_BaseAmount = cmd.GetMoney(1); else { var delta = (jp.m_ShortAmount - jp.m_CurrentAmount) / (jp.m_ShortTime - jp.m_ElapsedTime); jp.m_BaseAmount = jp.m_CurrentAmount - delta * jp.m_ElapsedTime } } } }; JackpotHandler.tick = function (time) { time = getTimer() / 1E3; for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) { var o = JackpotHandler.m_Jackpots[i]; var start = o.m_ElapsedTime + (time - o.m_RecvTime); var currentAmount = 0; var alpha = start / o.m_ShortTime; alpha = Math.floor(alpha * 1E3) / 1E3; if (alpha < 0) alpha = 0; if (alpha > 1) { start = o.m_ElapsedTime + (time - o.m_RecvTime) - o.m_ShortTime; alpha = start / (o.m_ProjectionTime - o.m_ShortTime); alpha = Math.floor(alpha * 1E3) / 1E3; if (alpha < 0) alpha = 0; if (alpha > 1) alpha = 1; currentAmount = Math.round(Utils.Lerp(o.m_ShortAmount, o.m_ProjectionAmount, alpha)) } else currentAmount = Math.round(Utils.Lerp(o.m_BaseAmount, o.m_ShortAmount, alpha)); if (o.m_JpWinAmount > 0 && currentAmount > o.m_JpWinAmount) o.m_CurrentAmount = o.m_JpWinAmount; else o.m_CurrentAmount = currentAmount; o.Update() } }; JackpotHandler.GetAmount = function (id) { for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) if (JackpotHandler.m_Jackpots[i].kz == id) return JackpotHandler.m_Jackpots[i].m_CurrentAmount; return 0 }; JackpotHandler.Find = function (id) { for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) if (JackpotHandler.m_Jackpots[i].kz == id) return JackpotHandler.m_Jackpots[i]; return undefined }; JackpotHandler.ReconnectEnd = function () { for (var i = 0; i < JackpotHandler.m_Jackpots.length; i++) JackpotHandler.m_Jackpots[i].ReconnectEnd() }; MysteryJackpotFeature.ANIMSTATE_STARTFIREWORKS = 1; MysteryJackpotFeature.ANIMSTATE_STOPFIREWORKS = 2; MysteryJackpotFeature.ANIMSTATE_SHOWPANEL = 3; MysteryJackpotFeature.ANIMSTATE_STARTCOINS = 4; MysteryJackpotFeature.ANIMSTATE_STOPCOINS = 5; MysteryJackpotFeature.ANIMSTATE_COLLECT = 6; MysteryJackpotFeature.Active = false; function MysteryJackpotFeature(callback, settings) { this._super(callback); getMysteryJackpotSounds(); this.m_Panel; this.m_Displays; this.m_ParticleOverlay; this.m_AnimState = undefined; this.bZ = undefined; this.bG = settings; this.aP = true; var m = new sjs.Layer("mystery", undefined, sjs.layers.scalelayer, undefined, mysteryjackpot.layer.stacked); m.Origin("center", "bottom"); m.Scale(1.1, 1.1); this.m_JackpotPositions = { topleft: new MysteryJackpotPosition(MysteryJackpotPosition.TOPLEFT), topright: new MysteryJackpotPosition(MysteryJackpotPosition.TOPRIGHT), bottomleft: new MysteryJackpotPosition(MysteryJackpotPosition.BOTTOMLEFT), bottomright: new MysteryJackpotPosition(MysteryJackpotPosition.BOTTOMRIGHT) }; JackpotDisplay.m_Speed = 4; JackpotDisplay.dotSize = 1; this.m_JackpotDisplays = []; this.m_Popup = new MysterJackpotWinPopup; this.m_UseCoinSound = typeof SoundManager != "undefined" && SoundManager !== undefined && Snd !== undefined && SoundManager.GetSoundDefinition("winCoinTick") !== undefined; if (this.m_UseCoinSound) this.m_CoinsSnd = new Snd("winCoinTick"); this.aW = this; if (sjs.isPixi) { this.m_ParticleOverlay = new PIXI.DisplayObjectContainer; this.m_ParticleOverlay.w = mysteryjackpot.popup.w; this.m_ParticleOverlay.h = mysteryjackpot.popup.h; this.m_ParticleOverlay.x = mysteryjackpot.popup.x + this.m_Popup.m_Popup.width / 2; this.m_ParticleOverlay.y = mysteryjackpot.popup.y + 400; this.m_ParticleOverlay.scaleX = 1.8; this.m_ParticleOverlay.scaleY = 1.8; sjs.layers.scalelayer.view.addChild(this.m_ParticleOverlay); var fireworksRocketPool = MJFireworks.createRocketPool(3, this.m_ParticleOverlay); var fireworksParticlePool = MJFireworks.createParticlePool(20, this.m_ParticleOverlay); var fireworksParticleDustPool = MJFireworks.createParticleDustPool(100, this.m_ParticleOverlay); this.m_FireworksEmitter = new MJFireworks(this.m_ParticleOverlay, fireworksRocketPool, fireworksParticlePool, fireworksParticleDustPool, undefined) } else { this.m_Popup = new MysterJackpotWinPopup; new sjs.Layer("mysteryanimations", undefined, sjs.layers["scalelayer"], undefined, mysteryjackpot.jackpotpos_old.layer_jackpot); new sjs.Layer("particles", undefined, sjs.layers["mysteryanimations"], undefined, mysteryjackpot.jackpotpos_old.layer_particles); sjs.layers.mysteryanimations.Show(false); this.m_Popup.InitCoinShower(); var fireworksRocketPool = Fireworks.CreateRocketPool(10, sjs.layers["particles"]); this.m_FireworksEmitter = new Fireworks({ x: 0, y: 0 }, fireworksRocketPool, "fireworksParticlePool", "fireworksParticleDustPool", "fireworksSndEffects") } } Classify.constr(MysteryJackpotFeature).ext(Feature); MysteryJackpotFeature.prototype.onBetChange = function (newbet) { for (var i = 0; i < this.m_JackpotDisplays.length; i++) this.m_JackpotDisplays[i].onBetChange(newbet) }; MysteryJackpotFeature.prototype.Show = function (b) { this.aP = b; sjs.layers.mystery.Show(b); if (b) for (var key in this.m_JackpotPositions) this.m_JackpotPositions[key].updateVisibility(); else for (var i = 0; i < this.m_JackpotDisplays.length; i++) this.m_JackpotDisplays[i].Show(false) }; MysteryJackpotFeature.prototype.setGambleMode = function (b) { for (var i = 0; i < this.m_JackpotDisplays.length; i++) this.m_JackpotDisplays[i].setGambleMode(b) }; MysteryJackpotFeature.override("FeatureProcessed", function () { this.SetAcceptInput(false) }); MysteryJackpotFeature.override("Process", function () { if (this._super()) return true; if (!this.CanProcess()) return false; switch (this.State()) { case Feature.FEATURE_IDLE: this.m_AnimState = MysteryJackpotFeature.ANIMSTATE_STARTFIREWORKS; this.bZ = getTimer() + 100; this.ChangeState(Feature.FEATURE_STARTED); var jackpotID = this.GetAward(0).Value(); var display = this.FindJackpotWithId(jackpotID); display.LockJackpotWin(this.GetAward(0).Amount()); break; case Feature.FEATURE_STARTED: if (this.bZ > 0 && (getTimer() > this.bZ || this.C)) { this.bZ = 0; this.NextAnim() } break; case Feature.FEATURE_RUNNING: if (this.bZ > 0 && (getTimer() > this.bZ || this.C && this.m_AnimState != MysteryJackpotFeature.ANIMSTATE_COLLECT)) { this.bZ = 0; this.NextAnim() } break } this.m_Popup.kC.Tick(); this.m_FireworksEmitter.Tick(); return this.State() === Feature.FEATURE_COLLECTED }); MysteryJackpotFeature.prototype.HandleOrientationChange = function () { if (this.m_FireworksEmitter.HandleOrientationChange) this.m_FireworksEmitter.HandleOrientationChange(); this.UpdateJackpotPositions(); this.UpdateJackpotPopup() }; MysteryJackpotFeature.prototype.UpdateJackpotPositions = function () { for (var key in this.m_JackpotPositions) this.m_JackpotPositions[key] = new MysteryJackpotPosition(this.m_JackpotPositions[key].m_DisplayPosition); for (var key in this.m_JackpotDisplays) if (mysteryjackpot_old.layout == "single_4" || mysteryjackpot.layout == "single_4") this.m_JackpotPositions[MysteryJackpotPosition.TOPLEFT].addJackpot(this.m_JackpotDisplays[key]); else if (mysteryjackpot_old.layout == "top_2" || mysteryjackpot.layout == "top_2") if (this.m_JackpotDisplays[key].m_DisplayPosition == MysteryJackpotPosition.TOPLEFT || this.m_JackpotDisplays[key].m_DisplayPosition == MysteryJackpotPosition.BOTTOMLEFT) this.m_JackpotPositions[MysteryJackpotPosition.TOPLEFT].addJackpot(this.m_JackpotDisplays[key]); else this.m_JackpotPositions[MysteryJackpotPosition.TOPRIGHT].addJackpot(this.m_JackpotDisplays[key]); else this.m_JackpotPositions[this.m_JackpotDisplays[key].m_DisplayPosition].addJackpot(this.m_JackpotDisplays[key]); for (var key in this.m_JackpotPositions) this.m_JackpotPositions[key].startRevolving() }; MysteryJackpotFeature.prototype.UpdateJackpotPopup = function () { if (sjs.isPixi) { this.m_Popup.m_Popup.x = mysteryjackpot.popup.x; this.m_ParticleOverlay.x = mysteryjackpot.popup.x + this.m_Popup.m_Popup.width / 2 } else { this.m_Popup.m_Popup.setBounds({ x: mysteryjackpot_old.popup.x }); sjs.layers.mysteryanimations.setBounds({ x: mysteryjackpot.jackpotpos_old.layer_jackpot.x }) } }; MysteryJackpotFeature.prototype.NextAnim = function () { switch (this.m_AnimState) { case MysteryJackpotFeature.ANIMSTATE_STARTFIREWORKS: if (!sjs.isPixi) sjs.layers.mysteryanimations.Show(true); else this.m_ParticleOverlay.visible = true; if (!this.C) this.m_FireworksEmitter.start(); this.m_AnimState = MysteryJackpotFeature.ANIMSTATE_SHOWPANEL; this.bZ = getTimer() + 0; break; case MysteryJackpotFeature.ANIMSTATE_STOPFIREWORKS: this.m_FireworksEmitter.stop(); this.m_AnimState = MysteryJackpotFeature.ANIMSTATE_SHOWPANEL; this.bZ = getTimer() + 500; break; case MysteryJackpotFeature.ANIMSTATE_SHOWPANEL: var jackpotID = this.GetAward(0).Value(); var display = this.FindJackpotWithId(jackpotID); var jackpotPosition = this.m_JackpotPositions[display.getDisplayPosition()]; jackpotPosition.stopRevolving(); jackpotPosition.showJackpot(display); SoundPlayer.Play(mysteryjackpot.winSounds[display.getID()]); this.m_Popup.Show(true); this.m_Popup.setJackpotName(display.m_Name); this.m_Popup.setWinValue(JackpotHandler.getDemoMode() ? "DEMO MODE" : Utils.DenominationString(this.GetAward(0).Amount(), JackpotHandler.GetCurrency(), THOUSAND_SEPARATED)); this.ChangeState(Feature.FEATURE_RUNNING); this.m_AnimState = MysteryJackpotFeature.ANIMSTATE_STARTCOINS; this.bZ = getTimer() + 400; display.ShowJackpotWin(); break; case MysteryJackpotFeature.ANIMSTATE_STARTCOINS: this.m_Popup.kC.setParameter("density", 5 - this.GetAward(0).Value()); if (!this.C) this.m_Popup.kC.start(); if (this.m_UseCoinSound) this.m_CoinsSnd.PlayForever(0.5); this.m_AnimState = MysteryJackpotFeature.ANIMSTATE_STOPCOINS; this.bZ = getTimer() + 8E3 + (this.GetAward(0).Value() - 1) * 4E3; break; case MysteryJackpotFeature.ANIMSTATE_STOPCOINS: this.m_FireworksEmitter.stop(); this.m_Popup.kC.stop(); if (this.m_UseCoinSound) this.m_CoinsSnd.FadeOut(0.25); this.m_AnimState = MysteryJackpotFeature.ANIMSTATE_COLLECT; this.bZ = getTimer() + 3E3; break; case MysteryJackpotFeature.ANIMSTATE_COLLECT: this.m_Popup.Show(false); this.ChangeState(Feature.FEATURE_COLLECTED); if (!sjs.isPixi) sjs.layers.mysteryanimations.Show(false); else this.m_ParticleOverlay.visible = false; for (var k in this.m_JackpotPositions) this.m_JackpotPositions[k].startRevolving(); break } }; MysteryJackpotFeature.prototype.createJackpot = function (jackpotData) { var jackpot = new MysteryJackpotDisplay(jackpotData.id, jackpotData.name, this.bG, jackpotData.displayPosition); jackpot.setTotalBet(jackpotData.totalbet); jackpot.setActive(true); this.m_JackpotDisplays.push(jackpot); this.m_JackpotPositions[jackpotData.displayPosition].addJackpot(jackpot) }; MysteryJackpotFeature.prototype.createJackpots = function (jackpots) { if (mysteryjackpot.brand_img_path) this.rearrangeBrandedJackpots(jackpots); for (var i = 0; i < jackpots.length; i++) this.createJackpot(jackpots[i]); for (var k in this.m_JackpotPositions) this.m_JackpotPositions[k].startRevolving() }; MysteryJackpotFeature.prototype.rearrangeBrandedJackpots = function (jackpots) { var positions = {}; positions[MysteryJackpotPosition.TOPLEFT] = []; positions[MysteryJackpotPosition.TOPRIGHT] = []; positions[MysteryJackpotPosition.BOTTOMLEFT] = []; positions[MysteryJackpotPosition.BOTTOMRIGHT] = []; for (var i = 0; i < jackpots.length; i++) { var desiredPosition = jackpots[i].displayPosition; if (jackpots[i].id == 3 || jackpots[i].id == 4) { if (desiredPosition == MysteryJackpotPosition.BOTTOMLEFT) desiredPosition = MysteryJackpotPosition.TOPLEFT; if (desiredPosition == MysteryJackpotPosition.BOTTOMRIGHT) desiredPosition = MysteryJackpotPosition.TOPRIGHT; positions[desiredPosition].unshift(jackpots[i]) } else positions[desiredPosition].push(jackpots[i]) } for (var currentPos in positions) this.moveJackpotIfNeeded(positions, currentPos, 0); for (var pos in positions) for (var i = 0; i < positions[pos].length; i++) positions[pos][i].displayPosition = pos }; MysteryJackpotFeature.prototype.moveJackpotIfNeeded = function (positions, currentPos, depth) { while (positions[currentPos].length > 1) { var popped = positions[currentPos].pop(); var highBackground = popped.id == 3 || popped.id == 4; var availablePositions = []; if (highBackground) availablePositions = [MysteryJackpotPosition.TOPLEFT, MysteryJackpotPosition.TOPRIGHT]; else availablePositions = [MysteryJackpotPosition.TOPLEFT, MysteryJackpotPosition.TOPRIGHT, MysteryJackpotPosition.BOTTOMLEFT, MysteryJackpotPosition.BOTTOMRIGHT]; var minLength = Infinity; var minLengthPos = ""; for (var i = 0; i < availablePositions.length; i++) if (availablePositions[i] != currentPos && positions[availablePositions[i]].length < minLength) { minLength = positions[availablePositions[i]].length; minLengthPos = availablePositions[i] } if (minLengthPos == "") { positions[currentPos].push(popped); break } else { if (highBackground) positions[minLengthPos].unshift(popped); else positions[minLengthPos].push(popped); if (minLength > 0 && depth < 4) this.moveJackpotIfNeeded(positions, minLengthPos, depth + 1) } } }; MysteryJackpotFeature.prototype.Tick = function () { for (var k in this.m_JackpotPositions) this.m_JackpotPositions[k].tick() }; MysteryJackpotFeature.prototype.FindJackpotWithId = function (id) { for (var i = 0; i < this.m_JackpotDisplays.length; i++) if (this.m_JackpotDisplays[i].getID() == id) return this.m_JackpotDisplays[i]; return undefined }; game_name = "superflipmobile"; customized_popup = false; frame_rate = 80; tick_time = 70; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//ajax.googleapis.com/ajax/libs/webfont/1.5.10/webfont.js"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(js, s); WebFontConfig = { google: { families: ["Oswald:300"] } }; var N_ZERO = 0, N_ONE = 1, N_TWO = 2, N_THREE = 3, N_FOUR = 4, N_FIVE = 5, N_SIX = 6, N_SEVEN = 7, N_EIGHT = 8, N_NINE = 9, N_TEN = 10, N_ELEVEN = 11, N_TWELVE = 12, N_THIRTEEN = 13, N_FOURTEEN = 14, N_FIFTEEN = 15, N_SIXTEEN = 16, N_SEVENTEEN = 17, N_EIGHTEEN = 18, N_NINETEEN = 19, N_TWENTY = 20, N_POINTFIVE = 0.5; function setValues() { setMainValues(); setVSValues(); if (DEVICE.orientation === "pt") { var bgr_gamepanel_pos = 1E3, bgr_top = bgr_gamepanel_pos - game_panel_layer_pos.pt.y / scale_layer_pos.pt.scale, adj = gamepanel_pos.game_panel_layer_pos.pt.scale.y * gamepanel_pos.game_panel_layer_pos.pt.h; adj = adj - gamepanel_pos.game_panel_layer_pos.pt.h; if (bgr_top + adj < -45) { mysteryjackpot.layer.stacked.y = 140 + (bgr_top + adj) / 2 * 1; mysteryjackpot.layout = "stacked" } else if (bgr_top + adj < 70) { mysteryjackpot.layer.bottom.y = 200 + (bgr_top + adj) / 2 * 1; mysteryjackpot.layout = "lstop" } else if (bgr_top + adj > 70) mysteryjackpot.layout = "bottom"; scale_layer_pos.pt.y = gamepanel_pos.game_panel_layer_pos.pt.y - 1150; DEVICE.pt.set = false } else { var bgr_gamepanel_pos = 930, bgr_top = bgr_gamepanel_pos - game_panel_layer_pos.ls.y / scale_layer_pos.ls.scale, logoheight = game_bgr_pos.logo.layer.ls.y + game_bgr_pos.logo.layer.ls.h - bgr_top, logoscale = logoheight / game_bgr_pos.logo.layer.ls.h; if (logoscale < 0.25) logoscale = 0.25; else if (logoscale > 0.75) logoscale = 0.75; game_bgr_pos.logo.layer.ls.scale = logoscale; var adj = gamepanel_pos.game_panel_layer_pos.ls.scale.y * gamepanel_pos.game_panel_layer_pos.ls.h; adj = adj - gamepanel_pos.game_panel_layer_pos.ls.h; adj = 420 + (bgr_top + adj - 420) / 2 * 1; if (adj > 400) mysteryjackpot.layer.ls.y = adj; mysteryjackpot.layout = "landscape" } if (BrandHandler.BRANDHANDLER !== undefined) BrandHandler.BRANDHANDLER.GamePanelOnTop() } function setSoundPathAndTimes(resourceroot) { stime_ticker_delay = [2200, 2200, 3100, 4100, 5200, 6100] }; symbol_map = [[2, 7], [0, 6], [0, 7], [0, 5], [0, 4], [0, 6], [0, 0], [0, 1], [0, 2], [0, 3], [2, 3], [4, 3], [6, 3], [8, 3], [10, 3]]; symbol_cycle = [[0, 0, 2], [0, 120, 2], [0, 240, 2], [0, 360, 2], [0, 480, 2], [0, 600, 2]]; symbol_cycles = []; startF = 0; for (var sym = 0; sym < 17; sym++) { symbol_cycles.push([]); var tmpYOff = symbol_size.h * sym, speed = 2, tmpArray, i, j; switch (sym) { case 0: case 1: case 2: tmpArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 3: case 4: case 5: case 6: case 7: case 8: tmpYOff = symbol_size.h * 3; speed = 4; for (i = 0; i < 3; i++) { symbol_cycles[sym].push([symbol_size.w * startF, tmpYOff, speed]); symbol_cycles[sym].push([symbol_size.w * (startF + 1), tmpYOff, speed]) } symbol_cycles[sym].push([symbol_size.w * startF, tmpYOff, speed]); startF += 2; break; case 9: tmpYOff = symbol_size.h * 4; tmpArray = [0]; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * i, tmpYOff, 2]); break; case 10: tmpArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; tmpYOff = symbol_size.h * 5; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 11: tmpArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; tmpYOff = symbol_size.h * 6; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 12: tmpArray = [10, 11]; tmpYOff = symbol_size.h * 7; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 13: tmpArray = [0]; tmpYOff = symbol_size.h * 5; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 14: tmpArray = [11]; tmpYOff = symbol_size.h * 6; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 15: tmpArray = [1, 2, 1, 0, 3]; tmpYOff = symbol_size.h * 4; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break; case 16: tmpArray = [3, 4, 5, 6, 7, 8, 9, 10, 11]; tmpYOff = symbol_size.h * 4; for (i = 0, j = tmpArray.length; i < j; i++) symbol_cycles[sym].push([symbol_size.w * tmpArray[i], tmpYOff, speed]); break } } win_counter_duration = [[1, 500], [25, 1E3], [50, 1250], [100, 2E3], [250, 3E3], [500, 5E3]]; VALUES.TOPFILL = 600; portraitlayout = { gamepanelmargin: 192, logomargin: 130, basewidth: 800, reelheight: 450 }; quickstop_hitarea = { w: 4E3, h: 4E3 }; scatter_frame_pos = { x: symbol_startpos.x, y: -240, w: 150, h: 150 }; scatter_frame_yoffset = 0; scatter_frame_gap = { w: 160, h: 120 }; scatter_frame_adjust = { x: 0, y: 150 }; scatter_frame_modifier = 0; winline = { award: { pos: { x: 170, y: 44 }, offset: { x: -96, y: 40 }, fontsize: 70, font: "Impact", align: "center" }, scale: { init: 1, offsetx: -79, offsety: -86, x: 0.79 * 1, y: 0.73 * 1 } }; reels_layer_pos = { x: 234, y: 465, w: 795, h: 460, scale: 1 * 1 }; game_bgr_pos = { layer: { pt: { x: 0, y: 0, scale: 1 * 1 }, ls: { x: 0, y: 0, scale: 1 * 1 } }, reel_bg: { x: 0, y: 0, w: 1260, h: 1180 }, reel_base_bottom: { x: 0, y: 600, w: 1040, h: 260 }, reel_base: { x: 58, y: 100, w: 924, h: 533 }, pt: { x: 0, y: 0, w: 1260, h: 1180, scale: 1 * 1 }, ls: { x: 0, y: 0, w: 1260, h: 1180, scale: 1 * 1 }, overlay: { layer: { x: 0, y: 0 }, top: { x: 0, y: 0, w: 1260, h: 1180, xoffset: 0, yoffset: 0 }, bottom: { x: 0, y: 446, w: 794, h: 36, xoffset: 0, yoffset: 36 }, payboxes: { x: 0, y: 0, w: 1260, h: 1180 } }, logo: { layer: { pt: { x: 368, y: 318, mystery_y: 350, w: 520, h: 118, scale: 1 * 1 }, ls: { x: 370, y: 360, w: 520, h: 118, scale: 1 * 1 } } } }; drawing_paylines = { draw: { thickness: 7, shadowthickness: 10, shadowoffsetx: 0, shadowoffsety: 10, arcwidth: 10, gradient: { x0: 0, y0: 0, x1: 830, y1: 0 } } }; freespin = { layer: { x: 0, y: 0, w: 1260, h: 1180 }, popup: { x: reels_layer_pos.x + reels_layer_pos.w / 2 * 1, y: reels_layer_pos.y + reels_layer_pos.h / 2 * 1, w: 0, h: 0 }, hud: { layer: { x: reels_layer_pos.x + reels_layer_pos.w / 2 * 1, y: reels_layer_pos.y - 30, w: reels_layer_pos.w, h: 64 }, line: { x: -632, y: -64, w: 1264, h: 128, offset: { x: 0, y: 304 }, scale: 0.5 * 1 }, text: { x: -175, y: -64, w: 350, h: 128 }, rays: { x: -200, y: 44, w: 400, h: 400 } }, respiny: 250 }; paytable_toucharea = { x: -200, y: 30, w: 2400, h: 2400 }; paytable_pt_hp_translate_x = -50; paytable_pt_lp_translate_x = -130; splashscreen_pos = { bgimg: { x: 0, y: 0, w: 1260, h: 1180 }, layers: { bgrlayer: { x: 0, y: 0, w: 1260, h: 1180, scale: 1 * 1 }, containerlayer: { pt: { x: 150, y: 470, w: 1260, h: 600, scale: 1 * 1 }, ls: { x: 150, y: 470, w: 1260, h: 600, scale: 1 * 1 } } }, content: { w: 960, h: 476, logo: { ls: { x: 360, y: -14, scale: 0.5 * 1 }, pt: { x: 230, y: -110, scale: 1 * 1 } }, background: { x: 0, y: 0, w: 0, h: 0 }, continue_btn: { x: 290, y: 380, w: 236, h: 56, xoffset: 0, yoffset: 242, offsets: { xenabled: 0, yenabled: 0, xon: 236, yon: 0, xoff: 0, yoff: 0 }, sprite: { x: 290, y: 380, w: 236, h: 56 } }, btn_bg: { x: 0, y: 0, w: 236, h: 56, offsetx: 0, offsety: 0, adjustx: 0, adjusty: 0 }, checkbox: { btn: { x: 530, y: 380, w: 56, h: 56, offsets: { xon: 472, yon: 0, xoff: 527, yoff: 0 } }, textfield: { x: 586, y: 382, w: 150, h: 54 } }, toggleSoundCheckbox: { btn: { x: 210, y: 380, w: 56, h: 56, offsets: { xon: 640, yon: 0, xoff: 584, yoff: 0 } } }, decorOverlay: { x: 0, y: 0, w: 1260, h: 1180, offsets: { x: 0, y: 0 } }, symbolScatter: { x: 140, y: 120, scale: 0.7 * 1 }, symbolScatter1: { x: 245, y: 120, scale: 0.7 * 1 }, symbolScatter2: { x: 350, y: 120, scale: 0.7 * 1 }, txtLabelFreespins: { x: 220, y: 48, w: 500, h: 40 }, txtLabelRespin: { x: 220, y: 48, w: 500, h: 40 }, txtFreespin: { x: 160, y: 225, w: 280, h: 58 }, txtRespin: { x: 160, y: 130, w: 280, h: 150 }, txtWinUpTo: { x: 360, y: 320, w: 580, h: 40 }, slider: { x: 500, y: 110 } } }; particles_pos = { coinshower: { layer: { x: 0, y: 0, w: 1260, h: 1180 }, x: 630, y: 910, w: 50, h: 50, scalestart: 0.7 * 1, scalerate: 0.01 * 1, ymoverate: 3, cntstart: 50 * 1, density: 5 * 1, angle: function () { return (Math.random() - 0.5 * 1) * 0.5 * 1 }, radius: function () { return Math.random() * 4 + 30 }, y_kill_level: 300 + 50 * 1 }, adjustPos: { pt: { yadj: 200 }, ls: { yadj: 80 } } }; gamble = { gamble_layer: { pt: { x: 213, y: 450, w: 698, h: 430, scale: 1.2 * 1 }, ls: { x: 254, y: 450, w: 698, h: 430, scale: 1.075 * 1 } }, gamble_window: { size: { w: 698, h: 430 }, pos: { x: 0, y: 0, w: 698, h: 430 } }, buttons: { red: { size: { w: 120, h: 74 }, offset: { xoff: 720, yoff: 0, xon: 720, yon: 74, xenabled: 720, yenabled: 0, xdisabled: 720, ydisabled: 148 }, pos: { x: 107, y: 162, w: 120, h: 74, xoffset_on: 720, yoffset_on: 74, caption_offset: { x: 0, y: 0 }, offsets: { xoff: 720, yoff: 0, xon: 720, yon: 74, xenabled: 720, yenabled: 0, xdisabled: 720, ydisabled: 148 } }, textpos: { x: 107, w: 120 } }, black: { size: { w: 120, h: 74 }, offset: { xoff: 840, yoff: 0, xon: 840, yon: 74, xenabled: 840, yenabled: 0, xdisabled: 840, ydisabled: 148 }, pos: { x: 107, y: 244, w: 120, h: 74, xoffset_on: 840, yoffset_on: 74, caption_offset: { x: 0, y: 0 }, offsets: { xoff: 840, yoff: 0, xon: 840, yon: 74, xenabled: 840, yenabled: 0, xdisabled: 840, ydisabled: 148 } }, textpos: { x: 107, w: 120 } }, heart: { size: { w: 70, h: 70 }, offset: { xoff: 0, yoff: 430, xon: 70, yon: 430, xenabled: 0, yenabled: 430, xdisabled: 140, ydisabled: 430 }, pos: { x: 445, y: 166, w: 70, h: 70, xoffset_on: 70, yoffset_on: 430, offsets: { xoff: 0, yoff: 430, xon: 70, yon: 430, xenabled: 0, yenabled: 430, xdisabled: 140, ydisabled: 430 } } }, diamond: { size: { w: 70, h: 70 }, offset: { xoff: 210, yoff: 430, xon: 280, yon: 430, xenabled: 210, yenabled: 430, xdisabled: 350, ydisabled: 430 }, pos: { x: 525, y: 166, w: 70, h: 70, xoffset_on: 280, yoffset_on: 430, offsets: { xoff: 210, yoff: 430, xon: 280, yon: 430, xenabled: 210, yenabled: 430, xdisabled: 350, ydisabled: 430 } } }, club: { size: { w: 70, h: 70 }, offset: { xoff: 420, yoff: 430, xon: 490, yon: 430, xenabled: 420, yenabled: 430, xdisabled: 560, ydisabled: 430 }, pos: { x: 445, y: 248, w: 70, h: 70, xoffset_on: 490, yoffset_on: 430, offsets: { xoff: 420, yoff: 430, xon: 490, yon: 430, xenabled: 420, yenabled: 430, xdisabled: 560, ydisabled: 430 } } }, spade: { size: { w: 70, h: 70 }, offset: { xoff: 630, yoff: 430, xon: 700, yon: 430, xenabled: 630, yenabled: 430, xdisabled: 770, ydisabled: 430 }, pos: { x: 525, y: 248, w: 70, h: 70, xoffset_on: 700, yoffset_on: 430, offsets: { xoff: 630, yoff: 430, xon: 700, yon: 430, xenabled: 630, yenabled: 430, xdisabled: 770, ydisabled: 430 } } } }, text: { info_val: { pos: { x: 88, y: 62, w: 514, h: 28 } }, color_cap: { pos: { x: 92, y: 98, w: 170, h: 20 } }, suit_cap: { pos: { x: 445, y: 98, w: 160, h: 20 } }, color_val: { pos: { x: 90, y: 124, w: 160, h: 28 } }, suit_val: { pos: { x: 440, y: 124, w: 160, h: 28 } }, prev_cards_cap: { pos: { x: 68, y: 330, w: 216, h: 34 } } }, history_suit: { xadj: 40, pos: { x: 300, y: 329, w: 32, h: 32 }, offset: { x: 808, yempty: 270, yheart: 302, ydiamond: 334, yclub: 366, yspade: 398 } }, gamble_card: { size: { w: 120, h: 170 }, pos: { x: 288, y: 125, w: 120, h: 170 }, scale: { x: 1.3 * 1, y: 1.3 * 1 }, offset: { yoffset: 500 }, card_anim_cycle: { card_anim_cycle: [[120 * 0 * 1, 500, 0.5 * 1], [120 * 1 * 1, 500, 0.5 * 1], [120 * 2 * 1, 500, 0.5 * 1], [120 * 3 * 1, 500, 0.5 * 1], [120 * 4 * 1, 500, 0.5 * 1], [120 * 5 * 1, 500, 0.5 * 1]] }, face_scale_cycle: [0.25 * 1, 0.7 * 1, 1.2 * 1], face_scale_cycle_back: [0.7 * 1, 0.25 * 1, 0 * 1], gambleCardImage: "vs_cards_gamble.png" } }; big_win = { layer: { x: 0, y: 0, w: 1260, h: 1180 }, value: { x: 630, y: 700, w: 300, h: 300, xadj: 20 }, label: { x: 630, y: 600 }, rays: { x: 430, y: 490, w: 400, h: 400 }, fontsize: 72, particles: { x: 600, y: 900, w: 50, h: 50, xoffset: 0, yoffset: 400, ymoverate: 2 } }; onscreenpaytable = { size: { w: 273, h: 150 }, right: { xadj: -12, text: { w: 70, h: 30, five: { x: 170, y: 25 }, four: { x: 170, y: 60 }, three: { x: 170, y: 95 } }, num: { w: 30, h: 30, five: { x: 150, y: 25 }, four: { x: 150, y: 60 }, three: { x: 150, y: 95 } }, stext: { w: 100, h: 120, stextpos: { x: 140, y: 12 } } }, left: { xadj: 148, text: { w: 70, h: 30, five: { x: 50, y: 25 }, four: { x: 50, y: 60 }, three: { x: 50, y: 95 } }, num: { w: 30, h: 30, five: { x: 30, y: 25 }, four: { x: 30, y: 60 }, three: { x: 30, y: 95 } }, stext: { w: 100, h: 120, stextpos: { x: 30, y: 12 } } } }; function getMysteryJackpotSounds() { mysteryjackpot.winSounds = { 1: SoundManager.GetSoundDefinition("win10Snd").id - 1, 2: SoundManager.GetSoundDefinition("win9Snd").id - 1, 3: SoundManager.GetSoundDefinition("win8Snd").id - 1, 4: SoundManager.GetSoundDefinition("win7Snd").id - 1 } }; function Blink(duration, parent, rect) { this.count = 0; this.duration = duration; this.parent = parent; this.rect = rect } Blink.prototype.constructor = Blink; Blink.prototype.start = function () { if (this.graphics === undefined) { var w = symbol_spacing.w * 5, h = symbol_spacing.h * 3; this.graphics = new PIXI.Graphics; this.graphics.beginFill(16777215); this.graphics.drawRect(0, 0, w, h); this.graphics.endFill(); this.parent.addChild(this.graphics) } this.count = this.duration }; Blink.prototype.tick = function () { if (this.graphics === undefined) return; var f = 0; if (this.count) { f = Math.cos((1 - this.count / this.duration) * Math.PI * 0.5); this.count-- } this.graphics.visible = this.count > 0; this.graphics.alpha = f * 0.25 }; Localizer._allowInstantiation = false; function Localizer() { if (!Localizer._allowInstantiation) throw new Error("Error: Instantiation failed: Use getInstance() instead of new."); this.ki = {} } Classify.constr(Localizer); Localizer.getInstance = function () { if (Localizer.m_Instance === undefined) { Localizer._allowInstantiation = true; Localizer.m_Instance = new Localizer; Localizer._allowInstantiation = false } return Localizer.m_Instance }; Localizer.prototype.normalize = function (string) { string = string.replace(/<br\s*\/?>/g, "\n"); return string }; Localizer.prototype.getString = function (name2) { if (name2 === undefined) { if (typeof console === "object" && typeof console.error === "function") console.error("Requested undefined key"); return "" } if (this.ki[name2] === undefined) { var local = Locale[name2]; if (local !== undefined) { this.normalize(local); this.ki[name2] = local; return local } else { if (typeof console === "object" && typeof console.error === "function") console.error("Can't find localization for key:", name2); return name2 } } else return this.ki[name2] }; ExpandingNumberDisplay.ALIGN_BEGIN = 1; ExpandingNumberDisplay.ALIGN_CENTER = 0.5; ExpandingNumberDisplay.ALIGN_END = 0; function ExpandingNumberDisplay(str, style, pos) { this.pos = { x: pos.x, y: pos.y }; this.m_Scale = 1; this.m_VScale = 0; this.m_TScale = 0; this.m_MaxWidth = undefined; this.T = new PNG.BitmapText(str, style); this.fontSize = this.T.fontSize; this.bQ = false; this.update() } ExpandingNumberDisplay.prototype.Show = function (b) { this.T.visible = b }; ExpandingNumberDisplay.prototype.setMaxWidth = function (value) { this.m_MaxWidth = value }; ExpandingNumberDisplay.prototype.setPos = function (pos) { this.pos.x = pos.x; this.pos.y = pos.y; this.update() }; ExpandingNumberDisplay.prototype.expandTo = function (tScale, scale, vScale) { this.m_TScale = tScale; if (scale !== undefined) this.m_Scale = scale; if (vScale !== undefined) this.m_VScale = vScale; this.bQ = true }; ExpandingNumberDisplay.prototype.display = function (value) { if (value < 0) value = 0; var str = CreditFormatter.FormatCoinValue(value); var curcode = ["&#128;", "&#36;", "&pound;", "&#165;"]; var cursign = ["\u20ac", "$", "\u00a3", "\u00a5"]; for (var i = 0; i < 4; i++) if (str.search(curcode[i]) === 0) str = str.replace(curcode[i], cursign[i]); this.T.setText(str.toUpperCase()); this.update() }; ExpandingNumberDisplay.prototype.displayText = function (str) { this.T.setText(str); this.update() }; ExpandingNumberDisplay.prototype.onEnterFrame = function () { if (this.bQ) { var f = (this.m_TScale - this.m_Scale) * 0.3 - this.m_VScale * 0.5; this.m_VScale += f; this.m_Scale += this.m_VScale; if (this.m_VScale * this.m_VScale < 1.0E-8 && f * f < 1.0E-8) { this.m_Scale = this.m_TScale; this.m_VScale = 0; this.bQ = false } this.update() } }; ExpandingNumberDisplay.prototype.update = function () { this.T.fontSize = this.m_Scale * this.fontSize; this.T.updateText(); if (this.m_MaxWidth && this.T.textWidth >= this.m_MaxWidth) { this.T.width = this.m_MaxWidth; this.T.scale.y = this.T.scale.x; this.T.updateText() } this.T.x = this.pos.x - this.T.width / 2; this.T.y = this.pos.y - this.T.textHeight / 2 }; Object.defineProperty(ExpandingNumberDisplay.prototype, "width", { get: function () { this.T.width } }); Object.defineProperty(ExpandingNumberDisplay.prototype, "height", { get: function () { this.T.height } }); function SFWinScatter(cb) { this._super(cb) } SFWinScatter = Classify.constr(SFWinScatter).ext(WinScatter); SFWinScatter.override("InternalSetVisible", function () { }); WinLineDrawer.THICKNESS = drawing_paylines.draw.thickness; WinLineDrawer.COLOR_OUTER = 15825670; WinLineDrawer.COLOR_INNER = 16708482; WinLineDrawer.COLOR_INNER_OFFSETMULTIPLIER = 0.25; WinLineDrawer.ALPHA = 1; WinLineDrawer.ITERATIONS = 3; WinLineDrawer.ARC_WIDTH = drawing_paylines.draw.arcwidth; WinLineDrawer.SHADOW_COLOR = 0; WinLineDrawer.SHADOW_ALPHA = 0.5; WinLineDrawer.SHADOW_THICKNESS = drawing_paylines.draw.shadowthickness; WinLineDrawer.SHADOW_OFFSET_X = drawing_paylines.draw.shadowoffsetx; WinLineDrawer.SHADOW_OFFSET_Y = drawing_paylines.draw.shadowoffsety; WinLineDrawer.ANIMSTATE_IDLE = 0; WinLineDrawer.ANIMSTATE_FADEIN = 1; WinLineDrawer.ANIMSTATE_ANIMATE = 2; WinLineDrawer.ANIMSTATE_DISPLAYLINE = 3; WinLineDrawer.ANIMSTATE_FADEOUT = 4; WinLineDrawer.ANIMSTATE_DISPLAYED = 5; WinLineDrawer.TIME_FADEIN = 250; WinLineDrawer.TIME_DISPLAY = 100; WinLineDrawer.TIME_FADEOUT = 250; WinLineDrawer.GLOW_MOVESPEED = 1.5; function WinLineDrawer(positions, symbolSpacing, symbolSize, layer) { this.m_canvas = new LineCanvasRenderer; this.m_container = new PIXI.DisplayObjectContainer; this.m_container.addChild(this.m_canvas); this.m_layer = layer; layer.addChild(this.m_container); this.m_positions = positions; this.m_symbolSpacing = symbolSpacing; this.m_symbolSize = symbolSize; this.m_linePoints = []; this.m_currentLineIndex = 0; this.m_lastAnimatedPoint = 0; this.m_firstTime = false; this.m_animationVelocity = 0; this.m_animateX = 0; this.m_state = WinLineDrawer.ANIMSTATE_IDLE; this.m_nextStateTime = 0; this.m_lastTime = 0 } WinLineDrawer.prototype.InitLineData = function (index) { this.m_currentLineIndex = index - 1; this._calculateActualPoints(); this.m_canvas.setPoints(this.m_linePoints) }; WinLineDrawer.prototype._calculateActualPoints = function () { this.m_linePoints.length = 0; var x = 0, y = this.m_positions[this.m_currentLineIndex][0] * this.m_symbolSize.y + this.m_symbolSize.y * 0.5, symbolWidth; this.m_linePoints.push({ x: x, y: y }); for (var i = 0, j = this.m_positions[this.m_currentLineIndex].length; i < j; i++) { symbolWidth = i === 0 ? this.m_symbolSize.x : this.m_symbolSpacing.x; x = symbolWidth * (i + 0.5); y = this.m_symbolSize.y * (this.m_positions[this.m_currentLineIndex][i] + 0.5); this.m_linePoints.push({ x: x, y: y }) } x += this.m_symbolSize.x * 0.5 - (this.m_symbolSpacing.x - this.m_symbolSize.x) * 0.5; this.m_linePoints.push({ x: x, y: y }) }; WinLineDrawer.prototype.Show = function (b) { this.m_canvas.visible = b }; WinLineDrawer.prototype.Animate = function (firstTime) { this._stop(); if (firstTime) { this.m_state = WinLineDrawer.ANIMSTATE_ANIMATE; this.m_canvas.alpha = 1; this.m_animationVelocity = 0 } else { this.m_state = WinLineDrawer.ANIMSTATE_FADEIN; this.m_canvas.alpha = 0 } this.m_firstTime = firstTime; this.m_lastAnimatedPoint = 0; this.m_animationVelocity = 0; this.m_canvas.animationAmount = 0; this.m_animateX = 0 }; WinLineDrawer.prototype._stop = function () { }; WinLineDrawer.prototype.Tick = function () { var time = getTimer(), dt = time - this.m_lastTime; switch (this.m_state) { case WinLineDrawer.ANIMSTATE_IDLE: case WinLineDrawer.ANIMSTATE_DISPLAYED: break; case WinLineDrawer.ANIMSTATE_FADEIN: this.m_canvas.alpha += dt / WinLineDrawer.TIME_FADEIN; if (this.m_canvas.alpha >= 1) { this.m_canvas.alpha = 1; if (true) { this.m_state = WinLineDrawer.ANIMSTATE_ANIMATE; this.m_animationVelocity = 0 } else { this.m_nextStateTime = time + WinLineDrawer.TIME_DISPLAY; this.m_state = WinLineDrawer.ANIMSTATE_DISPLAYLINE } } break; case WinLineDrawer.ANIMSTATE_ANIMATE: this.m_animateX += dt * WinLineDrawer.GLOW_MOVESPEED; this.m_canvas.animationAmount = this.m_animateX / this.m_linePoints[this.m_linePoints.length - 1].x; if (this.m_animateX >= this.m_linePoints[this.m_lastAnimatedPoint + 1].x) { this.m_lastAnimatedPoint++; if (this.m_lastAnimatedPoint === this.m_linePoints.length - 1) { this.m_state = WinLineDrawer.ANIMSTATE_DISPLAYLINE; this.m_nextStateTime = time + WinLineDrawer.TIME_DISPLAY; return } } break; case WinLineDrawer.ANIMSTATE_DISPLAYLINE: if (time > this.m_nextStateTime) if (this.m_firstTime) this.m_state = WinLineDrawer.ANIMSTATE_DISPLAYED; else this.m_state = WinLineDrawer.ANIMSTATE_FADEOUT; break; case WinLineDrawer.ANIMSTATE_FADEOUT: this.m_canvas.alpha -= dt / WinLineDrawer.TIME_FADEIN; if (this.m_canvas.alpha <= 0) { this.m_canvas.alpha = 0; this.m_state = WinLineDrawer.ANIMSTATE_DISPLAYED; this._stop() } break } this.m_lastTime = time }; WinLineDrawer.prototype.isDisplaying = function () { return this.m_state !== WinLineDrawer.ANIMSTATE_DISPLAYED }; WinLineDrawer.prototype.getAlpha = function () { return this.m_canvas.visible ? this.m_canvas.alpha : 0 }; function InterpolateColors(color1, color2, amount) { var c1 = { r: color1 >> 16 & 255, g: color1 >> 8 & 255, b: color1 & 255 }; var c2 = { r: color2 >> 16 & 255, g: color2 >> 8 & 255, b: color2 & 255 }; var c3 = { r: Utils.Lerp(c1.r, c2.r, amount), g: Utils.Lerp(c1.g, c2.g, amount), b: Utils.Lerp(c1.b, c2.b, amount) }; return (c3.r << 16) + (c3.g << 8) + c3.b }; function LineCanvasRenderer() { var graphics = new PIXI.DisplayObject; graphics.m_linePoints = undefined; graphics.interactive = false; graphics.children = []; graphics.animationAmount = 0; graphics.setPoints = LineCanvasRenderer.prototype.setPoints; graphics._setBlendMode = LineCanvasRenderer.prototype._setBlendMode; graphics._renderCanvas = LineCanvasRenderer.prototype._renderCanvas; graphics._drawGradientOverlay = LineCanvasRenderer.prototype._drawGradientOverlay; graphics._drawShadow = LineCanvasRenderer.prototype._drawShadow; graphics._drawInterpolatedLine = LineCanvasRenderer.prototype._drawInterpolatedLine; graphics.lineStyle = LineCanvasRenderer.prototype.lineStyle; graphics._arcBetweenPoints = LineCanvasRenderer.prototype._arcBetweenPoints; if (UAGENT_IE) graphics._arcBetweenPoints = LineCanvasRenderer.prototype._lineBetweenPoints; return graphics } LineCanvasRenderer.prototype.setPoints = function (points) { this.m_linePoints = points }; LineCanvasRenderer.prototype._renderCanvas = function (renderSession) { if (this.visible === false || this.alpha === 0) return; if (this.m_linePoints !== undefined) { renderSession.context.save(); var transform = this.worldTransform; renderSession.context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty); this._drawShadow(renderSession); this._drawInterpolatedLine(renderSession); this._drawGradientOverlay(renderSession); renderSession.context.restore() } }; LineCanvasRenderer.prototype._setBlendMode = function (blendMode, renderSession) { if (blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = blendMode; renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode] } }; LineCanvasRenderer.prototype._drawShadow = function (renderSession) { var context = renderSession.context; this._setBlendMode(PIXI.blendModes.NORMAL, renderSession); var i, j, currentX, currentY, nextX, nextY, points = []; context.beginPath(); this.lineStyle(context, WinLineDrawer.SHADOW_THICKNESS, WinLineDrawer.SHADOW_COLOR, WinLineDrawer.SHADOW_ALPHA); context.lineCap = "round"; context.moveTo(this.m_linePoints[0].x | 0, this.m_linePoints[0].y + WinLineDrawer.SHADOW_OFFSET_Y | 0); context.moveTo(this.m_linePoints[0].x | 0, this.m_linePoints[0].y + WinLineDrawer.SHADOW_OFFSET_Y | 0); for (i = 0, j = this.m_linePoints.length; i < j; i++) { currentX = this.m_linePoints[i].x + WinLineDrawer.SHADOW_OFFSET_X | 0; currentY = this.m_linePoints[i].y + WinLineDrawer.SHADOW_OFFSET_Y | 0; points.push({ x: currentX, y: currentY }) } this._arcBetweenPoints(context, points, WinLineDrawer.ARC_WIDTH); context.stroke() }; LineCanvasRenderer.prototype._drawInterpolatedLine = function (renderSession) { var context = renderSession.context; this._setBlendMode(PIXI.blendModes.NORMAL, renderSession); var i, j, k, currentX, currentY, width, color, points; for (j = 0; j < WinLineDrawer.ITERATIONS; j++) { context.beginPath(); width = (1 - j / WinLineDrawer.ITERATIONS) * WinLineDrawer.THICKNESS | 0; color = InterpolateColors(WinLineDrawer.COLOR_OUTER, WinLineDrawer.COLOR_INNER, j / WinLineDrawer.ITERATIONS); points = []; this.lineStyle(context, width, color, 1); context.lineCap = "round"; context.moveTo(this.m_linePoints[0].x | 0, this.m_linePoints[0].y + width * WinLineDrawer.COLOR_INNER_OFFSETMULTIPLIER | 0); for (i = 0, k = this.m_linePoints.length; i < k; i++) { currentX = this.m_linePoints[i].x | 0; currentY = this.m_linePoints[i].y + width * WinLineDrawer.COLOR_INNER_OFFSETMULTIPLIER | 0; points.push({ x: currentX, y: currentY }) } this._arcBetweenPoints(context, points, WinLineDrawer.ARC_WIDTH); context.stroke() } }; LineCanvasRenderer.prototype._drawGradientOverlay = function (renderSession) { if (this.animationAmount > 1 || this.animationAmount === 0) return; var context = renderSession.context; this._setBlendMode(PIXI.blendModes.ADD, renderSession); var i, j, currentX, currentY, points = []; context.beginPath(); this.lineStyle(context, WinLineDrawer.THICKNESS, 0, 0.5); context.lineCap = "round"; var grd = context.createLinearGradient(drawing_paylines.draw.gradient.x0, drawing_paylines.draw.gradient.y0, drawing_paylines.draw.gradient.x1, drawing_paylines.draw.gradient.y1); this.animationAmount = (this.animationAmount * 1E3 | 0) / 1E3; grd.addColorStop(Math.min(this.animationAmount, 1), "black"); grd.addColorStop(Math.min(this.animationAmount + 0.1, 1), "white"); grd.addColorStop(Math.min(this.animationAmount + 0.2, 1), "black"); context.strokeStyle = grd; context.moveTo(this.m_linePoints[0].x | 0, this.m_linePoints[0].y | 0); for (i = 0, j = this.m_linePoints.length; i < j; i++) { currentX = this.m_linePoints[i].x | 0; currentY = this.m_linePoints[i].y | 0; points.push({ x: currentX, y: currentY }) } this._arcBetweenPoints(context, points, WinLineDrawer.ARC_WIDTH); context.stroke() }; LineCanvasRenderer.prototype.lineStyle = function (context, thickness, hexColor, alpha) { context.lineWidth = thickness; if (hexColor) context.strokeStyle = "#" + ("00000" + (hexColor | 0).toString(16)).substr(-6); context.globalAlpha = this.worldAlpha * alpha }; LineCanvasRenderer.prototype._arcBetweenPoints = function (context, points, radius) { context.moveTo(points[0].x, points[0].y); context.lineTo(points[1].x, points[1].y); for (var i = 1, l = points.length - 1; i < l; i++) context.arcTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, radius); context.lineTo(points[i].x, points[i].y) }; LineCanvasRenderer.prototype._lineBetweenPoints = function (context, points, radius) { context.moveTo(points[0].x, points[0].y); for (var i = 0, l = points.length; i < l; i++) context.lineTo(points[i].x, points[i].y) }; function ExtendedWinLineDrawer(positions, symbolSpacing, symbolSize, layer) { this._super(positions, symbolSpacing, symbolSize, layer) } ExtendedWinLineDrawer = Classify.constr(ExtendedWinLineDrawer).ext(WinLineDrawer); ExtendedWinLineDrawer.override("_calculateActualPoints", function () { var i = 0; do this.m_linePoints.push({ x: this.m_positions[this.m_currentLineIndex][i++] * winline.scale.init * winline.scale.x + winline.scale.offsetx, y: this.m_positions[this.m_currentLineIndex][i++] * winline.scale.init * winline.scale.y + winline.scale.offsety }); while (i < this.m_positions[this.m_currentLineIndex].length) }); WinLineWithCustomDuration.QUICKWINWIEV_DURATION_FACTOR = 0.2; function WinLineWithCustomDuration(pl, index, paylineBehind) { this._super(pl, index, paylineBehind); this.lO; this.m_EndTime } WinLineWithCustomDuration = Classify.constr(WinLineWithCustomDuration).ext(WinLine); WinLineWithCustomDuration.override("Tick", function () { var time = getTimer(); if (this.lO > 0 && this.lO < time) this.Start(); if (this.m_EndTime < time) { this.Stop(); this.Show(false); return false } return true }); WinLineWithCustomDuration.override("Animate", function (freeSpinMode, firstTime) { var coinsWon = this.GetWonAmount() / this.ow; var delay = this.getDelay(this.kM, this.ag, coinsWon, firstTime); var duration = this.getDuration(this.kM, this.ag, coinsWon, firstTime); if (this.C) { delay = 0; duration = 0 } this.lO = getTimer() + delay; this.m_EndTime = this.lO + duration; if (this.fk && firstTime) this.m_EndTime = this.lO + (this.m_EndTime - this.lO) * WinLineWithCustomDuration.QUICKWINWIEV_DURATION_FACTOR; if (delay === 0) this.Start() }); WinLineWithCustomDuration.override("getEndTime", function () { return this.m_EndTime }); WinLineWithCustomDuration.prototype.Start = function () { if (this.lO === 0) return false; this.lO = 0; return true }; WinLineWithCustomDuration.prototype.isDelayed = function () { return this.lO > 0 }; WinLineWithCustomDuration.prototype.getDelay = function (symbol, numSymbols, winAmount, firstTime) { return 0 }; WinLineWithCustomDuration.prototype.getDuration = function (symbol, numSymbols, winAmount, firstTime) { var duration = 500; if (winAmount >= 0) duration += 500; return duration }; WinLineWithCustomDuration.override("OnQuickView", function (e) { this._super(e); this.m_EndTime = 100 + getTimer() + (this.m_EndTime - getTimer()) * WinLineWithCustomDuration.QUICKWINWIEV_DURATION_FACTOR }); SFWinLine.m_WinlinePoints = [[65, 404, 1100, 404], [65, 248, 113, 221, 1100, 221], [65, 613, 113, 613, 1100, 613], [65, 194, 113, 194, 600, 630, 1100, 194], [65, 665, 113, 665, 600, 220, 1100, 665], [1135, 352, 1008, 352, 804, 194, 396, 194, 192, 352, 100, 352], [1135, 456, 1008, 456, 804, 613, 396, 613, 192, 456, 100, 456], [1135, 508, 804, 508, 396, 221, 100, 221], [65, 561, 396, 561, 804, 248, 1100, 248], [65, 352, 113, 352, 396, 613, 804, 221, 1008, 352, 1100, 352], [65, 508, 192, 508, 396, 221, 804, 613, 1008, 456, 1100, 456], [1135, 300, 1008, 300, 804, 417, 396, 417, 192, 221, 100, 221], [1135, 561, 1008, 561, 804, 417, 396, 417, 192, 613, 100, 613], [1135, 194, 1087, 194, 804, 417, 600, 221, 396, 417, 192, 221, 100, 221], [1135, 665, 1008, 665, 804, 417, 600, 613, 396, 417, 192, 613, 100, 613], [1135, 404, 804, 404, 600, 221, 396, 404, 100, 404], [65, 456, 396, 456, 600, 613, 804, 456, 1100, 456], [1135, 248, 804, 248, 600, 613, 396, 248, 100, 248], [1135, 613, 804, 613, 600, 221, 396, 613, 100, 613], [65, 300, 192, 300, 396, 613, 804, 613, 1008, 300, 1100, 300]]; function SFWinLine(pl, index, paylineBehind, symbolPositions, payLinesLayout, paylinesOverlay, awardOverlay) { this._super(pl, index, paylineBehind); this.m_SymbolPositions = symbolPositions; this.m_DrawerOpened; this.m_IsPostBigWin = false; this.m_LineDrawer = new ExtendedWinLineDrawer(SFWinLine.m_WinlinePoints, { x: symbol_spacing.w + 0, y: symbol_spacing.h + 6 }, { x: symbol_spacing.w, y: symbol_spacing.h }, paylinesOverlay); this.m_LineDrawer.InitLineData(this.aA); this.m_AwardContainer = PIXI.Sprite.fromImage(image_path_game + "winline/win_amount_bg.png"); awardOverlay.addChild(this.m_AwardContainer); this.m_AwardContainer.visible = false; var style = { font: winline.award.fontsize.toString() + " " + winline.award.font, align: winline.award.align }; this.m_NumberDisplay = new ExpandingNumberDisplay("", style, winline.award.pos); this.m_AwardContainer.addChild(this.m_NumberDisplay.T) } SFWinLine = Classify.constr(SFWinLine).ext(WinLineWithCustomDuration); SFWinLine.override("Animate", function (freeSpinMode, firstTime) { if (this.m_IsPostBigWin) firstTime = true; this.m_LineDrawer.Show(true); this.m_LineDrawer.Animate(firstTime); this._super(freeSpinMode, firstTime); var idx = this.ag >> 1; this.m_AwardContainer.x = this.m_SymbolPositions[idx].x + winline.award.offset.x; this.m_AwardContainer.y = this.m_SymbolPositions[idx].y + winline.award.offset.y; this.m_AwardContainer.visible = true }); SFWinLine.override("getDuration", function (symbol, numSymbols, winAmount, firstTime) { var duration = this.m_IsPostBigWin && !this.fk ? 500 : this._super(symbol, numSymbols, winAmount, firstTime); return duration }); SFWinLine.override("Tick", function () { this.m_LineDrawer.Tick(); this.m_NumberDisplay.onEnterFrame(); this.m_AwardContainer.alpha = this.m_LineDrawer.getAlpha(); return this._super() }); SFWinLine.prototype.Stop = function () { this.m_LineDrawer.Show(false); this.m_AwardContainer.visible = false }; SFWinLine.override("Clear", function () { this._super(); this.m_IsPostBigWin = false; this.m_LineDrawer.Show(false) }); SFWinLine.prototype.Enable = function (b, gameInited) { this.Show(b && gameInited) }; SFWinLine.prototype.Show = function (b) { if (b) { this.m_NumberDisplay.display(this.kU); this.m_NumberDisplay.expandTo(0.8, 0, 0.2) } else this.m_AwardContainer.visible = false; this.m_LineDrawer.Show(b) }; SFWinLine.prototype.getAmountIdx = function (winAmount) { var idx = 0; if (winAmount >= 150) idx++; if (winAmount >= 100) idx++; if (winAmount >= 75) idx++; if (winAmount >= 50) idx++; if (winAmount >= 25) idx++; if (winAmount >= 11) idx++; if (winAmount >= 5) idx++; return idx }; SFWinLine.prototype.setPostBigWin = function () { this.m_IsPostBigWin = true }; function SFWinDisplay(cb) { this._super(cb) } SFWinDisplay = Classify.constr(SFWinDisplay).ext(WinDisplay); SFWinDisplay.override("IsActive", function () { if (this.m_PostWin) return true; return this.aK >= 0 && this.aN }); SFWinDisplay.override("LinesStart", function (firstTime) { if (firstTime === undefined) firstTime = false; if (this.bQ) { this.aN = firstTime; this.ao("linesstart"); for (var i = 0, j = this.ac.length; i < j; i++) { this.aV[this.ac[i]].Show(true); this.aV[this.ac[i]].Stop() } if (this.ac.length > 0 || this.cw.length > 0) { this.aK = 0; this.eK = getTimer() + (firstTime ? 0 : 2E3) } else { if (this.aN && !this.bh) this.ao("allticked"); this.aK = -1; this.ao("done") } } }); SFWinDisplay.override("restart", function (force) { if (force === undefined) force = false; if (this.aN && !this.bh) this.ao("allticked"); this.aN = false; this.m_PostWin = false; this.ao("done"); if (force) this.bQ = true; if (this.bQ) this.LinesStart() }); SFWinDisplay.override("Start", function (freeSpinMode, reSpinMode, delay, skipFirstRound, postwin) { if (freeSpinMode === undefined) freeSpinMode = false; if (reSpinMode === undefined) reSpinMode = false; if (delay === undefined) delay = 0; if (skipFirstRound === undefined) skipFirstRound = false; if (postwin === undefined) postwin = false; this.m_PostWin = postwin; this.bh = freeSpinMode; this.m_ReSpinMode = reSpinMode; this.bQ = true; this.mP = true; this.aN = !skipFirstRound; this.mg = getTimer() + delay }); SFWinDisplay.override("OnQuickWinView", function () { for (var i = 0, j = this.ac.length; i < j; i++) { var winLine = this.aV[this.ac[i]]; winLine.OnQuickView() } }); SFWinDisplay.prototype.setPostBigWin = function () { for (var pl = 0, j = this.aV.length; pl < j; pl++) this.aV[pl].setPostBigWin() }; SFWinDisplay.prototype.HasScatterWins = function () { return this.cw && this.cw.length > 0 }; SFBigWinDisplay.STATE_NONE = 0; SFBigWinDisplay.STATE_RUNNING = 1; SFBigWinDisplay.STATE_STOPPING = 2; SFBigWinDisplay.MIN_TIME = 5E3; SFBigWinDisplay.MAX_TIME = 3E4; SFBigWinDisplay.WAIT_TIME = 4E3; SFBigWinDisplay.OUTRO_TIME = 500; SFBigWinDisplay.COMPLETE = "bigWinComplete"; SFBigWinDisplay.STOP = "bigWinStop"; SFBigWinDisplay.LABEL_TEXTS = ["BIG WIN", "BIG WIN", "SUPER BIG WIN", "MEGA BIG WIN", "ULTRA BIG WIN"]; SFBigWinDisplay.LABEL_SIZES = [1, 1, 1.1, 1.2, 1.3]; SFBigWinDisplay.BET_MULTIPLIERS = [10, 20, 30, 50]; SFBigWinDisplay.TRIGGER_BET_MULTIPLIER = SFBigWinDisplay.BET_MULTIPLIERS[0]; function SFBigWinDisplay(layerName, settings, font, cb) { if (this.constructor !== arguments.callee) return new SFBigWinDisplay(layerName, settings, font, cb); if (font === undefined) font = "Impact"; this.K = sjs.layers[layerName]; this.bG = settings; this.ct = cb; this.m_LevelIdx; this.dr; this.aa; this.cv; this.bi = 0; this.m_LabelsHidden = false; this.m_ClientStop = false; this.m_ClientStopSet = false; this.m_RaysBg = new sjs.Sprite(image_path_game + "big_win_animation_objects.png", this.K, undefined, big_win.rays); this.m_RaysBg.scale(1.5, 1.5); this.m_RaysTransform = new sjs.Sprite(image_path_game + "big_win_animation_objects.png", this.K, undefined, big_win.rays); this.m_RaysTransform.scale(3, 3); this.m_RaysTransform.xoffset = big_win.rays.w; var emitterMC = new PIXI.DisplayObjectContainer; emitterMC.x = big_win.particles.x; emitterMC.y = big_win.particles.y; this.K.view.addChild(emitterMC); this.m_ParticlePool = BigWinEmitter.createPool(100, emitterMC); this.si = new BigWinEmitter(emitterMC, this.m_ParticlePool, 2); var style = { font: big_win.fontsize + "px " + font, align: "center", monospace: { width: 38 } }; this.m_BigWinNumberDisplay = new ExpandingNumberDisplay("", style, big_win.value); this.m_BigWinNumberDisplay.setMaxWidth(game_bgr_pos.reel_base.w * 0.8); this.K.view.addChild(this.m_BigWinNumberDisplay.T); style = { font: big_win.fontsize + "px " + font, align: "center" }; this.m_Label = new ExpandingNumberDisplay("", style, big_win.label); this.K.view.addChild(this.m_Label.T); var self = this; this.m_Cover = new sjs.Solid("#000000", this.K, big_win.layer); this.m_Cover.opacity = 0; this.m_Cover.view.click = this.m_Cover.view.tap = function () { self.m_ClientStop = true }; this.m_LoopSndTime = 0; this.m_SoundEnded = false; this.m_TriggerSnd = new Snd("bigWinTriggerSnd"); this.m_LevelUpSnd = new Snd("bigWinLevelUpSnd"); this.m_EndSnd = new Snd("bigWinEndSnd"); this.m_LevelSnd = null; this.m_LevelSnds = [new Snd("bigWinLevel1Snd"), new Snd("bigWinLevel2Snd"), new Snd("bigWinLevel3Snd"), new Snd("bigWinLevel4Snd")]; this.m_State = SFBigWinDisplay.STATE_NONE; this.stop() } SFBigWinDisplay.prototype.constructor = SFBigWinDisplay; SFBigWinDisplay.prototype.setCurrent = function (value) { this.aa = value }; SFBigWinDisplay.prototype.setTarget = function (value) { this.bi = value }; SFBigWinDisplay.prototype.add = function (value) { this.bi += value }; SFBigWinDisplay.prototype.start = function () { if (this.m_State !== SFBigWinDisplay.STATE_NONE) return; this.K.Show(true); var duration = this.getDuration(); if (duration > 0) { this.dr = getTimer() + duration; this.cv = (this.bi - this.aa) / duration; this.m_RaysRotate = 0; this.m_State = SFBigWinDisplay.STATE_RUNNING } this.m_SoundEnded = false; this.m_TriggerSnd.Play(0.8); for (var i = 0, j = this.m_LevelSnds.length; i < j; i++) this.m_LevelSnds[i].PlayForever(0) }; SFBigWinDisplay.prototype.getDuration = function () { var level = this.getLevelIdx(this.bi); if (level < 1) return 0; var duration = (this.bi - this.aa) / this.bG.GetBetCoins() * 300; if (duration < SFBigWinDisplay.MIN_TIME) duration = SFBigWinDisplay.MIN_TIME; else if (duration > SFBigWinDisplay.MAX_TIME) duration = SFBigWinDisplay.MAX_TIME; return duration }; SFBigWinDisplay.prototype.getTotalDuration = function () { var duration = this.getDuration(); return duration > 0 ? duration + SFBigWinDisplay.WAIT_TIME : 0 }; SFBigWinDisplay.prototype.showValue = function (value) { var level = this.getLevelIdx(value); if (this.m_LevelIdx !== level) { this.setLevel(level); this.m_LevelIdx = level } this.m_BigWinNumberDisplay.Show(true); this.m_BigWinNumberDisplay.display(value); this.m_BigWinNumberDisplay.expandTo(Math.min(2, (Math.log(value + 200) - 2) * 0.28)) }; SFBigWinDisplay.prototype.getLevelIdx = function (value) { value /= this.bG.GetBetCoins(); var idx; if (value <= 0) idx = -1; else if (value < SFBigWinDisplay.BET_MULTIPLIERS[0]) idx = 0; else if (value < SFBigWinDisplay.BET_MULTIPLIERS[1]) idx = 1; else if (value < SFBigWinDisplay.BET_MULTIPLIERS[2]) idx = 2; else if (value < SFBigWinDisplay.BET_MULTIPLIERS[3]) idx = 3; else idx = 4; return idx }; SFBigWinDisplay.prototype.setLevel = function (level) { var prevLabel = this.m_LevelIdx >= 0 ? SFBigWinDisplay.LABEL_TEXTS[this.m_LevelIdx] : null; this.m_Label.displayText(SFBigWinDisplay.LABEL_TEXTS[level]); var scale = SFBigWinDisplay.LABEL_SIZES[level]; this.m_Label.expandTo(scale, scale, SFBigWinDisplay.LABEL_TEXTS[level] !== prevLabel ? scale * 0.2 : 0); if (this.m_LevelIdx === -1) this.si.start(); else this.si.setDensity(SFBigWinDisplay.BET_MULTIPLIERS.length - level + 1); if (level <= 3) { this.m_LevelSnd = this.m_LevelSnds[level]; this.m_LevelSnd.FadeTo(0.8, 1) } if (level <= 4) if (level >= 2) this.m_LevelUpSnd.Play(0.7) }; SFBigWinDisplay.prototype.stop = function () { if (this.m_State !== SFBigWinDisplay.STATE_NONE) this.ct({ Type: SFBigWinDisplay.COMPLETE }); this.si.stop(); this.m_State = SFBigWinDisplay.STATE_NONE; this.m_ClientStop = false; this.m_ClientStopSet = false; this.m_LabelsHidden = false; this.bi = 0; this.aa = 0; this.m_LevelIdx = -1; this.K.view.alpha = 1; this.K.Show(false); this.m_Label.displayText(" "); for (var i = 0, j = this.m_LevelSnds.length; i < j; i++) this.m_LevelSnds[i].FadeOut(0.5) }; SFBigWinDisplay.prototype.reset = function () { this.stop() }; SFBigWinDisplay.prototype.Tick = function () { if (this.m_State === SFBigWinDisplay.STATE_NONE) return false; this.si.onEnterFrame(); this.m_ParticlePool.onEnterFrame(); this.m_BigWinNumberDisplay.onEnterFrame(); this.m_Label.onEnterFrame(); if (this.m_RaysTransform.visible) this.m_RaysTransform.rotate(this.m_RaysRotate += 0.02); var time = getTimer(), ret = true; if (time < this.dr && !this.m_ClientStop) this.aa = this.bi - this.cv * (this.dr - time); else if (time < this.dr + SFBigWinDisplay.WAIT_TIME * 0.45 && this.m_ClientStop && !this.m_ClientStopSet) { this.aa = this.bi; this.m_State = SFBigWinDisplay.STATE_STOPPING; this.dr = time - SFBigWinDisplay.WAIT_TIME * 0.45; this.m_ClientStopSet = true; this.m_EndSnd.Play(0.8); for (var i = 0, j = this.m_LevelSnds.length; i < j; i++) this.m_LevelSnds[i].FadeOut(0.5) } else { if (this.m_State === SFBigWinDisplay.STATE_RUNNING) { this.m_EndSnd.Play(0.8); for (var i = 0, j = this.m_LevelSnds.length; i < j; i++) this.m_LevelSnds[i].FadeOut(0.5); this.aa = this.bi; this.m_State = SFBigWinDisplay.STATE_STOPPING } if (this.dr + SFBigWinDisplay.WAIT_TIME < time) { this.stop(); ret = false } else if (this.dr + SFBigWinDisplay.WAIT_TIME * 0.5 < time) this.si.stop(); if (this.dr + SFBigWinDisplay.WAIT_TIME * 0.8 < time) if (!this.m_LabelsHidden) { Tweener.AddTween({ obj: this.K.view, properties: { alpha: 0 }, duration: SFBigWinDisplay.WAIT_TIME * 0.2, durationType: Tweener.MS, objectType: SJSTweener.TYPE_SPRITE }); this.m_LabelsHidden = true } } this.showValue(this.aa); return ret }; Object.defineProperty(SFBigWinDisplay.prototype, "IsRunning", { get: function () { return this.m_State !== SFBigWinDisplay.STATE_NONE } }); Object.defineProperty(SFBigWinDisplay.prototype, "TriggerValue", { get: function () { return SFBigWinDisplay.TRIGGER_BET_MULTIPLIER * this.bG.GetBetCoins() } }); function FeatureBase(event) { this._super(event) } FeatureBase = Classify.constr(FeatureBase).ext(Feature); FeatureBase.override("FeatureProcessed", function () { this._super(); this.SetAcceptInput(false) }); FeatureBase.override("Process", function () { if (this._super()) return true; if (!this.CanProcess()) return false; switch (this.m_State) { case Feature.FEATURE_IDLE: this.ChangeState(Feature.FEATURE_STARTED); break; case Feature.FEATURE_STARTED: this.ChangeState(Feature.FEATURE_RUNNING); break; case Feature.FEATURE_RUNNING: this.SetAcceptInput(true); if (!this.Reconnecting() || !this.NeedsCollect()) this.ChangeState(Feature.FEATURE_COLLECTED); break } return this.m_State === Feature.FEATURE_COLLECTED }); SFFreeSpinHandler.ANIMSTATE_NONE = 0; SFFreeSpinHandler.ANIMSTATE_INIT = 1; SFFreeSpinHandler.ANIMSTATE_FLIP = 2; SFFreeSpinHandler.ANIMSTATE_FLIPPED = 3; SFFreeSpinHandler.ANIMSTATE_CLOSING = 4; SFFreeSpinHandler.ANIMSTATE_SUMMARY = 5; SFFreeSpinHandler.ANIMSTATE_OUTRO = 6; SFFreeSpinHandler.ANIMSTATE_COMPLETE = 7; SFFreeSpinHandler.ANIMSTATE_RETRIGGER = 8; SFFreeSpinHandler.ANIMSTATE_PRESS_SPIN = 9; SFFreeSpinHandler.REEL_STOP = FreeSpinHandler.COMPLETE + 100; FreeSpinHandler.SELECT = 7; FreeSpinHandler.COMPLETE = 8; FreeSpinHandler.ANIMTIME_MULTIPLIER = 1; function SFFreeSpinHandler(callback, reelHandler, reelFlipper, logo, freespinReelDefinitions) { this._super(callback); function deactivate(doc) { doc.tap = undefined; doc.click = undefined; doc.interactive = false } function createSprite(src, layer, input, bounds, style, tiling) { var ret = new sjs.Sprite(src, layer, input, bounds, style, tiling); deactivate(ret.view); return ret } function createSolid(color, layer, bounds, style) { var ret = new sjs.Solid(color, layer, bounds, style); deactivate(ret.view); return ret } function createTextfield(layer, pos, caption, textColor, style, multiline, verticalAlign, ieShadow) { var ret = new Textfield(layer, pos, caption, textColor, style, multiline, verticalAlign, ieShadow); deactivate(ret.T.view); return ret } function createArmature(name) { var ret = (new PixiArmature(name)).getDisplay(); deactivate(ret); return ret } function createTextInArmature(container, text, style, rect) { var textfield = createTextfield(sjs.layers.freespinLayer, rect, text, false, style, false, "top"); textfield.SetPos({ x: reels_layer_pos.w / -2, y: textfield.actualHeight / -2, w: reels_layer_pos.w, h: textfield.actualHeight }); container.addChild(textfield.T.view); return textfield } this.ao = callback; this.aQ = reelHandler; this.m_ReelFlipper = reelFlipper; this.m_Logo = logo; this.m_FreespinReelDefinitions = freespinReelDefinitions; this.m_IsRespin = false; this.m_WasRespin = false; this.m_AfterRespin = false; this.FreespinCorrection = 0; this.RespinCorrection = 0; this.m_OriginalSpinners = []; this.m_OriginalDefinitions = []; this.bZ = 0; this.m_NextAnimState = SFFreeSpinHandler.ANIMSTATE_NONE; this.jd = false; this.m_IsRetriggerFull = false; this.K = sjs.layers["freespinLayer"] ? sjs.layers["freespinLayer"] : new sjs.Layer("freespinLayer", undefined, sjs.layers.scalelayer, undefined, freespin.layer); this.K.Origin("left", "top"); this.m_IntroBox = createArmature("FsIntroPopup"); this.m_IntroBox.x = freespin.popup.x; this.m_IntroBox.y = freespin.popup.y; this.m_IntroBox.gotoAndPlay("stop"); this.K.view.addChild(this.m_IntroBox); this.kp = createTextInArmature(this.m_IntroBox.getSlot("text1").getDisplay(), Localizer.getInstance().getString("IDS_MSG_CONGRATULATIONS"), "freespin_intro_congrat"); this.m_WonNumText = createTextInArmature(this.m_IntroBox.getSlot("text2").getDisplay(), Localizer.getInstance().getString("IDS_X_FREESPINS"), "freespin_you_won_x"); this.m_CalToActionText = createTextInArmature(this.m_IntroBox.getSlot("text3").getDisplay(), Localizer.getInstance().getString("IDS_SF_FREESPIN_FLIP1"), "freespin_call_to_action"); this.m_Description = createTextInArmature(this.m_IntroBox.getSlot("text4").getDisplay(), Localizer.getInstance().getString("IDS_SF_FREESPIN_FLIP2"), "freespin_description"); this.m_PressSpinText = createTextInArmature(this.m_IntroBox.getSlot("pressSpin").getDisplay().getSlot("text").getDisplay(), Localizer.getInstance().getString("IDS_PRESSPIN"), "freespin_press_spin"); this.m_Description.T.multiline = true; this.m_Description.SetPos({ x: reels_layer_pos.w / -4, y: reels_layer_pos.h / -8, w: reels_layer_pos.w / 2, h: reels_layer_pos.h / 4 }); this.m_SummaryBox = createArmature("FsIntroPopup"); this.m_SummaryBox.x = freespin.popup.x; this.m_SummaryBox.y = freespin.popup.y; this.m_SummaryBox.gotoAndPlay("stop"); this.K.view.addChild(this.m_SummaryBox); this.m_CongratText2 = createTextInArmature(this.m_SummaryBox.getSlot("text1").getDisplay(), Localizer.getInstance().getString("IDS_MSG_CONGRATULATIONS"), "freespin_summary_congrat"); this.nF = createTextInArmature(this.m_SummaryBox.getSlot("text2").getDisplay(), Localizer.getInstance().getString("IDS_TOTALWIN"), "freespin_summary_total_win"); this.m_TotalWinValue = createTextInArmature(this.m_SummaryBox.getSlot("text3").getDisplay(), "0", "freespin_summary_total_win_value"); this.m_HudBox = new sjs.Layer("freespinHud", undefined, this.K, undefined, freespin.hud.layer); this.m_HudBox.Show(false); this.m_RaysBg = createSprite(image_path_game + "big_win_animation_objects.png", this.m_HudBox, undefined, freespin.hud.rays); this.m_RaysBg.visible = false; this.m_RaysBg.scale(1.5, 1.5); this.m_RaysTransform = createSprite(image_path_game + "big_win_animation_objects.png", this.m_HudBox, undefined, freespin.hud.rays); this.m_RaysTransform.visible = false; this.m_RaysTransform.scale(3, 3); this.m_RaysTransform.xoffset = big_win.rays.w; this.m_RaysRotate = 0; this.m_HudLineGraph = createSprite(image_path_game + "fs_intro_tp.png", this.m_HudBox, undefined, freespin.hud.line); this.m_HudLineGraph.offset(freespin.hud.line.offset.x, freespin.hud.line.offset.y); this.m_HudLineGraph.scale(freespin.hud.line.scale, freespin.hud.line.scale); this.m_CurrFreeSpinsText = createTextfield(this.m_HudBox, freespin.hud.text, Localizer.getInstance().getString("IDS_FREESPIN_X_OF_Y"), false, "freespin_hud"); this.m_IntroSnd = new Snd("freespinIntro"); this.cP = new Snd("freespinMusic"); this.sY = new Snd("freespinSummary"); this.m_NearhitLoopSnd = new Snd("nearhitLoopSnd"); this.m_NearhitSpinUpSnd = new Snd("nearhitSpinUpSnd"); this.m_NearhitStopSnd = new Snd("nearhitStopSnd"); this.m_NearhitTriggerSnd = new Snd("nearhitTriggerSnd"); this.m_FullButton = createSolid("#ff0000", this.K, { x: 0, y: 0, w: game_bgr_pos.reel_bg.w, h: game_bgr_pos.reel_bg.h }); this.m_FullButton.opacity = 0; this.m_FullButton.visible = false; this.m_Dummy = {}; this.m_DelegatedUpdateText = Utils.delegate(this, this.updateText); this.m_DelegatedMoveText = Utils.delegate(this, this.moveText); this.m_DelegatedShowLine = Utils.delegate(this, this.showLine); this.m_DelegatedHideRays = Utils.delegate(this, this.hideRays); this.m_DelegatedClickSummary = Utils.delegate(this, this.ClickOnSummrayBox) } SFFreeSpinHandler = Classify.constr(SFFreeSpinHandler).ext(FreeSpinHandler); SFFreeSpinHandler.prototype.ForceInit = function () { this.bh = false; this.jd = false }; SFFreeSpinHandler.prototype.InitFreeSpin = function () { this.m_IsRespin = false; this.m_AfterRespin = false; this.FreespinCorrection = 0; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_INIT; this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 3E3; this.fL = 0; this.K.Show(true); this.updateReelDefinitions() }; SFFreeSpinHandler.prototype.InitReSpin = function () { this.m_OriginalSpinners = []; this.m_AfterRespin = false; var reel, spinner; for (var i = 0; i < 5; i++) { reel = this.aQ.GetReel(i); spinner = reel.GetSpinner(); this.m_OriginalSpinners[i] = spinner; if (i !== 2) { if (this.C && spinner.state !== ReelSpinner.STATE_IDLE) spinner.stopped(); reel.SetSpinner(new EmptyReelSpinner(this.ao, reel, spinner.finalSymbols.concat())) } } if (!this.getIsRunning()) this.fL = getTimer() + 100; this.K.Show(true); this.m_ReelFlipper.showMidOverlay(); this.m_Logo.hide(this.C); this.m_HudBox.Show(true); this.m_CurrFreeSpinsText.SetText(Localizer.getInstance().getString("IDS_SF_RESPIN")); if (!this.C) { this.m_RaysRotate = 0; this.m_RaysBg.visible = true; this.m_RaysBg.alpha = 0; this.m_RaysTransform.visible = true; this.m_RaysTransform.alpha = 0; Tweener.AddTween({ obj: this.m_RaysBg, duration: 200, durationType: Tweener.MS, objectType: SJSTweener.TYPE_GENERIC, transition: Tweener.T_EASEOUTQUAD, properties: { alpha: 1 } }); Tweener.AddTween({ obj: this.m_RaysTransform, duration: 200, durationType: Tweener.MS, objectType: SJSTweener.TYPE_GENERIC, transition: Tweener.T_EASEOUTQUAD, properties: { alpha: 1 } }); this.m_CurrFreeSpinsText.SetPos({ y: freespin.hud.text.y + freespin.respiny }); this.m_CurrFreeSpinsText.Scale({ x: 2.5, y: 2.5 }); this.m_CurrFreeSpinsText.SetOpacity(0); this.m_HudLineGraph.visible = false; this.m_Dummy = { y: this.m_HudLineGraph.h / -2 + freespin.respiny, scale: 3.5, opacity: 0 }; Tweener.AddTween({ obj: this.m_Dummy, duration: 200, durationType: Tweener.MS, objectType: SJSTweener.TYPE_GENERIC, transition: Tweener.T_EASEOUTQUAD, onTick: this.m_DelegatedUpdateText, onComplete: this.m_DelegatedMoveText, properties: { scale: 1.5, opacity: 1 } }) } this.m_NearhitTriggerSnd.Play(0.8); this.m_NearhitSpinUpSnd.Play(0.6); this.m_NearhitLoopSnd.PlayFadeIn(1, 0.5, undefined, true, true) }; SFFreeSpinHandler.prototype.showLine = function () { this.m_HudLineGraph.visible = true }; SFFreeSpinHandler.prototype.moveText = function () { Tweener.AddTween({ obj: this.m_RaysBg, delay: 600, duration: 300, durationType: Tweener.MS, objectType: SJSTweener.TYPE_GENERIC, transition: Tweener.T_EASEOUTQUAD, properties: { alpha: 0 } }); Tweener.AddTween({ obj: this.m_RaysTransform, delay: 600, duration: 300, durationType: Tweener.MS, objectType: SJSTweener.TYPE_GENERIC, transition: Tweener.T_EASEOUTQUAD, onComplete: this.m_DelegatedHideRays, properties: { alpha: 0 } }); Tweener.AddTween({ obj: this.m_Dummy, delay: 700, duration: 500, durationType: Tweener.MS, objectType: SJSTweener.TYPE_GENERIC, transition: Tweener.T_EASEOUTQUAD, onStart: this.m_DelegatedShowLine, onTick: this.m_DelegatedUpdateText, properties: { y: this.m_HudLineGraph.h / -2, scale: 1 } }) }; SFFreeSpinHandler.prototype.hideRays = function () { this.m_RaysBg.visible = false; this.m_RaysTransform.visible = false }; SFFreeSpinHandler.prototype.updateText = function () { this.m_CurrFreeSpinsText.SetPos({ y: this.m_Dummy.y }); this.m_CurrFreeSpinsText.Scale({ x: this.m_Dummy.scale, y: this.m_Dummy.scale }); this.m_CurrFreeSpinsText.SetOpacity(this.m_Dummy.opacity) }; SFFreeSpinHandler.prototype.Go = function () { if (!this.getIsRunning()) { this.jd = true; if (!this.getIsRespin()) { this.UpdateFreeSpinHud(0); this.gF = this.C ? 1 : 1E3; this.m_IntroBox.gotoAndPlay(this.C ? "stop" : "back"); this.m_Logo.hide(this.C) } this.cP.FadeTo(0.5, 1); return true } return false }; SFFreeSpinHandler.prototype.OnSpinEnd = function () { if (this.getIsRespin()) { this.RestoreReels(); this.m_AfterRespin = true; if (this.getTotalFreeSpinWin() > 0) this.m_IsRespin = false; else; this.m_ReelFlipper.hideMidOverlay(); this.cP.FadeTo(0.5, 0.5) } else this.m_AfterRespin = false }; SFFreeSpinHandler.prototype.End = function () { if (!this.getIsRespin()) { this.cP.FadeOut(2); this.m_LoopSndIsPlaying = false; this.restoreReelDefinitions() } this.m_AnimState = this.getIsRespin() ? SFFreeSpinHandler.ANIMSTATE_COMPLETE : SFFreeSpinHandler.ANIMSTATE_CLOSING; this.NextAnim(); if (this.m_IsRespin) this.m_WasRespin = true; else this.m_WasRespin = false; this.m_IsRespin = false }; SFFreeSpinHandler.prototype.onNearHitReelStop = function () { this.m_NearhitStopSnd.Play(1) }; SFFreeSpinHandler.prototype.onNearHitReelStopping = function () { this.m_NearhitLoopSnd.FadeOut() }; SFFreeSpinHandler.prototype.RestoreReels = function () { if (this.m_OriginalSpinners === undefined) return; for (var i = 0, j = this.aQ.getNumReels() ; i < j; i++) this.aQ.GetReel(i).SetSpinner(this.m_OriginalSpinners[i]) }; SFFreeSpinHandler.prototype.showWonMsg = function (isAutoPlayOn, isRetrigger) { if (!this.C) { var str = isRetrigger ? Localizer.getInstance().getString("IDS_WON_ADD_X_FREESPINS") : Localizer.getInstance().getString("IDS_X_FREESPINS"); str = Str.Replace(str, "%d", this.qT); if (str) this.m_WonNumText.SetText(str); if (isRetrigger) this.m_IntroBox.gotoAndPlay("retrigger"); else { this.m_IntroBox.gotoAndPlay("start"); this.m_IntroBox.getSlot("pressSpin").getDisplay().gotoAndPlay(isAutoPlayOn ? "stop" : "loop") } if (!this.m_LoopSndIsPlaying) this.m_IntroSnd.Play(0.8); if (this.getIsRunning()) { this.gF = 7E3; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_RETRIGGER; this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 3E3 } } }; SFFreeSpinHandler.prototype.ShowSummaryBox = function () { this.m_TotalWinValue.SetText(CreditFormatter.FormatCoinValue(this.getTotalFreeSpinWin())); this.m_FullButton.visible = true; this.m_FullButton.view.click = this.m_DelegatedClickSummary; this.m_FullButton.view.tap = this.m_FullButton.view.click; this.m_SummaryBox.gotoAndPlay(this.C ? "summary_started" : "summary_start"); this.sY.Play(0.8, 0, false, false, 1) }; SFFreeSpinHandler.prototype.HideSummaryBox = function () { this.m_SummaryBox.gotoAndPlay(this.C ? "stop" : "summary_back"); this.m_FullButton.visible = false; this.m_FullButton.view.click = undefined; this.m_FullButton.view.tap = undefined }; SFFreeSpinHandler.prototype.ClickOnSummrayBox = function () { this.bZ = 1 }; SFFreeSpinHandler.prototype.Outro = function () { if (!this.getIsRespin()) { this.HideSummaryBox(); this.m_ReelFlipper.flip(this.C, ReelFlipper.DIR_BACK) } }; SFFreeSpinHandler.prototype.Complete = function () { this.jd = false; this.ao(FreeSpinHandler.COMPLETE); this.K.Show(false); this.m_HudBox.Show(false); this.m_Logo.show(this.C) }; SFFreeSpinHandler.prototype.UpdateFreeSpinHud = function (freespin) { if (freespin === undefined) freespin = this.getTotalFreeSpins() - this.getNumFreeSpins(); if (freespin === 0 || this.getIsRespin()) return; if (!this.m_HudBox.aP) this.m_HudBox.Show(true); var str = Localizer.getInstance().getString("IDS_FREESPIN_X_OF_Y"); str = Str.Replace(str, "%d", freespin - this.RespinCorrection); str = Str.Replace(str, "%t", this.getTotalFreeSpins() - this.RespinCorrection); if (str) this.m_CurrFreeSpinsText.SetText(str); this.FreespinCorrection = 0; this.colorHeaderText() }; SFFreeSpinHandler.prototype.colorHeaderText = function () { }; SFFreeSpinHandler.prototype.OnHasWins = function (targetVolume) { if (targetVolume === undefined) targetVolume = 5 }; SFFreeSpinHandler.prototype.NextAnim = function () { switch (this.m_AnimState) { case SFFreeSpinHandler.ANIMSTATE_INIT: this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 3500; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_FLIP; break; case SFFreeSpinHandler.ANIMSTATE_FLIP: this.m_ReelFlipper.flip(this.C, ReelFlipper.DIR_FWD); this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 2E3; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_FLIPPED; break; case SFFreeSpinHandler.ANIMSTATE_FLIPPED: this.m_IntroBox.gotoAndPlay("flipped"); this.cP.PlayFadeIn(0.2, 1, undefined, true, true); this.m_LoopSndIsPlaying = true; this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 1300; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_PRESS_SPIN; break; case SFFreeSpinHandler.ANIMSTATE_PRESS_SPIN: this.ao(FreeSpinHandler.SELECT); break; case SFFreeSpinHandler.ANIMSTATE_CLOSING: this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 1E3; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_SUMMARY; break; case SFFreeSpinHandler.ANIMSTATE_SUMMARY: this.ShowSummaryBox(); this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 4E3; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_OUTRO; break; case SFFreeSpinHandler.ANIMSTATE_OUTRO: this.Outro(); this.bZ = getTimer() + FreeSpinHandler.ANIMTIME_MULTIPLIER * 4E3; this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_COMPLETE; break; case SFFreeSpinHandler.ANIMSTATE_COMPLETE: this.Complete(); break; case SFFreeSpinHandler.ANIMSTATE_RETRIGGER: this.UpdateFreeSpinHud(); this.m_AnimState = SFFreeSpinHandler.ANIMSTATE_NONE; break } }; SFFreeSpinHandler.prototype.HandleOrientationChange = function (isPortrait) { }; SFFreeSpinHandler.prototype.updateReelDefinitions = function () { var spinner; for (var i = 0; i < 5; i++) { spinner = this.aQ.GetReel(i).GetSpinner(); this.m_OriginalDefinitions[i] = spinner.getReelDefinition(); spinner.setReelDefinition(this.m_FreespinReelDefinitions[i]) } }; SFFreeSpinHandler.prototype.restoreReelDefinitions = function () { var spinner; if (this.m_OriginalDefinitions.length > 0) for (var i = 0; i < 5; i++) { spinner = this.aQ.GetReel(i).GetSpinner(); spinner.setReelDefinition(this.m_OriginalDefinitions[i]) } this.m_OriginalDefinitions = [] }; SFFreeSpinHandler.prototype.startBigWin = function () { this.cP.FadeTo(0, 0.5) }; SFFreeSpinHandler.prototype.stopBigWin = function () { this.cP.FadeTo(0.5, 1) }; SFFreeSpinHandler.prototype.getIsRespin = function () { return this.m_IsRespin }; SFFreeSpinHandler.prototype.getIsAfterRespin = function () { return this.m_AfterRespin }; SFFreeSpinHandler.prototype.setIsRespin = function (value) { this.m_IsRespin = value }; SFFreeSpinHandler.prototype.getIsRunning = function () { return this.jd }; SFFreeSpinHandler.override("OnNextSpinTimer", function (e) { this._super(e); this.gF = 1; if (!this.getIsRespin()) this.UpdateFreeSpinHud() }); SFFreeSpinHandler.override("AddFreeSpins", function (num) { this._super(num); this.qT = num; if (num === 1) this.RespinCorrection += 1 }); SFFreeSpinHandler.override("Tick", function () { this._super(); if (this.m_RaysTransform.visible) this.m_RaysTransform.rotate(this.m_RaysRotate += 0.02); if (this.bZ > 0 && (getTimer() > this.bZ || this.C)) { this.bZ = 0; this.NextAnim() } }); SFFreeSpinHandler.override("Reset", function () { this._super(); this.RespinCorrection = 0 }); ReelFlipper.DIR_FWD = 0; ReelFlipper.DIR_BACK = 1; ReelFlipper.SYMBOLS_MIRRORED = true; function ReelFlipper(reelHandler, reelAnim, payboxes) { this.sL; this.ja = []; this.aQ = reelHandler; this.m_PayBoxes = payboxes; this.m_ReelsAnim = reelAnim; this.m_MidOverlay = this.m_ReelsAnim.getSlot("mid_overlay").getDisplay(); this.m_LastAnim = "stop"; this.m_PayBoxes.parent.cacheAsBitmap = true; this.m_FlipReelsSnd = new Snd("fsFlipReelsSnd"); this.m_DelegatedFlip2 = Utils.delegate(this, this.flipPart2); this.m_DelegatedFlipEnd = Utils.delegate(this, this.flipEnd) } ReelFlipper = Classify.constr(ReelFlipper); ReelFlipper.prototype.flip = function (reconnecting, dir) { this.sL = dir; if (this.m_LastAnim === "flipped" && this.sL === ReelFlipper.DIR_FWD || this.m_LastAnim === "stop" && this.sL === ReelFlipper.DIR_BACK) return; this.saveSymbols(); this.m_LastAnim = this.sL === ReelFlipper.DIR_FWD ? "flipped" : "stop"; if (!reconnecting) setTimeout(Utils.delegate(this, this.flipPart1), this.sL === ReelFlipper.DIR_FWD ? 1E3 : 2E3); else { this.m_ReelsAnim.gotoAndPlay(this.m_LastAnim); this.flipSymbols() } }; ReelFlipper.prototype.flipPart1 = function () { this.m_PayBoxes.parent.cacheAsBitmap = false; this.m_PayBoxes.gotoAndPlay("flip"); this.m_ReelsAnim.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, this.m_DelegatedFlip2); this.m_ReelsAnim.gotoAndPlay(this.sL === ReelFlipper.DIR_FWD ? "flip_1" : "flip_back1"); if (game_name === "superflipmobile") Tweener.AddTween({ obj: sjs.layers.background.fsbackground, duration: 1E3, durationType: Tweener.MS, objectType: SJSTweener.TYPE_SPRITE, transition: Tweener.T_EASEOUTQUAD, properties: { alpha: this.sL === ReelFlipper.DIR_FWD ? 1 : 0 } }); this.m_FlipReelsSnd.Play() }; ReelFlipper.prototype.flipPart2 = function () { this.m_ReelsAnim.armature.removeAllEventListeners(); this.flipSymbols(); this.m_ReelsAnim.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, this.m_DelegatedFlipEnd); this.m_ReelsAnim.gotoAndPlay(this.sL === ReelFlipper.DIR_FWD ? "flip_2" : "flip_back2") }; ReelFlipper.prototype.flipEnd = function () { this.m_ReelsAnim.armature.removeAllEventListeners(); this.m_PayBoxes.parent.cacheAsBitmap = true }; ReelFlipper.prototype.showMidOverlay = function () { if (this.m_MidOverlay.armature.animation.getLastAnimationName() !== "show") this.m_MidOverlay.gotoAndPlay("show") }; ReelFlipper.prototype.hideMidOverlay = function () { if (this.m_MidOverlay.armature.animation.getLastAnimationName() === "show") this.m_MidOverlay.gotoAndPlay("hide") }; ReelFlipper.prototype.saveSymbols = function () { this.ja = []; for (var col = 0, i = this.aQ.getNumReels() ; col < i; col++) { this.ja[col] = []; for (var row = 0, j = this.aQ.GetReel(col).getNumSymbols() ; row < j; row++) this.ja[col][row] = this.aQ.GetSymbol(col, row).GetSymbol() } }; ReelFlipper.prototype.flipSymbols = function () { this.ja.reverse(); var invSpinner, symbol, symbolIndex, display; for (var col = 0, i = this.aQ.getNumReels() ; col < i; col++) { invSpinner = this.aQ.GetReel(this.aQ.getNumReels() - col - 1).GetSpinner(); for (var row = 0; row < this.aQ.GetReel(col).getNumSymbols() ; row++) { symbolIndex = this.ja[col][row]; symbol = this.aQ.GetSymbol(col, row); symbol.SetSymbol(symbolIndex); symbol.Fade(symbol.GetSymbol() !== SFReelSymbol.SYMBOL_SCATTER); invSpinner.setCurrentSymbol(row, symbolIndex) } if (ReelFlipper.SYMBOLS_MIRRORED) { display = invSpinner.getDisplay(); display.scale.x *= -1; display.x -= symbol_size.w * display.scale.x } } }; ReelFlipper.prototype.HandleOrientationChange = function () { if (DEVICE.orientation === "pt") this.m_PayBoxes.parent.visible = false; else this.m_PayBoxes.parent.visible = true }; function SFReelManager(cb) { this._super(cb); this.m_FirstSymbolsChecked = []; this.m_CanceledQuickStop = false; this.dE = [0, 0, 0, 0, 0] } Classify.constr(SFReelManager).ext(ReelManager); SFReelManager.prototype.getSymbolsPerReel = function () { return this.GetReel(0).getNumSymbols() }; SFReelManager.prototype.setSuspense = function () { this.m_CanceledQuickStop = true }; SFReelManager.prototype.cancelQuickStop = function (reel) { var currT = this.dE[reel]; for (var i = reel; i < this.az; i++) { this.GetReel(i).GetSpinner().cancelQuickStop(); if (i === 4) currT += ReelSpinner.SLOWDOWN_TIME; else if (i > reel) currT += ReelSpinner.SLOWDOWN_TIME * 0.65; this.dE[i] = currT } this.du = false; this.m_CanceledQuickStop = true; this.ao("cancel_quickstop") }; SFReelManager.override("OnQuickStop", function (e) { var currentTime = getTimer(), minFullStopTime = this.fA + this.lQ, estimatedFullStopTime = currentTime + this.pg; if (this.az > this.bj && minFullStopTime > estimatedFullStopTime) currentTime += minFullStopTime - estimatedFullStopTime; this.du = true; this.aU = currentTime; for (var i = 0; i < this.az; i++) { this.GetReel(i).GetSpinner().quickStop(); this.dE[i] = currentTime + this.pg } }); SFReelManager.override("StartReels", function (e) { this._super(); this.m_CanceledQuickStop = false }); SFReelManager.override("InternalStopReels", function (delay) { if (delay === undefined) delay = 0; if (!this.cl) { this.SetReels(); this.cl = true } if (this.bj < this.az) if (this.eC) { var reel = this.nC[this.bj]; this.StopReel(reel, delay); this.bj++ } else if (this.du) { var scatterNum = 0, i, j, k = this.getSymbolsPerReel(), arr; for (i = 0; i < this.bj; i++) { arr = this.GetReel(i).GetSpinner().finalSymbols; for (j = 0; j < k; j++) if (arr[j] === SFReelSymbol.SYMBOL_SCATTER) scatterNum++ } if (scatterNum === 2 && this.bj < 5 && !this.m_CanceledQuickStop) { this.cancelQuickStop(i); return false } for (i = this.bj; i < this.az; i++) { arr = this.GetReel(i).GetSpinner().finalSymbols; for (j = 0; j < k; j++) if (arr[j] === SFReelSymbol.SYMBOL_SCATTER) scatterNum++; this.StopReel(i, this.eA ? 0 : delay); this.bj++; if (scatterNum === 2 && this.bj < 5 && !this.m_CanceledQuickStop) { this.cancelQuickStop(i); return false } } } else { this.StopReel(this.bj, delay); this.bj++ } else return true; return false }); SFReelManager.override("AddReel", function (reel) { this._super(reel); this.m_FirstSymbolsChecked[this.az - 1] = false }); SFReelManager.override("SetReels", function (reel) { this._super(reel); if (reel === undefined) reel = -1; var spinner; for (var reelNr = 0; reelNr < this.az; reelNr++) if ((reel === -1 || reel === reelNr) && this.m_FirstSymbolsChecked[reelNr] === false) { spinner = this.ab[reelNr].GetSpinner(); spinner.checkFirstSymbols(); spinner.setZIndices(); this.m_FirstSymbolsChecked[reelNr] = true } }); function SFReel(reelIndex, layer, reelSlot) { this.K = layer; this.da = reelIndex; this.bc = []; this.m_ReelSlot = reelSlot; this.dJ = 0; this.sJ = symbol_spacing.h; this.qr = undefined; this.aP = true; this.nk = function () { }; this.ja = []; this.dF; this.mh = false; this.uu = 0; this.ag = 0; this.uw = 0; this.L = reel_values_gen; var p = this.L; var startYOffset = p.reel_spin_img_height - p.reel_base_height; this.iW = [startYOffset]; var symbolSpinCycleSpeed = startYOffset / p.anim_cycle_length; for (var i = p.anim_cycle_length - 1; i >= 0; i--) this.iW.push(i * symbolSpinCycleSpeed) } SFReel.prototype.constructor = SFReel; SFReel.prototype.getIndex = function () { return this.da }; SFReel.prototype.GetVisible = function () { return this.aP }; SFReel.prototype.Show = function (b) { if (this.aP === b) return; this.aP = b; if (b) this.dF.show(); else this.dF.hide() }; SFReel.prototype.SetSpinner = function (spinner) { this.dF = spinner }; SFReel.prototype.GetSpinner = function () { return this.dF }; SFReel.prototype.SetSpinnerSymbols = function (index, symbolIndex) { this.dF.setFinalSymbol(index, symbolIndex) }; SFReel.prototype.AddSymbolMap = function (symbolMap) { this.qr = symbolMap }; SFReel.prototype.AddSymbol = function (symbol) { this.bc.push(symbol); this.ag++ }; SFReel.prototype.GetSymbol = function (index) { return this.bc[index] }; SFReel.prototype.GetSymbols = function () { return this.ja }; SFReel.prototype.ResetSymbol = function () { this.dJ = 0 }; SFReel.prototype.SetHalfStop = function (b) { }; SFReel.prototype.SetFreeSpinMode = function (b) { for (var i = 0, j = this.bc.length; i < j; i++) this.bc[i].SetFreeSpinMode(b) }; SFReel.prototype.ReconnectEnd = function () { }; SFReel.prototype.ClearAnimationData = function () { return }; SFReel.prototype.Animate = function (index, repeat, loopCycle) { if (!this.aP) return; this.bc[index].Animate() }; SFReel.prototype.StopSymbolAnimation = function () { if (!this.aP) return }; SFReel.prototype.getNumSymbols = function () { return this.bc.length }; SFReel.prototype.StartSpin = function (random) { if (!this.aP) return; this.mh = true; if (this.dF) this.dF.show(); var currSymbols = [this.bc[0].dJ, this.bc[1].dJ, this.bc[2].dJ]; if (this.dF) this.dF.start(currSymbols); for (var i = 0, j = this.bc.length; i < j; i++) this.bc[i].Clear() }; SFReel.prototype.StopSpin = function (direct, freespin, delay) { this.dF.stop() }; SFReel.prototype.SpinnerStopped = function () { this.mh = false; this.nk(this.da) }; SFReel.prototype.AnimateLine = function (num, line, firstFlag, startPos) { if (startPos === undefined) startPos = 0; for (var i = 0; i < num; i++) this.GetPaylineSymbol(startPos + i, line).Animate(firstFlag) }; SFReel.prototype.SetLayout = function (paylineLayouts) { this.bo = paylineLayouts }; SFReel.prototype.GetPaylineSymbolIndex = function (reel, payline) { var symbols = this.ab[0].getNumSymbols(); return this.bv[reel * symbols + this.bo[payline][reel]] }; SFReel.prototype.GetPaylineSymbol = function (reel, payline) { return this.ab[reel].GetSymbol(this.bo[payline][reel]) }; SFReel.prototype.StopAllAnimations = function () { for (var i = 0, j = this.bc.length; i < j; i++) this.bc[i].StopAnimation() }; SFReel.prototype.Ticker = function () { if (this.mh && this.dF) return this.dF.tick(); return false }; SFReel.prototype.setAdjacentSymbols = function (topAdjArray, bottomAdjArray) { if (this.dF && typeof this.dF.setAdjacentSymbols === "function") this.dF.setAdjacentSymbols(topAdjArray, bottomAdjArray) }; ReelSpinner.STATE_IDLE = 0; ReelSpinner.STATE_SPINNING = 1; ReelSpinner.STATE_STOPPING = 2; ReelSpinner.STATE_QUICKSTOP = 3; ReelSpinner.STATE_SLOWDOWN = 4; ReelSpinner.STATE_SLOWDOWN_BOUNCE = 5; ReelSpinner.STATE_STOPPED = 6; ReelSpinner.SPINUP_TIME = 1E3; ReelSpinner.STOPPING_TIME = 300; ReelSpinner.QUICKSTOP_TIME = 300; ReelSpinner.SLOWDOWN_TIME = 3500; ReelSpinner.SLOWDOWN_BOUNCE_TIME = 200; ReelSpinner.SLOWDOWN_BOUNCE_AMOUNT = 0.05; ReelSpinner.USE_COMPENSATION = true; ReelSpinner.COMPENSATION_THRESHOLD_MS = 22; ReelSpinner.COMPENSATION_TICKDELTA = 16; function ReelSpinner(symbols, rows, reelDefinition, bumperSymbol, symbolSpacing, reelHeight, index) { if (symbolSpacing === undefined) symbolSpacing = symbol_size.h; if (reelHeight === undefined) reelHeight = symbolSpacing * rows; this.symbols = symbols; this.rows = rows; this.reelDefinition = reelDefinition; this.symbolSpacing = symbolSpacing; this.height = reelHeight; this.index = index; this.symbolAtlas; this.finalSymbols = []; this.topAdjSymbols = []; this.bottomAdjSymbols = []; this.bottomAdjLength = 0; this.topAdjLength = 0; this.deltaY = 0; this.velocity = 0; this.maximumVelocity = 60; this.originalTarget = 0; this.startedWithAdjSymbols = false; this.startDirection = true; this.waitEndBounce = false; this.shouldQuickStop = false; this.shouldSlowDown = false; this.doubleBumper = false; this.firstSymbolsChecked = false; this.firstZIndicesChecked = false; this.currentStopAlgorithm = this._algoEnd; this.timer = 0; this.lastTime = 0; this.bounceStartedTime = 0; this.suspenseStopFactor = 1; for (var i = 0, j = this.symbols.length; i < j; i++) { this.symbols[i].SetX(0); this.symbols[i].SetY(this.symbolSpacing * i) } this.storedIndex = Utils.Rand(this.reelDefinition.length); this.nextBottom = this.reelDefinition[Utils.Rand(this.reelDefinition.length)]; this.bumper; this.topBumper; this.bottomBumper; if (typeof bumperSymbol === "object" && bumperSymbol.hasOwnProperty("topBumper") && bumperSymbol.hasOwnProperty("bottomBumper")) { this.doubleBumper = true; this.topBumper = bumperSymbol.topBumper; this.topBumper.SetY(this.symbolSpacing * -1); this.topBumper.SetSymbol(this.reelDefinition[this.storedIndex]); this.bottomBumper = bumperSymbol.bottomBumper; this.bottomBumper.SetSymbol(this.nextBottom); this.bottomBumper.SetY(this.symbolSpacing * this.symbols.length) } else { this.bumper = bumperSymbol; this.bumper.SetSymbol(this.nextBottom); this.bumper.SetY(this.symbolSpacing * symbols.length) } this.state = ReelSpinner.STATE_IDLE } ReelSpinner.prototype.constructor = ReelSpinner; ReelSpinner.prototype.start = function (currentSymbols) { if (!this.firstSymbolsChecked) console.error("First symbols were never checked against rules, ensure that overridden ReelManager calls the appropriate method (checkFirstSymbols)!!!"); if (!this.firstZIndicesSet) console.error("First symbols' Z indices were never checked against rules, ensure that overridden ReelManager calls the appropriate method (setZIndices)!!!"); if (this.topAdjSymbols.length > 0) { this.symbolAtlas = this.topAdjSymbols.concat(); this.startedWithAdjSymbols = true } else { this.symbolAtlas = this.reelDefinition.slice(this.storedIndex); this.startedWithAdjSymbols = false } this.currentSymbols = currentSymbols.concat(this.nextBottom); this.running = true; this.startDirection = true; this.waitEndBounce = false; this.stopping = false; this.shouldQuickStop = false; this.shouldSlowDown = false; this.topAdjSymbols = []; this.bottomAdjSymbols = []; this.topAdjLength = 0; this.bottomAdjLength = 0; this.velocity = 0; this.deltaY = 0; this.suspenseStopFactor = 1; this.checkSymbolAtlas(false); this.nextSymbols(true); this.timer = 0; this.lastTime = getTimer(); this.state = ReelSpinner.STATE_SPINNING }; ReelSpinner.prototype.tick = function () { if (this.state === ReelSpinner.STATE_IDLE || this.state === ReelSpinner.STATE_STOPPED) return false; var now = getTimer(); var frameTime = now - this.lastTime; this.lastTime = now; if (!ReelSpinner.USE_COMPENSATION || frameTime < ReelSpinner.COMPENSATION_THRESHOLD_MS) return this.updateReelSpinner(frameTime); else { var target = frameTime; var times = 0; do { if (!this.updateReelSpinner(ReelSpinner.COMPENSATION_TICKDELTA)) return false; target -= ReelSpinner.COMPENSATION_TICKDELTA; times++ } while (target >= ReelSpinner.COMPENSATION_TICKDELTA && times < 10) } return true }; ReelSpinner.prototype.updateReelSpinner = function (dt) { if (this.shouldSlowDown && this.shouldQuickStop) dt *= this.suspenseStopFactor; this.timer += dt; if (!this._updateState()) return false; this.updatePositions(); if (this.state === ReelSpinner.STATE_STOPPED) { this.stopped(); return false } return true }; ReelSpinner.prototype.updatePositions = function () { var prevDY = this.deltaY; this.deltaY += this.velocity; if (this.startDirection && prevDY < 0 && this.deltaY >= 0) { this.startDirection = false; this.waitEndBounce = true; if (!this.doubleBumper) { this.bumper.SetSymbol(this.currentSymbols[0]); this.setZIndices(false) } } else if (this.waitEndBounce && prevDY > 0 && this.deltaY <= 0) { this.waitEndBounce = false; this.onlastbounce(this.index); if (!this.doubleBumper) { this.bumper.SetSymbol(this.nextBottom); this.setZIndices(false) } } if (this.doubleBumper) { if (this.deltaY > this.symbolSpacing * 0.5) { var times = Math.floor(this.deltaY / this.symbolSpacing + 0.5); while (times-- > 0) this.nextSymbols(false); this.deltaY = (this.deltaY + this.symbolSpacing * 0.5) % this.symbolSpacing - this.symbolSpacing * 0.5 } this.topBumper.SetY(this.symbolSpacing * -1 + this.deltaY); this.bottomBumper.SetY(this.symbolSpacing * this.rows + this.deltaY); for (var i = 0; i < this.rows; i++) this.symbols[i].SetY(this.symbolSpacing * i + this.deltaY) } else { if (this.deltaY > this.symbolSpacing) { var times = Math.floor(this.deltaY / this.symbolSpacing); while (times-- > 0) this.nextSymbols(false); this.deltaY = this.deltaY % this.symbolSpacing } if (this.deltaY < 0) this.bumper.SetY(this.deltaY + this.rows * this.symbolSpacing); else this.bumper.SetY(this.deltaY - this.symbolSpacing); for (var i = 0; i < this.rows; i++) this.symbols[i].SetY(this.symbolSpacing * i + this.deltaY) } }; ReelSpinner.prototype.nextSymbols = function (start) { this.currentSymbols.unshift(this.symbolAtlas.shift()); if (this.currentSymbols.length > this.rows + 2) this.currentSymbols.pop(); for (var i = 0; i < this.rows; i++) this.symbols[i].SetSymbol(this.currentSymbols[i + 1]); var upcomingBottom = this.currentSymbols[this.rows + 1]; if (this.doubleBumper) { this.topBumper.SetSymbol(this.currentSymbols[0]); this.bottomBumper.SetSymbol(this.currentSymbols[this.rows + 1], true) } else if (start) this.bumper.SetSymbol(this.nextBottom); else this.bumper.SetSymbol(this.currentSymbols[0]); this.nextBottom = upcomingBottom; if (this.symbolAtlas.length === 0) { if (this.startedWithAdjSymbols) { this.startedWithAdjSymbols = false; this.symbolAtlas = this.reelDefinition.slice(this.storedIndex) } else this.symbolAtlas = this.reelDefinition.concat(); this.checkSymbolAtlas(false) } this.setZIndices(false) }; ReelSpinner.prototype.stop = function () { this.timer = 0; this.stopping = true; this.onreelstopping(this.index); var time = 0, algo; if (this.shouldQuickStop) { time = ReelSpinner.QUICKSTOP_TIME; algo = this._algoEnd } else if (this.shouldSlowDown) { time = ReelSpinner.SLOWDOWN_TIME; algo = this._algoEndSlow } else { time = ReelSpinner.STOPPING_TIME; algo = this._algoEnd } this.symbolAtlas = this.finalSymbols.concat().reverse(); var reverseDefinition = this.reelDefinition.concat().reverse(); this.storedIndex = Utils.Rand(reverseDefinition.length); this.checkFinalSymbols(true, reverseDefinition); var bAdj = this.bottomAdjSymbols.concat(); do { if (bAdj.length > 0) this.symbolAtlas.unshift(bAdj.shift()); else this.symbolAtlas.unshift(reverseDefinition[this.storedIndex % this.reelDefinition.length]); this.stopTarget = this.symbolSpacing * this.symbolAtlas.length - this.deltaY; this.virtualY = algo(17, 0, this.stopTarget, time); this.storedIndex++ } while (this.virtualY < this.velocity); this.storedIndex = Utils.Rand(this.reelDefinition.length); this.checkFinalSymbols(false, this.reelDefinition.concat()); if (this.topAdjSymbols.length > 0) this.symbolAtlas.push(this.topAdjSymbols[0]); else this.symbolAtlas.push(this.reelDefinition[this.storedIndex]); this.checkSymbolAtlas(true); if (this.state === ReelSpinner.STATE_STOPPING) return; if (this.shouldQuickStop) this.state = ReelSpinner.STATE_QUICKSTOP; else if (this.shouldSlowDown) this.state = ReelSpinner.STATE_SLOWDOWN; else this.state = ReelSpinner.STATE_STOPPING; this.virtualY = 0; this.stopTarget = this.symbolSpacing * this.symbolAtlas.length - this.deltaY; if (this.shouldSlowDown) { this.originalTarget = this.stopTarget; this.stopTarget += ReelSpinner.SLOWDOWN_BOUNCE_AMOUNT * this.symbolSpacing } }; ReelSpinner.prototype.stopped = function () { for (var i = 0; i < this.rows; i++) { this.symbols[i].SetY(this.symbolSpacing * i); this.symbols[i].SetSymbol(this.finalSymbols[i]) } if (this.doubleBumper) { this.topBumper.SetY(this.symbolSpacing * -1); this.topBumper.SetSymbol(this.currentSymbols[0]); this.bottomBumper.SetY(this.symbolSpacing * this.rows); this.bottomBumper.SetSymbol(this.currentSymbols[this.rows + 1]) } else { this.bumper.SetY(this.symbolSpacing * this.rows); this.bumper.SetSymbol(this.currentSymbols[this.rows + 1]) } this.setZIndices(true); this.state = ReelSpinner.STATE_IDLE; this.oncomplete(this.index) }; ReelSpinner.prototype.isStopping = function () { return this.state >= ReelSpinner.STATE_STOPPING && this.state <= ReelSpinner.STATE_SLOWDOWN_BOUNCE }; ReelSpinner.prototype.setFinalSymbol = function (row, symbolIndex) { this._checkOperationState(); this.finalSymbols[row] = symbolIndex }; ReelSpinner.prototype.setFinalSymbols = function (finalSymbolsArray) { this._checkOperationState(); this.finalSymbols = finalSymbolsArray }; ReelSpinner.prototype.setAdjacentSymbols = function (topAdjArray, bottomAdjArray) { this._checkOperationState(); this.topAdjSymbols = topAdjArray; this.topAdjLength = this.topAdjSymbols.length; this.bottomAdjSymbols = bottomAdjArray; this.bottomAdjLength = this.bottomAdjSymbols.length }; ReelSpinner.prototype.slowDown = function () { this.shouldSlowDown = true }; ReelSpinner.prototype.quickStop = function () { this.shouldQuickStop = true; if (this.state === ReelSpinner.STATE_SLOWDOWN) { var remainingTime = ReelSpinner.SLOWDOWN_TIME + ReelSpinner.SLOWDOWN_BOUNCE_TIME - this.timer; this.suspenseStopFactor = remainingTime / ReelSpinner.QUICKSTOP_TIME } }; ReelSpinner.prototype.cancelQuickStop = function () { this.shouldQuickStop = false; this.suspenseStopFactor = 1 }; ReelSpinner.prototype.destroy = function () { this.symbols = undefined; this.currentSymbols = undefined; this.symbolAtlas = undefined; this.bumper = undefined; this.topBumper = undefined; this.bottomBumper = undefined }; ReelSpinner.prototype.getReelDefinition = function () { return this.reelDefinition.concat() }; ReelSpinner.prototype.setReelDefinition = function (newReelDefinition) { this.reelDefinition = newReelDefinition; this.storedIndex = Utils.Rand(this.reelDefinition.length); this.checkFinalSymbols(false, this.reelDefinition.concat()) }; ReelSpinner.prototype.checkFirstSymbols = function () { this.firstSymbolsChecked = true }; ReelSpinner.prototype.checkSymbolAtlas = function (finalSymbols) { }; ReelSpinner.prototype.checkFinalSymbols = function (reversedAtStop, definition) { }; ReelSpinner.prototype.setZIndices = function (isStopped) { this.firstZIndicesSet = true }; ReelSpinner.prototype.onreelstopping = function (index) { }; ReelSpinner.prototype.onlastbounce = function (index) { }; ReelSpinner.prototype.oncomplete = function (index) { }; ReelSpinner.prototype.getDisplay = function () { return null }; ReelSpinner.prototype.setTarget = function (container) { }; ReelSpinner.prototype.show = function () { }; ReelSpinner.prototype.hide = function () { }; ReelSpinner.prototype.setX = function (x) { }; ReelSpinner.prototype.getX = function () { return 0 }; ReelSpinner.prototype.setY = function (y) { }; ReelSpinner.prototype.getY = function () { return 0 }; ReelSpinner.prototype._updateState = function () { switch (this.state) { case ReelSpinner.STATE_IDLE: return false; case ReelSpinner.STATE_SPINNING: this._spinning(); break; case ReelSpinner.STATE_STOPPING: if (this._stopping()) { this.timer = 0; this.state = ReelSpinner.STATE_STOPPED } break; case ReelSpinner.STATE_QUICKSTOP: if (this._quickstopping()) { this.timer = 0; this.state = ReelSpinner.STATE_STOPPED } break; case ReelSpinner.STATE_SLOWDOWN: if (this._slowdown()) { this.timer = 0; this.velocity = 0; this.virtualY = 0; this.bounceStartedTime = getTimer(); this.state = ReelSpinner.STATE_SLOWDOWN_BOUNCE } break; case ReelSpinner.STATE_SLOWDOWN_BOUNCE: if (this._slowdownBounce()) { this.timer = 0; this.state = ReelSpinner.STATE_STOPPED } break } return true }; ReelSpinner.prototype._spinning = function () { if (this.velocity < this.maximumVelocity) { var timer = Math.min(ReelSpinner.SPINUP_TIME, this.timer); this.velocity = this._algoStart(timer, 0, this.maximumVelocity, ReelSpinner.SPINUP_TIME) } else this.velocity = this.maximumVelocity }; ReelSpinner.prototype._stopping = function () { var timer = Math.min(ReelSpinner.STOPPING_TIME, this.timer), prev = this.virtualY; this.virtualY = this._algoEnd(timer, 0, this.stopTarget, ReelSpinner.STOPPING_TIME); this.velocity = this.virtualY - prev; return timer >= ReelSpinner.STOPPING_TIME }; ReelSpinner.prototype._quickstopping = function () { var timer = Math.min(ReelSpinner.QUICKSTOP_TIME, this.timer), prev = this.virtualY; this.virtualY = this._algoEnd(timer, 0, this.stopTarget, ReelSpinner.QUICKSTOP_TIME); this.velocity = this.virtualY - prev; return timer >= ReelSpinner.QUICKSTOP_TIME }; ReelSpinner.prototype._slowdown = function () { var timer = Math.min(ReelSpinner.SLOWDOWN_TIME, this.timer), prev = this.virtualY; this.virtualY = this._algoEndSlow(timer, 0, this.stopTarget, ReelSpinner.SLOWDOWN_TIME); if (this.virtualY <= this.originalTarget) { this.velocity = this.virtualY - prev; return false } else return true }; ReelSpinner.prototype._slowdownBounce = function () { var timer = this.timer, moveY = this._algoEndBounce(timer, 0, ReelSpinner.SLOWDOWN_BOUNCE_AMOUNT, ReelSpinner.SLOWDOWN_BOUNCE_TIME), prev = this.virtualY; this.virtualY = moveY * this.symbolSpacing; this.velocity = this.virtualY - prev; return timer > ReelSpinner.SLOWDOWN_BOUNCE_TIME }; ReelSpinner.prototype._checkOperationState = function () { if (this.state === ReelSpinner.STATE_IDLE || this.state === ReelSpinner.STATE_SPINNING) return; throw new Error("Operation not permitted at state:", this.state, "on reel:", this.index); }; ReelSpinner.prototype._algoStart = function (t, b, c, d) { var ts = (t /= d) * t; var tc = ts * t; return b + c * (tc * ts * -0.5 + ts * ts + tc * -1 + ts * 2 + t * -0.5) }; ReelSpinner.prototype._algoEnd = function (t, b, c, d) { var ts = (t /= d) * t; var tc = ts * t; return b + c * (tc * ts * 13.4 + ts * ts * -46.6 + tc * 61.4 + ts * -37.6 + t * 10.4) }; ReelSpinner.prototype._algoEndSlow = function (t, b, c, d) { var ts = (t /= d) * t; var tc = ts * t; return b + c * (tc + ts * -3 + t * 3) }; ReelSpinner.prototype._algoEndBounce = function (t, b, c, d) { return b + Math.sin(t / d * Math.PI) * c }; function EmptyReelSpinner(event, reel, finalSymbols) { this.ao = event; this.m_Reel = reel; this.bQ = false; this.state = 0; this.finalSymbols = finalSymbols } EmptyReelSpinner.prototype.constructor = EmptyReelSpinner; EmptyReelSpinner.prototype.Ticker = function (diff) { if (diff === undefined) diff = 0; if (!this.bQ) return false; return true }; EmptyReelSpinner.prototype.tick = function () { return this.running }; EmptyReelSpinner.prototype.show = function () { }; EmptyReelSpinner.prototype.hide = function () { }; EmptyReelSpinner.prototype.setFinalSymbol = function (row, symbolIndex) { }; EmptyReelSpinner.prototype.start = function () { }; EmptyReelSpinner.prototype.stop = function (abortFlag) { if (abortFlag === undefined) abortFlag = false; this.ao(SFFreeSpinHandler.REEL_STOP, this.m_Reel.da - 1) }; EmptyReelSpinner.prototype.getStarted = function () { return true }; EmptyReelSpinner.prototype.destroy = function () { }; EmptyReelSpinner.prototype.detach = function () { }; EmptyReelSpinner.prototype.quickStop = function () { }; EmptyReelSpinner.prototype.slowDown = function () { }; EmptyReelSpinner.prototype.isStopping = function () { return true }; function PixiReelSpinner(symbols, rows, reelDefinition, bumperSymbol, symbolSpacing, reelHeight, index) { this._super(symbols, rows, reelDefinition, bumperSymbol, symbolSpacing, reelHeight, index); this.m_Mask = new PIXI.Graphics; this.m_Mask.beginFill(16777215); this.m_Mask.drawRect(0, 0, symbol_size.w, this.height); this.cK = new PIXI.DisplayObjectContainer; this.cK.mask = this.m_Mask; this.cK.visible = true; this.cK.addChild(this.m_Mask); for (var i = 0, j = symbols.length; i < j; i++) this.cK.addChild(symbols[i].GetDisplay()); if (this.doubleBumper) { this.cK.addChild(this.topBumper.GetDisplay()); this.cK.addChild(this.bottomBumper.GetDisplay()) } else this.cK.addChild(this.bumper.GetDisplay()) } Classify.constr(PixiReelSpinner).ext(ReelSpinner); PixiReelSpinner.override("getDisplay", function () { return this.cK }); PixiReelSpinner.override("setTarget", function (container) { if (this.cK.parent) this.cK.parent.removeChild(this.cK); container.addChild(this.cK) }); PixiReelSpinner.override("show", function () { this.cK.visible = true }); PixiReelSpinner.override("hide", function () { this.cK.visible = false }); PixiReelSpinner.override("setX", function (x) { this.cK.x = x }); PixiReelSpinner.override("getX", function () { return this.cK.x }); PixiReelSpinner.override("setY", function (y) { this.cK.y = y }); PixiReelSpinner.override("getY", function () { return this.cK.y }); PixiReelSpinner.override("destroy", function () { this._super(); if (this.cK.parent) this.cK.parent.removeChild(this.cK) }); SFReelSpinner.superSpeed = false; SFReelSpinner.useStepper = false; function SFReelSpinner(symbols, rows, reelDefinition, symbolSpacing, reelHeight, index) { this._super(symbols, rows, reelDefinition, new SFReelSymbol(index, -1, 0, -symbol_spacing.h, true), symbolSpacing, reelHeight, index); this.m_Mask.clear(); this.m_Mask.drawRect(-symbol_size.w, 0, symbol_size.w * 3, this.height) } Classify.constr(SFReelSpinner).ext(PixiReelSpinner); SFReelSpinner.prototype.setCurrentSymbol = function (row, symbol) { this.currentSymbols[row + 1] = symbol }; SFReelSpinner.override("checkFinalSymbols", function (reversedAtStop, definition) { var serverSymbols = this.finalSymbols.concat(), originalIndex = this.storedIndex; if (this.bottomAdjSymbols !== null && this.bottomAdjSymbols.length > 0) serverSymbols = serverSymbols.concat(this.bottomAdjSymbols.slice(0, this.bottomAdjLength)); if (this.topAdjSymbols !== null && this.topAdjSymbols.length > 0) serverSymbols = serverSymbols.concat(this.topAdjSymbols.slice(0, this.topAdjLength)); if (serverSymbols.indexOf(SFReelSymbol.SYMBOL_WILD) === -1) serverSymbols.push(SFReelSymbol.SYMBOL_WILD); if (serverSymbols.indexOf(SFReelSymbol.SYMBOL_SCATTER) === -1) serverSymbols.push(SFReelSymbol.SYMBOL_SCATTER); if (SFReelSpinner.useStepper) while (serverSymbols.indexOf(definition[this.storedIndex]) > -1) { this.storedIndex += reversedAtStop ? -1 : 1; if (this.storedIndex === originalIndex) throw new Error("Unable to find proper plus adjacent symbol"); else if (this.storedIndex < 0) this.storedIndex = definition.length - 1; else if (this.storedIndex > definition.length - 1) this.storedIndex = 0 } else { var tmp = []; for (var i = 0; i < SFReelSymbol.SYMBOL_NUM; i++) if (serverSymbols.indexOf(i) === -1 && definition.indexOf(i) > -1) tmp.push(i); if (tmp.length === 0) throw new Error("Unable to find proper plus adjacent symbol"); var newSymbol = tmp[Utils.Rand(tmp.length)]; if (reversedAtStop) this.bottomAdjSymbols.push(newSymbol); else this.topAdjSymbols.push(newSymbol) } }); SFReelSymbol.SYMBOL_LP1 = 0; SFReelSymbol.SYMBOL_LP2 = 1; SFReelSymbol.SYMBOL_LP3 = 2; SFReelSymbol.SYMBOL_LP4 = 3; SFReelSymbol.SYMBOL_HP1 = 4; SFReelSymbol.SYMBOL_HP2 = 5; SFReelSymbol.SYMBOL_HP3 = 6; SFReelSymbol.SYMBOL_HP4 = 7; SFReelSymbol.SYMBOL_HP5 = 8; SFReelSymbol.SYMBOL_WILD = 9; SFReelSymbol.SYMBOL_SCATTER = 10; SFReelSymbol.SYMBOL_NUM = 11; SFReelSymbol.faderNames = ["lp1_fade.png", "lp2_fade.png", "lp3_fade.png", "lp4_fade.png", "hp1_fade.png", "hp2_fade.png", "hp3_fade.png", "hp4_fade.png", "hp5_fade.png", "wild_fade.png", "scatter_fade.png"]; SFReelSymbol.firstFrameNamesSuper = ["_bitmaps/symbols/LP1.png", "_bitmaps/symbols/LP2.png", "_bitmaps/symbols/LP3.png", "_bitmaps/symbols/LP4.png", "_bitmaps/symbols/HP1.png", "_bitmaps/symbols/HP2.png", "_bitmaps/symbols/HP3.png", "_bitmaps/symbols/HP4.png", "_bitmaps/symbols/HP5.png", "_bitmaps/symbols/WILD.png", "_bitmaps/symbols/SCATTER.png"]; SFReelSymbol.firstFrameNamesDanish = ["_bitmaps/symbols/LP1.png", "_bitmaps/symbols/LP2.png", "_bitmaps/symbols/LP3.png", "_bitmaps/symbols/LP4.png", "_bitmaps/symbols/HP1_first.png", "_bitmaps/symbols/HP2_first.png", "_bitmaps/symbols/HP3_first.png", "_bitmaps/symbols/HP4_first.png", "_bitmaps/symbols/HP5_first.png", "_bitmaps/symbols/WILD.png", "_bitmaps/symbols/SCATTER.png"]; SFReelSymbol.armaturePool = new ArmaturePool; SFReelSymbol.StaticTextures = {}; SFReelSymbol.GenerateStaticTexture = function () { var arr = game_name === "superflipmobile" ? SFReelSymbol.firstFrameNamesSuper : SFReelSymbol.firstFrameNamesDanish; for (var i = 0; i < SFReelSymbol.SYMBOL_NUM; i++) SFReelSymbol.StaticTextures[i] = PIXI.Texture.fromFrame(arr[i]) }; function SFReelSymbol(reelIndex, rowIndex, x, y, isBumper) { if (isBumper === undefined) isBumper = false; this.m_Point = { x: x, y: y }; this.fk = false; this.da = reelIndex; this.iC = rowIndex; this.m_IsBumper = isBumper; this.aN = false; this.dJ = -1; this.bh = false; this.ad = false; this.m_ScatterAnim = false; this.bP; this.m_Armature; this.cK = new PIXI.DisplayObjectContainer; this.H = new PIXI.Sprite(SFReelSymbol.StaticTextures[0]); this.cK.addChild(this.H); this.m_DelegatedAnimEnd = Utils.delegate(this, this.animEnd); this.m_DelegatedPlayFreespinIdle = Utils.delegate(this, this.playFreespinIdle) } SFReelSymbol.prototype.constructor = SFReelSymbol; Object.defineProperty(SFReelSymbol.prototype, "x", { get: function () { return this.cK.x }, set: function (value) { this.cK.x = value } }); Object.defineProperty(SFReelSymbol.prototype, "y", { get: function () { return this.cK.y }, set: function (value) { this.cK.y = value } }); Object.defineProperty(SFReelSymbol.prototype, "globalX", { get: function () { return this.H.worldTransform.tx } }); Object.defineProperty(SFReelSymbol.prototype, "globalY", { get: function () { return this.H.worldTransform.ty } }); Object.defineProperty(SFReelSymbol.prototype, "width", { get: function () { return this.H.width } }); Object.defineProperty(SFReelSymbol.prototype, "height", { get: function () { return this.H.height } }); SFReelSymbol.prototype.SetX = function (value) { this.cK.x = value }; SFReelSymbol.prototype.GetX = function () { return this.cK.x }; SFReelSymbol.prototype.SetY = function (value) { this.cK.y = value }; SFReelSymbol.prototype.GetY = function () { return this.cK.y }; SFReelSymbol.prototype.getRowIndex = function () { return this.iC }; SFReelSymbol.prototype.GetSymbol = function () { return this.dJ }; SFReelSymbol.prototype.SetSymbol = function (symbolIndex) { if (this.dJ !== symbolIndex) { this.dJ = symbolIndex; this.H.setTexture(SFReelSymbol.StaticTextures[this.dJ]); if (this.m_IsBumper) return; this.addFader(); this.clearArmature() } }; SFReelSymbol.prototype.GetDisplay = function () { return this.cK }; SFReelSymbol.prototype.SetFreeSpinMode = function (b) { this.bh = b }; SFReelSymbol.prototype.getFreeSpinMode = function () { return this.bh }; SFReelSymbol.prototype.addFader = function () { if (this.m_IsBumper) return; var name = SFReelSymbol.faderNames[this.dJ]; if (this.m_FaderSprite === undefined) { this.m_FaderSprite = PIXI.Sprite.fromImage(name); this.m_FaderSprite.alpha = 0.4; this.cK.addChild(this.m_FaderSprite) } else this.m_FaderSprite.texture = PIXI.Texture.fromFrame(name); this.m_FaderSprite.visible = false }; SFReelSymbol.prototype.Fade = function (val) { if (this.m_IsBumper) return; this.m_FaderSprite.visible = val }; SFReelSymbol.prototype.playFreespinLand = function () { if (this.m_IsBumper || this.C) return; this.setArmature(); this.bP.armature.removeAllEventListeners(); this.bP.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, this.m_DelegatedPlayFreespinIdle); this.bP.gotoAndPlay("land"); this.m_ScatterAnim = true }; SFReelSymbol.prototype.playFreespinIdle = function () { if (this.m_IsBumper) return; this.bP.armature.removeAllEventListeners(); this.bP.gotoAndPlay("loop"); this.m_ScatterAnim = true }; SFReelSymbol.prototype.playFreespinWin = function () { if (this.m_IsBumper) return; this.setArmature(); this.bP.armature.removeAllEventListeners(); this.bP.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, this.m_DelegatedAnimEnd); this.bP.gotoAndPlay("win"); this.m_ScatterAnim = true }; SFReelSymbol.prototype.clearFreespinLand = function () { if (this.m_IsBumper || !this.m_ScatterAnim) return; this.setArmature(); this.bP.armature.removeAllEventListeners(); this.bP.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, this.m_DelegatedAnimEnd); this.bP.gotoAndPlay("lose"); this.m_ScatterState = SFReelSymbol.SCATTER_STATE_LOOSE }; SFReelSymbol.prototype.animEnd = function (idx) { if (this.m_IsBumper) return; this.H.visible = true; this.bP.armature.removeAllEventListeners(); this.bP.armature.animation.stop(); this.bP.visible = false }; SFReelSymbol.prototype.Animate = function (firstTime) { if (this.m_IsBumper) return; if (firstTime === undefined) firstTime = true; this.aN = firstTime; this.Fade(false); if (this.aN) { this.setArmature(); if (this.dJ !== SFReelSymbol.SYMBOL_SCATTER) this.fk ? this.idle() : this.win() } }; SFReelSymbol.prototype.AnimationComplete = function () { this.removeAnimation() }; SFReelSymbol.prototype.removeAnimation = function () { if (this.m_IsBumper) return; this.clearArmature() }; SFReelSymbol.prototype.StopAnimation = function () { this.Clear() }; SFReelSymbol.prototype.OnQuickView = function (e) { this.fk = true }; SFReelSymbol.prototype.idle = function (label) { }; SFReelSymbol.prototype.win = function (label) { if (this.m_IsBumper) return; if (label === undefined) label = "win"; this.setArmature(); this.bP.gotoAndPlay(label) }; SFReelSymbol.prototype.destroy = function () { }; SFReelSymbol.prototype.Clear = function () { this.clearArmature(); this.aN = false; this.fk = false; this.cK.visible = true; this.H.visible = true; this.m_FaderSprite.visible = false }; SFReelSymbol.prototype.Ticker = function () { }; SFReelSymbol.prototype.clearArmature = function () { if (this.m_IsBumper) return; if (this.bP && this.bP.armature) { if (this.bP.parent) this.bP.parent.removeChild(this.bP); this.bP.armature.removeAllEventListeners(); this.bP.armature.dispose(); this.bP = undefined; this.m_Armature.dispose(); this.m_Armature = undefined; this.H.visible = true } }; SFReelSymbol.prototype.setArmature = function (id) { if (this.m_IsBumper) return; id = id === undefined ? this.dJ : id; var name = "_symbols/symbol" + (id + 1).toString() + "/symbol" + (id + 1).toString(); if (this.bP && this.bP.armature && this.bP.armature.name === name) return; if (this.bP && this.bP.armature) this.clearArmature(); if (this.bP === undefined) { this.m_Armature = new PixiArmature(name); this.bP = this.m_Armature.getDisplay(); this.bP.gotoAndPlay("stop"); this.bP.x = -this.bP.getLocalBounds().x; this.bP.y = -this.bP.getLocalBounds().y; this.bP.visible = true; this.cK.addChild(this.bP); this.cK.addChild(this.m_FaderSprite); this.H.visible = false } if (this.dJ === SFReelSymbol.SYMBOL_WILD && this.cK.parent) { if (this.cK.parent.parent) this.cK.parent.parent.addChild(this.cK.parent); this.cK.parent.addChild(this.cK) } }; SFReelSymbol.prototype.show = function (b) { this.cK.visible = b }; function Paytable() { this._super(Localizer.getInstance().getString("IDS_BTN_PAYTABLE")); this.m_View = DOMHelper.createDiv("paytable"); this.m_MaximumWin; this.qr = { lp1: "_bitmaps/symbols/LP1.png", lp2: "_bitmaps/symbols/LP2.png", lp3: "_bitmaps/symbols/LP3.png", lp4: "_bitmaps/symbols/LP4.png", hp1: "_bitmaps/symbols/HP1.png", hp2: "_bitmaps/symbols/HP2.png", hp3: "_bitmaps/symbols/HP3.png", hp4: "_bitmaps/symbols/HP4.png", hp5: "_bitmaps/symbols/HP5.png", wild: "_bitmaps/symbols/WILD.png", scatter: "_bitmaps/symbols/SCATTER.png" }; this.m_SymbolMapDanish = { lp1: "_bitmaps/symbols/LP1.png", lp2: "_bitmaps/symbols/LP2.png", lp3: "_bitmaps/symbols/LP3.png", lp4: "_bitmaps/symbols/LP4.png", hp1: "_bitmaps/symbols/HP1_first.png", hp2: "_bitmaps/symbols/HP2_first.png", hp3: "_bitmaps/symbols/HP3_first.png", hp4: "_bitmaps/symbols/HP4_first.png", hp5: "_bitmaps/symbols/HP5_first.png", wild: "_bitmaps/symbols/WILD.png", scatter: "_bitmaps/symbols/SCATTER.png" }; this.m_ScreenshotsMap = { ss1: "seq1_1.png", ss2: "seq1_2.png", ss3: "seq1_3.png", ss4: "seq1_4.png", ss5: "seq1_5.png", ss6: "seq2_1.png", ss7: "seq2_2.png", ss8: "seq2_3.png", ss9: "seq2_4.png", ss10: "seq2_5.png" }; this.m_View.appendChild(this.createScatterSection()); this.m_View.appendChild(document.createElement("hr")); this.m_View.appendChild(this.createWildSection()); this.m_View.appendChild(document.createElement("hr")); this.m_View.appendChild(this.createHPSymbolTable()); this.m_View.appendChild(document.createElement("hr")); this.m_View.appendChild(this.createLPSymbolTable()); this.m_View.appendChild(document.createElement("hr")); this.m_View.appendChild(this.createPaylines()); this.m_freespinSlideShow = new HTMLSlideShow(".paytable_slideshow .paytable_screenshot_freespin"); this.m_respinSlideShow = new HTMLSlideShow(".paytable_slideshow .paytable_screenshot_respin") } Classify.constr(Paytable).ext(MenuItem); Paytable.override("onFocusIn", function () { this.m_StatsTimeOut = setTimeout(function () { StatsHandler.HandleEvent("showpaytable") }, 3E3) }); Paytable.override("onFocusOut", function () { clearTimeout(this.m_StatsTimeOut) }); Paytable.prototype.appendSymbol = function (parent, name, className, symbol) { var arr = game_name === "superflipmobile" ? this.qr : this.m_SymbolMapDanish; var texture = PIXI.Texture.fromFrame(arr[symbol]); var imageData = { x: texture.crop.x, y: texture.crop.y, w: texture.crop.width, h: texture.crop.height }; return DOMHelper.createImageFromSpriteSheet(parent, name, className, texture.baseTexture.source.src, imageData) }; Paytable.prototype.appendScreenshot = function (parent, name, className, ss) { var texture = PIXI.Texture.fromFrame(this.m_ScreenshotsMap[ss]); var imageData = { x: texture.crop.x, y: texture.crop.y, w: texture.crop.width, h: texture.crop.height }; return DOMHelper.createImageFromSpriteSheet(parent, name, className, texture.baseTexture.source.src, imageData) }; Paytable.prototype.createScatterSection = function () { var i; var section = DOMHelper.createDiv("paytable_scatter"); var header = document.createElement("h2"); header.appendChild(document.createTextNode(Localizer.getInstance().getString("IDS_SCATTER"))); section.appendChild(header); var table = section.appendChild(document.createElement("table")); var scatterRow = table.appendChild(document.createElement("tr")); var symbolContainer = scatterRow.appendChild(document.createElement("td")); this.appendSymbol(symbolContainer, undefined, undefined, "scatter"); var payoutContainer = scatterRow.appendChild(document.createElement("td")); var data = { symbol: "scatter", payout: [250, 40, 2] }; payoutContainer.appendChild(this.createPayoutTableRight(data)); var rightOfSymbol = DOMHelper.createAndAppendDiv(scatterRow, "paytable_scatter_right", "paytable_scatter_info_right"); this.createParagraph(Localizer.getInstance().getString("IDS_PT_SF_FREESPINTEXT"), rightOfSymbol); var belowSymbol = DOMHelper.createAndAppendDiv(section, "paytable_scatter_below"); var heading = document.createElement("h1"); heading.innerHTML = Localizer.getInstance().getString("IDS_PT_RR_FREESPIN").replace("15", "15"); belowSymbol.appendChild(heading); var slideDiv1 = DOMHelper.createDiv("ss_table1", "paytable_slideshow"); var ss_table1 = belowSymbol.appendChild(slideDiv1); for (i = 1; i < 6; i++) this.appendScreenshot(ss_table1, undefined, "paytable_screenshot_freespin", "ss" + i.toString()); this.createParagraph(Localizer.getInstance().getString("IDS_PT_FREESPINLIMIT").replace("%d", "90"), belowSymbol); this.createParagraph(Localizer.getInstance().getString("IDS_PT_SCATTER_MONEY"), belowSymbol); this.m_MaximumWin = document.createElement("h1"); this.m_MaximumWin.innerHTML = Localizer.getInstance().getString("IDS_WINUPTO") + " 10000x"; belowSymbol.appendChild(this.m_MaximumWin); heading = document.createElement("h1"); heading.innerHTML = Localizer.getInstance().getString("IDS_RESPIN_UC"); belowSymbol.appendChild(heading); var slideDiv2 = DOMHelper.createDiv("ss_table2", "paytable_slideshow"); var ss_table2 = belowSymbol.appendChild(slideDiv2); for (i = 6; i < 11; i++) this.appendScreenshot(ss_table2, undefined, "paytable_screenshot_respin", "ss" + i.toString()); this.createParagraph(Localizer.getInstance().getString("IDS_PT_SF_RESPINTEXT"), belowSymbol); heading = document.createElement("h1"); belowSymbol.appendChild(heading); belowSymbol.appendChild(heading); heading = document.createElement("h1"); heading.innerHTML = Localizer.getInstance().getString("IDS_PT_SF_RESPINTEXT2"); belowSymbol.appendChild(heading); return section }; Paytable.prototype.createWildSection = function () { var section = DOMHelper.createDiv("paytable_wild"); var header = document.createElement("h2"); header.appendChild(document.createTextNode(Localizer.getInstance().getString("IDS_WILD"))); section.appendChild(header); var table = section.appendChild(document.createElement("table")); var wildRow = table.appendChild(document.createElement("tr")); var symbolContainer = wildRow.appendChild(document.createElement("td")); this.appendSymbol(symbolContainer, undefined, undefined, "wild"); var payoutContainer = wildRow.appendChild(document.createElement("td")); var data = { symbol: "wild", payout: [250, 100, 50] }; payoutContainer.appendChild(this.createPayoutTableRight(data)); var wildInfo = DOMHelper.createAndAppendDiv(wildRow, "paytable_scatter_right", "paytable_scatter_info_right"); this.createParagraph(Localizer.getInstance().getString("IDS_PT_RTR_WILD"), wildInfo); return section }; Paytable.prototype.createHPSymbolTable = function () { var section = DOMHelper.createDiv("paytable_hpsymbols", "paytable_symbols"); var data = [{ symbol: "hp5", payout: [250, 100, 50] }, { symbol: "hp4", payout: [80, 40, 20] }, { symbol: "hp3", payout: [80, 40, 20] }]; section.appendChild(this.createPayoutTable(data)); data = [{ symbol: "hp2", payout: [40, 20, 10] }, { symbol: "hp1", payout: [40, 20, 10] }]; section.appendChild(this.createPayoutTable(data)); this.hpSymbolsSection = section; return section }; Paytable.prototype.createLPSymbolTable = function () { var section = DOMHelper.createDiv("paytable_lpsymbols", "paytable_symbols"); data = [{ symbol: "lp4", payout: [20, 10, 5] }, { symbol: "lp3", payout: [20, 10, 5] }, { symbol: "lp2", payout: [20, 10, 5] }, { symbol: "lp1", payout: [20, 10, 5] }]; section.appendChild(this.createPayoutTable(data)); this.lpSymbolsSection = section; return section }; Paytable.prototype.createPayoutTable = function (data) { var table = document.createElement("table"); table.id = "paytable_payout"; var tr, td, i, j; tr = table.appendChild(document.createElement("tr")); for (i = 0; i < data.length; i++) { td = tr.appendChild(document.createElement("td")); td.className = "paytable_symbol_gap"; td = tr.appendChild(document.createElement("td")); this.appendSymbol(td, undefined, "paytable_payout_symbol", data[i].symbol) } for (i = 5; i > 5 - data[0].payout.length; i--) { tr = table.appendChild(document.createElement("tr")); for (j = 0; j < data.length; j++) { td = tr.appendChild(document.createElement("td")); td.className = "paytable_symbol_count"; td.appendChild(document.createTextNode(i)); var payout = data[j].payout[5 - i].toString(); if (payout === "0") payout = "-"; td = tr.appendChild(document.createElement("td")); td.className = "paytable_payout_value"; td.appendChild(document.createTextNode(payout)) } } return table }; Paytable.prototype.createPayoutTableRight = function (data) { var table = document.createElement("table"); table.id = "paytable_payout"; var i, j, tr, td; for (i = 5; i > 5 - data.payout.length; i--) { tr = table.appendChild(document.createElement("tr")); td = tr.appendChild(document.createElement("td")); td.className = "paytable_symbol_count_right"; td.appendChild(document.createTextNode(i)); var payout = data.payout[5 - i].toString(); if (payout === "0") payout = "-"; td = tr.appendChild(document.createElement("td")); td.className = "paytable_payout_value_right"; td.appendChild(document.createTextNode(payout)) } return table }; Paytable.prototype.createPaylines = function () { var section = DOMHelper.createDiv("paytable_paylines"); var paylines = [this.createPayline([1, 1, 1, 1, 1]), this.createPayline([0, 0, 0, 0, 0]), this.createPayline([2, 2, 2, 2, 2]), this.createPayline([0, 1, 2, 1, 0]), this.createPayline([2, 1, 0, 1, 2]), this.createPayline([1, 0, 0, 0, 1]), this.createPayline([1, 2, 2, 2, 1]), this.createPayline([0, 0, 1, 2, 2]), this.createPayline([2, 2, 1, 0, 0]), this.createPayline([1, 2, 1, 0, 1]), this.createPayline([1, 0, 1, 2, 1]), this.createPayline([0, 1, 1, 1, 0]), this.createPayline([2, 1, 1, 1, 2]), this.createPayline([0, 1, 0, 1, 0]), this.createPayline([2, 1, 2, 1, 2]), this.createPayline([1, 1, 0, 1, 1]), this.createPayline([1, 1, 2, 1, 1]), this.createPayline([0, 0, 2, 0, 0]), this.createPayline([2, 2, 0, 2, 2]), this.createPayline([0, 2, 2, 2, 0])]; var table = document.createElement("table"); var i, j, tr, td; for (i = 0; i < 4; i++) { tr = table.appendChild(document.createElement("tr")); for (j = 0; j < 5; j++) { var index = j + i * 5; td = tr.appendChild(document.createElement("td")); td.className = "paytable_paylines_numbers"; td.appendChild(document.createTextNode(index + 1)); td = tr.appendChild(document.createElement("td")); td.className = "paytable_paylines_payline"; td.appendChild(paylines[index]) } } section.appendChild(table); this.createParagraph(Localizer.getInstance().getString("IDS_PT_STANDARDTEXT_MONEY"), section); return section }; Paytable.prototype.createPayline = function (path) { var table = document.createElement("table"); table.className = "paytable_payline"; var i, j, tr, td; for (i = 0; i < 3; i++) { tr = table.appendChild(document.createElement("tr")); for (j = 0; j < 5; j++) { td = tr.appendChild(document.createElement("td")); if (path[j] === i) td.style.backgroundColor = "#f17b06" } } return table }; Paytable.prototype.createParagraph = function (text, parent, className) { var paragraph = document.createElement("p"); if (className) paragraph.className = className; paragraph.innerHTML = text; if (parent) parent.appendChild(paragraph); return paragraph }; Paytable.prototype.setHighestDenomination = function (denomination) { var maxWin = 1E4 * 100, str = ""; str += Localizer.getInstance().getString("IDS_WINUPTO"); str += " "; str += CreditFormatter.GetCreditString(maxWin, Utils.DenominationString(maxWin * denomination)); if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) { str += " "; str += Localizer.getInstance().getString("IDS_SLOT_COINS") } this.m_MaximumWin.innerHTML = str }; Paytable.prototype.show = function (b) { this.m_freespinSlideShow.show(b); this.m_respinSlideShow.show(b) }; Paytable.prototype.HandleOrientationChange = function () { var t = ""; if (DEVICE.orientation === "pt") { t = "scale(0.8) translateX(" + paytable_pt_hp_translate_x.toString() + "px)"; this.hpSymbolsSection.style.transform = t; this.hpSymbolsSection.style["-webkit-transform"] = t; this.hpSymbolsSection.style["-moz-transform"] = t; t = "scale(0.7) translateX(" + paytable_pt_lp_translate_x.toString() + "px)"; this.lpSymbolsSection.style.transform = t; this.lpSymbolsSection.style["-webkit-transform"] = t; this.lpSymbolsSection.style["-moz-transform"] = t } else { this.hpSymbolsSection.style.transform = t; this.hpSymbolsSection.style["-webkit-transform"] = t; this.hpSymbolsSection.style["-moz-transform"] = t; this.lpSymbolsSection.style.transform = t; this.lpSymbolsSection.style["-webkit-transform"] = t; this.lpSymbolsSection.style["-moz-transform"] = t } }; SlideAnimator.STATE_CROSSFADE = 0; SlideAnimator.STATE_WAIT = 1; SlideAnimator.TIME_CROSSFADE = 1E3; SlideAnimator.TIME_WAIT = 750; function SlideAnimator(array, callback) { this.callback = callback; this._items = array; this._running = false; this._nextAnimTime; this._currItemIdx; this._state } SlideAnimator.prototype.constructor = SlideAnimator; SlideAnimator.prototype.isRunning = function () { return this._running }; SlideAnimator.prototype.getSequenceTime = function () { return this._items.length * (SlideAnimator.TIME_CROSSFADE + SlideAnimator.TIME_WAIT) + SlideAnimator.TIME_CROSSFADE }; SlideAnimator.prototype.init = function (delay) { delay = typeof delay === "undefined" ? 0 : delay; var i, j; for (i = 0, j = this._items.length; i < j; i++) { this._items[i].visible = false; this._items[i].alpha = 0 } this._prevItemIdx = 0; this._currItemIdx = 0; this._items[this._currItemIdx].visible = true; this._items[this._currItemIdx].alpha = 1; this._timeout = setTimeout(Utils.delegate(this, this.start), delay) }; SlideAnimator.prototype.start = function () { clearTimeout(this._timeout); this._running = true; this._state = SlideAnimator.STATE_WAIT; this._nextAnimTime = getTimer() + SlideAnimator.TIME_WAIT }; SlideAnimator.prototype.end = function () { this._running = false }; SlideAnimator.prototype.tick = function () { if (!this._running) return; if (this._nextAnimTime <= getTimer()) this.switchState(); if (this._state === SlideAnimator.STATE_CROSSFADE) { this.tween(this._items[this._prevItemIdx], 0); this.tween(this._items[this._currItemIdx], 1) } }; SlideAnimator.prototype.tween = function (item, alphaTo) { item.visible = true; item.alpha += 0.2 * (alphaTo - item.alpha); if (item.alpha < 0.05) item.visible = false; else if (item.alpha > 0.95) item.alpha = 1 }; SlideAnimator.prototype.switchState = function () { switch (this._state) { case SlideAnimator.STATE_CROSSFADE: this._nextAnimTime = getTimer() + SlideAnimator.TIME_CROSSFADE; this._state = SlideAnimator.STATE_WAIT; break; case SlideAnimator.STATE_WAIT: if (typeof this.callback === "function" && this._currItemIdx === this._items.length - 1) { this.callback(); return } this._prevItemIdx = this._currItemIdx; this._currItemIdx = this.getNextItemIdx(); this._nextAnimTime = getTimer() + SlideAnimator.TIME_CROSSFADE; this._state = SlideAnimator.STATE_CROSSFADE; break } }; SlideAnimator.prototype.getNextItemIdx = function () { return this._currItemIdx + 1 === this._items.length ? 0 : this._currItemIdx + 1 }; function HTMLSlideShow(query) { this._query = query; this._items = []; this._counter = 1; this._firstTime = true } HTMLSlideShow.prototype.show = function (b) { if (b) { this._items = document.querySelectorAll(this._query); var firstTimeItem = this._items[0]; this.setinterval = setInterval(Utils.delegate(this, this.slideShow, this._items), 3E3); if (this._firstTime) { this.atFirstTime(firstTimeItem); this._firstTime = false } } else clearInterval(this.setinterval) }; HTMLSlideShow.prototype.slideShow = function (items) { var items = items, numItems = items.length; var itemToShow = Math.abs(this._counter % numItems);[].forEach.call(items, function (el) { el.classList.remove("show") }); items[itemToShow].classList.add("show"); this._counter++ }; HTMLSlideShow.prototype.atFirstTime = function (item) { item.classList.add("show") }; function BigWinEmitter(mc, pool, density) { this.hD = 0; this.pR = 0; this._super(mc, pool); if (density <= 0) density = 1; this.pR = density } BigWinEmitter = Classify.constr(BigWinEmitter).ext(Emitter); BigWinEmitter.createPool = function (size, mc) { return new Pool(size, BigWinEmitterItem, mc) }; BigWinEmitter.prototype.setDensity = function (density) { if (density <= 0) density = 1; this.pR = density }; BigWinEmitter.override("start", function () { this._super(); this.hD = 0 }); BigWinEmitter.override("tickCompleted", function () { if (this.ee.parent === undefined) return; if (this.hD++ % this.pR === 0) { var item1 = this.ko.add(); if (item1) item1.init(this) } }); BigWinEmitter.override("getPos", function (o) { return { x: Utils.RandRange(-50, 50), y: 0 } }); BigWinEmitterItem = function () { this._super(); this.hD; this.nU; this.nq; this.m_Vr; this.ee; this.hY = 1; this.mPos = big_win.particles; if (!BigWinEmitterItem.contentClass) { BigWinEmitterItem.contentClass = []; var basetexture = PIXI.BaseTexture.fromImage(image_path_game + "big_win_animation_objects.png"); for (var i = 0; i < 8; i++) { var texture = new PIXI.Texture(basetexture, new PIXI.Rectangle(i * big_win.particles.w, big_win.particles.yoffset, big_win.particles.w, big_win.particles.h)); BigWinEmitterItem.contentClass.push(texture) } } this.sprite = new PIXI.Sprite(BigWinEmitterItem.contentClass[Math.floor(Math.random() * BigWinEmitterItem.contentClass.length)]); this.sprite.scale.x = 1.2; this.sprite.scale.y = 1.2; this.sprite.pivot.x = this.mPos.w / 2; this.sprite.pivot.y = this.mPos.w / 2; this.addChild(this.sprite) }; BigWinEmitterItem = Classify.constr(BigWinEmitterItem).ext(Particle); BigWinEmitterItem.override("init", function (emitter) { this._super(emitter); this.nU = (Math.random() - 0.5) * 20; this.nq = (Math.random() - 6) * 7; this.m_Vr = Math.random() * 0.5 - 0.25; this.hD = 50 }); BigWinEmitterItem.override("tick", function (part) { this.x += this.nU * part; this.y += this.nq * part; this.sprite.rotation += this.m_Vr }); BigWinEmitterItem.override("tickCompleted", function () { this.nq += this.mPos.ymoverate; this.hD--; return this.hD > 0 }); SFOnScreenPaytableHandler.DIRECTION_RIGHT = 0; SFOnScreenPaytableHandler.DIRECTION_LEFT = 1; function SFOnScreenPaytableHandler(entity, mc, hitFieldContainer, reelHandler, settings, gameController, paytableHandler, featurePreview) { if (this.constructor !== arguments.callee) return new SFOnScreenPaytableHandler(entity, mc, hitFieldContainer, reelHandler, settings, gameController, paytableHandler, featurePreview); this.m_Entity = entity; this.ee = mc; this.m_HitFieldContainer = hitFieldContainer; this.aQ = reelHandler; this.bG = settings; this.m_GameController = gameController; this.m_PaytableHandler = paytableHandler; this.m_FeaturePreview = featurePreview; this.m_Display; this.m_Transform; this.m_EntityAnimator; this.m_Toggled; this.m_ReelSymbol; this.ag; this.af; this.K = sjs.layers.onscreenpaytablecontent; this.m_Bg = new sjs.Sprite(image_path_game + "on_screen_paytable.png", this.K, undefined, onscreenpaytable.size); var tp = onscreenpaytable.right; this.m_FiveNum = new Textfield(this.K, tp.num, "5", false, "osp_numbers", undefined, undefined, true); this.m_FourNum = new Textfield(this.K, tp.num, "4", false, "osp_numbers", undefined, undefined, true); this.m_ThreeNum = new Textfield(this.K, tp.num, "3", false, "osp_numbers", undefined, undefined, true); this.m_FiveText = new Textfield(this.K, tp.text, "5", false, "osp_win_numbers", undefined, undefined, true); this.m_FourText = new Textfield(this.K, tp.text, "5", false, "osp_win_numbers", undefined, undefined, true); this.m_ThreeText = new Textfield(this.K, tp.text, "5", false, "osp_win_numbers", undefined, undefined, true); this.m_ScatterText = new Textfield(this.K, tp.stext, Str.Replace(Localizer.getInstance().getString("IDS_PT_THREE_TRIGGER_FREESPIN"), "%d", "3"), false, "osp_text", true); this.m_WildText = new Textfield(this.K, tp.stext, Localizer.getInstance().getString("IDS_PT_RTR_WILD"), false, "osp_text", true); this.ag = 0; this.bB = []; var i, j, k, l, reel, button, tpos; for (i = 0, k = this.aQ.getNumReels() ; i < k; i++) { reel = this.aQ.GetReel(i); for (j = 0, l = reel.getNumSymbols() ; j < l; j++) { button = new Button(sjs.layers["onscreenpaytable"], { w: symbol_size.w, h: symbol_size.h }, Utils.delegate(this, function (reel, row, index) { this.onClick(reel, row, index) }, i, j, this.ag), undefined, undefined, " ", "control", undefined, undefined, undefined, undefined); tpos = { x: symbol_spacing.w * i, y: symbol_spacing.h * j }; this.ag++; button.SetPos(tpos); this.bB.push(button) } } this.af = [[20, 10, 5], [20, 10, 5], [20, 10, 5], [20, 10, 5], [40, 20, 10], [40, 20, 10], [80, 40, 20], [80, 40, 20], [250, 100, 50], [250, 100, 50], [250, 40, 2]]; this.K.Show(false); this.m_enabled = false }; SFOnScreenPaytableHandler.prototype.constructor = SFOnScreenPaytableHandler; SFOnScreenPaytableHandler.prototype.onClick = function (reel, row, index) { var symbol = this.aQ.GetSymbol(reel, row); var direction = index < this.ag / 2 + 1 ? SFOnScreenPaytableHandler.DIRECTION_RIGHT : SFOnScreenPaytableHandler.DIRECTION_LEFT; if (this.m_GameController.m_State === VideoSlot.WAITINGSPIN) { var offsx = symbol_size.w * 1.5; this.show(symbol, symbol.H.parent.parent.parent.x - offsx, symbol.H.parent.y, direction, index) } }; SFOnScreenPaytableHandler.prototype.show = function (symbol, x, y, direction, index) { if (this.K.aP && this.aL === index) { this.K.Show(false); return } this.K.Show(true); this.aL = index; var p; switch (direction) { case SFOnScreenPaytableHandler.DIRECTION_LEFT: this.K.x = x - onscreenpaytable.left.xadj; this.K.y = y; this.m_Bg.scale(-1, 1); if (symbol.dJ === SFReelSymbol.SYMBOL_SCATTER || symbol.dJ === SFReelSymbol.SYMBOL_WILD) { this.m_FiveText.SetText(""); this.m_FourText.SetText(""); this.m_ThreeText.SetText(""); this.m_FiveNum.SetText(""); this.m_FourNum.SetText(""); this.m_ThreeNum.SetText(""); p = onscreenpaytable.left.stext; if (symbol.dJ === SFReelSymbol.SYMBOL_SCATTER) { this.m_WildText.SetText(""); this.m_ScatterText.SetText(Str.Replace(Localizer.getInstance().getString("IDS_PT_THREE_TRIGGER_FREESPIN"), "%d", "3")); this.m_ScatterText.SetPos(p.stextpos) } else { this.m_WildText.SetText(Localizer.getInstance().getString("IDS_PT_RTR_WILD")); this.m_WildText.SetPos(p.stextpos); this.m_ScatterText.SetText("") } return } p = onscreenpaytable.left.text; this.m_FiveText.SetPos(p.five); this.m_FourText.SetPos(p.four); this.m_ThreeText.SetPos(p.three); p = onscreenpaytable.left.num; this.m_FiveNum.SetPos(p.five); this.m_FourNum.SetPos(p.four); this.m_ThreeNum.SetPos(p.three); break; case SFOnScreenPaytableHandler.DIRECTION_RIGHT: this.K.x = x - onscreenpaytable.right.xadj; this.K.y = y; this.m_Bg.scale(1, 1); if (symbol.dJ === SFReelSymbol.SYMBOL_SCATTER || symbol.dJ === SFReelSymbol.SYMBOL_WILD) { this.m_FiveText.SetText(""); this.m_FourText.SetText(""); this.m_ThreeText.SetText(""); this.m_FiveNum.SetText(""); this.m_FourNum.SetText(""); this.m_ThreeNum.SetText(""); p = onscreenpaytable.right.stext; if (symbol.dJ === SFReelSymbol.SYMBOL_SCATTER) { this.m_ScatterText.SetText(Str.Replace(Localizer.getInstance().getString("IDS_PT_THREE_TRIGGER_FREESPIN"), "%d", "3")); this.m_ScatterText.SetPos(p.stextpos); this.m_WildText.SetText("") } else { this.m_WildText.SetText(Localizer.getInstance().getString("IDS_PT_RTR_WILD")); this.m_WildText.SetPos(p.stextpos); this.m_ScatterText.SetText("") } return } var p = onscreenpaytable.right.text; this.m_FiveText.SetPos(p.five); this.m_FourText.SetPos(p.four); this.m_ThreeText.SetPos(p.three); p = onscreenpaytable.right.num; this.m_FiveNum.SetPos(p.five); this.m_FourNum.SetPos(p.four); this.m_ThreeNum.SetPos(p.three); break } this.m_FiveText.SetText(this.af[symbol.dJ][0]); this.m_FourText.SetText(this.af[symbol.dJ][1]); this.m_ThreeText.SetText(this.af[symbol.dJ][2]); this.m_FiveNum.SetText("5"); this.m_FourNum.SetText("4"); this.m_ThreeNum.SetText("3"); this.m_ScatterText.SetText(""); this.m_WildText.SetText("") }; SFOnScreenPaytableHandler.prototype.enable = function (b) { if (this.ad !== b) { this.ad = b; this.K.Show(b && this.dJ !== undefined); for (var i in this.bB) this.bB[i].setInteractive(b) } }; function GameSplashScreen(gameId, removecb, toggleSoundCB) { var ret = new SplashScreen(gameId, removecb); ret.toggleSoundCB = toggleSoundCB; return ret } GameSplashScreen.prototype.constructor = GameSplashScreen; SplashScreen.prototype.CreateContent = function (handler) { handler.fpBgLayer = new sjs.Layer("fpBgLayer", undefined, sjs.layers.splashscreen); handler.background = new sjs.Sprite(image_path_game + "bg_normal.jpg", handler.fpBgLayer, splashscreen_pos.bgimg); handler.fpContentLayer = new sjs.Layer("fpContentLayer", undefined, sjs.layers.splashscreen, undefined, splashscreen_pos.layers.containerlayer.ls); handler.fpContentLayer.Origin("center", "center"); handler.fpContentLayer.Scale(1.1, 1.1); handler.logo = new PixiArmature("LOGO/Logo"); handler.logoDisplay = handler.logo.getDisplay(); handler.innerLogo = handler.logo.getSlot("i_logo").getDisplay(); handler.fpContentLayer.view.addChild(handler.logoDisplay); handler.setHighestDenomination = SplashScreen.prototype.setHighestDenomination; handler._toggleSound = SplashScreen.prototype._toggleSound; handler.onScatterTimeout = SplashScreen.prototype.onScatterTimeout; handler.delegatedOnScatterTimeout = Utils.delegate(handler, SplashScreen.prototype.onScatterTimeout); handler.delegatedNextScatterAnim = Utils.delegate(handler, SplashScreen.prototype.nextScatterAnim); handler.decorOverlay = new sjs.Sprite(image_path_game + "splashscreen.png", handler.fpBgLayer, undefined, splashscreen_pos.content.decorOverlay); handler.decorOverlay.offset(splashscreen_pos.content.decorOverlay.offsets.x, splashscreen_pos.content.decorOverlay.offsets.y); handler.freespinsPanel = new sjs.Layer("freespinsLayer", undefined, handler.fpBgLayer, undefined, splashscreen_pos.layers.containerlayer.ls); handler.scatter0 = new PixiArmature("_symbols/symbol11/symbol11"); handler.scatter0.getDisplay().x = splashscreen_pos.content.symbolScatter.x; handler.scatter0.getDisplay().y = splashscreen_pos.content.symbolScatter.y; handler.scatter0.getDisplay().scaleX = splashscreen_pos.content.symbolScatter.scale; handler.scatter0.getDisplay().scaleY = handler.scatter0.getDisplay().scaleX; handler.freespinsPanel.view.addChild(handler.scatter0.getDisplay()); handler.scatter1 = new PixiArmature("_symbols/symbol11/symbol11"); handler.scatter1.getDisplay().x = splashscreen_pos.content.symbolScatter1.x; handler.scatter1.getDisplay().y = splashscreen_pos.content.symbolScatter1.y; handler.scatter1.getDisplay().scaleX = splashscreen_pos.content.symbolScatter.scale; handler.scatter1.getDisplay().scaleY = handler.scatter1.getDisplay().scaleX; handler.freespinsPanel.view.addChild(handler.scatter1.getDisplay()); handler.scatter2 = new PixiArmature("_symbols/symbol11/symbol11"); handler.scatter2.getDisplay().x = splashscreen_pos.content.symbolScatter2.x; handler.scatter2.getDisplay().y = splashscreen_pos.content.symbolScatter2.y; handler.scatter2.getDisplay().scaleX = splashscreen_pos.content.symbolScatter.scale; handler.scatter2.getDisplay().scaleY = handler.scatter2.getDisplay().scaleX; handler.freespinsPanel.view.addChild(handler.scatter2.getDisplay()); new Textfield(handler.freespinsPanel, splashscreen_pos.content.txtLabelFreespins, Localizer.getInstance().getString("IDS_FREESPINS_HEADER"), "", "ss_title", false, true); new Textfield(handler.freespinsPanel, splashscreen_pos.content.txtFreespin, Localizer.getInstance().getString("IDS_PT_SF_FREESPINTEXT"), "", "ss_common", true, true); handler._slideAnimatorsArray = []; handler._panelsId = 0; handler._nextAnimTime = -1; handler.STATE_CROSSFADE = 0; handler.STATE_WAIT = 1; handler.TIME_CROSSFADE = 1E3; handler._state = handler.STATE_WAIT; var freespinSlider = new PIXI.DisplayObjectContainer; freespinSlider.x = splashscreen_pos.content.slider.x; freespinSlider.y = splashscreen_pos.content.slider.y; freespinSlider.scale = new PIXI.Point(0.6, 0.6); handler.freespinsPanel.view.addChild(freespinSlider); var array = [], i; for (i = 0; i < 5; i++) { array[i] = new PIXI.Sprite(PIXI.Texture.fromFrame("seq1_" + (i + 1).toString() + ".png")); freespinSlider.addChild(array[i]) } handler._slideAnimatorsArray[0] = new SlideAnimator(array, Utils.delegate(handler, this.flipParents)); handler.respinPanel = new sjs.Layer("respinLayer", undefined, handler.fpBgLayer, undefined, splashscreen_pos.layers.containerlayer.ls); handler.respinPanel.view.alpha = 0; new Textfield(handler.respinPanel, splashscreen_pos.content.txtLabelRespin, Localizer.getInstance().getString("IDS_RESPIN_UC"), "", "ss_title", true, true); new Textfield(handler.respinPanel, splashscreen_pos.content.txtRespin, Localizer.getInstance().getString("IDS_FP_SF_RESPINTEXT"), "", "ss_common_big", true, true); var respinSlider = new PIXI.DisplayObjectContainer; respinSlider.x = splashscreen_pos.content.slider.x; respinSlider.y = splashscreen_pos.content.slider.y; respinSlider.scale = new PIXI.Point(0.6, 0.6); handler.respinPanel.view.addChild(respinSlider); array = []; for (i = 0; i < 5; i++) { array[i] = new PIXI.Sprite(PIXI.Texture.fromFrame("seq2_" + (i + 1).toString() + ".png")); respinSlider.addChild(array[i]) } handler._slideAnimatorsArray[1] = new SlideAnimator(array, Utils.delegate(handler, this.flipParents)); handler._panelsArray = []; handler._panelsArray[0] = handler.freespinsPanel; handler._panelsArray[1] = handler.respinPanel }; SplashScreen.prototype.flipParents = function () { this._panelsId = this._panelsId + 1 & this._panelsArray.length - 1; for (var i = 0, j = this._slideAnimatorsArray.length; i < j; i++) this._slideAnimatorsArray[i].end(); this._panelsArray[this._panelsId].view.visible = true; this._slideAnimatorsArray[this._panelsId].init(1E3); this._state = this.STATE_CROSSFADE; this._nextAnimTime = getTimer() + this.TIME_CROSSFADE }; SplashScreen.prototype.CreateButtons = function (handler) { handler.qw = new Button(handler.fpContentLayer, handler.L.content.continue_btn, Utils.delegate(handler, handler.OnContinue), image_path_game + "splashscreen_ui.png", Localizer.getInstance().getString("IDS_BTN_CONTINUE"), undefined, "splash_continue_btn_cap_superflip"); handler.qw.H.setBounds(handler.L.content.continue_btn.sprite); handler.oj = new Button(handler.fpContentLayer, handler.L.content.checkbox.btn, Utils.delegate(handler, handler.ToggleSaveCookie), image_path_game + "splashscreen_ui.png", undefined, ""); handler.oj.H.setBounds(handler.L.content.checkbox.btn); new Textfield(handler.fpContentLayer, handler.L.content.checkbox.textfield, Localizer.getInstance().getString("IDS_DONTSHOWAGAIN"), undefined, "splash_checkbox_cap_superflip", true); handler._tweenChainButtonSprite = new TweenChain(handler.qw.H, Tweener.SECONDS); handler._tweenChainButtonSprite.QueueTween({ xscale: 1.1, yscale: 1.1 }, 0.1); handler._tweenChainButtonSprite.QueueTween({ xscale: 0.9, yscale: 0.9 }, 0.15); handler._tweenChainButtonSprite.QueueTween({ xscale: 1, yscale: 1 }, 0.2); handler._tweenChainButtonText = new TweenChain(handler.qw.T, Tweener.SECONDS); handler._tweenChainButtonText.QueueTween({ xscale: 1.1, yscale: 1.1 }, 0.1); handler._tweenChainButtonText.QueueTween({ xscale: 0.9, yscale: 0.9 }, 0.15); handler._tweenChainButtonText.QueueTween({ xscale: 1, yscale: 1 }, 0.2); handler.m_WinUpToTextfield = new Textfield(handler.fpContentLayer, splashscreen_pos.content.txtWinUpTo, Localizer.getInstance().getString("IDS_WINUPTO") + " 10000x", "", "ss_winupto", true, true) }; SplashScreen.prototype._toggleSound = function () { this.toggleSoundCB(0, true); this.m_ToggleSound.Checked(SoundManager.IsEnabled()) }; SplashScreen.prototype.HandleOrientationChange = function () { sjs.layers.splashscreen.Scale(scale_layer_pos[DEVICE.orientation].scale, scale_layer_pos[DEVICE.orientation].scale); sjs.layers.splashscreen.setBounds(scale_layer_pos[DEVICE.orientation]); if (DEVICE.orientation === "ls") sjs.layers.splashscreen.Origin("center", "78.813559322033898305084745762712%"); else sjs.layers.splashscreen.Origin("center", "bottom"); var orient = DEVICE.orientation; this.logoDisplay.scaleX = splashscreen_pos.content.logo[orient].scale; this.logoDisplay.scaleY = this.logoDisplay.scaleX; this.logoDisplay.x = splashscreen_pos.content.logo[orient].x; this.logoDisplay.y = splashscreen_pos.content.logo[orient].y; sjs.layers.splashscreencontainer.setBounds({ x: splashscreen_pos.layers.containerlayer[DEVICE.orientation].x, y: splashscreen_pos.layers.containerlayer[DEVICE.orientation].y, w: splashscreen_pos.layers.containerlayer[DEVICE.orientation].w, h: splashscreen_pos.layers.containerlayer[DEVICE.orientation].h }); sjs.layers.splashscreencontainer.Scale(splashscreen_pos.layers.containerlayer[DEVICE.orientation].scale, splashscreen_pos.layers.containerlayer[DEVICE.orientation].scale) }; SplashScreen.prototype.onScatterTimeout = function () { this.innerLogo.gotoAndPlay("idle"); var sct; for (var i = 0; i < 3; i++) { sct = this["scatter" + i.toString()]; sct.gotoAndPlay("land"); sct.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, this.delegatedNextScatterAnim) } this._tweenChainButtonSprite.PlayChain(); this._tweenChainButtonText.PlayChain(); this._timeout = setTimeout(this.delegatedOnScatterTimeout, Utils.RandRange(3E3, 6E3)) }; SplashScreen.prototype.nextScatterAnim = function () { var sct; for (var i = 0; i < 3; i++) { sct = this["scatter" + i.toString()]; sct.removeAllEventListeners(); sct.gotoAndPlay("win") } }; SplashScreen.prototype.setHighestDenomination = function (denomination) { var maxWin = 1E4 * 100, str = ""; str += Localizer.getInstance().getString("IDS_WINUPTO"); str += " "; str += CreditFormatter.GetCreditString(maxWin, Utils.DenominationString(maxWin * denomination)); if (CreditFormatter.Display(CreditFormatter.CREDITDISPLAY_COINS)) { str += " "; str += Localizer.getInstance().getString("IDS_SLOT_COINS") } this.m_WinUpToTextfield.SetText(str) }; SplashScreen.prototype.Show = function (value) { if (value) { this.onScatterTimeout(); this._slideAnimatorsArray[this._panelsId].init() } else { clearTimeout(this._timeout); for (var i = 0, j = this._slideAnimatorsArray.length; i < j; i++) this._slideAnimatorsArray[i] = null; for (i = 0, j = this._panelsArray.length; i < j; i++) this._panelsArray[i] = null } this.K.Show(value) }; SplashScreenHandler.prototype.tick = function () { for (var i = 0, j = this._slideAnimatorsArray.length; i < j; i++) this._slideAnimatorsArray[i].tick(); if (this._nextAnimTime <= getTimer()) this.switchState(); if (this._state === this.STATE_CROSSFADE) { var temp = this.getLastItemIdx(); this.tween(this._panelsArray[temp].view, 0); this.tween(this._panelsArray[this._panelsId].view, 1) } }; SplashScreenHandler.prototype.switchState = function () { this._state = this.STATE_WAIT }; SplashScreenHandler.prototype.tween = function (item, alphaTo) { item.visible = true; item.alpha += (alphaTo - item.alpha) * 0.2; if (item.alpha < 0.05) item.visible = false; else if (item.alpha > 0.95) item.alpha = 1 }; SplashScreenHandler.prototype.getLastItemIdx = function () { return this._panelsId - 1 === -1 ? this._panelsArray.length - 1 : this._panelsId - 1 }; function SFLogo() { this.m_View = (new PixiArmature("LOGO/Logo")).getDisplay(); this.m_View.gotoAndPlay("stop"); this.m_View.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, Utils.delegate(this, this.cacheLogo)); this.K = sjs.layers.logo; this.K.view.addChild(this.m_View); this.m_InnerView = this.m_View.getSlot("i_logo").getDisplay(); this.m_InnerView.armature.addEventListener(dragonBones.events.AnimationEvent.COMPLETE, Utils.delegate(this, this.cacheLogo)); this.m_Hidden = false; this.m_MysteryEnabled = false } SFLogo = Classify.constr(SFLogo); SFLogo.prototype.show = function (reconnecting) { this.m_Hidden = false; if (DEVICE.orientation === "ls") if (this.m_View.armature.animation.getLastAnimationName() !== "stop") { this.K.view.cacheAsBitmap = false; this.m_View.gotoAndPlay(reconnecting ? "stop" : "show") } }; SFLogo.prototype.hide = function (reconnecting) { this.m_Hidden = true; if (DEVICE.orientation === "ls" || this.m_MysteryEnabled) if (this.m_View.armature.animation.getLastAnimationName() !== "hidden") { this.K.view.cacheAsBitmap = false; this.m_View.gotoAndPlay(reconnecting ? "hidden" : "hide") } }; SFLogo.prototype.win = function () { if (this.m_InnerView.armature.animation.getLastAnimationName() === "stop") { this.K.view.cacheAsBitmap = false; this.m_InnerView.gotoAndPlay("win") } }; SFLogo.prototype.idle = function () { if (this.m_InnerView.armature.animation.getLastAnimationName() === "stop") { this.K.view.cacheAsBitmap = false; this.m_InnerView.gotoAndPlay("idle") } }; SFLogo.prototype.HandleOrientationChange = function () { if (this.m_Hidden) { this.K.view.cacheAsBitmap = false; if (DEVICE.orientation === "ls" || this.m_MysteryEnabled) this.m_View.gotoAndPlay("hidden"); else this.m_View.gotoAndPlay("stop") } this.K.setBounds(game_bgr_pos.logo.layer[DEVICE.orientation]); this.K.SetScale(game_bgr_pos.logo.layer[DEVICE.orientation].scale) }; SFLogo.prototype.cacheLogo = function () { this.K.view.cacheAsBitmap = true }; SFLogo.prototype.enableMysteryJackpot = function () { this.m_MysteryEnabled = true; game_bgr_pos.logo.layer.pt.y = game_bgr_pos.logo.layer.pt.mystery_y; if (DEVICE.orientation === "pt") { this.K.setBounds(game_bgr_pos.logo.layer[DEVICE.orientation]); this.K.SetScale(game_bgr_pos.logo.layer[DEVICE.orientation].scale) } }; SFLogo.prototype.chekFinalState = function () { this.m_InnerView.gotoAndPlay("stop"); if (this.m_Hidden && (DEVICE.orientation === "ls" || this.m_MysteryEnabled)) this.m_View.gotoAndPlay("hidden"); else this.m_View.gotoAndPlay("stop") }; Game.ALLOW_QUICKSTOP_AUTOPLAY = true; Game.ALLOW_QUICKSTOP_FREESPIN = true; Game.ALLOW_SKIPWIN_AUTOPLAY = true; Game.ALLOW_SKIPWIN_FREESPIN = true; function Game() { if (this.constructor !== arguments.callee) return new Game; Utils.Trace.DisableAllChannels(); SFReelSymbol.GenerateStaticTexture(); this.aQ = new SFReelManager(Utils.delegate(this, this.ReelHandlerCallback)); this.av = new FeatureManager(Utils.delegate(this, this.FeatureManagerCallback)); this.R = new VideoSlot("SuperFlip", "0.1", this); this.R.aQ = this.aQ; this.R.av = this.av; this.R.jP = scatter_frame_yoffset; this.R.qS = false; this.R.qX = false; this.bo = [[1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [2, 2, 2, 2, 2], [0, 1, 2, 1, 0], [2, 1, 0, 1, 2], [1, 0, 0, 0, 1], [1, 2, 2, 2, 1], [0, 0, 1, 2, 2], [2, 2, 1, 0, 0], [1, 2, 1, 0, 1], [1, 0, 1, 2, 1], [0, 1, 1, 1, 0], [2, 1, 1, 1, 2], [0, 1, 0, 1, 0], [2, 1, 2, 1, 2], [1, 1, 0, 1, 1], [1, 1, 2, 1, 1], [0, 0, 2, 0, 0], [2, 2, 0, 2, 2], [0, 2, 2, 2, 0]]; this.bc = [[1, 1, 1, 0, 0, 0, 3, 9, 6, 6, 6, 2, 10, 7, 7, 7, 0, 2, 2, 2, 10, 4, 4, 4, 9, 9, 9, 2, 5, 5, 5, 8, 8, 8, 1, 3, 3, 3, 7, 4], [0, 0, 0, 4, 4, 4, 10, 5, 5, 5, 2, 1, 1, 1, 2, 2, 2, 9, 9, 9, 8, 1, 1, 1, 10, 6, 6, 6, 8, 8, 8, 8, 9, 3, 3, 3, 4, 7, 7, 7], [1, 1, 1, 7, 4, 4, 4, 0, 0, 0, 10, 2, 2, 2, 5, 5, 5, 5, 2, 7, 7, 7, 9, 9, 9, 0, 8, 10, 3, 3, 3, 6, 6, 6, 7, 9, 3, 8, 8, 8], [5, 5, 5, 1, 0, 0, 0, 10, 6, 6, 6, 2, 9, 9, 9, 2, 2, 2, 9, 5, 8, 8, 8, 0, 1, 3, 3, 3, 10, 7, 7, 7, 0, 1, 1, 1, 5, 4, 4, 4], [2, 2, 2, 0, 4, 4, 4, 9, 9, 9, 1, 1, 1, 6, 9, 8, 8, 8, 10, 3, 3, 3, 8, 8, 8, 7, 7, 7, 10, 6, 6, 6, 9, 3, 0, 0, 0, 5, 5, 5]]; this._soundBgmAmbience; this._bgmStemSnd1; this._bgmStemSnd2; this._soundCurrentSpinIndex; this._soundReelStart; this._soundReelSpin; this._soundReelStop; this._soundReelWait; this._soundBgmGamble; this._soundBgmGamblePre; this._soundGambleRoundEnd; this._soundGambleWin; this._soundGambleLose; this._isReelWaitSndPlaying = false; this._soundPlayingFastSpin = false; this._soundHasNewSpinIndex = false; this._soundPlayedWinSound = false; this._IsPostFreespin = false; this._soundWinLP = []; this._soundWinHP = []; this._soundScatterLand = []; this.m_AmbianceAfterBigWinTime; this.m_OnScreenPaytableHandler; this.aO; this.m_BigWinDisplay; this.m_Logo; this.m_Blink; this.ma = 0; this.m_RespinScatterNum = 0; this.m_WonCoinsServerPrev = 0; this.m_BigWinWon = false; this.m_PostBigWin = false; this.m_BigWinHandlesCounting = false; this.m_QuickWinView = false; this.m_ReconnectFreespinStart = false; this.m_OldRenderTime = getTimer() } Game.prototype.constructor = Game; Game.prototype.DelayedInit = function (gameUI) { sjs.layers.scalelayer.Show(false); this.bJ = gameUI.bJ; this.bA = this.R.bA; this.m_BigWinDisplay = new SFBigWinDisplay("bigwin", gameUI.bG, "Impact", Utils.delegate(this, this.OnBigWinComplete)); this.m_Logo = new SFLogo; this.m_Payboxes = (new PixiArmature("Payboxes")).getDisplay(); var payboxHolder = new PIXI.DisplayObjectContainer; payboxHolder.addChild(this.m_Payboxes); sjs.layers.overlay.view.addChild(payboxHolder); this.m_Reel_Bg = (new PixiArmature("Reel_bg")).getDisplay(); this.m_Reel_Bg.gotoAndPlay("stop"); sjs.layers.reel_background.view.addChild(this.m_Reel_Bg); this.m_AnticipationReelEffect = []; this.m_AnticipationReelEffect.push(this.m_Reel_Bg.getSlot("suspense_light3").getDisplay()); this.m_AnticipationReelEffect.push(this.m_Reel_Bg.getSlot("suspense_light4").getDisplay()); this.m_AnticipationReelEffect.push(this.m_Reel_Bg.getSlot("suspense_light5").getDisplay()); this.anticipationEffect(false, 2); this.anticipationEffect(false, 3); this.anticipationEffect(false, 4); this.m_ReelFlipper = new ReelFlipper(this.aQ, this.m_Reel_Bg, this.m_Payboxes); this.aO = new SFFreeSpinHandler(Utils.delegate(this.R, this.R.FreeSpinCallBack), this.aQ, this.m_ReelFlipper, this.m_Logo, this.bc.concat().reverse()); this.m_FreeSpinFeature = new FeatureBase(Utils.delegate(this, this.OnFreespinFeature)); this.m_RespinFeature = new FeatureBase(Utils.delegate(this, this.OnRespinFeature)); this.R.aO = this.aO; var symbolX, x, y, symbols, reel, i, j, reelSpinner, symbol; for (i = 0; i < 5; i++) { reel = new SFReel(i, sjs.layers.reels); reel.nk = Utils.delegate(this.aQ, this.aQ.ReelStopped); symbolX = symbol_spacing.w * i; symbols = []; for (j = 0; j < 3; j++) { x = symbol_spacing.w * i; y = symbol_spacing.h * j; symbol = new SFReelSymbol(i, j, x, y); reel.AddSymbol(symbol); symbols.push(symbol) } reelSpinner = new SFReelSpinner(symbols, 3, this.bc[i], undefined, undefined, i); reelSpinner.onreelstopping = Utils.delegate(this, this.ReelHandlerCallback, "reelstop_start", reelSpinner.index); reelSpinner.onlastbounce = Utils.delegate(this, this.ReelHandlerCallback, "reelstop_bounce", reelSpinner.index); reelSpinner.oncomplete = Utils.delegate(this, this.ReelHandlerCallback, "reelstop_complete", reelSpinner.index); reelSpinner.setTarget(this.m_Reel_Bg.getSlot("reel" + (i + 1).toString()).getDisplay()); reel.SetSpinner(reelSpinner); this.aQ.AddReel(reel); this.R.ab.push(reel) } this.aQ.NextReels([Utils.RandRange(0, 3), Utils.RandRange(4, 6), Utils.RandRange(7, 9), Utils.RandRange(3, 6), Utils.RandRange(0, 2), Utils.RandRange(7, 8), Utils.RandRange(0, 2), Utils.RandRange(5, 7), Utils.RandRange(3, 4), Utils.RandRange(7, 8), Utils.RandRange(0, 3), Utils.RandRange(4, 6), Utils.RandRange(4, 6), Utils.RandRange(0, 3), Utils.RandRange(1, 3)]); this.aQ.SetReels(); this.aQ.SetLayout(this.bo); this.R.DelayedInit(gameUI); this.R.m_PayLinesInited = false; this.R.SetAutoPlaySettings(1); if (this.R.O.ReadSoundCookie()) { this.R.SetGameSettings(0); SoundManager.SetMute(true) } this.R.m_GamePanelHandler.updateSoundButton(); this.R.bX = new GameSplashScreen(this.R.O.cp, Utils.delegate(this.R, this.R.OnSplashContinue), Utils.delegate(this.R, this.R.SetGameSettings)); this.R.m_GamePanelHandler.enableMenuButton(false); if (!(this.R.O.qh && !SplashScreenHandler.ReadCookie(this.R.O.cp))) { this.R.bX.RemoveSplashFromDOM(); this.R.bX = null; this.R.bu.aT.ShowSpinPanel(true); this.R.m_GamePanelHandler.enableMenuButton(true); this.R.m_GamePanelHandler.enableSoundButton(false) } this.m_OnScreenPaytableHandler = new SFOnScreenPaytableHandler("onScreenPaytableEntity", "onScreenPaytableMC", "onScreenPaytableHitfieldContainer", this.aQ, this.R.bG, this.R, "paytableHandler", "splashscreenMC"); this.m_OnScreenPaytableHandler.enable(true); this.m_skipWinPresentationLayer = new PIXI.DisplayObjectContainer; this.m_skipWinPresentationLayer.interactive = true; this.m_skipWinPresentationLayer.hitArea = new PIXI.Rectangle(0, 0, quickstop_hitarea.w, quickstop_hitarea.h); this.m_skipWinPresentationLayer.click = Utils.delegate(this, this.OnSkipWinPresentation); this.m_skipWinPresentationLayer.tap = this.m_skipWinPresentationLayer.click; sjs.layers.overlay.view.addChild(this.m_skipWinPresentationLayer); this.m_Blink = new Blink(10, sjs.layers.reels.view, this.m_skipWinPresentationLayer); this.setupGameSounds() }; Game.prototype.RenderLoop = function () { var time = getTimer(); var diff = time - this.m_OldRenderTime; this.R.aQ.Tick(diff); this.m_BigWinDisplay.Tick(); this.m_OldRenderTime = time }; Game.prototype.MainLoop = function (evt) { this.R.MainLoop(); this.aO.Tick(); SoundManager.MainLoop(); if (this.R.bX) this.R.bX.tick(); var qsa = this.R.QuickstopAvailable(this.R.m_State === VideoSlot.STOPREELS || this.R.m_State === VideoSlot.WAITINGRESPONSE); var swa = this.SkipWinAvailable(this.R.m_State === VideoSlot.HANDLEWIN || this.R.m_State === VideoSlot.HANDLEFEATURES); this.m_OnScreenPaytableHandler.enable(!(qsa || swa)); if (this.R.m_State === VideoSlot.WAITINGSPIN && !this.m_BigWinWon) if (!this.aO.getFreeSpinMode()) { if (Utils.Rand(400) === 0) this.m_Logo.idle(); if (Utils.Rand(10) === 0) { var reel = Utils.Rand(10) % 5, row = Utils.Rand(6) % 3, symbol = this.aQ.GetSymbol(reel, row); symbol.idle() } } this.m_Blink.tick(); if (this.m_AmbianceAfterBigWinTime && this.m_AmbianceAfterBigWinTime <= getTimer()) { this.FadeUpStems(1); this.handleTotalWinSnd(); this.m_AmbianceAfterBigWinTime = 0 } }; Game.prototype.OnRoundEvent = function (e) { }; Game.prototype.CanShowWindow = function () { return this.R.O.CanShowWindow() }; Game.prototype.ReconnectEnd = function () { sjs.layers.gpcoveri.Show(false); sjs.layers.gpcoverb.Show(false) }; Game.prototype.HandleOrientationChange = function () { var portrait = this.R.O.ai.bF; this.aO.HandleOrientationChange(portrait); this.m_Logo.HandleOrientationChange(); this.R.bu.m_GamePanelHandler.HandleOrientationChange(); this.R.bu.aq.qu.HandleOrientationChange(); this.m_ReelFlipper.HandleOrientationChange(); var bgimg = sjs.layers.background.background; bgimg.scale(1, 1); bgimg.x = 0; if (portrait) { if (!this.R.m_MysteryJackpotFeature) this.handlePortraitLayout(); if (this.R.aJ.CanGamble() && this.R.m_State !== VideoSlot.GAMBLE) this.bJ.MoveWinCounterUp(); if (this.R.m_State === VideoSlot.GAMBLE) this.bJ.MoveWinCounterDown() } else { var bg = sjs.layers.background; bg.y = 0; bg.view.scale.x = 1; bg.view.scale.y = 1; var screenDiff = DEVICE.ls.w - bgimg.w; bgimg.x = -scale_layer_pos.ls.x + screenDiff * N_HALF; if (screenDiff > 0) { var s = DEVICE.ls.w / bgimg.w; s *= 1 / scale_layer_pos.ls.scale; bgimg.scale(s, s) } } }; Game.prototype.handlePortraitLayout = function () { var scaleLayer = sjs.layers.scalelayer, reelLayer = sjs.layers.reels, gamePanelHeight = document.getElementById("gamepanel").offsetHeight, gamePanelMargin = portraitlayout.gamepanelmargin, logoMargin = portraitlayout.logomargin, gameWidth = DEVICE[DEVICE.orientation].w, gameHeight = DEVICE[DEVICE.orientation].h - gamePanelHeight, gameMiddle = gameHeight / 2, newScale = gameWidth / portraitlayout.basewidth, reelHeight = portraitlayout.reelheight, reelTop = reelLayer.y * newScale, reelMiddle = (reelLayer.y + reelHeight / 2) * newScale, reelBottom = (reelLayer.y + reelHeight) * newScale, newY = gameMiddle - reelMiddle, bgScale = newScale >= 1 ? newScale : 1 / newScale; if (reelBottom + newY > gameHeight - gamePanelMargin) newY -= reelBottom + newY - gameHeight + gamePanelMargin; if (reelTop + newY < logoMargin) newY -= reelTop + newY - logoMargin; scaleLayer.Origin("center", "top"); scaleLayer.SetScale(newScale); scaleLayer.view.scale.x = newScale; scaleLayer.view.scale.y = newScale; scaleLayer.y = newY; var bg = sjs.layers.background; bg.y = -newY; bg.view.scale.x = bgScale; bg.view.scale.y = bgScale }; Game.prototype.setupGameSounds = function () { this._soundBgmAmbience = new Snd("bgmAmbience"); this._bgmStemSnd1 = new Snd("bgmStem1"); this._bgmStemSnd2 = new Snd("bgmStem2"); this._soundReelStart = new Snd("reelspinStart"); this._soundReelSpin = new Snd("reelspinNormal"); this._soundReelStop = new Snd("reelstop"); this._soundReelWait = new Snd("reelWait"); this._soundBgmGamble = new Snd("gambleMusic"); this._soundBgmGamblePre = new Snd("gamblePreGamble"); this._soundGambleRoundEnd = new Snd("gambleRoundEnd"); this._soundGambleWin = new Snd("gambleWin"); this._soundGambleLose = new Snd("gambleLose"); this._soundCoinTick = new Snd("winCoinTick"); this._soundWin1 = new Snd("win1Snd"); this._soundWin2 = new Snd("win2Snd"); this._soundWin3 = new Snd("win3Snd"); this._soundWin4 = new Snd("win4Snd"); this._soundWin5 = new Snd("win5Snd"); this._soundWin6 = new Snd("win6Snd"); this._soundWin7 = new Snd("win7Snd"); this._soundWin8 = new Snd("win8Snd"); this._soundWin9 = new Snd("win9Snd"); this._soundWin10 = new Snd("win10Snd"); this._soundScatterLand[0] = { played: false, sound: new Snd("scatterLand1") }; this._soundScatterLand[1] = { played: false, sound: new Snd("scatterLand2") }; this._soundScatterLand[2] = { played: false, sound: new Snd("scatterLand3") }; this.StartIdleSound() }; Game.prototype.handleTotalWinSnd = function () { var payLevel = this.R.oe / this.R.bG.GetBetCoins(), stemIdx = this.getBackgroundStemIdx(payLevel), winSnd = this.GetWinSound(payLevel); if (payLevel > 0 && !this.aO.getFreeSpinMode()) winSnd.Play(0.8); if (!this.aO.getFreeSpinMode()) { if (stemIdx >= 1) this._bgmStemSnd1.FadeTo(0.7, 1); if (stemIdx >= 3) this._bgmStemSnd2.FadeTo(0.7, 1) } }; Game.prototype.getBackgroundStemIdx = function (value) { var idx = 0; if (value >= 0.5) idx++; if (value >= 1) idx++; if (value >= 3) idx++; return idx }; Game.prototype.PauseSpinSound = function (time) { if (this._soundCurrentSpinIndex !== undefined) if (this._soundPlayingFastSpin) this._soundReelSpinFast.FadeTo(0, time); else this._soundReelSpin.FadeTo(0, time) }; Game.prototype.GetWinSound = function (payLevel) { var triggers = [0, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 8]; for (var snd = 0, j = triggers.length; snd <= j; snd++) if (triggers[snd] === undefined || payLevel < triggers[snd]) break; return this["_soundWin" + snd.toString()] }; Game.prototype.StopCoinSound = function () { if (this._soundCoinTick) this._soundCoinTick.FadeOut(0.1) }; Game.prototype.StartCoinSound = function () { if (this._soundCoinTick && !this._soundCoinTick.isPlaying() && !this.m_BigWinHandlesCounting && !this.aO.getIsRespin()) this._soundCoinTick.PlayForever(1) }; Game.prototype.StartIdleSound = function () { this._soundBgmAmbience.PlayFadeIn(1, 1.5, undefined, true, true); this._bgmStemSnd1.PlayFadeIn(0, 1.5, undefined, true, true); this._bgmStemSnd2.PlayFadeIn(0, 1.5, undefined, true, true); this._soundReelSpin.PlayFadeIn(0, 1.5, undefined, true, true) }; Game.prototype.StopIdleSound = function () { this._bgmStemSnd1.FadeOut(1); this._bgmStemSnd2.FadeOut(1); this._soundBgmAmbience.FadeOut(1); this._soundReelSpin.FadeOut(1) }; Game.prototype.FadeDownStems = function (value) { this._bgmStemSnd1.FadeTo(0, value); this._bgmStemSnd2.FadeTo(0, value); this._soundBgmAmbience.FadeTo(0, value); this._soundReelSpin.FadeTo(0, value) }; Game.prototype.FadeUpStems = function (value) { this._soundBgmAmbience.FadeTo(1, value) }; Game.prototype.StartIdleAnimation = function () { }; Game.prototype.StopIdleAnimation = function () { }; Game.prototype.anticipationEffect = function (show, reelIndex) { if (reelIndex < 2 || reelIndex > 4) return; reelIndex -= 2; if (show) { this.m_AnticipationReelEffect[reelIndex].gotoAndPlay("show"); this.m_AnticipationReelEffect[reelIndex].children[0].gotoAndPlay("loop") } else if (this.m_AnticipationReelEffect[reelIndex].children[0].armature.animation.getLastAnimationName() !== "stop") { this.m_AnticipationReelEffect[reelIndex].children[0].gotoAndPlay("stop"); this.m_AnticipationReelEffect[reelIndex].gotoAndPlay("hide") } }; Game.prototype.ReelHandlerCallback = function (type, reel) { switch (type) { case "reelstopping": this.OnReelStopping(reel); break; case "reelstop": break; case "allstopped": this.OnChangeState(VideoSlot.HANDLEFEATURES); this.OnReelsStopped(); break; case "cancel_quickstop": this.R.du = false; break; case "reelstop_start": break; case "reelstop_bounce": this.OnReelStop(reel); break; case "reelstop_complete": break } }; Game.prototype.OnSpin = function () { this.m_OnScreenPaytableHandler.enable(false); if (this.bX) return; if (this.m_BigWinDisplay.isRunning) this.m_BigWinDisplay.stop(); for (var i = 0; i < 3; i++) this._soundScatterLand[i].played = false; this.m_PostBigWin = false; this.m_BigWinHandlesCounting = false; this.m_QuickWinView = false; this.ma = 0; this.m_RespinScatterNum = 0; this._soundReelStart.Play(); this._soundReelSpin.FadeTo(0.7, 0.5, undefined, undefined, true) }; Game.prototype.OnReelStopping = function (reel) { var fsSymbolCount = 0, i, j; for (i = 0; i < reel; i++) for (j = 0; j < 3; j++) if (this.aQ.GetSymbolIndex(i, j) === SFReelSymbol.SYMBOL_SCATTER) fsSymbolCount++; if (!this.R.O.C && (fsSymbolCount >= 2 && reel >= 2 || this.aO.getIsRespin() && reel === 2)) { this.aQ.setSuspense(); this.aQ.GetReel(reel).GetSpinner().slowDown(); if (!this._isReelWaitSndPlaying) { this._soundReelWait.Play(1, 0, false, false, 1); this._isReelWaitSndPlaying = true } } if (this.aO.getIsRespin() && reel === 2) this.aO.onNearHitReelStopping() }; Game.prototype.OnReelStop = function (reel) { var time = this.R.du ? 5E3 : reel === 4 ? 360 : 240, col, row, numRow, symbol, j; this.R.aU = getTimer() + time; for (j = 0, numRow = this.aQ.getSymbolsPerReel() ; j < numRow; j++) { symbol = this.aQ.GetSymbol(reel, j); switch (symbol.GetSymbol()) { case SFReelSymbol.SYMBOL_SCATTER: this.ma++; if (5 - (reel + 1) >= 3 - this.ma) symbol.playFreespinLand(); break } } this.anticipationEffect(false, reel); if (this.ma > 1 && !this.aO.getIsRespin() && !this.R.du) this.anticipationEffect(true, reel + 1); if (this.ma < 3 && reel + 1 === this.aQ.getNumReels()) for (col = 0; col <= reel; col++) for (row = 0, numRow = this.aQ.getSymbolsPerReel() ; row < numRow; row++) { symbol = this.aQ.GetSymbol(col, row); symbol.Fade(false); if (symbol.GetSymbol() === SFReelSymbol.SYMBOL_SCATTER) symbol.clearFreespinLand() } if (this.ma > 0 && !(reel > 2 && this.ma < reel - 1)) { var scatterSoundNum = this.ma; if (scatterSoundNum > 3) scatterSoundNum = 3; if (!this._soundScatterLand[scatterSoundNum - 1].played) { this._soundScatterLand[scatterSoundNum - 1].sound.Play(0.8); this._soundScatterLand[scatterSoundNum - 1].played = true } } if (!this.R.du) this._soundReelStop.Play(1); else this._soundReelStop.Play(0.2); if (this.aO.getIsRespin() && reel === 2) this.aO.onNearHitReelStop() }; Game.prototype.OnReelsStopped = function () { this.R.du = false; this.R.eA = false; this.R.qY = false; this.m_OnScreenPaytableHandler.enable(true); if (this.aO.getFreeSpinMode()) this.aO.OnSpinEnd(); if (this.aO.getFreeSpinMode() && this.aO.getIsRespin()) this.anticipationEffect(false, 2); if (this._soundCurrentSpinIndex !== undefined && !this.R.bK.bf) this.PauseSpinSound(2); this._soundReelSpin.FadeTo(0, 12); this._soundReelWait.FadeOut(0.1); this._isReelWaitSndPlaying = false }; Game.prototype.OnChangeState = function (e) { switch (e) { case VideoSlot.STOPREELS: var fsSymbolCount = 0, currentStopTime = 0, stopTimes = [], wasSlowDown = false, reel, j, k, l; for (reel = 0, l = this.aQ.getNumReels() ; reel < l; reel++) { for (j = 0, k = this.aQ.getSymbolsPerReel() ; j < k; j++) if (this.aQ.GetSymbolIndex(reel, j) === SFReelSymbol.SYMBOL_SCATTER) fsSymbolCount++; if (this.aO.getFreeSpinMode() && this.aO.getIsRespin() && reel > 2) currentStopTime += 10; else if (this.aO.getIsRespin() && reel === 2) currentStopTime += ReelSpinner.SLOWDOWN_TIME; else if (fsSymbolCount > 1) if (wasSlowDown) if (reel < 4) currentStopTime += ReelSpinner.SLOWDOWN_TIME * 0.65; else currentStopTime += ReelSpinner.SLOWDOWN_TIME; else { wasSlowDown = true; currentStopTime += ReelSpinner.STOPPING_TIME } else currentStopTime += ReelSpinner.STOPPING_TIME; stopTimes.push(currentStopTime) } this.aQ.StopReels(this.aO.getFreeSpinMode(), stopTimes); break; default: this.R.OnChangeState(e); break } }; Game.prototype.FeatureFactory = function (cmd) { switch (cmd.GetInt(2)) { case SFReelSymbol.SYMBOL_SCATTER: return this.m_FreeSpinFeature } return this.m_RespinFeature }; Game.prototype.FeatureManagerCallback = function (e) { switch (e.type) { case "allstopped": this.OnFeaturesStopped(e); break; case FeatureManager.FEATURE_WAITCOLLECT: this.OnFeatureWaitCollect(); break; case FeatureManager.FEATURE_COLLECTED: this.OnFeatureCollected(); break } }; Game.prototype.OnFreespinFeature = function (event) { switch (event.State) { case Feature.FEATURE_STARTED: if (!this.R.O.C) { var symbol, col, numCol, row, numRow; for (col = 0, numCol = this.aQ.getNumReels() ; col < numCol; col++) for (row = 0, numRow = this.aQ.getSymbolsPerReel() ; row < numRow; row++) { symbol = this.aQ.GetSymbol(col, row); if (symbol.GetSymbol() === SFReelSymbol.SYMBOL_SCATTER) symbol.playFreespinWin() } } this.R.bA.AddScatterWin(this.m_FreeSpinFeature.Symbol(), this.m_FreeSpinFeature.TotalCoins(), this.m_FreeSpinFeature.NumSymbols(), this.aQ.GetSymbolIndexArray(this.m_FreeSpinFeature.Symbol())); if (this.aO.getIsRespin()) this.aO.ForceInit(); this.aO.setIsRespin(false); this.av.SetDelay(2E3); if (this.R.bK.getAutoPlay()) { this.R.bu.aT.ShowAutoPlayPanel(false); this.R.bu.aT.ShowSpinPanel(false) } break } }; Game.prototype.OnRespinFeature = function (event) { switch (event.State) { case Feature.FEATURE_STARTED: this.aO.setIsRespin(true); this.av.SetDelay(300); Tweener.AddTween({ obj: sjs.layers.background.fsbackground, duration: 1E3, durationType: Tweener.MS, objectType: SJSTweener.TYPE_SPRITE, transition: Tweener.T_EASEOUTQUAD, properties: { alpha: 1 } }); break } }; Game.prototype.FreeSpinCallBack = function (e, i) { switch (e) { case FreeSpinHandler.SELECT: this.ShowFreeSpinButton(); break; case FreeSpinHandler.INIT: this.R.FreeSpinModeInit(); break; case FreeSpinHandler.START: this.R.FreeSpinModeStart(); break; case FreeSpinHandler.END: this.R.DoFreeSpinModeEnd(); break; case FreeSpinHandler.NEXTSPIN: this.DoFreeSpin(); break; case FreeSpinHandler.UPDATE: this.R.UpdateFreeSpin(this.aO.getTotalFreeSpinWin()); break; case FreeSpinHandler.COMPLETE: this.R.FreeSpinModeEnd(); this.FreeSpinModeCompleted(); break } }; Game.prototype.FreeSpinModeInit = function () { if (!this.aO.getIsRespin()) { this.R.GotFreespinFeature(false); this.aO.InitFreeSpin(); this.aO.showWonMsg(this.R.bK.getAutoPlay(), false); this.R.bu.aT.ShowAutoPlayPanel(false); this.R.bu.aT.ShowSpinPanel(false); this.StopIdleSound() } else { this.R.GotFreespinFeature(true); this.bJ.addWinAmount(this.m_RespinFeature.TotalCoins(), 1E3); this.aO.InitReSpin(); this.anticipationEffect(true, 2); this._bgmStemSnd1.FadeTo(1, 1); this._bgmStemSnd2.FadeTo(1, 1) } }; Game.prototype.ShowFreeSpinButton = function () { if (this.R.bK.getAutoPlay() || this.R.O.C) { this.R.nu = true; this.R.setFreeSpinStartWait(false) } else this.R.setFreeSpinStartWait(true) }; Game.prototype.FreeSpinModeStart = function () { if (this.aO.getIsRunning()) if (this.aO.getIsRespin()) this.aO.InitReSpin(); else { this.aO.showWonMsg(this.R.bK.getAutoPlay(), true); this.av.SetDelay(5E3) } if (this.R.bK.bf) { this.R.bu.aT.ShowSpinPanel(true); this.R.bu.aT.ShowAutoPlayPanel(true) } this.aO.Go() }; Game.prototype.DoFreeSpin = function () { this.R.DoSpin(); this.m_BigWinHandlesCounting = false; if (this.aO.getIsRespin()) { this.m_RespinScatterNum = this.ma; for (var row = 0, numRow = this.aQ.getSymbolsPerReel() ; row < numRow; row++) if (this.aQ.GetSymbol(2, row).GetSymbol() === SFReelSymbol.SYMBOL_SCATTER) this.m_RespinScatterNum--; if (this.m_RespinScatterNum > 1) { var symbol, numReels = this.aQ.getNumReels(), numSymbols = this.aQ.getSymbolsPerReel(); for (var i = 0; i < numReels; i++) { if (i === 2) continue; for (var j = 0; j < numSymbols; j++) { symbol = this.aQ.GetSymbol(i, j); if (symbol.GetSymbol() === SFReelSymbol.SYMBOL_SCATTER) symbol.playFreespinLand() } } } } else this.m_RespinScatterNum = 0; this.ma = 0; for (var i = 0; i < 3; i++) this._soundScatterLand[i].played = false }; Game.prototype.DoFreeSpinModeEnd = function () { this.aO.End() }; Game.prototype.FreeSpinModeCompleted = function () { if (this.aO.getIsRespin()) { this.aO.RestoreReels(); this._bgmStemSnd1.FadeTo(0, 2); this._bgmStemSnd2.FadeTo(0, 2); Tweener.AddTween({ obj: sjs.layers.background.fsbackground, duration: 1E3, durationType: Tweener.MS, objectType: SJSTweener.TYPE_SPRITE, transition: Tweener.T_EASEOUTQUAD, properties: { alpha: 0 } }) } else { this.StartIdleSound(); this._IsPostFreespin = true } var i, j, k, l; for (i = 0, k = this.aQ.getNumReels() ; i < k; i++) for (j = 0, l = this.aQ.getSymbolsPerReel() ; j < l; j++) this.aQ.GetSymbol(i, j).Fade(false); this.R.bu.aT.ShowAutoPlayPanel(this.R.bK.getAutoPlay()) }; Game.prototype.OnFeaturesStopped = function (e) { this.m_SpinSnd = this.m_ReelNormalSnd; var win = this.R.oe; if (this.aO.getFreeSpinMode()) win -= this.m_WonCoinsServerPrev; this.m_BigWinDisplay.setTarget(win); this.m_PostBigWin = false; this.R.OnFeaturesStopped(e) }; Game.prototype.OnWin = function (line, symbol, num, firstFlag) { }; Game.prototype.WinDisplayStart = function () { if (this.aO.getIsRespin()) this.anticipationEffect(false, 2); if (this.m_BigWinDisplay.getTotalDuration() > 0 && !this.m_PostBigWin && !this.R.C) this.showBigWin(); else { if (this.m_Logo && this.R.bA.HasWins()) this.m_Logo.win(); this.m_ActualWin = 0; if (!this.m_PostBigWin) this.handleTotalWinSnd(); this.R.bA.Start(this.aO.getFreeSpinMode(), this.aO.getIsRespin(), 0, this.m_PostBigWin, this.m_PostBigWin) } }; Game.prototype.OnWinDisplayWin = function (obj) { this.m_PostBigWin = false; var i, j, k, l; for (i = 0, k = this.aQ.getNumReels() ; i < k; i++) for (j = 0, l = this.aQ.getSymbolsPerReel() ; j < l; j++) this.aQ.GetSymbol(i, j).Fade(true); if (obj.aS === "line" && obj.aN) { var payline = obj.od; if (payline.isDelayed()) this.m_SavedWinDisplayEvent = obj } }; Game.prototype.AnimateLine = function (num, line, firstFlag, startPos) { if (!firstFlag) { var i, j, k, l; for (i = 0, k = this.aQ.getNumReels() ; i < k; i++) for (j = 0, l = this.aQ.getSymbolsPerReel() ; j < l; j++) this.aQ.GetSymbol(i, j).removeAnimation() } this.aQ.AnimateLine(num, line, firstFlag, startPos) }; Game.prototype.showBigWin = function () { this.m_BigWinWon = true; this.m_BigWinHandlesCounting = true; this.lW = getTimer() + this.m_BigWinDisplay.getTotalDuration(); this.bJ.Show(false); this.m_BigWinDisplay.start(); if (this.aO.getFreeSpinMode()) this.aO.startBigWin(); this.FadeDownStems(1) }; Game.prototype.OnBigWinComplete = function () { this.m_BigWinWon = false; this.m_PostBigWin = true; this.R.lW = getTimer(); this.bJ.setWinAmount(this.R.oe); this.bJ.flush(); this.bJ.Show(true); this.WinDisplayStart(); if (this.aO.getFreeSpinMode() && !this.aO.getIsRespin()) this.aO.stopBigWin(); else this.m_AmbianceAfterBigWinTime = getTimer() + 2E3 }; Game.prototype.GetWinCounterTickDuration = function (amount) { var duration = 0, idx = -1, i; for (i = 0, j = win_counter_duration.length; i < j; i++) if (amount >= win_counter_duration[i][0]) idx++; if (idx === -1) idx = 0; duration = win_counter_duration[idx][1]; return duration }; Game.prototype.SkipWinAvailable = function (b) { if (this.m_BigWinWon) b = false; var autoPlay = Game.ALLOW_SKIPWIN_AUTOPLAY ? false : this.R.bf !== undefined ? this.R.bf : this.R.bK && this.R.bK.bf, freespins = Game.ALLOW_SKIPWIN_FREESPIN ? false : this.R.aO && this.R.aO.getFreeSpinMode(); this.m_skipWinPresentationLayer.visible = b && !autoPlay && !freespins; return this.m_skipWinPresentationLayer.visible }; Game.prototype.OnSkipWinPresentation = function () { if (this.R.bA.bQ && this.R.bA.aN) { if (this.m_QuickWinView || this.ma > 2 || this.aO.getIsRespin() && !this.aO.getIsAfterRespin()) return; this.m_Blink.start(); this.m_QuickWinView = true; this.R.bA.restart(false); if (this.aO.getIsRunning()) this.R.bJ.setWinAmount(this.R.oe, 250); else this.R.bJ.setWinAmount(this.R.bJ.bi, 250); this.m_Logo.chekFinalState() } }; Game.prototype.moveWinCounter = function (infoBarShowing) { if (infoBarShowing) this.bJ.MoveWinCounterUp(); else this.bJ.MoveWinCounterDown() }; Game.prototype.enableMystertyJackpot = function () { this.m_Logo.enableMysteryJackpot() }; VideoSlot.prototype.PlayWinSound = function (line, symbol, num, coins, firstFlag, wilds) { if (line < 1E3) this.G.AnimateLine(num, line, firstFlag); else this.aQ.AnimateScatter(symbol, firstFlag) }; VideoSlot.prototype.displayWinLine = function (payline, amount) { if (this.bJ !== undefined) { var winCounterDurationAmount = amount / this.bG.getCoins(); var duration = this.C ? 0 : this.G.GetWinCounterTickDuration(winCounterDurationAmount); if (this.cw.length === 0 && !this.G.m_BigWinHandlesCounting) if (!this.G.m_PostBigWin) { var that = this; this.mK = setTimeout(function () { if (that.iU) that.bJ.addWinAmount(amount, duration, false) }, this.C ? 1 : 1) } } }; VideoSlot.prototype.InitWinDisplay = function () { this.bA = new SFWinDisplay(Utils.delegate(this, this.WinDisplayCallback)) }; VideoSlot.prototype.OnWinDisplayStart = function (e) { if (this.hg) { this.hg.Stop(); this.hg = null } if (!this.getStateChangeDelayed()) this.NextState() }; VideoSlot.prototype.OnWinDisplayWin = function (obj) { this.G.OnWinDisplayWin(obj); this.displayWinInfo(obj); if (obj.aS === "line") { var payline = obj.od; if (payline.GetJackpotWonAmount() > 0) this.GamePanelHandler.setInfoBarText(Str.Replace(Str.Replace(Localizer.getInstance().getString("IDS_MENU_WONJACKPOT_LINE"), "%d", Utils.MoneyToString(payline.GetJackpotWonAmount())), "%l", payline.GetIndex().toString()), 2); else if (payline.GetWonAmount() > 0) this.m_GamePanelHandler.setInfoBarText(Str.Replace(Str.Replace(CreditFormatter.GetCreditString(Localizer.getInstance().getString("IDS_MENU_WONCOINS_LINE"), Localizer.getInstance().getString("IDS_MENU_WONMONEY_LINE")), "%d", CreditFormatter.FormatCoinValue(payline.GetWonAmount())), "%l", payline.GetIndex().toString()), 2) } else if (obj.aS === "scatter") if (obj.fQ > 0) this.m_GamePanelHandler.setInfoBarText(Str.Replace(Str.Replace(CreditFormatter.GetCreditString(Localizer.getInstance().getString("IDS_MENU_WONCOINS_SCATTER"), Localizer.getInstance().getString("IDS_MENU_WONMONEY_SCATTER")), "%d", CreditFormatter.FormatCoinValue(obj.fQ)), "%s", obj.nb.toString()), 2); var amount = this.jn; if (this.G.AdjustWonAmount) amount = this.G.AdjustWonAmount(amount); if (obj.aS === "scatter") { var o = obj; this.PlayWinSound(o.aA, o.jC, o.nb, amount, o.aN); if (o.aN) { amount = o.fQ; if (this.aO.getFreeSpinMode()) this.aO.AddAmount(amount); this.displayWinScatter(amount, o, true) } } else { var payline = obj.od; this.PlayWinSound(obj.aA, payline.GetWinSymbol(), payline.GetNumSymbols(), amount, obj.aN, payline.GetNumWilds()); if (obj.aN) { if (this.aO.getFreeSpinMode()) this.aO.AddAmount(payline.GetWonAmount()); if (this.bA.aK === 0) this.displayWinLine(payline, amount) } } }; VideoSlot.prototype.OnWinDisplayStop = function (e) { if (e === undefined) e = null; if (this.G.m_BigWinDisplay) this.G.m_BigWinDisplay.reset(); this.G.m_QuickWinView = false }; VideoSlot.prototype.OnWinDisplayDone = function () { if (this.G.m_PostBigWin) { this.bA.setPostBigWin(); this.OnWinDisplayFirstWin(null); this.G.m_PostBigWin = false; return } sjs.layers.onscreenpaytable.Show(true); if (this.m_State === VideoSlot.HANDLEWIN) this.NextState(); if (this.aO.getFreeSpinMode() || this.m_State === VideoSlot.FREESPINANIM) { this.bA.Stop(); this.aO.NextSpin(); if (this.aO.getIsAfterRespin() && (this.bf !== undefined ? this.bf : this.bK && this.bK.bf)) this.lW = getTimer() + 1E3; return } this.G._bgmStemSnd1.FadeTo(0, 10); this.G._bgmStemSnd2.FadeTo(0, 10) }; VideoSlot.prototype.OnChangeState = function (e) { switch (e) { case VideoSlot.STOPREELS: this.m_State = VideoSlot.STOPREELS; if (this.aQ) this.aQ.StopReels(this.aO.getFreeSpinMode()); break; case VideoSlot.HANDLEFEATURES: this.m_State = VideoSlot.HANDLEFEATURES; if (this.av) this.av.Start(); break; case VideoSlot.HANDLEWIN: this.m_State = VideoSlot.HANDLEWIN; this.G.WinDisplayStart(); break; case VideoSlot.GAMBLE: if (DEVICE.orientation === "pt") this.bJ.MoveWinCounterDown(); this.m_State = VideoSlot.GAMBLE; this.bA.Stop(); this.bu.aT.ShowSpinPanel(false); this.bu.aT.ShowGamblePanel(true); this.bu.aT.SetBlinkButtons(false); this.bu.aT.DisableGamble(true); break } }; VideoSlot.prototype.OnCollect = function (e, force, spin) { if (this.aJ.CanGamble() || force) { this.RoundEnd(this.ft); this.ft = 0; this.aJ.End(); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.setGambleMode(false); if (!force) { this.eP = 0; if (!this.bG.getLock() && !spin) this.bu.aq.DisableAllBetSpinners(false); this.UpdateAutoPlayDlgStates() } else if (!this.bf) { this.bu.aT.ShowSpinPanel(true); if (!this.bG.getLock()) this.bu.aq.DisableAllBetSpinners(false); this.UpdateAutoPlayDlgStates() } this.bu.aT.ShowGamblePanel(false); clearTimeout(this.mK); this.m_State = VideoSlot.WAITINGSPIN } if (this.bf && !this.aT.et.getShowing()) { this.aT.ShowAutoPlayPanel(true); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Show(true) } this.bA.HidePayBoxAmount(); if (!spin && !this.bf) { var i, j; for (i = 0; i < 5; i++) for (j = 0; j < 3; j++) this.aQ.GetSymbol(i, j).Fade(false) } }; VideoSlot.prototype.InitPaylines = function (paylineBehind, dualNumbers, dualNumbersFirst, payboxLeft, payboxRight) { var payLines = [], pl = [], symbolPositions, layout, symbol, pos, i, j, k; var payLineOverlay = new PIXI.DisplayObjectContainer; sjs.layers.paylines.view.addChild(payLineOverlay); var awardOverlay = new PIXI.DisplayObjectContainer; sjs.layers.paylines.view.addChild(awardOverlay); for (i = 0, k = this.bG.getMaxLines() ; i < k; i++) { symbolPositions = []; for (j = 0; j < this.az; j++) { layout = this.G.bo[i]; symbol = this.aQ.GetReel(j).GetSymbol(layout[j]); pos = { x: symbol.m_Point.x, y: symbol.m_Point.y }; symbolPositions[j] = pos } payLines[i] = new SFWinLine(pl, i, paylineBehind, symbolPositions, this.G.bo, payLineOverlay, awardOverlay) } this.aV = payLines; return this.aV }; VideoSlot.prototype.InitWinScatter = function () { var paylines_layer = sjs.layers.paylines; this.sy = []; this.qf = this.ab[0].bc.length; this.ij = []; var v; for (var j = 0; j < this.az; j++) { this.ij[j] = new sjs.Sprite(this.G.qA, paylines_layer, undefined, scatter_frame_pos); this.ij[j].x += scatter_frame_gap.w * j; this.ij[j].Visible(false); if (this.jP !== undefined) this.ij[j].yoffset = this.jP; v = this.ij[j].view; v.interactive = false; v.click = undefined; v.tap = undefined } this.dp = new SFWinScatter(this.ij, this.ab); return this.dp }; VideoSlot.prototype.DoFreeSpinModeEnd = function () { if (this.G.DoFreeSpinModeEnd) this.G.DoFreeSpinModeEnd(); this.m_GamePanelHandler.setInfoBarText(Str.Replace(CreditFormatter.GetCreditString(Localizer.getInstance().getString("IDS_MENU_WONCOINS_FREESPINS"), Localizer.getInstance().getString("IDS_MENU_WONMONEY_FREESPINS")), "%d", CreditFormatter.FormatCoinValue(this.aO.m_WasRespin ? this.jn : this.aO.getTotalFreeSpinWin())), 2) }; VideoSlot.prototype.onGambleEvent = function (e) { switch (e.n) { case -1: if (!this.G._IsPostFreespin) { this.G._soundBgmAmbience.FadeTo(0, 10); this.G._soundReelSpin.FadeTo(0, 10); this.G._soundBgmGamblePre.PlayFadeIn(1, 4, undefined, true, true, 10) } else { this.G._soundBgmAmbience.FadeTo(0, 0); this.G._soundReelSpin.FadeTo(0, 0); this.G._soundBgmGamblePre.PlayFadeIn(1, 4, undefined, true, true, 1); this.G._IsPostFreespin = false } break; case RedOrBlack.RUNNING: this.m_State = VideoSlot.GAMBLE; this.OnChangeState(VideoSlot.GAMBLE); this.bu.aT.gC = false; this.bu.aT.BlinkSequenceEnd(); this.bu.aT.DisableGamble(true); this.G._soundBgmGamble.PlayFadeIn(1, 1, undefined, true, true, 0); break; case RedOrBlack.INIT: if (this.bJ) { if (this.iU) this.bJ.setWinAmount(this.aJ.getWonCoins()); this.bJ.showInfo(); var str = Str.Replace(Str.Replace(CreditFormatter.GetCreditString(Localizer.getInstance().getString("IDS_GAMBLELIMIT"), Localizer.getInstance().getString("IDS_GAMBLELIMIT_MONEY")), "%d", this.aJ.getMaxGambles()), "%c", CreditFormatter.FormatCoinValue(this.aJ.getGambleLimit())); this.m_GamePanelHandler.setInfoBarText(str, 2); this.StopWinAnim(true); this.bu.aq.EnableAutoPlayDlg(false, true) } if (!this.m_GambleInited) { this.G._soundBgmAmbience.FadeTo(0, 1); this.G._soundReelSpin.FadeTo(0, 1); this.m_GambleInited = true; this.G._soundBgmGamblePre.FadeOut(0.5); this.G._soundBgmGamble.PlayFadeIn(1, 1, undefined, true, true, 0) } else this.G._soundBgmGamble.FadeTo(1, 0.3); HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_STARTED }); break; case RedOrBlack.PICK: this.DisableCollectButton(true); this.O.aZ.Send(CmdType.GAMBLECMD, e.rb_choice); if (e.n == 4 && e.rb_choice == 0) HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_ENDED }); if (e.rb_choice === 0) { this.bJ.Show(false); this.G._soundBgmGamble.FadeOut(0.5); this.G._soundBgmGamblePre.FadeOut(0.5); this.G._soundBgmAmbience.FadeTo(1, 1); this.m_GambleInited = false } else this.G._soundGambleRoundEnd.Play(); break; case RedOrBlack.WINAMOUNTCHANGED: if (this.bJ) if (this.aJ.getWonCoins() > 0 && this.iU) this.bJ.setWinAmount(this.aJ.getWonCoins(), 700); else this.bJ.reset(); this.ft = this.bG.CoinsToAmount(this.aJ.getWonCoins()); this.m_GamePanelHandler.setWin(Utils.MoneyToString(this.ft)); this.G._soundBgmGamble.FadeTo(0, 0.3); if (this.G.R.aJ.iR === 0) this.G._soundGambleLose.Play(); else this.G._soundGambleWin.Play(); if (this.aJ.getWonCoins() > 0) HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_WON, winamount: this.aJ.getWonCoins() }); break; case RedOrBlack.COMPLETE: this.SetTickerText(" ", GameBase.MSG_INFORMATION); this.OnCollect(null, true); this.bu.aq.EnableAutoPlayDlg(true, true); this.G._soundBgmGamble.Stop(); this.G._soundBgmAmbience.FadeTo(1, 2); this.m_GambleInited = false; HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_ENDED }); if (this.G.R.aJ.iR == 0) HostInterface.processGambleEvent({ type: HostInterface.CALL_GAMBLE_LOST }); break; case RedOrBlack.DISABLECOLLECT: this.DisableCollectButton(e.b); break } }; VideoSlot.prototype.SidePanelCallback = function (num) { switch (num) { case 0: if (this.G.m_BigWinDisplay.IsRunning) this.G.m_BigWinDisplay.stop(); if (this.aO.getFreeSpinMode()) this.OnFreeSpinStart(); else this.OnSpin(); break; case 1: if (this.G.m_BigWinDisplay.IsRunning) { this.StopAutoPlay(); this.eP = 0; break } this.StopAutoPlay(); break; case 2: this.OnChangeState(VideoSlot.GAMBLE); this.bu.aT.ShowSpinPanel(false); this.bu.aT.DisableGamble(true); this.aJ.Start(); break; case 3: this.bu.aT.ShowSpinPanel(true); this.OnCollect(); this.bu.aq.EnableAutoPlayDlg(true, true); break } }; VideoSlot.prototype.RoundStart = function (inGame) { clearTimeout(this.mK); if (this.aO.getFreeSpinMode() && this.aO.getTotalFreeSpins() > 1) { if (this.bJ.ga.text !== Localizer.getInstance().getString("IDS_MENU_TOTALWIN")) { this.bJ.ga.setText(Localizer.getInstance().getString("IDS_MENU_TOTALWIN")); this.bJ.m_LeftTextHolder.position.x = this.bJ.m_midPoint - this.bJ.m_scaledWidth / 2 - this.bJ.m_LeftTextHolder.width - this.bJ.L.win_counter_text_offset / 2 } } else { this.bJ.Show(false); this.bJ.reset() } this.O.RoundStart(inGame); if (inGame) this.m_GamePanelHandler.setWin(Utils.MoneyToString(0)); if (this.G.OnRoundStart) this.G.OnRoundStart() }; VideoSlot.prototype.ProcessCommand = function (cmd) { if (cmd.ae === Command.SRECONNECTEND && !this.O.C) return; this.O.ProcessCommand(cmd); if (this.qW) { var packet = this.qW.FromServer(cmd); if (packet) this.aJ.OnIncomingPacket(cmd) } else this.aJ.OnIncomingPacket(cmd); switch (cmd.ae) { case Command.SLOGINANSWER: this.SetWin(0); if (this.bu.aq.m_GameRulesView != undefined && this.O.ha != "") this.bu.aq.m_GameRulesView.loadPage(decodeURIComponent(this.O.ha) + "&method=open&currency=" + this.O.cW); break; case Command.SRECONNECTEND: if (this.G.ReconnectEnd) this.G.ReconnectEnd(); if (this.bu.aT) this.bu.aT.ReconnectEnd(); if (this.aJ) this.aJ.ReconnectEnd(); if (this.aO) this.aO.ReconnectEnd(); if (this.bu.aq) this.bu.aq.ReconnectEnd(); if (this.aQ) this.aQ.ReconnectEnd(); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.onBetChange(this.GetBetAmount()); this.bJ.flush(); this.bA.ReconnectEnd(); this.SetBet(this.GetBetAmount(), true); if (this.av) this.av.ReconnectEnd(); else for (var i = 0, j = this.bw.length; i < j; i++) this.bw[i].ReconnectEnd(); this.OnSettingsNotify({ type: "SoundEnabled" }); if (this.O.aM) this.O.ai.initOrientationCheck(); this.initGamePanelValues(); if (this.m_State === VideoSlot.WAITINGSPIN && this.bX) this.bu.aT.ShowSpinPanel(false); this.C = false; break; case Command.SSPDENOMINATIONS: this.ProcessDenominationsCommand(cmd); break; case CmdType.SFREESPINCMD: if (this.O.C) { this.la = cmd.GetInt(0); if (this.la === 0) this.G.m_ReconnectFreespinStart = true; this.aJ.setConfirmCollect(true) } break; case CmdType.SPIN: if (this.O.C && this.aO.getFreeSpinMode()) { if (this.O.aZ.PeekNext() !== CmdType.FEATURE) if (this.aO.GetPlayedFreeSpins() === this.la) { var reconnectCmd = new Command; reconnectCmd.ae = Command.SRECONNECTEND; this.ProcessCommand(reconnectCmd) } this.bu.aT.ShowSpinPanel(false) } if (!this.hy && !this.aO.getFreeSpinMode()) this.StartAnimSpin(); this.hy = false; this.eQ = false; this.cw = []; this.cT = 0; if (this.av) this.av.Clear(); else { this.bw = []; this.bs = 0 } this.bG.setCoins(cmd.GetInt(0)); this.bG.setLines(cmd.GetInt(1)); if (this.O.C && !this.aO.getFreeSpinMode()) this.bb.GameStart(); var denom = cmd.GetMoney(2); if (this.O.C || this.aO.getNumFreeSpins() > 0) { if (this.O.C) { this.cl = false; this.bu.aT.ShowSpinPanel(false) } this.m_State = VideoSlot.WAITINGRESPONSE } this.bG.setDenomination(denom); this.SetBet(this.GetBetAmount()); this.RoundStart(); this.og = 0; this.oY = 0; this.jn = 0; this.ProcessSpinCommand(cmd); if (!this.aO.getFreeSpinMode()) this.aU = this.fA + this.O.fW; else this.aU = getTimer() + 700; this.m_State = VideoSlot.STOPREELS; if (this.G.OnChangeState) this.G.OnChangeState(VideoSlot.STOPREELS); break; case CmdType.SPINEND: this.G.m_WonCoinsServerPrev = this.oe || 0; var canContinueGamble = cmd.GetInt(0) > 0; this.oe = cmd.GetInt(1); this.ft = cmd.GetInt(2); if (this.ft <= 0) canContinueGamble = false; if (this.av) this.av.Complete(); if (this.CheckAutoPlay) this.CheckAutoPlay(this.ft, this.O.getCurrentFunds()); this.aO.setWonCoins(cmd.GetInt(1)); this.eQ = true; this.aJ.SetGambleFinished(!canContinueGamble); if (this.aO.getFreeSpinMode()) if (cmd.GetInt(3) === 0) this.aO.ForceEnd(); if (this.O.C && this.aO.getFreeSpinMode()) if (this.aO.GetPlayedFreeSpins() === this.la) { reconnectCmd = new Command; reconnectCmd.ae = Command.SRECONNECTEND; this.ProcessCommand(reconnectCmd) } break; case CmdType.FEATURE: switch (cmd.GetInt(0)) { case CmdType.FEATURE_START: if (this.av) this.av.AddFeature(this.FeatureFactoryInternal(cmd), this.O.aZ, this.bu.bG, this.bK); else { var feature = this.av.AddFeature(this.FeatureFactoryInternal(cmd)); this.bw.push(feature); feature.Clean(this.O.C, this.O.aZ, this.bu.bG) } default: if (this.av) this.av.HandleCommand(cmd); else { this.bw[this.bw.length - 1].HandleCommand(cmd); if (cmd.GetInt(0) === CmdType.FEATURE_AWARD && cmd.GetInt(1) === FeatureAward.COINS) { this.oY += cmd.GetInt(2); this.jn += cmd.GetInt(2) } } break } break; case Command.SSFREEGAME: this.bb.OnIncomingPacket(cmd); break; case Command.SSFREEGAMEEND: this.bb.OnIncomingPacket(cmd); break; case CmdType.PAYOUT: this.aJ.SetGambleFinished(true); break; case Command.SSPCUSTOMDATA: this.ProcessCustomData(cmd); break } }; VideoSlot.prototype.ProcessSpinCommand = function (cmd) { var data = this.az * 3 + 3; this.qi = cmd.GetInt(data++); var winLines = cmd.GetInt(data++); var lineIndex, wonAmount, symbols, symbol, flags, i, j, k; for (i = 0; i < winLines; i++) { lineIndex = cmd.GetInt(data), symbol = cmd.GetInt(data + 1), symbols = cmd.GetInt(data + 2), flags = cmd.GetInt(data + 3), wonAmount = cmd.GetInt(data + 4); this.bA.AddLineWin(i, lineIndex, wonAmount, symbols, symbol, flags, this.bG.getCoins()); data += 5; this.og += wonAmount; this.jn += wonAmount } var symbolArray = [cmd.GetInt(3), cmd.GetInt(4), cmd.GetInt(5), cmd.GetInt(6), cmd.GetInt(7), cmd.GetInt(8), cmd.GetInt(9), cmd.GetInt(10), cmd.GetInt(11), cmd.GetInt(12), cmd.GetInt(13), cmd.GetInt(14), cmd.GetInt(15), cmd.GetInt(16), cmd.GetInt(17)]; this.bv = symbolArray; if (this.aQ) this.aQ.NextReels(symbolArray); if (this.C) { this.UpdateBetMenuSpinnerData(); if (this.aO.getFreeSpinMode() || this.G.m_ReconnectFreespinStart) { this.bu.aq.DisableAllBetSpinners(true); if (this.G.m_ReconnectFreespinStart) this.G.m_ReconnectFreespinStart = false } } var numReels = this.aQ.getNumReels(), numSymbols = this.aQ.getSymbolsPerReel(), allAdj = [], topAdj = [], bottomAdj = [], reel, adj, numAdj; data = numReels * numSymbols + winLines * numReels + 5; adj = cmd.GetInt(data); while (!isNaN(adj)) { allAdj.push(adj); data++; adj = cmd.GetInt(data) } numAdj = allAdj.length / (numReels * 2); if (numAdj > 0) for (i = 0, k = 0; i < numReels; i++) { topAdj = []; bottomAdj = []; for (j = 0; j < numAdj; j++, k++) topAdj[j] = allAdj[k]; for (j = 0; j < numAdj; j++, k++) bottomAdj[j] = allAdj[k]; reel = this.aQ.GetReel(i); reel.setAdjacentSymbols(topAdj, bottomAdj) } }; VideoSlot.prototype.ProcessDenominationsCommand = function (cmd) { this.bG.SetEnabledDenominations(cmd); this.bG.ResolveDenominations(this.oV); var defaultDenomination = this.O.lJ; this.bG.setDenomination(defaultDenomination * this.bG.getDenominationMultiplier()); var denominations = this.bG.getDenominationData(), multiplierDenoms = [], i, j; for (i = 0, j = denominations.length; i < j; i++) multiplierDenoms[i] = denominations[i] * 0.01; this.bu.aq.getPaytable().setHighestDenomination(denominations[denominations.length - 1]); if (this.bX !== null) this.bX.setHighestDenomination(denominations[denominations.length - 1]); this.UpdateBetMenuSpinnerData(); this.UpdateGamePanel(this.O.getBalance()) }; VideoSlot.prototype.OnFreeGameEvent = function (state, data, lastRound) { this.m_GamePanelHandler.OnFreeGameEvent(state, data, lastRound, this.bb); if (state === this.bb.START) { this.pU = this.bb.START; if (this.bG.addTemporaryFreegameDenomIfMissing(data.Denomination)) this.bu.aq.AddTemporaryDenomination(data.Denomination, data.Bet, data.Lines); this.bG.setCoins(data.Bet); this.bG.setLines(data.Lines); this.bG.setDenomination(data.Denomination); this.bG.setLock(true); this.SetBetDlgValues(true); if (!data.Resumed) { var message = ""; if (data.FreeGames > 1) message = Str.Replace(Localizer.getInstance().getString("IDS_WONFREEGAMES"), "%d", data.FreeGames.toString()); else message = Str.Replace(Localizer.getInstance().getString("IDS_WONFREEGAME"), "%d", data.FreeGames.toString()); var msg = new ServerMessage(this.O, Localizer.getInstance().getString("IDS_FREEGAMESTITLE"), message, 0, undefined, true) } else { var message = ""; if (data.FreeGames > 1) message = Str.Replace(Localizer.getInstance().getString("IDS_FREEGAMES_RECONNECT"), "%d", "" + data.FreeGames); else message = Str.Replace(Localizer.getInstance().getString("IDS_FREEGAME_RECONNECT"), "%d", "" + data.FreeGames); var msg = new ServerMessage(this.O, Locale.IDS_FREEGAMESTITLE, message, 0, undefined, true) } this.OnFreeGameEvent(this.bb.TOTALWIN, data); this.bu.aq.LockBetSpinners(true) } else if (state === this.bb.END) { var denom = this.bG.removeTemporaryFreegameDenom(); if (denom != -1) this.bu.aq.RemoveTemporaryDenominations(); var msg = new ServerMessage(this.O, Locale.IDS_FREEGAMESTITLE, Locale.IDS_FREEGAMESCOMPLETED, 0, undefined, true), coins = this.O.mv, lines = this.O.mo, denomination = this.O.lJ * this.bG.getDenominationMultiplier(); this.bG.setLock(false); this.bG.setCoins(coins > 0 && coins <= this.bG.getMaxCoins() ? coins : this.bG.getMaxCoins()); this.bG.setLines(lines > 0 && lines <= this.bG.getMaxLines() ? lines : this.bG.getMaxLines()); this.bG.setDenomination(denomination); this.SetBet(this.GetBetAmount(), true); this.O.SetBalanceText(); this.StopAutoPlay(); this.ie = false; this.bu.aq.LockBetSpinners(false); this.bu.aq.EnableAutoPlayDlg(true); this.bu.aq.cN.ik.Enable2(true); this.SetBetDlgValues(true) } else if (state === this.bb.TOTALWIN); else if (state === this.bb.ADDITIONAL_FREEGAMES) this.O.qF.Show(true) }; VideoSlot.prototype.ShowMenu = function (b) { if (b) { this.UpdateAutoPlayDlgStates(); this.SetBetDlgValues(0) } sjs.layers.coinshower.Show(!b); sjs.layers.scalelayer.Show(!b); this.bu.aq.Show(b); this.bu.aq.qu.show(b) }; VideoSlot.prototype.OnSettingsNotify = function (e) { if (e.type === "CHANGE" || e.type === "CLICKED") { this.OnCollect(); this.StopWinAnim(); this.SetBet(this.GetBetAmount()); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.onBetChange(this.GetBetAmount()); var i, j; for (i = 0, j = this.bG.eV; i < j; i++) this.aV[i].Enable(true, this.m_PayLinesInited && !this.C); for (i = this.bG.eV, j = this.bG.getMaxLines() ; i < j; i++) this.aV[i].Enable(false) } }; VideoSlot.prototype.OnAutoPlaySettingsNotify = function () { if (this.bK === undefined) return; if (this.aT.setAutoPlay) this.aT.setAutoPlay(this.bK.getAutoPlay()); this.aT.UpdateAutoPlayText(this.bK.GetSpins()); if (this.bK.GetSpins() <= 0) this.bf = false; this.bu.aq.EnableAutoPlayDlg(this.m_State === VideoSlot.GAMBLE ? false : !this.bK.getAutoPlay(), this.m_State === VideoSlot.GAMBLE); this.bu.aq.setAutoPlaySpins(this.bK.GetSpins()); if (this.aT.et.getShowing() && this.aT.et.getShowing() !== this.bK.getAutoPlay()) this.aT.ShowAutoPlayPanel(this.bK.getAutoPlay()) }; VideoSlot.prototype.InitQuickstopLayer = function () { this.jW = new PIXI.DisplayObjectContainer; this.jW.interactive = true; this.jW.hitArea = new PIXI.Rectangle(0, 0, quickstop_hitarea.w, quickstop_hitarea.h); this.jW.click = Utils.delegate(this, this.OnQuickStop); this.jW.tap = this.jW.click; sjs.layers.overlay.view.addChild(this.jW) }; VideoSlot.prototype.QuickstopAvailable = function (enabled) { if (!enabled || !this.O.m_QuickStopEnabled) this.jW.visible = false; else { var autoPlay = Game.ALLOW_QUICKSTOP_AUTOPLAY ? false : this.bf !== undefined ? this.bf : this.bK && this.bK.bf, freeSpins = Game.ALLOW_QUICKSTOP_FREESPIN ? false : this.aO && this.aO.getFreeSpinMode(); this.jW.visible = !autoPlay && !freeSpins } return this.jW.visible }; VideoSlot.prototype.OnQuickStop = function (e) { if (this.du) return; this.G.m_Blink.start(); if (this.aQ) this.aQ.OnQuickStop(e); this.G.anticipationEffect(false, 2); this.G.anticipationEffect(false, 3); this.G.anticipationEffect(false, 4); this.G.m_Logo.chekFinalState(); this.du = true; this.eA = true; this.qY = true }; VideoSlot.prototype.OnSplashContinue = function () { SoundPlayer.Play(-1); sjs.layers.scalelayer.Show(true); if (this.m_State === VideoSlot.WAITINGSPIN) this.bu.aT.ShowSpinPanel(true); if (SoundPlayer.GetEnabled()) StatsHandler.HandleEvent("initialsoundon"); else StatsHandler.HandleEvent("initialsoundoff"); this.bX = null; this.m_GamePanelHandler.enableMenuButton(true); this.m_GamePanelHandler.enableSoundButton(false) }; VideoSlot.prototype.SetGameSettings = function (button, initial) { switch (button) { case 0: SoundPlayer.ToggleOnOff(!SoundPlayer.GetEnabled()); if (!initial) if (SoundPlayer.GetEnabled()) StatsHandler.HandleEvent("soundon"); else StatsHandler.HandleEvent("soundoff"); if (!SoundPlayer.GetEnabled()) SoundPlayer.Pause(); this.O.SaveSoundCookie(); if (!SoundPlayer.CheckSoundSupport()) { SoundPlayer.Pause(); this.UpdateSettingsDlgStates(button, "disabled") } else this.UpdateSettingsDlgStates(button, SoundPlayer.GetEnabled()); break; case 1: this.bG.toggleAutoAdjustBet(); this.UpdateSettingsDlgStates(button, this.bG.getAutoAdjustBet()); break; case 2: this.m_GamePanelHandler.setLeftHandMode(); this.aT.setLeftHandMode(); this.UpdateSettingsDlgStates(button, this.m_GamePanelHandler.getLeftHandMode()); this.O.SaveLeftHandModeCookie(this.m_GamePanelHandler.getLeftHandMode()); break } }; VideoSlot.prototype.StartAutoPlay = function () { if (this.bK.GetSpins() > 0) { if (this.bu.aq.GetIsShowing()) { this.ShowMenu(false); this.m_GamePanelHandler.displayMenu(false) } this.bK.Start(this.O.getBalance()); this.bK.setAutoPlay(true); this.bf = true; if (!this.ji) this.aT.ShowAutoPlayPanel(true); else if (this.ji) this.ke = true } }; VideoSlot.prototype.DoSpin = function () { var that = this; setTimeout(function () { that.OnGameEvent("startspinsound") }, 200); if (this.aQ) this.aQ.StartReels(); this.eQ = false; if (!this.aQ) { if (this.oT && !this.O.C) { var time = getTimer(); spinTimer[0] = time + 2 * 83 * 1; spinTimer[1] = time + 2 * 83 * 2; spinTimer[2] = time + 2 * 83 * 3; spinTimer[3] = time + 2 * 83 * 4; this.fg = true; this.ab[0].Start() } else { var randReel1 = Utils.RandRange(1, 4); var randReel2 = Utils.RandRange(1, 4); var randReel3 = Utils.RandRange(1, 4); if (randReel1 === randReel2) randReel2 = (randReel2 + 1) % 4 + 1; if (randReel2 === randReel3) randReel3 = (randReel3 + 1) % 4 + 1; this.ab[0].Start(randReel1); this.ab[1].Start(randReel2); this.ab[2].Start(randReel3); if (this.az === 5) { this.ab[3].Start(randReel2); this.ab[4].Start(randReel1) } this.cl = false } this.bj = 0 } if (this.aO.getFreeSpinMode()) { if (!this.O.C && this.aJ.getConfirmCollect()) this.O.aZ.Send(CmdType.CFREESPINCMD, this.aO.GetPlayedFreeSpins()); this.m_State = VideoSlot.WAITINGRESPONSE } this.fA = getTimer(); this.bA.HidePayBoxAmount() }; VideoSlot.prototype.SetCurrency = function () { this.bu.aq.setCurrency(Utils.ju || Utils.cW) }; VideoSlot.prototype.SetAutoPlaySpinnerData = function () { if (this.bK === undefined) return; var spinsArray = this.O.getAutoSpins() !== undefined ? this.O.getAutoSpins() : this.bK.GetSpinsArray(), initSpins = this.O.getDefaultAutoSpins() !== undefined ? this.O.getDefaultAutoSpins() : 1; this.bK.SetSpinsArray(spinsArray); if (this.bu.aq) { var autoplayDlg_SpinnerValues = { spinsArray: spinsArray, initSpins: initSpins }; this.bu.aq.SetAutoPlayDlgSpinnerData(autoplayDlg_SpinnerValues) } }; VideoSlot.prototype.UpdateBetMenuSpinnerData = function () { if (this.bu.aq) { var betDlg_SpinnerValues = { denominations: this.bG.getDenominationData(), initDenomination: this.bG.getDenomination(), coins: this.bG.getMaxCoins(), initCoin: this.bG.getCoins(), lines: this.bG.getMaxLines(), initLine: this.bG.getLines() }; this.bu.aq.SetBetDlgSpinnerData(betDlg_SpinnerValues); this.bu.aq.SetDenominationMultiplier(this.bG.getDenominationMultiplier()); this.SetBetDlgValues(); this.m_PayLinesInited = true } }; VideoSlot.prototype.GotFreespinFeature = function (isRespin) { if (isRespin === undefined) isRespin = false; this.ji = true; if (!isRespin) { if (this.bK) this.bK.OnFsWin(); else this.StopAutoPlay(); this.aT.ShowAutoPlayPanel(false); if (this.m_MysteryJackpotFeature) this.m_MysteryJackpotFeature.Show(false) } }; GameBase.prototype.SetInitialSound = function (b) { if (UAGENT_IPAD || UAGENT_IPHONE) SoundPlayer.Play(-1); SoundPlayer.ToggleOnOff(b); if (this.bn.SetInitialSound) this.bn.SetInitialSound(b) }; ExpandingWinCounter.prototype.Ticking = function () { return this.aa !== this.bi || G.m_BigWinWon }; Button.prototype.setInteractive = function (b) { if (this.H) { this.H.view.interactive = b; this.H.update() } if (this.ak) { this.ak.view.interactive = b; this.ak.update() } if (this.bO !== undefined) { this.bO.view.interactive = b; this.bO.update() } this.T.view.interactive = b; this.T.update() }; CoinShower.prototype.StartSound = function () { G.StartCoinSound.call(G) }; CoinShower.prototype.StopSound = function () { G.StopCoinSound.call(G) }; GambleCard.prototype.Init = function (initData) { this.m_CardBack = new sjs.Sprite(image_path_game + "gamble.png", this.K, undefined, this.L.pos); this.m_CardBack.yoffset = this.L.offset.yoffset; this.m_CardBack.scale(this.L.scale.x, this.L.scale.y); this.m_CardCycle = new sjs.Cycle(this.L.card_anim_cycle.card_anim_cycle); this.m_CardCycle.sprites = [this.m_CardBack]; this.m_CardCycle.repeat = false; var cardImage = "vp_cards.png"; if (gamble.gamble_card.gambleCardImage) cardImage = gamble.gamble_card.gambleCardImage; this.m_CardFace = new sjs.Sprite(image_path_cards + cardImage, this.K, undefined, this.L.pos); this.m_CardFace.scale(0, this.L.scale.y - 0.12) }; GambleCard.prototype.Ticker = function () { if (this.m_Animating === 1 && this.m_RunAnim) { if (this.m_FrameCount < 5) { this.m_CardCycle.next(); this.m_CardCycle.sprites[0].update() } else if (this.m_FrameCount <= 10) { if (this.m_FrameCount === 5) { this.m_CardCycle.sprites[0].Visible(false); this.m_CardCycle.sprites[0].update(); this.m_CardFace.Visible(true) } this.m_CardFace.xscale = (this.m_FrameCount - 5) / 5 * 1.24; this.m_CardFace.update() } if (this.m_FrameCount === 10) { this.m_FrameCount = 0; this.m_Animating = 0; this.m_RunAnim = false; this.onComplete() } else { this.m_FrameCount += 0.5; this.m_FrameCount = Math.round(this.m_FrameCount * 10) / 10 } } }; GambleButton.prototype.show = function (bShow) { this.hc.style.opacity = bShow ? 1 : 0; this.m_bVisible = bShow; if (bShow) { this.hc.style.pointerEvents = ""; G.R.onGambleEvent({ n: -1 }) } else this.hc.style.pointerEvents = "none" }; PNG.Text.prototype.updateOffsets = function () { var myX = this.x, myY = this.y; this._compensate = new PIXI.Point; if (this._autoScale && this._wantedWidth !== 0 && this.width < this._width) this.scale.x = this.width / this._width; else if (this._wantedWidth !== 0 && this._align !== "left") { switch (this._align) { case "center": this._compensate.x = this._wantedWidth / 2 - this._width / 2; break; case "right": this._compensate.x = this._wantedWidth - this._width; break } this._compensate.x *= this.scale.x } if (this._autoScale && this._wantedHeight !== 0 && this._wantedHeight < this._height) this.scale.y = this._wantedHeight / this._height; else if (this._wantedHeight !== 0 && this._verticalAlign !== "top") { switch (this._verticalAlign) { case "middle": this._compensate.y = this._wantedHeight / 2 - this._height / 2; break; case "bottom": this._compensate.y = this._wantedHeight - this._height; break } this._compensate.y *= this.scale.y } this.x = myX; this.y = myY; this.position.x = Math.round(this.position.x); this.position.y = Math.round(this.position.y) }; UAGENT_OLDSOUNDCHROME = false; Tweener.FPS = 60; var gameUI, G; function mainLoop() { Tweener.Tick(); dragonBones.animation.WorldClock.clock.advanceTime(-1); G.MainLoop() } function renderLoop(ticker) { sjs.tick(); G.RenderLoop() }; function setup() { var gameID = 100295, menuName = "SUPERFLIP", paylines = 20, betCoins = 5, features = { bonus: false, freespin: true, jackpot: false }; function createLayer(name, position, parent) { return new sjs.Layer(name, null, parent, true, position) } function setupVisuals() { var orientation = DEVICE.orientation; var scale_layer = createLayer("scalelayer", scale_layer_pos[orientation]); var background_layer = createLayer("background", game_bgr_pos.layer[orientation], scale_layer); background_layer.background = new sjs.Sprite(image_path_game + "bg_normal.jpg", background_layer, undefined, game_bgr_pos[orientation]); background_layer.fsbackground = new sjs.Sprite(image_path_game + "bg_freespin.jpg", background_layer, undefined, game_bgr_pos[orientation]); background_layer.fsbackground.alpha = 0; var reel_bg_layer = createLayer("reel_background", game_bgr_pos.layer[orientation], scale_layer); var reels_layer = createLayer("reels", reels_layer_pos, scale_layer); var overlay_layer = createLayer("overlay", game_bgr_pos.overlay.layer, scale_layer); var paylines_layer = createLayer("paylines", reels_layer_pos, scale_layer); var hdsigns_layer = createLayer("hudsigns", freespin.hud.currfreespinstext, scale_layer); var ospt_layer = createLayer("onscreenpaytable", reels_layer_pos, scale_layer); var ospt_content_layer = createLayer("onscreenpaytablecontent", onscreenpaytable.size, ospt_layer); ospt_layer.Show(true); var gamble_layer = createLayer("gamblelayer", gamble.gamble_layer[orientation], scale_layer); gamble_layer.SetScale(1.075); var coinshower_layer = createLayer("coinshower", particles_pos.coinshower.layer, scale_layer); var free_spin_layer = createLayer("freespinLayer", freespin.layer, scale_layer); free_spin_layer.Show(false); var bigwin_layer = createLayer("bigwin", big_win.layer, scale_layer); bigwin_layer.m_Cover = new sjs.Solid("#000000", bigwin_layer, big_win.layer); bigwin_layer.m_Cover.opacity = 0.5; bigwin_layer.Show(false); var win_counter_layer = createLayer("wincounter", win_counter.win_counter_layer_pos[orientation], scale_layer); win_counter_layer.Origin("center", "center"); var logo_layer = createLayer("logo", game_bgr_pos.logo.layer[orientation], scale_layer); logo_layer.Origin("center", "bottom"); var gamblepanel_layer = createLayer("gamblepanellayer", side_panels.gamble_panel_layer[orientation]); var splash_layer = createLayer("splashscreen"); var splash_content_layer = createLayer("splashscreencontainer", splash_layer); splash_layer.Show(false); var menu_layer = createLayer("menulayer", menu_pos.layer[orientation]); var gamepanel_layer = createLayer("gamepanellayer", gamepanel_pos.game_panel_layer_pos[orientation]); var s = new PIXI.Graphics; s.beginFill(0); s.drawRect(-2E3, 0, 5E3, -2E3); sjs.layers.scalelayer.view.addChild(s); var miniloader_layer = createLayer("miniLoaderLayer"); var modal_win_dis_layer = createLayer("modalwindis", modalwin_pos.disable[orientation]); modal_win_dis_layer.Origin("center", "center"); var modal_win_layer = createLayer("modalwin", modalwin_pos.layer[orientation]); modal_win_layer.Origin("center", "center") } G = new Game; var R = G.R; var O = R.O; O.cp = gameID; O.jQ = new BrandHandler(O, true); LoginSubmitPointer = O; sjs.setW(Utils.eD); sjs.setH(Utils.sB); sjs.autoClear = false; setupVisuals(); var i, j; var gameRulesCallback = undefined; if (O.ha !== "") gameRulesCallback = Utils.delegate(O, O.OpenGameRulesPage); var gameHistoryCallback = undefined; if (O.en !== "") { gameHistoryCallback = Utils.delegate(O, O.OpenGameHistoryPage); var hb; for (i = 0, j = categorypanel.length; i < j; i++) if (categorypanel[i].type === MENU_BTN_ID_HISTORY) hb = true; if (!hb) categorypanel.push(historybutton) } var cashierCallback = undefined; if (O.eg !== "") { cashierCallback = Utils.delegate(O, O.OpenCashierPage); categorypanel.push(cashierbutton) } for (i = 0, j = categorypanel.length; i < j; i++) if (categorypanel[i].type === MENU_BTN_ID_HISTORY) categorypanel[i].callback = gameHistoryCallback; else if (categorypanel[i].type === MENU_BTN_ID_CASHIER) categorypanel[i].callback = cashierCallback; var bG = new VideoSlotSettings(paylines, betCoins, Utils.delegate(R, R.OnSettingsNotify), Utils.delegate(R, R.OnSettingsNotifyLock)); var dw = new AutoPlaySettings(Utils.delegate(R, R.OnAutoPlaySettingsNotify)); R.HasFeatures(features.bonus, features.freespin, features.jackpot, dw); var bJ = new ExpandingWinCounter(win_counter); bJ.setBetSettings(bG); var aT = new SidePanelVS(Utils.delegate(R, R.HTMLUISidePanelCallback), document.body, O.m_QuickBetValues, dw); aT.UpdateAutoPlayText(49); aT.ShowSpinPanel(true); aT.ShowAutoPlayPanel(false); aT.ShowGamblePanel(false); var m_GamePanelHandler = new GamePanel(Utils.delegate(O, O.ShowLobbyConfirmation), Utils.delegate(R, R.ShowMenu), O.eU, R.bb, function () { G.R.SetGameSettings(0) }); m_GamePanelHandler.m_infoBarShowing.add(Utils.delegate(G, G.moveWinCounter)); var aq = new VideoSlotMenu(menuName, O, Utils.delegate(R, R.UpdateBetValue), Utils.delegate(R, R.SetGameSettings), Utils.delegate(R, R.SetAutoPlaySettings), Utils.delegate(R, R.StartAutoPlay), Utils.delegate(R, R.StopAutoPlay), gameRulesCallback, gameHistoryCallback, cashierCallback, dw, bG); gameUI = { aq: aq, bG: bG, dw: dw, aT: aT, m_GamePanelHandler: m_GamePanelHandler, bJ: bJ }; menu_pos.contwin.touch_area = paytable_toucharea; return G } if (UAGENT_IPHONE) { var xStart, yStart = 0; document.addEventListener("touchstart", function (e) { xStart = e.touches[0].screenX; yStart = e.touches[0].screenY }); document.addEventListener("touchmove", function (e) { var xMovement = Math.abs(e.touches[0].screenX - xStart), yMovement = Math.abs(e.touches[0].screenY - yStart); if (xMovement > 5 && yMovement < 50) e.preventDefault() }) };